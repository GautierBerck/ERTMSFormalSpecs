
using XmlBooster;
using System.IO;
using System.Collections;
using System;

/// <remarks>XMLBooster-generated code (Version 2.22.4.0)
/// This code is generated automatically. It is not meant
/// to be maintained or even read. As it is generated, 
/// it does not follow any coding standard. Please refrain
/// from performing any change directly on this generated 
/// code, as it might be overwritten anytime.
/// This documentation is provided for information purposes
/// only, in order to make the generated API somewhat more
/// understandable. It is meant to be a maintenance guide,
/// as this code is not meant to be maintained at all.</remarks>
namespace DataDictionary.Generated{
public abstract partial class BaseModelElement
: Utils.ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getGuid().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.BaseModelElementController.alertChange(aLock, this);
}
private   string  aGuid;

public   string  getGuid() { return aGuid;}

public  void setGuid( string  v) {
  aGuid = v;
  __setDirty(true);
  NotifyControllers(null);
}


public BaseModelElement()
{
BaseModelElement obj = this;
aGuid=(null);
}

public void copyTo(BaseModelElement other)
{
other.aGuid = aGuid;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl101;
bool fl102;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl101 = false ; 
fl102 = true ; 
while (fl102) { // BeginLoop 
if (ctxt.lookAheadString("Guid=")){
indicator = 101;
} else {
indicator = 103;
} // If
switch (indicator) {
case 101: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl101){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl101 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 103: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl102 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<BaseModelElement";
  endingTag = "</BaseModelElement>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"BaseModelElement\"");
} // If
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write("/>");
pw.Write('\n');
unParseBody(pw);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public abstract partial class Namable
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.NamableController.alertChange(aLock, this);
}
private   string  aName;

public   string  getName() { return aName;}

public  void setName( string  v) {
  aName = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Namable()
{
Namable obj = this;
aName=(null);
}

public void copyTo(Namable other)
{
base.copyTo(other);
other.aName = aName;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl105;
bool fl106;
bool fl107;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl105 = false ; 
fl106 = false ; 
fl107 = true ; 
while (fl107) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 105;
} else {
indicator = 108;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 106;
} else {
indicator = 108;
} // If
break;
} // Case
default:
indicator = 108;
break;
} // Switch
switch (indicator) {
case 105: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl105){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl105 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 106: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl106){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl106 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 108: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl107 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Namable";
  endingTag = "</Namable>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Namable\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public abstract partial class ReferencesParagraph
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ReferencesParagraphController.alertChange(aLock, this);
}
private System.Collections.ArrayList aRequirements;

/// <summary>Part of the list interface for Requirements</summary>
/// <returns>a collection of all the elements in Requirements</returns>
public System.Collections.ArrayList allRequirements()
  {
if (aRequirements == null){
    setAllRequirements( new System.Collections.ArrayList() );
} // If
    return aRequirements;
  }

/// <summary>Part of the list interface for Requirements</summary>
/// <returns>a collection of all the elements in Requirements</returns>
private System.Collections.ArrayList getRequirements()
  {
    return allRequirements();
  }

/// <summary>Part of the list interface for Requirements</summary>
/// <param name="coll">a collection of elements which replaces 
///        Requirements's current content.</param>
public void setAllRequirements(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirements = coll;
    NotifyControllers(null);
  }
public void setAllRequirements(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirements = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements</summary>
/// <param name="el">a ReqRef to add to the collection in 
///           Requirements</param>
/// <seealso cref="appendRequirements(System.Collections.IList)"/>
public void appendRequirements(ReqRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRequirements(Lock aLock,ReqRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Requirements</summary>
/// <param name="coll">a collection ofReqRefs to add to the collection in 
///           Requirements</param>
/// <seealso cref="appendRequirements(ReqRef)"/>
public void appendRequirements(System.Collections.IList coll)
  {
  __setDirty(true);
  allRequirements().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRequirements(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRequirements().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements
/// This insertion function inserts a new element in the
/// collection in Requirements</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRequirements(int idx, ReqRef el)
  {
  __setDirty(true);
  allRequirements().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRequirements(int idx, ReqRef el,Lock aLock)
  {
  __setDirty(true);
  allRequirements().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRequirements(IXmlBBase el)
  {
  return ((System.Collections.IList) allRequirements()).IndexOf (el);
  }

/// <summary>Part of the list interface for Requirements
/// This deletion function removes an element from the
/// collection in Requirements</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRequirements(int idx)
  {
  __setDirty(true);
  allRequirements().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRequirements(int idx,Lock aLock)
  {
  __setDirty(true);
  allRequirements().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements
/// This deletion function removes an element from the
/// collection in Requirements
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRequirements(IXmlBBase obj)
  {
  int idx = indexOfRequirements(obj);
  if (idx >= 0) { deleteRequirements(idx);
NotifyControllers(null);
   }
  }

public void removeRequirements(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRequirements(obj);
  if (idx >= 0) { deleteRequirements(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Requirements</summary>
/// <returns>the number of elements in Requirements</returns>
public int countRequirements()
  {
  return allRequirements().Count;
  }

/// <summary>Part of the list interface for Requirements
/// This function returns an element from the
/// collection in Requirements based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ReqRef getRequirements(int idx)
{
  return (ReqRef) ( allRequirements()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ReferencesParagraph()
{
ReferencesParagraph obj = this;
aRequirements=(null);
aComment=(null);
}

public void copyTo(ReferencesParagraph other)
{
base.copyTo(other);
other.aRequirements = aRequirements;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
ReqRef fl113;
bool fl124;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl113 = null;
while(ctxt.lookAheadOpeningTag ("<ReqRef")) {
fl113 = acceptor.lAccept_ReqRef(ctxt, "</ReqRef>");
appendRequirements(fl113);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl124 = true ; 
while (fl124) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl124 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl125;
bool fl126;
bool fl127;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl125 = false ; 
fl126 = false ; 
fl127 = true ; 
while (fl127) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 125;
} else {
indicator = 128;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 126;
} else {
indicator = 128;
} // If
break;
} // Case
default:
indicator = 128;
break;
} // Switch
switch (indicator) {
case 125: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl125){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl125 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 126: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl126){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl126 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 128: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl127 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ReferencesParagraph";
  endingTag = "</ReferencesParagraph>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ReferencesParagraph\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRequirements(), false, "<ReqRef", "</ReqRef>");
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countRequirements(); i++) {
  l.Add(getRequirements(i));
}
}

}
public abstract partial class ReqRelated
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ReqRelatedController.alertChange(aLock, this);
}
private  bool aImplemented;

public  bool getImplemented() { return aImplemented;}

public  void setImplemented(bool v) {
  aImplemented = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aVerified;

public  bool getVerified() { return aVerified;}

public  void setVerified(bool v) {
  aVerified = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aNeedsRequirement;

public  bool getNeedsRequirement() { return aNeedsRequirement;}

public  void setNeedsRequirement(bool v) {
  aNeedsRequirement = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ReqRelated()
{
ReqRelated obj = this;
aImplemented=(false);
aVerified=(false);
aNeedsRequirement=(false);
}

public void copyTo(ReqRelated other)
{
base.copyTo(other);
other.aImplemented = aImplemented;
other.aVerified = aVerified;
other.aNeedsRequirement = aNeedsRequirement;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl132;
bool fl133;
bool fl134;
bool fl135;
bool fl136;
bool fl137;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl132 = false ; 
fl133 = false ; 
fl134 = false ; 
fl135 = false ; 
fl136 = false ; 
fl137 = true ; 
while (fl137) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 133;
} else {
indicator = 138;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 134;
} else {
indicator = 138;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 135;
} else {
indicator = 138;
} // If
break;
} // Case
default:
indicator = 138;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 132;
} else {
indicator = 138;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 136;
} else {
indicator = 138;
} // If
break;
} // Case
default:
indicator = 138;
break;
} // Switch
switch (indicator) {
case 132: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl132){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl132 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 133: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl133){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl133 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 134: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl134){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl134 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 135: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl135){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl135 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 136: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl136){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl136 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 138: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl132){
this.setImplemented( false);
} // If
if (!fl133){
this.setVerified( false);
} // If
if (!fl134){
this.setNeedsRequirement( true);
} // If
fl137 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ReqRelated";
  endingTag = "</ReqRelated>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ReqRelated\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Dictionary
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getXsi().CompareTo((String) search) == 0)return true;
if(getXsiLocation().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DictionaryController.alertChange(aLock, this);
}
private System.Collections.ArrayList aSpecifications;

/// <summary>Part of the list interface for Specifications</summary>
/// <returns>a collection of all the elements in Specifications</returns>
public System.Collections.ArrayList allSpecifications()
  {
if (aSpecifications == null){
    setAllSpecifications( new System.Collections.ArrayList() );
} // If
    return aSpecifications;
  }

/// <summary>Part of the list interface for Specifications</summary>
/// <returns>a collection of all the elements in Specifications</returns>
private System.Collections.ArrayList getSpecifications()
  {
    return allSpecifications();
  }

/// <summary>Part of the list interface for Specifications</summary>
/// <param name="coll">a collection of elements which replaces 
///        Specifications's current content.</param>
public void setAllSpecifications(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecifications = coll;
    NotifyControllers(null);
  }
public void setAllSpecifications(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecifications = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications</summary>
/// <param name="el">a Specification to add to the collection in 
///           Specifications</param>
/// <seealso cref="appendSpecifications(System.Collections.IList)"/>
public void appendSpecifications(Specification el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecifications().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSpecifications(Lock aLock,Specification el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecifications().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Specifications</summary>
/// <param name="coll">a collection ofSpecifications to add to the collection in 
///           Specifications</param>
/// <seealso cref="appendSpecifications(Specification)"/>
public void appendSpecifications(System.Collections.IList coll)
  {
  __setDirty(true);
  allSpecifications().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSpecifications(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSpecifications().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications
/// This insertion function inserts a new element in the
/// collection in Specifications</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSpecifications(int idx, Specification el)
  {
  __setDirty(true);
  allSpecifications().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSpecifications(int idx, Specification el,Lock aLock)
  {
  __setDirty(true);
  allSpecifications().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSpecifications(IXmlBBase el)
  {
  return ((System.Collections.IList) allSpecifications()).IndexOf (el);
  }

/// <summary>Part of the list interface for Specifications
/// This deletion function removes an element from the
/// collection in Specifications</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSpecifications(int idx)
  {
  __setDirty(true);
  allSpecifications().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSpecifications(int idx,Lock aLock)
  {
  __setDirty(true);
  allSpecifications().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications
/// This deletion function removes an element from the
/// collection in Specifications
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSpecifications(IXmlBBase obj)
  {
  int idx = indexOfSpecifications(obj);
  if (idx >= 0) { deleteSpecifications(idx);
NotifyControllers(null);
   }
  }

public void removeSpecifications(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSpecifications(obj);
  if (idx >= 0) { deleteSpecifications(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Specifications</summary>
/// <returns>the number of elements in Specifications</returns>
public int countSpecifications()
  {
  return allSpecifications().Count;
  }

/// <summary>Part of the list interface for Specifications
/// This function returns an element from the
/// collection in Specifications based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Specification getSpecifications(int idx)
{
  return (Specification) ( allSpecifications()[idx]);
}

private System.Collections.ArrayList aRuleDisablings;

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <returns>a collection of all the elements in RuleDisablings</returns>
public System.Collections.ArrayList allRuleDisablings()
  {
if (aRuleDisablings == null){
    setAllRuleDisablings( new System.Collections.ArrayList() );
} // If
    return aRuleDisablings;
  }

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <returns>a collection of all the elements in RuleDisablings</returns>
private System.Collections.ArrayList getRuleDisablings()
  {
    return allRuleDisablings();
  }

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <param name="coll">a collection of elements which replaces 
///        RuleDisablings's current content.</param>
public void setAllRuleDisablings(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRuleDisablings = coll;
    NotifyControllers(null);
  }
public void setAllRuleDisablings(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRuleDisablings = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <param name="el">a RuleDisabling to add to the collection in 
///           RuleDisablings</param>
/// <seealso cref="appendRuleDisablings(System.Collections.IList)"/>
public void appendRuleDisablings(RuleDisabling el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRuleDisablings().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRuleDisablings(Lock aLock,RuleDisabling el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRuleDisablings().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for RuleDisablings</summary>
/// <param name="coll">a collection ofRuleDisablings to add to the collection in 
///           RuleDisablings</param>
/// <seealso cref="appendRuleDisablings(RuleDisabling)"/>
public void appendRuleDisablings(System.Collections.IList coll)
  {
  __setDirty(true);
  allRuleDisablings().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRuleDisablings(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRuleDisablings().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This insertion function inserts a new element in the
/// collection in RuleDisablings</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRuleDisablings(int idx, RuleDisabling el)
  {
  __setDirty(true);
  allRuleDisablings().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRuleDisablings(int idx, RuleDisabling el,Lock aLock)
  {
  __setDirty(true);
  allRuleDisablings().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRuleDisablings(IXmlBBase el)
  {
  return ((System.Collections.IList) allRuleDisablings()).IndexOf (el);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This deletion function removes an element from the
/// collection in RuleDisablings</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRuleDisablings(int idx)
  {
  __setDirty(true);
  allRuleDisablings().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRuleDisablings(int idx,Lock aLock)
  {
  __setDirty(true);
  allRuleDisablings().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This deletion function removes an element from the
/// collection in RuleDisablings
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRuleDisablings(IXmlBBase obj)
  {
  int idx = indexOfRuleDisablings(obj);
  if (idx >= 0) { deleteRuleDisablings(idx);
NotifyControllers(null);
   }
  }

public void removeRuleDisablings(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRuleDisablings(obj);
  if (idx >= 0) { deleteRuleDisablings(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <returns>the number of elements in RuleDisablings</returns>
public int countRuleDisablings()
  {
  return allRuleDisablings().Count;
  }

/// <summary>Part of the list interface for RuleDisablings
/// This function returns an element from the
/// collection in RuleDisablings based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RuleDisabling getRuleDisablings(int idx)
{
  return (RuleDisabling) ( allRuleDisablings()[idx]);
}

private System.Collections.ArrayList aNameSpaces;

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
public System.Collections.ArrayList allNameSpaces()
  {
if (aNameSpaces == null){
    setAllNameSpaces( new System.Collections.ArrayList() );
} // If
    return aNameSpaces;
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
private System.Collections.ArrayList getNameSpaces()
  {
    return allNameSpaces();
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaces's current content.</param>
public void setAllNameSpaces(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaces(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="el">a NameSpace to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(System.Collections.IList)"/>
public void appendNameSpaces(NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaces(Lock aLock,NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection ofNameSpaces to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(NameSpace)"/>
public void appendNameSpaces(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaces().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaces(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This insertion function inserts a new element in the
/// collection in NameSpaces</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaces(int idx, NameSpace el)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaces(int idx, NameSpace el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaces(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaces()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaces(int idx)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaces(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaces(IXmlBBase obj)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaces(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>the number of elements in NameSpaces</returns>
public int countNameSpaces()
  {
  return allNameSpaces().Count;
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns an element from the
/// collection in NameSpaces based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpace getNameSpaces(int idx)
{
  return (NameSpace) ( allNameSpaces()[idx]);
}

private System.Collections.ArrayList aNameSpaceRefs;

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
public System.Collections.ArrayList allNameSpaceRefs()
  {
if (aNameSpaceRefs == null){
    setAllNameSpaceRefs( new System.Collections.ArrayList() );
} // If
    return aNameSpaceRefs;
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
private System.Collections.ArrayList getNameSpaceRefs()
  {
    return allNameSpaceRefs();
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaceRefs's current content.</param>
public void setAllNameSpaceRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaceRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="el">a NameSpaceRef to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(System.Collections.IList)"/>
public void appendNameSpaceRefs(NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(Lock aLock,NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection ofNameSpaceRefs to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(NameSpaceRef)"/>
public void appendNameSpaceRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaceRefs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This insertion function inserts a new element in the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaceRefs(int idx, NameSpaceRef el)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaceRefs(int idx, NameSpaceRef el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaceRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaceRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaceRefs(int idx)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaceRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaceRefs(IXmlBBase obj)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaceRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>the number of elements in NameSpaceRefs</returns>
public int countNameSpaceRefs()
  {
  return allNameSpaceRefs().Count;
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns an element from the
/// collection in NameSpaceRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpaceRef getNameSpaceRefs(int idx)
{
  return (NameSpaceRef) ( allNameSpaceRefs()[idx]);
}

private System.Collections.ArrayList aTests;

/// <summary>Part of the list interface for Tests</summary>
/// <returns>a collection of all the elements in Tests</returns>
public System.Collections.ArrayList allTests()
  {
if (aTests == null){
    setAllTests( new System.Collections.ArrayList() );
} // If
    return aTests;
  }

/// <summary>Part of the list interface for Tests</summary>
/// <returns>a collection of all the elements in Tests</returns>
private System.Collections.ArrayList getTests()
  {
    return allTests();
  }

/// <summary>Part of the list interface for Tests</summary>
/// <param name="coll">a collection of elements which replaces 
///        Tests's current content.</param>
public void setAllTests(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTests = coll;
    NotifyControllers(null);
  }
public void setAllTests(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTests = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests</summary>
/// <param name="el">a Frame to add to the collection in 
///           Tests</param>
/// <seealso cref="appendTests(System.Collections.IList)"/>
public void appendTests(Frame el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTests().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTests(Lock aLock,Frame el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTests().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Tests</summary>
/// <param name="coll">a collection ofFrames to add to the collection in 
///           Tests</param>
/// <seealso cref="appendTests(Frame)"/>
public void appendTests(System.Collections.IList coll)
  {
  __setDirty(true);
  allTests().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTests(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTests().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests
/// This insertion function inserts a new element in the
/// collection in Tests</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTests(int idx, Frame el)
  {
  __setDirty(true);
  allTests().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTests(int idx, Frame el,Lock aLock)
  {
  __setDirty(true);
  allTests().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTests(IXmlBBase el)
  {
  return ((System.Collections.IList) allTests()).IndexOf (el);
  }

/// <summary>Part of the list interface for Tests
/// This deletion function removes an element from the
/// collection in Tests</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTests(int idx)
  {
  __setDirty(true);
  allTests().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTests(int idx,Lock aLock)
  {
  __setDirty(true);
  allTests().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests
/// This deletion function removes an element from the
/// collection in Tests
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTests(IXmlBBase obj)
  {
  int idx = indexOfTests(obj);
  if (idx >= 0) { deleteTests(idx);
NotifyControllers(null);
   }
  }

public void removeTests(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTests(obj);
  if (idx >= 0) { deleteTests(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Tests</summary>
/// <returns>the number of elements in Tests</returns>
public int countTests()
  {
  return allTests().Count;
  }

/// <summary>Part of the list interface for Tests
/// This function returns an element from the
/// collection in Tests based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Frame getTests(int idx)
{
  return (Frame) ( allTests()[idx]);
}

private System.Collections.ArrayList aTestRefs;

/// <summary>Part of the list interface for TestRefs</summary>
/// <returns>a collection of all the elements in TestRefs</returns>
public System.Collections.ArrayList allTestRefs()
  {
if (aTestRefs == null){
    setAllTestRefs( new System.Collections.ArrayList() );
} // If
    return aTestRefs;
  }

/// <summary>Part of the list interface for TestRefs</summary>
/// <returns>a collection of all the elements in TestRefs</returns>
private System.Collections.ArrayList getTestRefs()
  {
    return allTestRefs();
  }

/// <summary>Part of the list interface for TestRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        TestRefs's current content.</param>
public void setAllTestRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestRefs = coll;
    NotifyControllers(null);
  }
public void setAllTestRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs</summary>
/// <param name="el">a FrameRef to add to the collection in 
///           TestRefs</param>
/// <seealso cref="appendTestRefs(System.Collections.IList)"/>
public void appendTestRefs(FrameRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTestRefs(Lock aLock,FrameRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TestRefs</summary>
/// <param name="coll">a collection ofFrameRefs to add to the collection in 
///           TestRefs</param>
/// <seealso cref="appendTestRefs(FrameRef)"/>
public void appendTestRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allTestRefs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTestRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTestRefs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs
/// This insertion function inserts a new element in the
/// collection in TestRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTestRefs(int idx, FrameRef el)
  {
  __setDirty(true);
  allTestRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTestRefs(int idx, FrameRef el,Lock aLock)
  {
  __setDirty(true);
  allTestRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTestRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allTestRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for TestRefs
/// This deletion function removes an element from the
/// collection in TestRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTestRefs(int idx)
  {
  __setDirty(true);
  allTestRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTestRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allTestRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs
/// This deletion function removes an element from the
/// collection in TestRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTestRefs(IXmlBBase obj)
  {
  int idx = indexOfTestRefs(obj);
  if (idx >= 0) { deleteTestRefs(idx);
NotifyControllers(null);
   }
  }

public void removeTestRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTestRefs(obj);
  if (idx >= 0) { deleteTestRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TestRefs</summary>
/// <returns>the number of elements in TestRefs</returns>
public int countTestRefs()
  {
  return allTestRefs().Count;
  }

/// <summary>Part of the list interface for TestRefs
/// This function returns an element from the
/// collection in TestRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public FrameRef getTestRefs(int idx)
{
  return (FrameRef) ( allTestRefs()[idx]);
}

private  TranslationDictionary aTranslationDictionary;

public  TranslationDictionary getTranslationDictionary() { return aTranslationDictionary;}

public  void setTranslationDictionary(TranslationDictionary v) {
  aTranslationDictionary = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  ShortcutDictionary aShortcutDictionary;

public  ShortcutDictionary getShortcutDictionary() { return aShortcutDictionary;}

public  void setShortcutDictionary(ShortcutDictionary v) {
  aShortcutDictionary = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aXsi;

public   string  getXsi() { return aXsi;}

public  void setXsi( string  v) {
  aXsi = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aXsiLocation;

public   string  getXsiLocation() { return aXsiLocation;}

public  void setXsiLocation( string  v) {
  aXsiLocation = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Dictionary()
{
Dictionary obj = this;
aSpecifications=(null);
aRuleDisablings=(null);
aNameSpaces=(null);
aNameSpaceRefs=(null);
aTests=(null);
aTestRefs=(null);
aTranslationDictionary=(null);
aShortcutDictionary=(null);
aXsi=(null);
aXsiLocation=(null);
}

public void copyTo(Dictionary other)
{
base.copyTo(other);
other.aSpecifications = aSpecifications;
other.aRuleDisablings = aRuleDisablings;
other.aNameSpaces = aNameSpaces;
other.aNameSpaceRefs = aNameSpaceRefs;
other.aTests = aTests;
other.aTestRefs = aTestRefs;
other.aTranslationDictionary = aTranslationDictionary;
other.aShortcutDictionary = aShortcutDictionary;
other.aXsi = aXsi;
other.aXsiLocation = aXsiLocation;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
Specification fl147;
bool fl158;
RuleDisabling fl160;
bool fl171;
NameSpace fl173;
NameSpaceRef fl185;
bool fl196;
Frame fl198;
FrameRef fl210;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl147 = null;
while(ctxt.lookAheadOpeningTag ("<Specification")) {
fl147 = acceptor.lAccept_Specification(ctxt, "</Specification>");
appendSpecifications(fl147);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<RuleDisabling")){
ctxt.skipWhiteSpace();
fl158 = true ; 
while (fl158) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl158 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl160 = null;
while(ctxt.lookAheadOpeningTag ("<RuleDisabling")) {
fl160 = acceptor.lAccept_RuleDisabling(ctxt, "</RuleDisabling>");
appendRuleDisablings(fl160);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</RuleDisabling>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<NameSpaces");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl171 = true ; 
while (fl171) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl171 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl173 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpace")) {
fl173 = acceptor.lAccept_NameSpace(ctxt, "</NameSpace>");
appendNameSpaces(fl173);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl185 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpaceRef")) {
fl185 = acceptor.lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
appendNameSpaceRefs(fl185);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</NameSpaces>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Tests")){
ctxt.skipWhiteSpace();
fl196 = true ; 
while (fl196) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl196 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl198 = null;
while(ctxt.lookAheadOpeningTag ("<Frame")) {
fl198 = acceptor.lAccept_Frame(ctxt, "</Frame>");
appendTests(fl198);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl210 = null;
while(ctxt.lookAheadOpeningTag ("<FrameRef")) {
fl210 = acceptor.lAccept_FrameRef(ctxt, "</FrameRef>");
appendTestRefs(fl210);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Tests>");
} // If
} // If
// End enclosed
// Element Ref : TranslationDictionary
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<TranslationDictionary")){
// Parsing sub element
this.setTranslationDictionary(acceptor.lAccept_TranslationDictionary(ctxt,"</TranslationDictionary>"));
setSon(this.getTranslationDictionary());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Element Ref : ShortcutDictionary
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<ShortcutDictionary")){
// Parsing sub element
this.setShortcutDictionary(acceptor.lAccept_ShortcutDictionary(ctxt,"</ShortcutDictionary>"));
setSon(this.getShortcutDictionary());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl221;
bool fl222;
bool fl223;
bool fl224;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl221 = false ; 
fl222 = false ; 
fl223 = false ; 
fl224 = true ; 
while (fl224) { // BeginLoop 
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
if (ctxt.lookAheadString("i:noNamespaceSchemaLocation=")){
indicator = 222;
} else {
indicator = 225;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("lns:xsi=")){
indicator = 221;
} else {
indicator = 225;
} // If
break;
} // Case
default:
indicator = 225;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 223;
} else {
indicator = 225;
} // If
break;
} // Case
default:
indicator = 225;
break;
} // Switch
switch (indicator) {
case 221: {
// Handling attribute xmlns:xsi
// Also handles alien attributes with prefix xmlns:xsi
if (fl221){
ctxt.fail ("Duplicate attribute: xmlns:xsi");
} // If
fl221 = true ; 
quoteChar = ctxt.acceptQuote();
this.setXsi((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 222: {
// Handling attribute xsi:noNamespaceSchemaLocation
// Also handles alien attributes with prefix xsi:noNamespaceSchemaLocation
if (fl222){
ctxt.fail ("Duplicate attribute: xsi:noNamespaceSchemaLocation");
} // If
fl222 = true ; 
quoteChar = ctxt.acceptQuote();
this.setXsiLocation((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 223: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl223){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl223 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 225: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl221){
ctxt.fail ("Mandatory attribute missing: xmlns:xsi in Dictionary");
} // If
if (!fl222){
ctxt.fail ("Mandatory attribute missing: xsi:noNamespaceSchemaLocation in Dictionary");
} // If
fl224 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Dictionary";
  endingTag = "</Dictionary>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Dictionary\"");
} // If
pw.Write('\n');
pw.Write(" xmlns:xsi=\"");
acceptor.unParsePcData(pw, this.getXsi());
pw.Write('"');
pw.Write('\n');
pw.Write(" xsi:noNamespaceSchemaLocation=\"");
acceptor.unParsePcData(pw, this.getXsiLocation());
pw.Write('"');
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSpecifications(), false, "<Specification", "</Specification>");
// Unparsing Enclosed
// Testing for empty content: RuleDisablings
if (countRuleDisablings() > 0){
pw.Write("<RuleDisabling>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRuleDisablings(), false, "<RuleDisabling", "</RuleDisabling>");
pw.Write("</RuleDisabling>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: RuleDisablings
// Unparsing Enclosed
pw.Write("<NameSpaces>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaces(), false, "<NameSpace", "</NameSpace>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaceRefs(), false, "<NameSpaceRef", "</NameSpaceRef>");
pw.Write("</NameSpaces>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<Tests>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTests(), false, "<Frame", "</Frame>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTestRefs(), false, "<FrameRef", "</FrameRef>");
pw.Write("</Tests>");
// Father is not a mixed
pw.Write('\n');
// Unparsing ElementRef
if (this.getTranslationDictionary() != null){
unParse(pw, this.getTranslationDictionary(),false,"<TranslationDictionary","</TranslationDictionary>");
} // If
// Unparsing ElementRef
if (this.getShortcutDictionary() != null){
unParse(pw, this.getShortcutDictionary(),false,"<ShortcutDictionary","</ShortcutDictionary>");
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSpecifications(); i++) {
  l.Add(getSpecifications(i));
}
for (int i = 0; i < countRuleDisablings(); i++) {
  l.Add(getRuleDisablings(i));
}
for (int i = 0; i < countNameSpaces(); i++) {
  l.Add(getNameSpaces(i));
}
for (int i = 0; i < countNameSpaceRefs(); i++) {
  l.Add(getNameSpaceRefs(i));
}
for (int i = 0; i < countTests(); i++) {
  l.Add(getTests(i));
}
for (int i = 0; i < countTestRefs(); i++) {
  l.Add(getTestRefs(i));
}
l.Add(this.getTranslationDictionary());
l.Add(this.getShortcutDictionary());
}

}
public partial class RuleDisabling
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getRule().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RuleDisablingController.alertChange(aLock, this);
}
private   string  aRule;

public   string  getRule() { return aRule;}

public  void setRule( string  v) {
  aRule = v;
  __setDirty(true);
  NotifyControllers(null);
}


public RuleDisabling()
{
RuleDisabling obj = this;
aRule=(null);
}

public void copyTo(RuleDisabling other)
{
base.copyTo(other);
other.aRule = aRule;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl231;
bool fl232;
bool fl233;
bool fl234;
bool fl235;
bool fl236;
bool fl237;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl231 = false ; 
fl232 = false ; 
fl233 = false ; 
fl234 = false ; 
fl235 = false ; 
fl236 = false ; 
fl237 = true ; 
while (fl237) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 233;
} else {
indicator = 238;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("ule=")){
indicator = 231;
} else {
indicator = 238;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 234;
} else {
indicator = 238;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 235;
} else {
indicator = 238;
} // If
break;
} // Case
default:
indicator = 238;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 232;
} else {
indicator = 238;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 236;
} else {
indicator = 238;
} // If
break;
} // Case
default:
indicator = 238;
break;
} // Switch
switch (indicator) {
case 231: {
// Handling attribute Rule
// Also handles alien attributes with prefix Rule
if (fl231){
ctxt.fail ("Duplicate attribute: Rule");
} // If
fl231 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRule((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 232: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl232){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl232 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 233: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl233){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl233 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 234: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl234){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl234 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 235: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl235){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl235 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 236: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl236){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl236 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 238: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl231){
ctxt.fail ("Mandatory attribute missing: Rule in RuleDisabling");
} // If
if (!fl232){
this.setImplemented( false);
} // If
if (!fl233){
this.setVerified( false);
} // If
if (!fl234){
this.setNeedsRequirement( true);
} // If
fl237 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RuleDisabling";
  endingTag = "</RuleDisabling>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RuleDisabling\"");
} // If
pw.Write('\n');
pw.Write(" Rule=\"");
acceptor.unParsePcData(pw, this.getRule());
pw.Write('"');
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class NameSpaceRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.NameSpaceRefController.alertChange(aLock, this);
}
public NameSpaceRef()
{
NameSpaceRef obj = this;
}

public void copyTo(NameSpaceRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl247;
bool fl248;
bool fl249;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl247 = false ; 
fl248 = false ; 
fl249 = true ; 
while (fl249) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 247;
} else {
indicator = 250;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 248;
} else {
indicator = 250;
} // If
break;
} // Case
default:
indicator = 250;
break;
} // Switch
switch (indicator) {
case 247: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl247){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl247 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 248: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl248){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl248 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 250: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl249 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<NameSpaceRef";
  endingTag = "</NameSpaceRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"NameSpaceRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class NameSpace
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.NameSpaceController.alertChange(aLock, this);
}
private System.Collections.ArrayList aNameSpaces;

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
public System.Collections.ArrayList allNameSpaces()
  {
if (aNameSpaces == null){
    setAllNameSpaces( new System.Collections.ArrayList() );
} // If
    return aNameSpaces;
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
private System.Collections.ArrayList getNameSpaces()
  {
    return allNameSpaces();
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaces's current content.</param>
public void setAllNameSpaces(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaces(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="el">a NameSpace to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(System.Collections.IList)"/>
public void appendNameSpaces(NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaces(Lock aLock,NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection ofNameSpaces to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(NameSpace)"/>
public void appendNameSpaces(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaces().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaces(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This insertion function inserts a new element in the
/// collection in NameSpaces</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaces(int idx, NameSpace el)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaces(int idx, NameSpace el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaces(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaces()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaces(int idx)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaces(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaces(IXmlBBase obj)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaces(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>the number of elements in NameSpaces</returns>
public int countNameSpaces()
  {
  return allNameSpaces().Count;
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns an element from the
/// collection in NameSpaces based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpace getNameSpaces(int idx)
{
  return (NameSpace) ( allNameSpaces()[idx]);
}

private System.Collections.ArrayList aNameSpaceRefs;

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
public System.Collections.ArrayList allNameSpaceRefs()
  {
if (aNameSpaceRefs == null){
    setAllNameSpaceRefs( new System.Collections.ArrayList() );
} // If
    return aNameSpaceRefs;
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
private System.Collections.ArrayList getNameSpaceRefs()
  {
    return allNameSpaceRefs();
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaceRefs's current content.</param>
public void setAllNameSpaceRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaceRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="el">a NameSpaceRef to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(System.Collections.IList)"/>
public void appendNameSpaceRefs(NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(Lock aLock,NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection ofNameSpaceRefs to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(NameSpaceRef)"/>
public void appendNameSpaceRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaceRefs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This insertion function inserts a new element in the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaceRefs(int idx, NameSpaceRef el)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaceRefs(int idx, NameSpaceRef el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaceRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaceRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaceRefs(int idx)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaceRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaceRefs(IXmlBBase obj)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaceRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>the number of elements in NameSpaceRefs</returns>
public int countNameSpaceRefs()
  {
  return allNameSpaceRefs().Count;
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns an element from the
/// collection in NameSpaceRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpaceRef getNameSpaceRefs(int idx)
{
  return (NameSpaceRef) ( allNameSpaceRefs()[idx]);
}

private System.Collections.ArrayList aRanges;

/// <summary>Part of the list interface for Ranges</summary>
/// <returns>a collection of all the elements in Ranges</returns>
public System.Collections.ArrayList allRanges()
  {
if (aRanges == null){
    setAllRanges( new System.Collections.ArrayList() );
} // If
    return aRanges;
  }

/// <summary>Part of the list interface for Ranges</summary>
/// <returns>a collection of all the elements in Ranges</returns>
private System.Collections.ArrayList getRanges()
  {
    return allRanges();
  }

/// <summary>Part of the list interface for Ranges</summary>
/// <param name="coll">a collection of elements which replaces 
///        Ranges's current content.</param>
public void setAllRanges(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRanges = coll;
    NotifyControllers(null);
  }
public void setAllRanges(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRanges = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges</summary>
/// <param name="el">a Range to add to the collection in 
///           Ranges</param>
/// <seealso cref="appendRanges(System.Collections.IList)"/>
public void appendRanges(Range el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRanges().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRanges(Lock aLock,Range el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRanges().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Ranges</summary>
/// <param name="coll">a collection ofRanges to add to the collection in 
///           Ranges</param>
/// <seealso cref="appendRanges(Range)"/>
public void appendRanges(System.Collections.IList coll)
  {
  __setDirty(true);
  allRanges().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRanges(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRanges().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges
/// This insertion function inserts a new element in the
/// collection in Ranges</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRanges(int idx, Range el)
  {
  __setDirty(true);
  allRanges().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRanges(int idx, Range el,Lock aLock)
  {
  __setDirty(true);
  allRanges().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRanges(IXmlBBase el)
  {
  return ((System.Collections.IList) allRanges()).IndexOf (el);
  }

/// <summary>Part of the list interface for Ranges
/// This deletion function removes an element from the
/// collection in Ranges</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRanges(int idx)
  {
  __setDirty(true);
  allRanges().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRanges(int idx,Lock aLock)
  {
  __setDirty(true);
  allRanges().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges
/// This deletion function removes an element from the
/// collection in Ranges
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRanges(IXmlBBase obj)
  {
  int idx = indexOfRanges(obj);
  if (idx >= 0) { deleteRanges(idx);
NotifyControllers(null);
   }
  }

public void removeRanges(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRanges(obj);
  if (idx >= 0) { deleteRanges(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Ranges</summary>
/// <returns>the number of elements in Ranges</returns>
public int countRanges()
  {
  return allRanges().Count;
  }

/// <summary>Part of the list interface for Ranges
/// This function returns an element from the
/// collection in Ranges based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Range getRanges(int idx)
{
  return (Range) ( allRanges()[idx]);
}

private System.Collections.ArrayList aEnumerations;

/// <summary>Part of the list interface for Enumerations</summary>
/// <returns>a collection of all the elements in Enumerations</returns>
public System.Collections.ArrayList allEnumerations()
  {
if (aEnumerations == null){
    setAllEnumerations( new System.Collections.ArrayList() );
} // If
    return aEnumerations;
  }

/// <summary>Part of the list interface for Enumerations</summary>
/// <returns>a collection of all the elements in Enumerations</returns>
private System.Collections.ArrayList getEnumerations()
  {
    return allEnumerations();
  }

/// <summary>Part of the list interface for Enumerations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Enumerations's current content.</param>
public void setAllEnumerations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aEnumerations = coll;
    NotifyControllers(null);
  }
public void setAllEnumerations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aEnumerations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations</summary>
/// <param name="el">a Enum to add to the collection in 
///           Enumerations</param>
/// <seealso cref="appendEnumerations(System.Collections.IList)"/>
public void appendEnumerations(Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allEnumerations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendEnumerations(Lock aLock,Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allEnumerations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Enumerations</summary>
/// <param name="coll">a collection ofEnums to add to the collection in 
///           Enumerations</param>
/// <seealso cref="appendEnumerations(Enum)"/>
public void appendEnumerations(System.Collections.IList coll)
  {
  __setDirty(true);
  allEnumerations().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendEnumerations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allEnumerations().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations
/// This insertion function inserts a new element in the
/// collection in Enumerations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertEnumerations(int idx, Enum el)
  {
  __setDirty(true);
  allEnumerations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertEnumerations(int idx, Enum el,Lock aLock)
  {
  __setDirty(true);
  allEnumerations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfEnumerations(IXmlBBase el)
  {
  return ((System.Collections.IList) allEnumerations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Enumerations
/// This deletion function removes an element from the
/// collection in Enumerations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteEnumerations(int idx)
  {
  __setDirty(true);
  allEnumerations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteEnumerations(int idx,Lock aLock)
  {
  __setDirty(true);
  allEnumerations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations
/// This deletion function removes an element from the
/// collection in Enumerations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeEnumerations(IXmlBBase obj)
  {
  int idx = indexOfEnumerations(obj);
  if (idx >= 0) { deleteEnumerations(idx);
NotifyControllers(null);
   }
  }

public void removeEnumerations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfEnumerations(obj);
  if (idx >= 0) { deleteEnumerations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Enumerations</summary>
/// <returns>the number of elements in Enumerations</returns>
public int countEnumerations()
  {
  return allEnumerations().Count;
  }

/// <summary>Part of the list interface for Enumerations
/// This function returns an element from the
/// collection in Enumerations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Enum getEnumerations(int idx)
{
  return (Enum) ( allEnumerations()[idx]);
}

private System.Collections.ArrayList aStructures;

/// <summary>Part of the list interface for Structures</summary>
/// <returns>a collection of all the elements in Structures</returns>
public System.Collections.ArrayList allStructures()
  {
if (aStructures == null){
    setAllStructures( new System.Collections.ArrayList() );
} // If
    return aStructures;
  }

/// <summary>Part of the list interface for Structures</summary>
/// <returns>a collection of all the elements in Structures</returns>
private System.Collections.ArrayList getStructures()
  {
    return allStructures();
  }

/// <summary>Part of the list interface for Structures</summary>
/// <param name="coll">a collection of elements which replaces 
///        Structures's current content.</param>
public void setAllStructures(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStructures = coll;
    NotifyControllers(null);
  }
public void setAllStructures(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStructures = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures</summary>
/// <param name="el">a Structure to add to the collection in 
///           Structures</param>
/// <seealso cref="appendStructures(System.Collections.IList)"/>
public void appendStructures(Structure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStructures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStructures(Lock aLock,Structure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStructures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Structures</summary>
/// <param name="coll">a collection ofStructures to add to the collection in 
///           Structures</param>
/// <seealso cref="appendStructures(Structure)"/>
public void appendStructures(System.Collections.IList coll)
  {
  __setDirty(true);
  allStructures().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStructures(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStructures().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures
/// This insertion function inserts a new element in the
/// collection in Structures</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStructures(int idx, Structure el)
  {
  __setDirty(true);
  allStructures().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStructures(int idx, Structure el,Lock aLock)
  {
  __setDirty(true);
  allStructures().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStructures(IXmlBBase el)
  {
  return ((System.Collections.IList) allStructures()).IndexOf (el);
  }

/// <summary>Part of the list interface for Structures
/// This deletion function removes an element from the
/// collection in Structures</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStructures(int idx)
  {
  __setDirty(true);
  allStructures().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStructures(int idx,Lock aLock)
  {
  __setDirty(true);
  allStructures().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures
/// This deletion function removes an element from the
/// collection in Structures
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStructures(IXmlBBase obj)
  {
  int idx = indexOfStructures(obj);
  if (idx >= 0) { deleteStructures(idx);
NotifyControllers(null);
   }
  }

public void removeStructures(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStructures(obj);
  if (idx >= 0) { deleteStructures(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Structures</summary>
/// <returns>the number of elements in Structures</returns>
public int countStructures()
  {
  return allStructures().Count;
  }

/// <summary>Part of the list interface for Structures
/// This function returns an element from the
/// collection in Structures based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Structure getStructures(int idx)
{
  return (Structure) ( allStructures()[idx]);
}

private System.Collections.ArrayList aCollections;

/// <summary>Part of the list interface for Collections</summary>
/// <returns>a collection of all the elements in Collections</returns>
public System.Collections.ArrayList allCollections()
  {
if (aCollections == null){
    setAllCollections( new System.Collections.ArrayList() );
} // If
    return aCollections;
  }

/// <summary>Part of the list interface for Collections</summary>
/// <returns>a collection of all the elements in Collections</returns>
private System.Collections.ArrayList getCollections()
  {
    return allCollections();
  }

/// <summary>Part of the list interface for Collections</summary>
/// <param name="coll">a collection of elements which replaces 
///        Collections's current content.</param>
public void setAllCollections(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCollections = coll;
    NotifyControllers(null);
  }
public void setAllCollections(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCollections = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections</summary>
/// <param name="el">a Collection to add to the collection in 
///           Collections</param>
/// <seealso cref="appendCollections(System.Collections.IList)"/>
public void appendCollections(Collection el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCollections().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendCollections(Lock aLock,Collection el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCollections().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Collections</summary>
/// <param name="coll">a collection ofCollections to add to the collection in 
///           Collections</param>
/// <seealso cref="appendCollections(Collection)"/>
public void appendCollections(System.Collections.IList coll)
  {
  __setDirty(true);
  allCollections().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendCollections(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allCollections().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections
/// This insertion function inserts a new element in the
/// collection in Collections</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertCollections(int idx, Collection el)
  {
  __setDirty(true);
  allCollections().Insert (idx, el);
NotifyControllers(null);
  }

public void insertCollections(int idx, Collection el,Lock aLock)
  {
  __setDirty(true);
  allCollections().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfCollections(IXmlBBase el)
  {
  return ((System.Collections.IList) allCollections()).IndexOf (el);
  }

/// <summary>Part of the list interface for Collections
/// This deletion function removes an element from the
/// collection in Collections</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteCollections(int idx)
  {
  __setDirty(true);
  allCollections().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteCollections(int idx,Lock aLock)
  {
  __setDirty(true);
  allCollections().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections
/// This deletion function removes an element from the
/// collection in Collections
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeCollections(IXmlBBase obj)
  {
  int idx = indexOfCollections(obj);
  if (idx >= 0) { deleteCollections(idx);
NotifyControllers(null);
   }
  }

public void removeCollections(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfCollections(obj);
  if (idx >= 0) { deleteCollections(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Collections</summary>
/// <returns>the number of elements in Collections</returns>
public int countCollections()
  {
  return allCollections().Count;
  }

/// <summary>Part of the list interface for Collections
/// This function returns an element from the
/// collection in Collections based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Collection getCollections(int idx)
{
  return (Collection) ( allCollections()[idx]);
}

private System.Collections.ArrayList aStateMachines;

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
public System.Collections.ArrayList allStateMachines()
  {
if (aStateMachines == null){
    setAllStateMachines( new System.Collections.ArrayList() );
} // If
    return aStateMachines;
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
private System.Collections.ArrayList getStateMachines()
  {
    return allStateMachines();
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection of elements which replaces 
///        StateMachines's current content.</param>
public void setAllStateMachines(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
    NotifyControllers(null);
  }
public void setAllStateMachines(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="el">a StateMachine to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(System.Collections.IList)"/>
public void appendStateMachines(StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStateMachines(Lock aLock,StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection ofStateMachines to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(StateMachine)"/>
public void appendStateMachines(System.Collections.IList coll)
  {
  __setDirty(true);
  allStateMachines().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStateMachines(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This insertion function inserts a new element in the
/// collection in StateMachines</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStateMachines(int idx, StateMachine el)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStateMachines(int idx, StateMachine el,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStateMachines(IXmlBBase el)
  {
  return ((System.Collections.IList) allStateMachines()).IndexOf (el);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStateMachines(int idx)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStateMachines(int idx,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStateMachines(IXmlBBase obj)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(null);
   }
  }

public void removeStateMachines(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>the number of elements in StateMachines</returns>
public int countStateMachines()
  {
  return allStateMachines().Count;
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns an element from the
/// collection in StateMachines based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StateMachine getStateMachines(int idx)
{
  return (StateMachine) ( allStateMachines()[idx]);
}

private System.Collections.ArrayList aFunctions;

/// <summary>Part of the list interface for Functions</summary>
/// <returns>a collection of all the elements in Functions</returns>
public System.Collections.ArrayList allFunctions()
  {
if (aFunctions == null){
    setAllFunctions( new System.Collections.ArrayList() );
} // If
    return aFunctions;
  }

/// <summary>Part of the list interface for Functions</summary>
/// <returns>a collection of all the elements in Functions</returns>
private System.Collections.ArrayList getFunctions()
  {
    return allFunctions();
  }

/// <summary>Part of the list interface for Functions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Functions's current content.</param>
public void setAllFunctions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFunctions = coll;
    NotifyControllers(null);
  }
public void setAllFunctions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFunctions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions</summary>
/// <param name="el">a Function to add to the collection in 
///           Functions</param>
/// <seealso cref="appendFunctions(System.Collections.IList)"/>
public void appendFunctions(Function el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFunctions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFunctions(Lock aLock,Function el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFunctions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Functions</summary>
/// <param name="coll">a collection ofFunctions to add to the collection in 
///           Functions</param>
/// <seealso cref="appendFunctions(Function)"/>
public void appendFunctions(System.Collections.IList coll)
  {
  __setDirty(true);
  allFunctions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFunctions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFunctions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions
/// This insertion function inserts a new element in the
/// collection in Functions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFunctions(int idx, Function el)
  {
  __setDirty(true);
  allFunctions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFunctions(int idx, Function el,Lock aLock)
  {
  __setDirty(true);
  allFunctions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFunctions(IXmlBBase el)
  {
  return ((System.Collections.IList) allFunctions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Functions
/// This deletion function removes an element from the
/// collection in Functions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFunctions(int idx)
  {
  __setDirty(true);
  allFunctions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFunctions(int idx,Lock aLock)
  {
  __setDirty(true);
  allFunctions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions
/// This deletion function removes an element from the
/// collection in Functions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFunctions(IXmlBBase obj)
  {
  int idx = indexOfFunctions(obj);
  if (idx >= 0) { deleteFunctions(idx);
NotifyControllers(null);
   }
  }

public void removeFunctions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFunctions(obj);
  if (idx >= 0) { deleteFunctions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Functions</summary>
/// <returns>the number of elements in Functions</returns>
public int countFunctions()
  {
  return allFunctions().Count;
  }

/// <summary>Part of the list interface for Functions
/// This function returns an element from the
/// collection in Functions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Function getFunctions(int idx)
{
  return (Function) ( allFunctions()[idx]);
}

private System.Collections.ArrayList aProcedures;

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
public System.Collections.ArrayList allProcedures()
  {
if (aProcedures == null){
    setAllProcedures( new System.Collections.ArrayList() );
} // If
    return aProcedures;
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
private System.Collections.ArrayList getProcedures()
  {
    return allProcedures();
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection of elements which replaces 
///        Procedures's current content.</param>
public void setAllProcedures(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
    NotifyControllers(null);
  }
public void setAllProcedures(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="el">a Procedure to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(System.Collections.IList)"/>
public void appendProcedures(Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendProcedures(Lock aLock,Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection ofProcedures to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(Procedure)"/>
public void appendProcedures(System.Collections.IList coll)
  {
  __setDirty(true);
  allProcedures().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendProcedures(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allProcedures().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This insertion function inserts a new element in the
/// collection in Procedures</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertProcedures(int idx, Procedure el)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(null);
  }

public void insertProcedures(int idx, Procedure el,Lock aLock)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfProcedures(IXmlBBase el)
  {
  return ((System.Collections.IList) allProcedures()).IndexOf (el);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteProcedures(int idx)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteProcedures(int idx,Lock aLock)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeProcedures(IXmlBBase obj)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(null);
   }
  }

public void removeProcedures(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>the number of elements in Procedures</returns>
public int countProcedures()
  {
  return allProcedures().Count;
  }

/// <summary>Part of the list interface for Procedures
/// This function returns an element from the
/// collection in Procedures based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Procedure getProcedures(int idx)
{
  return (Procedure) ( allProcedures()[idx]);
}

private System.Collections.ArrayList aVariables;

/// <summary>Part of the list interface for Variables</summary>
/// <returns>a collection of all the elements in Variables</returns>
public System.Collections.ArrayList allVariables()
  {
if (aVariables == null){
    setAllVariables( new System.Collections.ArrayList() );
} // If
    return aVariables;
  }

/// <summary>Part of the list interface for Variables</summary>
/// <returns>a collection of all the elements in Variables</returns>
private System.Collections.ArrayList getVariables()
  {
    return allVariables();
  }

/// <summary>Part of the list interface for Variables</summary>
/// <param name="coll">a collection of elements which replaces 
///        Variables's current content.</param>
public void setAllVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aVariables = coll;
    NotifyControllers(null);
  }
public void setAllVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables</summary>
/// <param name="el">a Variable to add to the collection in 
///           Variables</param>
/// <seealso cref="appendVariables(System.Collections.IList)"/>
public void appendVariables(Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendVariables(Lock aLock,Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Variables</summary>
/// <param name="coll">a collection ofVariables to add to the collection in 
///           Variables</param>
/// <seealso cref="appendVariables(Variable)"/>
public void appendVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allVariables().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allVariables().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables
/// This insertion function inserts a new element in the
/// collection in Variables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertVariables(int idx, Variable el)
  {
  __setDirty(true);
  allVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertVariables(int idx, Variable el,Lock aLock)
  {
  __setDirty(true);
  allVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for Variables
/// This deletion function removes an element from the
/// collection in Variables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteVariables(int idx)
  {
  __setDirty(true);
  allVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables
/// This deletion function removes an element from the
/// collection in Variables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeVariables(IXmlBBase obj)
  {
  int idx = indexOfVariables(obj);
  if (idx >= 0) { deleteVariables(idx);
NotifyControllers(null);
   }
  }

public void removeVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfVariables(obj);
  if (idx >= 0) { deleteVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Variables</summary>
/// <returns>the number of elements in Variables</returns>
public int countVariables()
  {
  return allVariables().Count;
  }

/// <summary>Part of the list interface for Variables
/// This function returns an element from the
/// collection in Variables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Variable getVariables(int idx)
{
  return (Variable) ( allVariables()[idx]);
}

private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public NameSpace()
{
NameSpace obj = this;
aNameSpaces=(null);
aNameSpaceRefs=(null);
aRanges=(null);
aEnumerations=(null);
aStructures=(null);
aCollections=(null);
aStateMachines=(null);
aFunctions=(null);
aProcedures=(null);
aVariables=(null);
aRules=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aComment=(null);
}

public void copyTo(NameSpace other)
{
base.copyTo(other);
other.aNameSpaces = aNameSpaces;
other.aNameSpaceRefs = aNameSpaceRefs;
other.aRanges = aRanges;
other.aEnumerations = aEnumerations;
other.aStructures = aStructures;
other.aCollections = aCollections;
other.aStateMachines = aStateMachines;
other.aFunctions = aFunctions;
other.aProcedures = aProcedures;
other.aVariables = aVariables;
other.aRules = aRules;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl254;
bool fl255;
NameSpace fl257;
NameSpaceRef fl269;
bool fl280;
Range fl282;
bool fl293;
Enum fl295;
bool fl306;
Structure fl308;
bool fl319;
Collection fl321;
bool fl332;
StateMachine fl334;
bool fl345;
Function fl347;
bool fl358;
Procedure fl360;
bool fl371;
Variable fl373;
bool fl384;
Rule fl386;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl254 = true ; 
while (fl254) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl254 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<NameSpaces")){
ctxt.skipWhiteSpace();
fl255 = true ; 
while (fl255) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl255 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl257 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpace")) {
fl257 = acceptor.lAccept_NameSpace(ctxt, "</NameSpace>");
appendNameSpaces(fl257);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl269 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpaceRef")) {
fl269 = acceptor.lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
appendNameSpaceRefs(fl269);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</NameSpaces>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Ranges")){
ctxt.skipWhiteSpace();
fl280 = true ; 
while (fl280) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl280 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl282 = null;
while(ctxt.lookAheadOpeningTag ("<Range")) {
fl282 = acceptor.lAccept_Range(ctxt, "</Range>");
appendRanges(fl282);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Ranges>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Enumerations")){
ctxt.skipWhiteSpace();
fl293 = true ; 
while (fl293) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl293 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl295 = null;
while(ctxt.lookAheadOpeningTag ("<Enum")) {
fl295 = acceptor.lAccept_Enum(ctxt, "</Enum>");
appendEnumerations(fl295);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Enumerations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Structures")){
ctxt.skipWhiteSpace();
fl306 = true ; 
while (fl306) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl306 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl308 = null;
while(ctxt.lookAheadOpeningTag ("<Structure")) {
fl308 = acceptor.lAccept_Structure(ctxt, "</Structure>");
appendStructures(fl308);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Structures>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Collections")){
ctxt.skipWhiteSpace();
fl319 = true ; 
while (fl319) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl319 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl321 = null;
while(ctxt.lookAheadOpeningTag ("<Collection")) {
fl321 = acceptor.lAccept_Collection(ctxt, "</Collection>");
appendCollections(fl321);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Collections>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<StateMachines")){
ctxt.skipWhiteSpace();
fl332 = true ; 
while (fl332) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl332 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl334 = null;
while(ctxt.lookAheadOpeningTag ("<StateMachine")) {
fl334 = acceptor.lAccept_StateMachine(ctxt, "</StateMachine>");
appendStateMachines(fl334);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</StateMachines>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Functions")){
ctxt.skipWhiteSpace();
fl345 = true ; 
while (fl345) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl345 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl347 = null;
while(ctxt.lookAheadOpeningTag ("<Function")) {
fl347 = acceptor.lAccept_Function(ctxt, "</Function>");
appendFunctions(fl347);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Functions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Procedures")){
ctxt.skipWhiteSpace();
fl358 = true ; 
while (fl358) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl358 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl360 = null;
while(ctxt.lookAheadOpeningTag ("<Procedure")) {
fl360 = acceptor.lAccept_Procedure(ctxt, "</Procedure>");
appendProcedures(fl360);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Procedures>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Variables")){
ctxt.skipWhiteSpace();
fl371 = true ; 
while (fl371) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl371 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl373 = null;
while(ctxt.lookAheadOpeningTag ("<Variable")) {
fl373 = acceptor.lAccept_Variable(ctxt, "</Variable>");
appendVariables(fl373);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Variables>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl384 = true ; 
while (fl384) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl384 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl386 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl386 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl386);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl397;
bool fl398;
bool fl399;
bool fl400;
bool fl401;
bool fl402;
bool fl403;
bool fl404;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl397 = false ; 
fl398 = false ; 
fl399 = false ; 
fl400 = false ; 
fl401 = false ; 
fl402 = false ; 
fl403 = false ; 
fl404 = true ; 
while (fl404) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 398;
} else {
indicator = 405;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 397;
} else {
indicator = 405;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 399;
} else {
indicator = 405;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 402;
} else {
indicator = 405;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 401;
} else {
indicator = 405;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 400;
} else {
indicator = 405;
} // If
break;
} // Case
default:
indicator = 405;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 403;
} else {
indicator = 405;
} // If
break;
} // Case
default:
indicator = 405;
break;
} // Switch
switch (indicator) {
case 397: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl397){
ctxt.fail ("Duplicate attribute: X");
} // If
fl397 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 398: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl398){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl398 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 399: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl399){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl399 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 400: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl400){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl400 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 401: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl401){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl401 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 402: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl402){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl402 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 403: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl403){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl403 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 405: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl397){
this.setX(0);
} // If
if (!fl398){
this.setY(0);
} // If
if (!fl399){
this.setWidth(0);
} // If
if (!fl400){
this.setHeight(0);
} // If
if (!fl401){
this.setHidden( false);
} // If
fl404 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<NameSpace";
  endingTag = "</NameSpace>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"NameSpace\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
pw.Write("<NameSpaces>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaces(), false, "<NameSpace", "</NameSpace>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaceRefs(), false, "<NameSpaceRef", "</NameSpaceRef>");
pw.Write("</NameSpaces>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: Ranges
if (countRanges() > 0){
pw.Write("<Ranges>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRanges(), false, "<Range", "</Range>");
pw.Write("</Ranges>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Ranges
// Unparsing Enclosed
// Testing for empty content: Enumerations
if (countEnumerations() > 0){
pw.Write("<Enumerations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getEnumerations(), false, "<Enum", "</Enum>");
pw.Write("</Enumerations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Enumerations
// Unparsing Enclosed
// Testing for empty content: Structures
if (countStructures() > 0){
pw.Write("<Structures>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStructures(), false, "<Structure", "</Structure>");
pw.Write("</Structures>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Structures
// Unparsing Enclosed
// Testing for empty content: Collections
if (countCollections() > 0){
pw.Write("<Collections>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getCollections(), false, "<Collection", "</Collection>");
pw.Write("</Collections>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Collections
// Unparsing Enclosed
// Testing for empty content: StateMachines
if (countStateMachines() > 0){
pw.Write("<StateMachines>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStateMachines(), false, "<StateMachine", "</StateMachine>");
pw.Write("</StateMachines>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: StateMachines
// Unparsing Enclosed
// Testing for empty content: Functions
if (countFunctions() > 0){
pw.Write("<Functions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFunctions(), false, "<Function", "</Function>");
pw.Write("</Functions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Functions
// Unparsing Enclosed
// Testing for empty content: Procedures
if (countProcedures() > 0){
pw.Write("<Procedures>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getProcedures(), false, "<Procedure", "</Procedure>");
pw.Write("</Procedures>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Procedures
// Unparsing Enclosed
// Testing for empty content: Variables
if (countVariables() > 0){
pw.Write("<Variables>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getVariables(), false, "<Variable", "</Variable>");
pw.Write("</Variables>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Variables
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countNameSpaces(); i++) {
  l.Add(getNameSpaces(i));
}
for (int i = 0; i < countNameSpaceRefs(); i++) {
  l.Add(getNameSpaceRefs(i));
}
for (int i = 0; i < countRanges(); i++) {
  l.Add(getRanges(i));
}
for (int i = 0; i < countEnumerations(); i++) {
  l.Add(getEnumerations(i));
}
for (int i = 0; i < countStructures(); i++) {
  l.Add(getStructures(i));
}
for (int i = 0; i < countCollections(); i++) {
  l.Add(getCollections(i));
}
for (int i = 0; i < countStateMachines(); i++) {
  l.Add(getStateMachines(i));
}
for (int i = 0; i < countFunctions(); i++) {
  l.Add(getFunctions(i));
}
for (int i = 0; i < countProcedures(); i++) {
  l.Add(getProcedures(i));
}
for (int i = 0; i < countVariables(); i++) {
  l.Add(getVariables(i));
}
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
}

}
public partial class ReqRef
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getId().CompareTo((String) search) == 0)return true;
if(getSpecId().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ReqRefController.alertChange(aLock, this);
}
private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aSpecId;

public   string  getSpecId() { return aSpecId;}

public  void setSpecId( string  v) {
  aSpecId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ReqRef()
{
ReqRef obj = this;
aId=(null);
aSpecId=(null);
aComment=(null);
}

public void copyTo(ReqRef other)
{
base.copyTo(other);
other.aId = aId;
other.aSpecId = aSpecId;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl415;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl415 = true ; 
while (fl415) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl415 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl416;
bool fl417;
bool fl418;
bool fl419;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl416 = false ; 
fl417 = false ; 
fl418 = false ; 
fl419 = true ; 
while (fl419) { // BeginLoop 
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
if (ctxt.lookAheadString("pecId=")){
indicator = 417;
} else {
indicator = 420;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 416;
} else {
indicator = 420;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 418;
} else {
indicator = 420;
} // If
break;
} // Case
default:
indicator = 420;
break;
} // Switch
switch (indicator) {
case 416: {
// Handling attribute Id
// Also handles alien attributes with prefix Id
if (fl416){
ctxt.fail ("Duplicate attribute: Id");
} // If
fl416 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 417: {
// Handling attribute SpecId
// Also handles alien attributes with prefix SpecId
if (fl417){
ctxt.fail ("Duplicate attribute: SpecId");
} // If
fl417 = true ; 
quoteChar = ctxt.acceptQuote();
this.setSpecId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 418: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl418){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl418 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 420: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl416){
ctxt.fail ("Mandatory attribute missing: Id in ReqRef");
} // If
fl419 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ReqRef";
  endingTag = "</ReqRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ReqRef\"");
} // If
pw.Write('\n');
pw.Write(" Id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
if (this.getSpecId() != null){
pw.Write(" SpecId=\"");
acceptor.unParsePcData(pw, this.getSpecId());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public abstract partial class Type
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getDefault().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TypeController.alertChange(aLock, this);
}
private   string  aDefault;

public   string  getDefault() { return aDefault;}

public  void setDefault( string  v) {
  aDefault = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Type()
{
Type obj = this;
aDefault=(null);
}

public void copyTo(Type other)
{
base.copyTo(other);
other.aDefault = aDefault;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl425;
bool fl426;
bool fl427;
bool fl428;
bool fl429;
bool fl430;
bool fl431;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl425 = false ; 
fl426 = false ; 
fl427 = false ; 
fl428 = false ; 
fl429 = false ; 
fl430 = false ; 
fl431 = true ; 
while (fl431) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 427;
} else {
indicator = 432;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 428;
} else {
indicator = 432;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 429;
} else {
indicator = 432;
} // If
break;
} // Case
default:
indicator = 432;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 426;
} else {
indicator = 432;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 430;
} else {
indicator = 432;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 425;
} else {
indicator = 432;
} // If
break;
} // Case
default:
indicator = 432;
break;
} // Switch
switch (indicator) {
case 425: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl425){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl425 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 426: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl426){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl426 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 427: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl427){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl427 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 428: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl428){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl428 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 429: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl429){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl429 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 430: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl430){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl430 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 432: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl426){
this.setImplemented( false);
} // If
if (!fl427){
this.setVerified( false);
} // If
if (!fl428){
this.setNeedsRequirement( true);
} // If
fl431 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Type";
  endingTag = "</Type>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Type\"");
} // If
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Enum
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.EnumController.alertChange(aLock, this);
}
private System.Collections.ArrayList aValues;

/// <summary>Part of the list interface for Values</summary>
/// <returns>a collection of all the elements in Values</returns>
public System.Collections.ArrayList allValues()
  {
if (aValues == null){
    setAllValues( new System.Collections.ArrayList() );
} // If
    return aValues;
  }

/// <summary>Part of the list interface for Values</summary>
/// <returns>a collection of all the elements in Values</returns>
private System.Collections.ArrayList getValues()
  {
    return allValues();
  }

/// <summary>Part of the list interface for Values</summary>
/// <param name="coll">a collection of elements which replaces 
///        Values's current content.</param>
public void setAllValues(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aValues = coll;
    NotifyControllers(null);
  }
public void setAllValues(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aValues = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values</summary>
/// <param name="el">a EnumValue to add to the collection in 
///           Values</param>
/// <seealso cref="appendValues(System.Collections.IList)"/>
public void appendValues(EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendValues(Lock aLock,EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Values</summary>
/// <param name="coll">a collection ofEnumValues to add to the collection in 
///           Values</param>
/// <seealso cref="appendValues(EnumValue)"/>
public void appendValues(System.Collections.IList coll)
  {
  __setDirty(true);
  allValues().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendValues(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allValues().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values
/// This insertion function inserts a new element in the
/// collection in Values</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertValues(int idx, EnumValue el)
  {
  __setDirty(true);
  allValues().Insert (idx, el);
NotifyControllers(null);
  }

public void insertValues(int idx, EnumValue el,Lock aLock)
  {
  __setDirty(true);
  allValues().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfValues(IXmlBBase el)
  {
  return ((System.Collections.IList) allValues()).IndexOf (el);
  }

/// <summary>Part of the list interface for Values
/// This deletion function removes an element from the
/// collection in Values</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteValues(int idx)
  {
  __setDirty(true);
  allValues().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteValues(int idx,Lock aLock)
  {
  __setDirty(true);
  allValues().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values
/// This deletion function removes an element from the
/// collection in Values
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeValues(IXmlBBase obj)
  {
  int idx = indexOfValues(obj);
  if (idx >= 0) { deleteValues(idx);
NotifyControllers(null);
   }
  }

public void removeValues(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfValues(obj);
  if (idx >= 0) { deleteValues(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Values</summary>
/// <returns>the number of elements in Values</returns>
public int countValues()
  {
  return allValues().Count;
  }

/// <summary>Part of the list interface for Values
/// This function returns an element from the
/// collection in Values based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public EnumValue getValues(int idx)
{
  return (EnumValue) ( allValues()[idx]);
}

private System.Collections.ArrayList aSubEnums;

/// <summary>Part of the list interface for SubEnums</summary>
/// <returns>a collection of all the elements in SubEnums</returns>
public System.Collections.ArrayList allSubEnums()
  {
if (aSubEnums == null){
    setAllSubEnums( new System.Collections.ArrayList() );
} // If
    return aSubEnums;
  }

/// <summary>Part of the list interface for SubEnums</summary>
/// <returns>a collection of all the elements in SubEnums</returns>
private System.Collections.ArrayList getSubEnums()
  {
    return allSubEnums();
  }

/// <summary>Part of the list interface for SubEnums</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubEnums's current content.</param>
public void setAllSubEnums(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubEnums = coll;
    NotifyControllers(null);
  }
public void setAllSubEnums(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubEnums = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums</summary>
/// <param name="el">a Enum to add to the collection in 
///           SubEnums</param>
/// <seealso cref="appendSubEnums(System.Collections.IList)"/>
public void appendSubEnums(Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubEnums().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubEnums(Lock aLock,Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubEnums().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubEnums</summary>
/// <param name="coll">a collection ofEnums to add to the collection in 
///           SubEnums</param>
/// <seealso cref="appendSubEnums(Enum)"/>
public void appendSubEnums(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubEnums().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubEnums(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubEnums().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums
/// This insertion function inserts a new element in the
/// collection in SubEnums</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubEnums(int idx, Enum el)
  {
  __setDirty(true);
  allSubEnums().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubEnums(int idx, Enum el,Lock aLock)
  {
  __setDirty(true);
  allSubEnums().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubEnums(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubEnums()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubEnums
/// This deletion function removes an element from the
/// collection in SubEnums</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubEnums(int idx)
  {
  __setDirty(true);
  allSubEnums().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubEnums(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubEnums().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums
/// This deletion function removes an element from the
/// collection in SubEnums
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubEnums(IXmlBBase obj)
  {
  int idx = indexOfSubEnums(obj);
  if (idx >= 0) { deleteSubEnums(idx);
NotifyControllers(null);
   }
  }

public void removeSubEnums(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubEnums(obj);
  if (idx >= 0) { deleteSubEnums(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubEnums</summary>
/// <returns>the number of elements in SubEnums</returns>
public int countSubEnums()
  {
  return allSubEnums().Count;
  }

/// <summary>Part of the list interface for SubEnums
/// This function returns an element from the
/// collection in SubEnums based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Enum getSubEnums(int idx)
{
  return (Enum) ( allSubEnums()[idx]);
}

public Enum()
{
Enum obj = this;
aValues=(null);
aSubEnums=(null);
}

public void copyTo(Enum other)
{
base.copyTo(other);
other.aValues = aValues;
other.aSubEnums = aSubEnums;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl441;
EnumValue fl443;
bool fl454;
Enum fl456;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Values")){
ctxt.skipWhiteSpace();
fl441 = true ; 
while (fl441) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl441 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl443 = null;
while(ctxt.lookAheadOpeningTag ("<EnumValue")) {
fl443 = acceptor.lAccept_EnumValue(ctxt, "</EnumValue>");
appendValues(fl443);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Values>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubEnums")){
ctxt.skipWhiteSpace();
fl454 = true ; 
while (fl454) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl454 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl456 = null;
while(ctxt.lookAheadOpeningTag ("<Enum")) {
fl456 = acceptor.lAccept_Enum(ctxt, "</Enum>");
appendSubEnums(fl456);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubEnums>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl467;
bool fl468;
bool fl469;
bool fl470;
bool fl471;
bool fl472;
bool fl473;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl467 = false ; 
fl468 = false ; 
fl469 = false ; 
fl470 = false ; 
fl471 = false ; 
fl472 = false ; 
fl473 = true ; 
while (fl473) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 469;
} else {
indicator = 474;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 470;
} else {
indicator = 474;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 471;
} else {
indicator = 474;
} // If
break;
} // Case
default:
indicator = 474;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 468;
} else {
indicator = 474;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 472;
} else {
indicator = 474;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 467;
} else {
indicator = 474;
} // If
break;
} // Case
default:
indicator = 474;
break;
} // Switch
switch (indicator) {
case 467: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl467){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl467 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 468: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl468){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl468 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 469: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl469){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl469 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 470: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl470){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl470 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 471: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl471){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl471 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 472: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl472){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl472 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 474: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl468){
this.setImplemented( false);
} // If
if (!fl469){
this.setVerified( false);
} // If
if (!fl470){
this.setNeedsRequirement( true);
} // If
fl473 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Enum";
  endingTag = "</Enum>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Enum\"");
} // If
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Values
if (countValues() > 0){
pw.Write("<Values>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getValues(), false, "<EnumValue", "</EnumValue>");
pw.Write("</Values>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Values
// Unparsing Enclosed
// Testing for empty content: SubEnums
if (countSubEnums() > 0){
pw.Write("<SubEnums>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubEnums(), false, "<Enum", "</Enum>");
pw.Write("</SubEnums>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubEnums
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countValues(); i++) {
  l.Add(getValues(i));
}
for (int i = 0; i < countSubEnums(); i++) {
  l.Add(getSubEnums(i));
}
}

}
public partial class EnumValue
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.EnumValueController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public EnumValue()
{
EnumValue obj = this;
aValue=(null);
}

public void copyTo(EnumValue other)
{
base.copyTo(other);
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl483;
bool fl484;
bool fl485;
bool fl486;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl483 = false ; 
fl484 = false ; 
fl485 = false ; 
fl486 = true ; 
while (fl486) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue=")){
indicator = 483;
} else {
indicator = 487;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 484;
} else {
indicator = 487;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 485;
} else {
indicator = 487;
} // If
break;
} // Case
default:
indicator = 487;
break;
} // Switch
switch (indicator) {
case 483: {
// Handling attribute Value
// Also handles alien attributes with prefix Value
if (fl483){
ctxt.fail ("Duplicate attribute: Value");
} // If
fl483 = true ; 
quoteChar = ctxt.acceptQuote();
this.setValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 484: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl484){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl484 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 485: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl485){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl485 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 487: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl483){
this.setValue("0");
} // If
fl486 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<EnumValue";
  endingTag = "</EnumValue>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"EnumValue\"");
} // If
pw.Write('\n');
if (this.getValue() != null){
pw.Write(" Value=\"");
acceptor.unParsePcData(pw, this.getValue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Range
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getMinValue().CompareTo((String) search) == 0)return true;
if(getMaxValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RangeController.alertChange(aLock, this);
}
private   string  aMinValue;

public   string  getMinValue() { return aMinValue;}

public  void setMinValue( string  v) {
  aMinValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMaxValue;

public   string  getMaxValue() { return aMaxValue;}

public  void setMaxValue( string  v) {
  aMaxValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSpecialValues;

/// <summary>Part of the list interface for SpecialValues</summary>
/// <returns>a collection of all the elements in SpecialValues</returns>
public System.Collections.ArrayList allSpecialValues()
  {
if (aSpecialValues == null){
    setAllSpecialValues( new System.Collections.ArrayList() );
} // If
    return aSpecialValues;
  }

/// <summary>Part of the list interface for SpecialValues</summary>
/// <returns>a collection of all the elements in SpecialValues</returns>
private System.Collections.ArrayList getSpecialValues()
  {
    return allSpecialValues();
  }

/// <summary>Part of the list interface for SpecialValues</summary>
/// <param name="coll">a collection of elements which replaces 
///        SpecialValues's current content.</param>
public void setAllSpecialValues(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecialValues = coll;
    NotifyControllers(null);
  }
public void setAllSpecialValues(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecialValues = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues</summary>
/// <param name="el">a EnumValue to add to the collection in 
///           SpecialValues</param>
/// <seealso cref="appendSpecialValues(System.Collections.IList)"/>
public void appendSpecialValues(EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecialValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSpecialValues(Lock aLock,EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecialValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SpecialValues</summary>
/// <param name="coll">a collection ofEnumValues to add to the collection in 
///           SpecialValues</param>
/// <seealso cref="appendSpecialValues(EnumValue)"/>
public void appendSpecialValues(System.Collections.IList coll)
  {
  __setDirty(true);
  allSpecialValues().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSpecialValues(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSpecialValues().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues
/// This insertion function inserts a new element in the
/// collection in SpecialValues</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSpecialValues(int idx, EnumValue el)
  {
  __setDirty(true);
  allSpecialValues().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSpecialValues(int idx, EnumValue el,Lock aLock)
  {
  __setDirty(true);
  allSpecialValues().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSpecialValues(IXmlBBase el)
  {
  return ((System.Collections.IList) allSpecialValues()).IndexOf (el);
  }

/// <summary>Part of the list interface for SpecialValues
/// This deletion function removes an element from the
/// collection in SpecialValues</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSpecialValues(int idx)
  {
  __setDirty(true);
  allSpecialValues().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSpecialValues(int idx,Lock aLock)
  {
  __setDirty(true);
  allSpecialValues().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues
/// This deletion function removes an element from the
/// collection in SpecialValues
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSpecialValues(IXmlBBase obj)
  {
  int idx = indexOfSpecialValues(obj);
  if (idx >= 0) { deleteSpecialValues(idx);
NotifyControllers(null);
   }
  }

public void removeSpecialValues(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSpecialValues(obj);
  if (idx >= 0) { deleteSpecialValues(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SpecialValues</summary>
/// <returns>the number of elements in SpecialValues</returns>
public int countSpecialValues()
  {
  return allSpecialValues().Count;
  }

/// <summary>Part of the list interface for SpecialValues
/// This function returns an element from the
/// collection in SpecialValues based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public EnumValue getSpecialValues(int idx)
{
  return (EnumValue) ( allSpecialValues()[idx]);
}

private  acceptor.PrecisionEnum aPrecision;

public  acceptor.PrecisionEnum getPrecision() { return aPrecision;}

public  void setPrecision(acceptor.PrecisionEnum v) {
  aPrecision = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getPrecision_AsString()
{
  return acceptor.Enum_PrecisionEnum_ToString (aPrecision);
}

public  bool setPrecision_AsString( string  v)
{
 acceptor.PrecisionEnum  temp = acceptor.StringTo_Enum_PrecisionEnum(v);
if (temp >= 0){
  aPrecision = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public Range()
{
Range obj = this;
aMinValue=(null);
aMaxValue=(null);
aSpecialValues=(null);
aPrecision=(0);
}

public void copyTo(Range other)
{
base.copyTo(other);
other.aMinValue = aMinValue;
other.aMaxValue = aMaxValue;
other.aSpecialValues = aSpecialValues;
other.aPrecision = aPrecision;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl492;
EnumValue fl494;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SpecialValues")){
ctxt.skipWhiteSpace();
fl492 = true ; 
while (fl492) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl492 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl494 = null;
while(ctxt.lookAheadOpeningTag ("<EnumValue")) {
fl494 = acceptor.lAccept_EnumValue(ctxt, "</EnumValue>");
appendSpecialValues(fl494);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SpecialValues>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl505;
bool fl506;
bool fl507;
bool fl508;
bool fl509;
bool fl510;
bool fl511;
bool fl512;
bool fl513;
bool fl514;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl505 = false ; 
fl506 = false ; 
fl507 = false ; 
fl508 = false ; 
fl509 = false ; 
fl510 = false ; 
fl511 = false ; 
fl512 = false ; 
fl513 = false ; 
fl514 = true ; 
while (fl514) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 510;
} else {
indicator = 515;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("recision=")){
indicator = 507;
} else {
indicator = 515;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 511;
} else {
indicator = 515;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 512;
} else {
indicator = 515;
} // If
break;
} // Case
default:
indicator = 515;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nValue=")){
indicator = 505;
} else {
indicator = 515;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("xValue=")){
indicator = 506;
} else {
indicator = 515;
} // If
break;
} // Case
default:
indicator = 515;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 509;
} else {
indicator = 515;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 513;
} else {
indicator = 515;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 508;
} else {
indicator = 515;
} // If
break;
} // Case
default:
indicator = 515;
break;
} // Switch
switch (indicator) {
case 505: {
// Handling attribute MinValue
// Also handles alien attributes with prefix MinValue
if (fl505){
ctxt.fail ("Duplicate attribute: MinValue");
} // If
fl505 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMinValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 506: {
// Handling attribute MaxValue
// Also handles alien attributes with prefix MaxValue
if (fl506){
ctxt.fail ("Duplicate attribute: MaxValue");
} // If
fl506 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMaxValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 507: {
// Handling attribute Precision
// Also handles alien attributes with prefix Precision
if (fl507){
ctxt.fail ("Duplicate attribute: Precision");
} // If
fl507 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPrecision(acceptor.lAcceptEnum_PrecisionEnum(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 508: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl508){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl508 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 509: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl509){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl509 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 510: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl510){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl510 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 511: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl511){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl511 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 512: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl512){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl512 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 513: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl513){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl513 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 515: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl505){
ctxt.fail ("Mandatory attribute missing: MinValue in Range");
} // If
if (!fl506){
ctxt.fail ("Mandatory attribute missing: MaxValue in Range");
} // If
if (!fl507){
this.setPrecision(acceptor.PrecisionEnum.aIntegerPrecision);
} // If
if (!fl509){
this.setImplemented( false);
} // If
if (!fl510){
this.setVerified( false);
} // If
if (!fl511){
this.setNeedsRequirement( true);
} // If
fl514 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Range";
  endingTag = "</Range>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Range\"");
} // If
pw.Write('\n');
pw.Write(" MinValue=\"");
acceptor.unParsePcData(pw, this.getMinValue());
pw.Write('"');
pw.Write('\n');
pw.Write(" MaxValue=\"");
acceptor.unParsePcData(pw, this.getMaxValue());
pw.Write('"');
pw.Write('\n');
if (this.getPrecision() != 0){
pw.Write(" Precision=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_PrecisionEnum_ToString(this.getPrecision()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: SpecialValues
if (countSpecialValues() > 0){
pw.Write("<SpecialValues>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSpecialValues(), false, "<EnumValue", "</EnumValue>");
pw.Write("</SpecialValues>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SpecialValues
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSpecialValues(); i++) {
  l.Add(getSpecialValues(i));
}
}

}
public partial class Structure
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StructureController.alertChange(aLock, this);
}
private System.Collections.ArrayList aElements;

/// <summary>Part of the list interface for Elements</summary>
/// <returns>a collection of all the elements in Elements</returns>
public System.Collections.ArrayList allElements()
  {
if (aElements == null){
    setAllElements( new System.Collections.ArrayList() );
} // If
    return aElements;
  }

/// <summary>Part of the list interface for Elements</summary>
/// <returns>a collection of all the elements in Elements</returns>
private System.Collections.ArrayList getElements()
  {
    return allElements();
  }

/// <summary>Part of the list interface for Elements</summary>
/// <param name="coll">a collection of elements which replaces 
///        Elements's current content.</param>
public void setAllElements(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aElements = coll;
    NotifyControllers(null);
  }
public void setAllElements(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aElements = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements</summary>
/// <param name="el">a StructureElement to add to the collection in 
///           Elements</param>
/// <seealso cref="appendElements(System.Collections.IList)"/>
public void appendElements(StructureElement el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allElements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendElements(Lock aLock,StructureElement el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allElements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Elements</summary>
/// <param name="coll">a collection ofStructureElements to add to the collection in 
///           Elements</param>
/// <seealso cref="appendElements(StructureElement)"/>
public void appendElements(System.Collections.IList coll)
  {
  __setDirty(true);
  allElements().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendElements(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allElements().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements
/// This insertion function inserts a new element in the
/// collection in Elements</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertElements(int idx, StructureElement el)
  {
  __setDirty(true);
  allElements().Insert (idx, el);
NotifyControllers(null);
  }

public void insertElements(int idx, StructureElement el,Lock aLock)
  {
  __setDirty(true);
  allElements().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfElements(IXmlBBase el)
  {
  return ((System.Collections.IList) allElements()).IndexOf (el);
  }

/// <summary>Part of the list interface for Elements
/// This deletion function removes an element from the
/// collection in Elements</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteElements(int idx)
  {
  __setDirty(true);
  allElements().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteElements(int idx,Lock aLock)
  {
  __setDirty(true);
  allElements().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements
/// This deletion function removes an element from the
/// collection in Elements
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeElements(IXmlBBase obj)
  {
  int idx = indexOfElements(obj);
  if (idx >= 0) { deleteElements(idx);
NotifyControllers(null);
   }
  }

public void removeElements(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfElements(obj);
  if (idx >= 0) { deleteElements(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Elements</summary>
/// <returns>the number of elements in Elements</returns>
public int countElements()
  {
  return allElements().Count;
  }

/// <summary>Part of the list interface for Elements
/// This function returns an element from the
/// collection in Elements based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StructureElement getElements(int idx)
{
  return (StructureElement) ( allElements()[idx]);
}

private System.Collections.ArrayList aProcedures;

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
public System.Collections.ArrayList allProcedures()
  {
if (aProcedures == null){
    setAllProcedures( new System.Collections.ArrayList() );
} // If
    return aProcedures;
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
private System.Collections.ArrayList getProcedures()
  {
    return allProcedures();
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection of elements which replaces 
///        Procedures's current content.</param>
public void setAllProcedures(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
    NotifyControllers(null);
  }
public void setAllProcedures(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="el">a Procedure to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(System.Collections.IList)"/>
public void appendProcedures(Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendProcedures(Lock aLock,Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection ofProcedures to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(Procedure)"/>
public void appendProcedures(System.Collections.IList coll)
  {
  __setDirty(true);
  allProcedures().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendProcedures(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allProcedures().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This insertion function inserts a new element in the
/// collection in Procedures</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertProcedures(int idx, Procedure el)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(null);
  }

public void insertProcedures(int idx, Procedure el,Lock aLock)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfProcedures(IXmlBBase el)
  {
  return ((System.Collections.IList) allProcedures()).IndexOf (el);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteProcedures(int idx)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteProcedures(int idx,Lock aLock)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeProcedures(IXmlBBase obj)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(null);
   }
  }

public void removeProcedures(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>the number of elements in Procedures</returns>
public int countProcedures()
  {
  return allProcedures().Count;
  }

/// <summary>Part of the list interface for Procedures
/// This function returns an element from the
/// collection in Procedures based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Procedure getProcedures(int idx)
{
  return (Procedure) ( allProcedures()[idx]);
}

private System.Collections.ArrayList aStateMachines;

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
public System.Collections.ArrayList allStateMachines()
  {
if (aStateMachines == null){
    setAllStateMachines( new System.Collections.ArrayList() );
} // If
    return aStateMachines;
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
private System.Collections.ArrayList getStateMachines()
  {
    return allStateMachines();
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection of elements which replaces 
///        StateMachines's current content.</param>
public void setAllStateMachines(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
    NotifyControllers(null);
  }
public void setAllStateMachines(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="el">a StateMachine to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(System.Collections.IList)"/>
public void appendStateMachines(StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStateMachines(Lock aLock,StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection ofStateMachines to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(StateMachine)"/>
public void appendStateMachines(System.Collections.IList coll)
  {
  __setDirty(true);
  allStateMachines().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStateMachines(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This insertion function inserts a new element in the
/// collection in StateMachines</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStateMachines(int idx, StateMachine el)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStateMachines(int idx, StateMachine el,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStateMachines(IXmlBBase el)
  {
  return ((System.Collections.IList) allStateMachines()).IndexOf (el);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStateMachines(int idx)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStateMachines(int idx,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStateMachines(IXmlBBase obj)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(null);
   }
  }

public void removeStateMachines(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>the number of elements in StateMachines</returns>
public int countStateMachines()
  {
  return allStateMachines().Count;
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns an element from the
/// collection in StateMachines based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StateMachine getStateMachines(int idx)
{
  return (StateMachine) ( allStateMachines()[idx]);
}

private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

public Structure()
{
Structure obj = this;
aElements=(null);
aProcedures=(null);
aStateMachines=(null);
aRules=(null);
}

public void copyTo(Structure other)
{
base.copyTo(other);
other.aElements = aElements;
other.aProcedures = aProcedures;
other.aStateMachines = aStateMachines;
other.aRules = aRules;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl528;
Rule fl530;
bool fl541;
Procedure fl543;
StructureElement fl555;
bool fl566;
StateMachine fl568;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl528 = true ; 
while (fl528) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl528 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl530 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl530 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl530);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Procedures")){
ctxt.skipWhiteSpace();
fl541 = true ; 
while (fl541) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl541 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl543 = null;
while(ctxt.lookAheadOpeningTag ("<Procedure")) {
fl543 = acceptor.lAccept_Procedure(ctxt, "</Procedure>");
appendProcedures(fl543);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Procedures>");
} // If
} // If
// End enclosed
// Repeat
ctxt.skipWhiteSpace();
fl555 = null;
while(ctxt.lookAheadOpeningTag ("<StructureElement")) {
fl555 = acceptor.lAccept_StructureElement(ctxt, "</StructureElement>");
appendElements(fl555);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<StateMachines")){
ctxt.skipWhiteSpace();
fl566 = true ; 
while (fl566) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl566 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl568 = null;
while(ctxt.lookAheadOpeningTag ("<StateMachine")) {
fl568 = acceptor.lAccept_StateMachine(ctxt, "</StateMachine>");
appendStateMachines(fl568);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</StateMachines>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl579;
bool fl580;
bool fl581;
bool fl582;
bool fl583;
bool fl584;
bool fl585;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl579 = false ; 
fl580 = false ; 
fl581 = false ; 
fl582 = false ; 
fl583 = false ; 
fl584 = false ; 
fl585 = true ; 
while (fl585) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 581;
} else {
indicator = 586;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 582;
} else {
indicator = 586;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 583;
} else {
indicator = 586;
} // If
break;
} // Case
default:
indicator = 586;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 580;
} else {
indicator = 586;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 584;
} else {
indicator = 586;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 579;
} else {
indicator = 586;
} // If
break;
} // Case
default:
indicator = 586;
break;
} // Switch
switch (indicator) {
case 579: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl579){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl579 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 580: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl580){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl580 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 581: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl581){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl581 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 582: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl582){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl582 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 583: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl583){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl583 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 584: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl584){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl584 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 586: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl580){
this.setImplemented( false);
} // If
if (!fl581){
this.setVerified( false);
} // If
if (!fl582){
this.setNeedsRequirement( true);
} // If
fl585 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Structure";
  endingTag = "</Structure>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Structure\"");
} // If
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
// Unparsing Enclosed
// Testing for empty content: Procedures
if (countProcedures() > 0){
pw.Write("<Procedures>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getProcedures(), false, "<Procedure", "</Procedure>");
pw.Write("</Procedures>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Procedures
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getElements(), false, "<StructureElement", "</StructureElement>");
// Unparsing Enclosed
// Testing for empty content: StateMachines
if (countStateMachines() > 0){
pw.Write("<StateMachines>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStateMachines(), false, "<StateMachine", "</StateMachine>");
pw.Write("</StateMachines>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: StateMachines
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countElements(); i++) {
  l.Add(getElements(i));
}
for (int i = 0; i < countProcedures(); i++) {
  l.Add(getProcedures(i));
}
for (int i = 0; i < countStateMachines(); i++) {
  l.Add(getStateMachines(i));
}
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
}

}
public partial class StructureElement
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
if(getDefault().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StructureElementController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDefault;

public   string  getDefault() { return aDefault;}

public  void setDefault( string  v) {
  aDefault = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.VariableModeEnumType aMode;

public  acceptor.VariableModeEnumType getMode() { return aMode;}

public  void setMode(acceptor.VariableModeEnumType v) {
  aMode = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMode_AsString()
{
  return acceptor.Enum_VariableModeEnumType_ToString (aMode);
}

public  bool setMode_AsString( string  v)
{
 acceptor.VariableModeEnumType  temp = acceptor.StringTo_Enum_VariableModeEnumType(v);
if (temp >= 0){
  aMode = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public StructureElement()
{
StructureElement obj = this;
aTypeName=(null);
aDefault=(null);
aMode=(0);
}

public void copyTo(StructureElement other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
other.aDefault = aDefault;
other.aMode = aMode;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl595;
bool fl596;
bool fl597;
bool fl598;
bool fl599;
bool fl600;
bool fl601;
bool fl602;
bool fl603;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl595 = false ; 
fl596 = false ; 
fl597 = false ; 
fl598 = false ; 
fl599 = false ; 
fl600 = false ; 
fl601 = false ; 
fl602 = false ; 
fl603 = true ; 
while (fl603) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 599;
} else {
indicator = 604;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ypeName=")){
indicator = 595;
} else {
indicator = 604;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 600;
} else {
indicator = 604;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 601;
} else {
indicator = 604;
} // If
break;
} // Case
default:
indicator = 604;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("ode=")){
indicator = 597;
} else {
indicator = 604;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 598;
} else {
indicator = 604;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 602;
} else {
indicator = 604;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 596;
} else {
indicator = 604;
} // If
break;
} // Case
default:
indicator = 604;
break;
} // Switch
switch (indicator) {
case 595: {
// Handling attribute TypeName
// Also handles alien attributes with prefix TypeName
if (fl595){
ctxt.fail ("Duplicate attribute: TypeName");
} // If
fl595 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 596: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl596){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl596 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 597: {
// Handling attribute Mode
// Also handles alien attributes with prefix Mode
if (fl597){
ctxt.fail ("Duplicate attribute: Mode");
} // If
fl597 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMode(acceptor.lAcceptEnum_VariableModeEnumType(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 598: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl598){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl598 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 599: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl599){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl599 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 600: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl600){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl600 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 601: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl601){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl601 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 602: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl602){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl602 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 604: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl595){
ctxt.fail ("Mandatory attribute missing: TypeName in StructureElement");
} // If
if (!fl596){
this.setDefault("");
} // If
if (!fl597){
this.setMode(acceptor.VariableModeEnumType.aInternal);
} // If
if (!fl598){
this.setImplemented( false);
} // If
if (!fl599){
this.setVerified( false);
} // If
if (!fl600){
this.setNeedsRequirement( true);
} // If
fl603 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<StructureElement";
  endingTag = "</StructureElement>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"StructureElement\"");
} // If
pw.Write('\n');
pw.Write(" TypeName=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMode() != 0){
pw.Write(" Mode=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_VariableModeEnumType_ToString(this.getMode()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Collection
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.CollectionController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aMaxSize;

public  int getMaxSize() { return aMaxSize;}

public  void setMaxSize(int v) {
  aMaxSize = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Collection()
{
Collection obj = this;
aTypeName=(null);
aMaxSize=(0);
}

public void copyTo(Collection other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
other.aMaxSize = aMaxSize;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl615;
bool fl616;
bool fl617;
bool fl618;
bool fl619;
bool fl620;
bool fl621;
bool fl622;
bool fl623;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl615 = false ; 
fl616 = false ; 
fl617 = false ; 
fl618 = false ; 
fl619 = false ; 
fl620 = false ; 
fl621 = false ; 
fl622 = false ; 
fl623 = true ; 
while (fl623) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 619;
} else {
indicator = 624;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ypeName=")){
indicator = 615;
} else {
indicator = 624;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 620;
} else {
indicator = 624;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 621;
} else {
indicator = 624;
} // If
break;
} // Case
default:
indicator = 624;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("axSize=")){
indicator = 616;
} else {
indicator = 624;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 618;
} else {
indicator = 624;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 622;
} else {
indicator = 624;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 617;
} else {
indicator = 624;
} // If
break;
} // Case
default:
indicator = 624;
break;
} // Switch
switch (indicator) {
case 615: {
// Handling attribute TypeName
// Also handles alien attributes with prefix TypeName
if (fl615){
ctxt.fail ("Duplicate attribute: TypeName");
} // If
fl615 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 616: {
// Handling attribute MaxSize
// Also handles alien attributes with prefix MaxSize
if (fl616){
ctxt.fail ("Duplicate attribute: MaxSize");
} // If
fl616 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMaxSize(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 617: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl617){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl617 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 618: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl618){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl618 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 619: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl619){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl619 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 620: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl620){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl620 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 621: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl621){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl621 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 622: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl622){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl622 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 624: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl615){
ctxt.fail ("Mandatory attribute missing: TypeName in Collection");
} // If
if (!fl616){
this.setMaxSize(10);
} // If
if (!fl618){
this.setImplemented( false);
} // If
if (!fl619){
this.setVerified( false);
} // If
if (!fl620){
this.setNeedsRequirement( true);
} // If
fl623 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Collection";
  endingTag = "</Collection>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Collection\"");
} // If
pw.Write('\n');
pw.Write(" TypeName=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
if (this.getMaxSize() != 10){
pw.Write(" MaxSize=\"");
acceptor.unParsePcData(pw, this.getMaxSize());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Function
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FunctionController.alertChange(aLock, this);
}
private System.Collections.ArrayList aParameters;

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
public System.Collections.ArrayList allParameters()
  {
if (aParameters == null){
    setAllParameters( new System.Collections.ArrayList() );
} // If
    return aParameters;
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
private System.Collections.ArrayList getParameters()
  {
    return allParameters();
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection of elements which replaces 
///        Parameters's current content.</param>
public void setAllParameters(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
    NotifyControllers(null);
  }
public void setAllParameters(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="el">a Parameter to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(System.Collections.IList)"/>
public void appendParameters(Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParameters(Lock aLock,Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection ofParameters to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(Parameter)"/>
public void appendParameters(System.Collections.IList coll)
  {
  __setDirty(true);
  allParameters().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParameters(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParameters().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This insertion function inserts a new element in the
/// collection in Parameters</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParameters(int idx, Parameter el)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParameters(int idx, Parameter el,Lock aLock)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParameters(IXmlBBase el)
  {
  return ((System.Collections.IList) allParameters()).IndexOf (el);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParameters(int idx)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParameters(int idx,Lock aLock)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParameters(IXmlBBase obj)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(null);
   }
  }

public void removeParameters(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>the number of elements in Parameters</returns>
public int countParameters()
  {
  return allParameters().Count;
  }

/// <summary>Part of the list interface for Parameters
/// This function returns an element from the
/// collection in Parameters based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Parameter getParameters(int idx)
{
  return (Parameter) ( allParameters()[idx]);
}

private System.Collections.ArrayList aCases;

/// <summary>Part of the list interface for Cases</summary>
/// <returns>a collection of all the elements in Cases</returns>
public System.Collections.ArrayList allCases()
  {
if (aCases == null){
    setAllCases( new System.Collections.ArrayList() );
} // If
    return aCases;
  }

/// <summary>Part of the list interface for Cases</summary>
/// <returns>a collection of all the elements in Cases</returns>
private System.Collections.ArrayList getCases()
  {
    return allCases();
  }

/// <summary>Part of the list interface for Cases</summary>
/// <param name="coll">a collection of elements which replaces 
///        Cases's current content.</param>
public void setAllCases(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCases = coll;
    NotifyControllers(null);
  }
public void setAllCases(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCases = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases</summary>
/// <param name="el">a Case to add to the collection in 
///           Cases</param>
/// <seealso cref="appendCases(System.Collections.IList)"/>
public void appendCases(Case el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendCases(Lock aLock,Case el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Cases</summary>
/// <param name="coll">a collection ofCases to add to the collection in 
///           Cases</param>
/// <seealso cref="appendCases(Case)"/>
public void appendCases(System.Collections.IList coll)
  {
  __setDirty(true);
  allCases().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendCases(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allCases().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases
/// This insertion function inserts a new element in the
/// collection in Cases</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertCases(int idx, Case el)
  {
  __setDirty(true);
  allCases().Insert (idx, el);
NotifyControllers(null);
  }

public void insertCases(int idx, Case el,Lock aLock)
  {
  __setDirty(true);
  allCases().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfCases(IXmlBBase el)
  {
  return ((System.Collections.IList) allCases()).IndexOf (el);
  }

/// <summary>Part of the list interface for Cases
/// This deletion function removes an element from the
/// collection in Cases</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteCases(int idx)
  {
  __setDirty(true);
  allCases().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteCases(int idx,Lock aLock)
  {
  __setDirty(true);
  allCases().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases
/// This deletion function removes an element from the
/// collection in Cases
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeCases(IXmlBBase obj)
  {
  int idx = indexOfCases(obj);
  if (idx >= 0) { deleteCases(idx);
NotifyControllers(null);
   }
  }

public void removeCases(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfCases(obj);
  if (idx >= 0) { deleteCases(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Cases</summary>
/// <returns>the number of elements in Cases</returns>
public int countCases()
  {
  return allCases().Count;
  }

/// <summary>Part of the list interface for Cases
/// This function returns an element from the
/// collection in Cases based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Case getCases(int idx)
{
  return (Case) ( allCases()[idx]);
}

private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aCacheable;

public  bool getCacheable() { return aCacheable;}

public  void setCacheable(bool v) {
  aCacheable = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Function()
{
Function obj = this;
aParameters=(null);
aCases=(null);
aTypeName=(null);
aCacheable=(false);
}

public void copyTo(Function other)
{
base.copyTo(other);
other.aParameters = aParameters;
other.aCases = aCases;
other.aTypeName = aTypeName;
other.aCacheable = aCacheable;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl635;
Parameter fl637;
bool fl648;
Case fl650;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Parameters")){
ctxt.skipWhiteSpace();
fl635 = true ; 
while (fl635) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl635 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl637 = null;
while(ctxt.lookAheadOpeningTag ("<Parameter")) {
fl637 = acceptor.lAccept_Parameter(ctxt, "</Parameter>");
appendParameters(fl637);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Parameters>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<Cases");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl648 = true ; 
while (fl648) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl648 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl650 = null;
while(ctxt.lookAheadOpeningTag ("<Case")) {
fl650 = acceptor.lAccept_Case(ctxt, "</Case>");
appendCases(fl650);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Cases>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl661;
bool fl662;
bool fl663;
bool fl664;
bool fl665;
bool fl666;
bool fl667;
bool fl668;
bool fl669;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl661 = false ; 
fl662 = false ; 
fl663 = false ; 
fl664 = false ; 
fl665 = false ; 
fl666 = false ; 
fl667 = false ; 
fl668 = false ; 
fl669 = true ; 
while (fl669) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 665;
} else {
indicator = 670;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 661;
} else {
indicator = 670;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 666;
} else {
indicator = 670;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 667;
} else {
indicator = 670;
} // If
break;
} // Case
default:
indicator = 670;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 664;
} else {
indicator = 670;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 668;
} else {
indicator = 670;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 663;
} else {
indicator = 670;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("acheable=")){
indicator = 662;
} else {
indicator = 670;
} // If
break;
} // Case
default:
indicator = 670;
break;
} // Switch
switch (indicator) {
case 661: {
// Handling attribute Type
// Also handles alien attributes with prefix Type
if (fl661){
ctxt.fail ("Duplicate attribute: Type");
} // If
fl661 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 662: {
// Handling attribute Cacheable
// Also handles alien attributes with prefix Cacheable
if (fl662){
ctxt.fail ("Duplicate attribute: Cacheable");
} // If
fl662 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCacheable(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 663: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl663){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl663 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 664: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl664){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl664 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 665: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl665){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl665 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 666: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl666){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl666 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 667: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl667){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl667 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 668: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl668){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl668 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 670: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl662){
this.setCacheable( false);
} // If
if (!fl664){
this.setImplemented( false);
} // If
if (!fl665){
this.setVerified( false);
} // If
if (!fl666){
this.setNeedsRequirement( true);
} // If
fl669 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Function";
  endingTag = "</Function>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Function\"");
} // If
pw.Write('\n');
if (this.getTypeName() != null){
pw.Write(" Type=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getCacheable()){
pw.Write(" Cacheable=\"");
acceptor.unParsePcData(pw, this.getCacheable());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Parameters
if (countParameters() > 0){
pw.Write("<Parameters>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParameters(), false, "<Parameter", "</Parameter>");
pw.Write("</Parameters>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Parameters
// Unparsing Enclosed
pw.Write("<Cases>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getCases(), false, "<Case", "</Case>");
pw.Write("</Cases>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countParameters(); i++) {
  l.Add(getParameters(i));
}
for (int i = 0; i < countCases(); i++) {
  l.Add(getCases(i));
}
}

}
public partial class Parameter
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ParameterController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Parameter()
{
Parameter obj = this;
aTypeName=(null);
}

public void copyTo(Parameter other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl681;
bool fl682;
bool fl683;
bool fl684;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl681 = false ; 
fl682 = false ; 
fl683 = false ; 
fl684 = true ; 
while (fl684) { // BeginLoop 
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 681;
} else {
indicator = 685;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 682;
} else {
indicator = 685;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 683;
} else {
indicator = 685;
} // If
break;
} // Case
default:
indicator = 685;
break;
} // Switch
switch (indicator) {
case 681: {
// Handling attribute Type
// Also handles alien attributes with prefix Type
if (fl681){
ctxt.fail ("Duplicate attribute: Type");
} // If
fl681 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 682: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl682){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl682 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 683: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl683){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl683 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 685: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl681){
ctxt.fail ("Mandatory attribute missing: Type in Parameter");
} // If
fl684 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Parameter";
  endingTag = "</Parameter>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Parameter\"");
} // If
pw.Write('\n');
pw.Write(" Type=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Case
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getExpression().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.CaseController.alertChange(aLock, this);
}
private System.Collections.ArrayList aPreConditions;

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
public System.Collections.ArrayList allPreConditions()
  {
if (aPreConditions == null){
    setAllPreConditions( new System.Collections.ArrayList() );
} // If
    return aPreConditions;
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
private System.Collections.ArrayList getPreConditions()
  {
    return allPreConditions();
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection of elements which replaces 
///        PreConditions's current content.</param>
public void setAllPreConditions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
    NotifyControllers(null);
  }
public void setAllPreConditions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="el">a PreCondition to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(System.Collections.IList)"/>
public void appendPreConditions(PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendPreConditions(Lock aLock,PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection ofPreConditions to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(PreCondition)"/>
public void appendPreConditions(System.Collections.IList coll)
  {
  __setDirty(true);
  allPreConditions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendPreConditions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This insertion function inserts a new element in the
/// collection in PreConditions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertPreConditions(int idx, PreCondition el)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertPreConditions(int idx, PreCondition el,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfPreConditions(IXmlBBase el)
  {
  return ((System.Collections.IList) allPreConditions()).IndexOf (el);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deletePreConditions(int idx)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deletePreConditions(int idx,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removePreConditions(IXmlBBase obj)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(null);
   }
  }

public void removePreConditions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>the number of elements in PreConditions</returns>
public int countPreConditions()
  {
  return allPreConditions().Count;
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns an element from the
/// collection in PreConditions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public PreCondition getPreConditions(int idx)
{
  return (PreCondition) ( allPreConditions()[idx]);
}

private   string  aExpression;

public   string  getExpression() { return aExpression;}

public  void setExpression( string  v) {
  aExpression = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Case()
{
Case obj = this;
aPreConditions=(null);
aExpression=(null);
aComment=(null);
}

public void copyTo(Case other)
{
base.copyTo(other);
other.aPreConditions = aPreConditions;
other.aExpression = aExpression;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl690;
bool fl691;
PreCondition fl693;
bool fl704;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl690 = true ; 
while (fl690) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl690 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<PreConditions")){
ctxt.skipWhiteSpace();
fl691 = true ; 
while (fl691) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl691 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl693 = null;
while(ctxt.lookAheadOpeningTag ("<PreCondition")) {
fl693 = acceptor.lAccept_PreCondition(ctxt, "</PreCondition>");
appendPreConditions(fl693);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</PreConditions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<Expression");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl704 = true ; 
while (fl704) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl704 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setExpression(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Expression>");
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl705;
bool fl706;
bool fl707;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl705 = false ; 
fl706 = false ; 
fl707 = true ; 
while (fl707) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 705;
} else {
indicator = 708;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 706;
} else {
indicator = 708;
} // If
break;
} // Case
default:
indicator = 708;
break;
} // Switch
switch (indicator) {
case 705: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl705){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl705 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 706: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl706){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl706 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 708: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl707 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Case";
  endingTag = "</Case>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Case\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: PreConditions
if (countPreConditions() > 0){
pw.Write("<PreConditions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getPreConditions(), false, "<PreCondition", "</PreCondition>");
pw.Write("</PreConditions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: PreConditions
// Unparsing Enclosed
pw.Write("<Expression>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getExpression());
pw.Write("</Expression>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countPreConditions(); i++) {
  l.Add(getPreConditions(i));
}
}

}
public partial class Procedure
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ProcedureController.alertChange(aLock, this);
}
private  StateMachine aStateMachine;

public  StateMachine getStateMachine() { return aStateMachine;}

public  void setStateMachine(StateMachine v) {
  aStateMachine = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

private System.Collections.ArrayList aParameters;

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
public System.Collections.ArrayList allParameters()
  {
if (aParameters == null){
    setAllParameters( new System.Collections.ArrayList() );
} // If
    return aParameters;
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
private System.Collections.ArrayList getParameters()
  {
    return allParameters();
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection of elements which replaces 
///        Parameters's current content.</param>
public void setAllParameters(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
    NotifyControllers(null);
  }
public void setAllParameters(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="el">a Parameter to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(System.Collections.IList)"/>
public void appendParameters(Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParameters(Lock aLock,Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection ofParameters to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(Parameter)"/>
public void appendParameters(System.Collections.IList coll)
  {
  __setDirty(true);
  allParameters().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParameters(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParameters().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This insertion function inserts a new element in the
/// collection in Parameters</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParameters(int idx, Parameter el)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParameters(int idx, Parameter el,Lock aLock)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParameters(IXmlBBase el)
  {
  return ((System.Collections.IList) allParameters()).IndexOf (el);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParameters(int idx)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParameters(int idx,Lock aLock)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParameters(IXmlBBase obj)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(null);
   }
  }

public void removeParameters(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>the number of elements in Parameters</returns>
public int countParameters()
  {
  return allParameters().Count;
  }

/// <summary>Part of the list interface for Parameters
/// This function returns an element from the
/// collection in Parameters based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Parameter getParameters(int idx)
{
  return (Parameter) ( allParameters()[idx]);
}

public Procedure()
{
Procedure obj = this;
aStateMachine=(null);
aRules=(null);
aParameters=(null);
}

public void copyTo(Procedure other)
{
base.copyTo(other);
other.aStateMachine = aStateMachine;
other.aRules = aRules;
other.aParameters = aParameters;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl712;
Parameter fl714;
bool fl725;
Rule fl727;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Parameters")){
ctxt.skipWhiteSpace();
fl712 = true ; 
while (fl712) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl712 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl714 = null;
while(ctxt.lookAheadOpeningTag ("<Parameter")) {
fl714 = acceptor.lAccept_Parameter(ctxt, "</Parameter>");
appendParameters(fl714);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Parameters>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl725 = true ; 
while (fl725) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl725 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl727 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl727 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl727);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
// Element Ref : StateMachine
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<StateMachine")){
// Parsing sub element
this.setStateMachine(acceptor.lAccept_StateMachine(ctxt,"</StateMachine>"));
setSon(this.getStateMachine());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl738;
bool fl739;
bool fl740;
bool fl741;
bool fl742;
bool fl743;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl738 = false ; 
fl739 = false ; 
fl740 = false ; 
fl741 = false ; 
fl742 = false ; 
fl743 = true ; 
while (fl743) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 739;
} else {
indicator = 744;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 740;
} else {
indicator = 744;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 741;
} else {
indicator = 744;
} // If
break;
} // Case
default:
indicator = 744;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 738;
} else {
indicator = 744;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 742;
} else {
indicator = 744;
} // If
break;
} // Case
default:
indicator = 744;
break;
} // Switch
switch (indicator) {
case 738: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl738){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl738 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 739: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl739){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl739 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 740: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl740){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl740 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 741: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl741){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl741 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 742: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl742){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl742 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 744: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl738){
this.setImplemented( false);
} // If
if (!fl739){
this.setVerified( false);
} // If
if (!fl740){
this.setNeedsRequirement( true);
} // If
fl743 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Procedure";
  endingTag = "</Procedure>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Procedure\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Parameters
if (countParameters() > 0){
pw.Write("<Parameters>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParameters(), false, "<Parameter", "</Parameter>");
pw.Write("</Parameters>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Parameters
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
// Unparsing ElementRef
if (this.getStateMachine() != null){
unParse(pw, this.getStateMachine(),false,"<StateMachine","</StateMachine>");
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
l.Add(this.getStateMachine());
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
for (int i = 0; i < countParameters(); i++) {
  l.Add(getParameters(i));
}
}

}
public partial class StateMachine
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getInitialState().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StateMachineController.alertChange(aLock, this);
}
private   string  aInitialState;

public   string  getInitialState() { return aInitialState;}

public  void setInitialState( string  v) {
  aInitialState = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aStates;

/// <summary>Part of the list interface for States</summary>
/// <returns>a collection of all the elements in States</returns>
public System.Collections.ArrayList allStates()
  {
if (aStates == null){
    setAllStates( new System.Collections.ArrayList() );
} // If
    return aStates;
  }

/// <summary>Part of the list interface for States</summary>
/// <returns>a collection of all the elements in States</returns>
private System.Collections.ArrayList getStates()
  {
    return allStates();
  }

/// <summary>Part of the list interface for States</summary>
/// <param name="coll">a collection of elements which replaces 
///        States's current content.</param>
public void setAllStates(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStates = coll;
    NotifyControllers(null);
  }
public void setAllStates(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStates = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States</summary>
/// <param name="el">a State to add to the collection in 
///           States</param>
/// <seealso cref="appendStates(System.Collections.IList)"/>
public void appendStates(State el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStates().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStates(Lock aLock,State el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStates().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for States</summary>
/// <param name="coll">a collection ofStates to add to the collection in 
///           States</param>
/// <seealso cref="appendStates(State)"/>
public void appendStates(System.Collections.IList coll)
  {
  __setDirty(true);
  allStates().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStates(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStates().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States
/// This insertion function inserts a new element in the
/// collection in States</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStates(int idx, State el)
  {
  __setDirty(true);
  allStates().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStates(int idx, State el,Lock aLock)
  {
  __setDirty(true);
  allStates().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStates(IXmlBBase el)
  {
  return ((System.Collections.IList) allStates()).IndexOf (el);
  }

/// <summary>Part of the list interface for States
/// This deletion function removes an element from the
/// collection in States</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStates(int idx)
  {
  __setDirty(true);
  allStates().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStates(int idx,Lock aLock)
  {
  __setDirty(true);
  allStates().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States
/// This deletion function removes an element from the
/// collection in States
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStates(IXmlBBase obj)
  {
  int idx = indexOfStates(obj);
  if (idx >= 0) { deleteStates(idx);
NotifyControllers(null);
   }
  }

public void removeStates(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStates(obj);
  if (idx >= 0) { deleteStates(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for States</summary>
/// <returns>the number of elements in States</returns>
public int countStates()
  {
  return allStates().Count;
  }

/// <summary>Part of the list interface for States
/// This function returns an element from the
/// collection in States based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public State getStates(int idx)
{
  return (State) ( allStates()[idx]);
}

private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

public StateMachine()
{
StateMachine obj = this;
aInitialState=(null);
aStates=(null);
aRules=(null);
}

public void copyTo(StateMachine other)
{
base.copyTo(other);
other.aInitialState = aInitialState;
other.aStates = aStates;
other.aRules = aRules;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl752;
State fl754;
bool fl765;
Rule fl767;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<States")){
ctxt.skipWhiteSpace();
fl752 = true ; 
while (fl752) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl752 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl754 = null;
while(ctxt.lookAheadOpeningTag ("<State")) {
fl754 = acceptor.lAccept_State(ctxt, "</State>");
appendStates(fl754);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</States>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl765 = true ; 
while (fl765) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl765 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl767 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl767 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl767);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl778;
bool fl779;
bool fl780;
bool fl781;
bool fl782;
bool fl783;
bool fl784;
bool fl785;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl778 = false ; 
fl779 = false ; 
fl780 = false ; 
fl781 = false ; 
fl782 = false ; 
fl783 = false ; 
fl784 = false ; 
fl785 = true ; 
while (fl785) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 781;
} else {
indicator = 786;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 782;
} else {
indicator = 786;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 783;
} else {
indicator = 786;
} // If
break;
} // Case
default:
indicator = 786;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("itialState=")){
indicator = 778;
} else {
indicator = 786;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("plemented=")){
indicator = 780;
} else {
indicator = 786;
} // If
break;
} // Case
default:
indicator = 786;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 784;
} else {
indicator = 786;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 779;
} else {
indicator = 786;
} // If
break;
} // Case
default:
indicator = 786;
break;
} // Switch
switch (indicator) {
case 778: {
// Handling attribute InitialState
// Also handles alien attributes with prefix InitialState
if (fl778){
ctxt.fail ("Duplicate attribute: InitialState");
} // If
fl778 = true ; 
quoteChar = ctxt.acceptQuote();
this.setInitialState((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 779: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl779){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl779 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 780: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl780){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl780 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 781: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl781){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl781 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 782: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl782){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl782 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 783: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl783){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl783 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 784: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl784){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl784 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 786: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl780){
this.setImplemented( false);
} // If
if (!fl781){
this.setVerified( false);
} // If
if (!fl782){
this.setNeedsRequirement( true);
} // If
fl785 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<StateMachine";
  endingTag = "</StateMachine>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"StateMachine\"");
} // If
pw.Write('\n');
if (this.getInitialState() != null){
pw.Write(" InitialState=\"");
acceptor.unParsePcData(pw, this.getInitialState());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: States
if (countStates() > 0){
pw.Write("<States>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStates(), false, "<State", "</State>");
pw.Write("</States>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: States
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countStates(); i++) {
  l.Add(getStates(i));
}
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
}

}
public partial class State
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StateController.alertChange(aLock, this);
}
private  StateMachine aStateMachine;

public  StateMachine getStateMachine() { return aStateMachine;}

public  void setStateMachine(StateMachine v) {
  aStateMachine = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


public State()
{
State obj = this;
aStateMachine=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
}

public void copyTo(State other)
{
base.copyTo(other);
other.aStateMachine = aStateMachine;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Element Ref : StateMachine
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<StateMachine")){
// Parsing sub element
this.setStateMachine(acceptor.lAccept_StateMachine(ctxt,"</StateMachine>"));
setSon(this.getStateMachine());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl797;
bool fl798;
bool fl799;
bool fl800;
bool fl801;
bool fl802;
bool fl803;
bool fl804;
bool fl805;
bool fl806;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl797 = false ; 
fl798 = false ; 
fl799 = false ; 
fl800 = false ; 
fl801 = false ; 
fl802 = false ; 
fl803 = false ; 
fl804 = false ; 
fl805 = false ; 
fl806 = true ; 
while (fl806) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 798;
} else {
indicator = 807;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 797;
} else {
indicator = 807;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 799;
} else {
indicator = 807;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 802;
} else {
indicator = 807;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 803;
} else {
indicator = 807;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 804;
} else {
indicator = 807;
} // If
break;
} // Case
default:
indicator = 807;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 801;
} else {
indicator = 807;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
if (ctxt.lookAheadString("eight=")){
indicator = 800;
} else {
indicator = 807;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 805;
} else {
indicator = 807;
} // If
break;
} // Case
default:
indicator = 807;
break;
} // Switch
switch (indicator) {
case 797: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl797){
ctxt.fail ("Duplicate attribute: X");
} // If
fl797 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 798: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl798){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl798 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 799: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl799){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl799 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 800: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl800){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl800 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 801: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl801){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl801 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 802: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl802){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl802 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 803: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl803){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl803 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 804: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl804){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl804 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 805: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl805){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl805 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 807: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl797){
this.setX(0);
} // If
if (!fl798){
this.setY(0);
} // If
if (!fl799){
this.setWidth(0);
} // If
if (!fl800){
this.setHeight(0);
} // If
if (!fl801){
this.setImplemented( false);
} // If
if (!fl802){
this.setVerified( false);
} // If
if (!fl803){
this.setNeedsRequirement( true);
} // If
fl806 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<State";
  endingTag = "</State>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"State\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing ElementRef
if (this.getStateMachine() != null){
unParse(pw, this.getStateMachine(),false,"<StateMachine","</StateMachine>");
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
l.Add(this.getStateMachine());
}

}
public partial class Variable
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
if(getDefaultValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.VariableController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDefaultValue;

public   string  getDefaultValue() { return aDefaultValue;}

public  void setDefaultValue( string  v) {
  aDefaultValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.VariableModeEnumType aVariableMode;

public  acceptor.VariableModeEnumType getVariableMode() { return aVariableMode;}

public  void setVariableMode(acceptor.VariableModeEnumType v) {
  aVariableMode = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getVariableMode_AsString()
{
  return acceptor.Enum_VariableModeEnumType_ToString (aVariableMode);
}

public  bool setVariableMode_AsString( string  v)
{
 acceptor.VariableModeEnumType  temp = acceptor.StringTo_Enum_VariableModeEnumType(v);
if (temp >= 0){
  aVariableMode = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aSubVariables;

/// <summary>Part of the list interface for SubVariables</summary>
/// <returns>a collection of all the elements in SubVariables</returns>
public System.Collections.ArrayList allSubVariables()
  {
if (aSubVariables == null){
    setAllSubVariables( new System.Collections.ArrayList() );
} // If
    return aSubVariables;
  }

/// <summary>Part of the list interface for SubVariables</summary>
/// <returns>a collection of all the elements in SubVariables</returns>
private System.Collections.ArrayList getSubVariables()
  {
    return allSubVariables();
  }

/// <summary>Part of the list interface for SubVariables</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubVariables's current content.</param>
public void setAllSubVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubVariables = coll;
    NotifyControllers(null);
  }
public void setAllSubVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables</summary>
/// <param name="el">a Variable to add to the collection in 
///           SubVariables</param>
/// <seealso cref="appendSubVariables(System.Collections.IList)"/>
public void appendSubVariables(Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubVariables(Lock aLock,Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubVariables</summary>
/// <param name="coll">a collection ofVariables to add to the collection in 
///           SubVariables</param>
/// <seealso cref="appendSubVariables(Variable)"/>
public void appendSubVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubVariables().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubVariables().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables
/// This insertion function inserts a new element in the
/// collection in SubVariables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubVariables(int idx, Variable el)
  {
  __setDirty(true);
  allSubVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubVariables(int idx, Variable el,Lock aLock)
  {
  __setDirty(true);
  allSubVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubVariables
/// This deletion function removes an element from the
/// collection in SubVariables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubVariables(int idx)
  {
  __setDirty(true);
  allSubVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables
/// This deletion function removes an element from the
/// collection in SubVariables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubVariables(IXmlBBase obj)
  {
  int idx = indexOfSubVariables(obj);
  if (idx >= 0) { deleteSubVariables(idx);
NotifyControllers(null);
   }
  }

public void removeSubVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubVariables(obj);
  if (idx >= 0) { deleteSubVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubVariables</summary>
/// <returns>the number of elements in SubVariables</returns>
public int countSubVariables()
  {
  return allSubVariables().Count;
  }

/// <summary>Part of the list interface for SubVariables
/// This function returns an element from the
/// collection in SubVariables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Variable getSubVariables(int idx)
{
  return (Variable) ( allSubVariables()[idx]);
}

public Variable()
{
Variable obj = this;
aTypeName=(null);
aDefaultValue=(null);
aVariableMode=(0);
aSubVariables=(null);
}

public void copyTo(Variable other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
other.aDefaultValue = aDefaultValue;
other.aVariableMode = aVariableMode;
other.aSubVariables = aSubVariables;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl819;
Variable fl821;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubVariables")){
ctxt.skipWhiteSpace();
fl819 = true ; 
while (fl819) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl819 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl821 = null;
while(ctxt.lookAheadOpeningTag ("<Variable")) {
fl821 = acceptor.lAccept_Variable(ctxt, "</Variable>");
appendSubVariables(fl821);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubVariables>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl832;
bool fl833;
bool fl834;
bool fl835;
bool fl836;
bool fl837;
bool fl838;
bool fl839;
bool fl840;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl832 = false ; 
fl833 = false ; 
fl834 = false ; 
fl835 = false ; 
fl836 = false ; 
fl837 = false ; 
fl838 = false ; 
fl839 = false ; 
fl840 = true ; 
while (fl840) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("rified=")){
indicator = 836;
} else {
indicator = 841;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("riableMode=")){
indicator = 834;
} else {
indicator = 841;
} // If
break;
} // Case
default:
indicator = 841;
break;
} // Switch
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 832;
} else {
indicator = 841;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 837;
} else {
indicator = 841;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 838;
} else {
indicator = 841;
} // If
break;
} // Case
default:
indicator = 841;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 835;
} else {
indicator = 841;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 839;
} else {
indicator = 841;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efaultValue=")){
indicator = 833;
} else {
indicator = 841;
} // If
break;
} // Case
default:
indicator = 841;
break;
} // Switch
switch (indicator) {
case 832: {
// Handling attribute Type
// Also handles alien attributes with prefix Type
if (fl832){
ctxt.fail ("Duplicate attribute: Type");
} // If
fl832 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 833: {
// Handling attribute DefaultValue
// Also handles alien attributes with prefix DefaultValue
if (fl833){
ctxt.fail ("Duplicate attribute: DefaultValue");
} // If
fl833 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefaultValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 834: {
// Handling attribute VariableMode
// Also handles alien attributes with prefix VariableMode
if (fl834){
ctxt.fail ("Duplicate attribute: VariableMode");
} // If
fl834 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVariableMode(acceptor.lAcceptEnum_VariableModeEnumType(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 835: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl835){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl835 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 836: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl836){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl836 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 837: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl837){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl837 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 838: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl838){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl838 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 839: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl839){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl839 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 841: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl834){
this.setVariableMode(acceptor.VariableModeEnumType.aInternal);
} // If
if (!fl835){
this.setImplemented( false);
} // If
if (!fl836){
this.setVerified( false);
} // If
if (!fl837){
this.setNeedsRequirement( true);
} // If
fl840 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Variable";
  endingTag = "</Variable>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Variable\"");
} // If
pw.Write('\n');
if (this.getTypeName() != null){
pw.Write(" Type=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefaultValue() != null){
pw.Write(" DefaultValue=\"");
acceptor.unParsePcData(pw, this.getDefaultValue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVariableMode() != 0){
pw.Write(" VariableMode=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_VariableModeEnumType_ToString(this.getVariableMode()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: SubVariables
if (countSubVariables() > 0){
pw.Write("<SubVariables>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubVariables(), false, "<Variable", "</Variable>");
pw.Write("</SubVariables>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubVariables
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSubVariables(); i++) {
  l.Add(getSubVariables(i));
}
}

}
public partial class Rule
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RuleController.alertChange(aLock, this);
}
private  acceptor.RulePriority aPriority;

public  acceptor.RulePriority getPriority() { return aPriority;}

public  void setPriority(acceptor.RulePriority v) {
  aPriority = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getPriority_AsString()
{
  return acceptor.Enum_RulePriority_ToString (aPriority);
}

public  bool setPriority_AsString( string  v)
{
 acceptor.RulePriority  temp = acceptor.StringTo_Enum_RulePriority(v);
if (temp >= 0){
  aPriority = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aConditions;

/// <summary>Part of the list interface for Conditions</summary>
/// <returns>a collection of all the elements in Conditions</returns>
public System.Collections.ArrayList allConditions()
  {
if (aConditions == null){
    setAllConditions( new System.Collections.ArrayList() );
} // If
    return aConditions;
  }

/// <summary>Part of the list interface for Conditions</summary>
/// <returns>a collection of all the elements in Conditions</returns>
private System.Collections.ArrayList getConditions()
  {
    return allConditions();
  }

/// <summary>Part of the list interface for Conditions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Conditions's current content.</param>
public void setAllConditions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aConditions = coll;
    NotifyControllers(null);
  }
public void setAllConditions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aConditions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions</summary>
/// <param name="el">a RuleCondition to add to the collection in 
///           Conditions</param>
/// <seealso cref="appendConditions(System.Collections.IList)"/>
public void appendConditions(RuleCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendConditions(Lock aLock,RuleCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Conditions</summary>
/// <param name="coll">a collection ofRuleConditions to add to the collection in 
///           Conditions</param>
/// <seealso cref="appendConditions(RuleCondition)"/>
public void appendConditions(System.Collections.IList coll)
  {
  __setDirty(true);
  allConditions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendConditions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allConditions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions
/// This insertion function inserts a new element in the
/// collection in Conditions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertConditions(int idx, RuleCondition el)
  {
  __setDirty(true);
  allConditions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertConditions(int idx, RuleCondition el,Lock aLock)
  {
  __setDirty(true);
  allConditions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfConditions(IXmlBBase el)
  {
  return ((System.Collections.IList) allConditions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Conditions
/// This deletion function removes an element from the
/// collection in Conditions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteConditions(int idx)
  {
  __setDirty(true);
  allConditions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteConditions(int idx,Lock aLock)
  {
  __setDirty(true);
  allConditions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions
/// This deletion function removes an element from the
/// collection in Conditions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeConditions(IXmlBBase obj)
  {
  int idx = indexOfConditions(obj);
  if (idx >= 0) { deleteConditions(idx);
NotifyControllers(null);
   }
  }

public void removeConditions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfConditions(obj);
  if (idx >= 0) { deleteConditions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Conditions</summary>
/// <returns>the number of elements in Conditions</returns>
public int countConditions()
  {
  return allConditions().Count;
  }

/// <summary>Part of the list interface for Conditions
/// This function returns an element from the
/// collection in Conditions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RuleCondition getConditions(int idx)
{
  return (RuleCondition) ( allConditions()[idx]);
}

public Rule()
{
Rule obj = this;
aPriority=(0);
aConditions=(null);
}

public void copyTo(Rule other)
{
base.copyTo(other);
other.aPriority = aPriority;
other.aConditions = aConditions;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl853;
bool fl854;
RuleCondition fl856;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubRules")){
ctxt.skipWhiteSpace();
fl853 = true ; 
while (fl853) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl853 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
acceptor.lAcceptPcData(ctxt, 0, '<', XmlBContext.WS_PRESERVE);
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubRules>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Conditions")){
ctxt.skipWhiteSpace();
fl854 = true ; 
while (fl854) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl854 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl856 = null;
while(ctxt.lookAheadOpeningTag ("<RuleCondition")) {
fl856 = acceptor.lAccept_RuleCondition(ctxt, "</RuleCondition>");
appendConditions(fl856);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Conditions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl867;
bool fl868;
bool fl869;
bool fl870;
bool fl871;
bool fl872;
bool fl873;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl867 = false ; 
fl868 = false ; 
fl869 = false ; 
fl870 = false ; 
fl871 = false ; 
fl872 = false ; 
fl873 = true ; 
while (fl873) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 869;
} else {
indicator = 874;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("riority=")){
indicator = 867;
} else {
indicator = 874;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 870;
} else {
indicator = 874;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 871;
} else {
indicator = 874;
} // If
break;
} // Case
default:
indicator = 874;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 868;
} else {
indicator = 874;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 872;
} else {
indicator = 874;
} // If
break;
} // Case
default:
indicator = 874;
break;
} // Switch
switch (indicator) {
case 867: {
// Handling attribute Priority
// Also handles alien attributes with prefix Priority
if (fl867){
ctxt.fail ("Duplicate attribute: Priority");
} // If
fl867 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPriority(acceptor.lAcceptEnum_RulePriority(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 868: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl868){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl868 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 869: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl869){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl869 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 870: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl870){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl870 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 871: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl871){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl871 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 872: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl872){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl872 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 874: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl868){
this.setImplemented( false);
} // If
if (!fl869){
this.setVerified( false);
} // If
if (!fl870){
this.setNeedsRequirement( true);
} // If
fl873 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Rule";
  endingTag = "</Rule>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Rule\"");
} // If
pw.Write('\n');
if (this.getPriority() != 0){
pw.Write(" Priority=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_RulePriority_ToString(this.getPriority()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
pw.Write("<SubRules>");
// Unparsing PcData
pw.Write("</SubRules>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: Conditions
if (countConditions() > 0){
pw.Write("<Conditions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getConditions(), false, "<RuleCondition", "</RuleCondition>");
pw.Write("</Conditions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Conditions
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countConditions(); i++) {
  l.Add(getConditions(i));
}
}

}
public partial class RuleCondition
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RuleConditionController.alertChange(aLock, this);
}
private System.Collections.ArrayList aPreConditions;

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
public System.Collections.ArrayList allPreConditions()
  {
if (aPreConditions == null){
    setAllPreConditions( new System.Collections.ArrayList() );
} // If
    return aPreConditions;
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
private System.Collections.ArrayList getPreConditions()
  {
    return allPreConditions();
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection of elements which replaces 
///        PreConditions's current content.</param>
public void setAllPreConditions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
    NotifyControllers(null);
  }
public void setAllPreConditions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="el">a PreCondition to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(System.Collections.IList)"/>
public void appendPreConditions(PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendPreConditions(Lock aLock,PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection ofPreConditions to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(PreCondition)"/>
public void appendPreConditions(System.Collections.IList coll)
  {
  __setDirty(true);
  allPreConditions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendPreConditions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This insertion function inserts a new element in the
/// collection in PreConditions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertPreConditions(int idx, PreCondition el)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertPreConditions(int idx, PreCondition el,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfPreConditions(IXmlBBase el)
  {
  return ((System.Collections.IList) allPreConditions()).IndexOf (el);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deletePreConditions(int idx)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deletePreConditions(int idx,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removePreConditions(IXmlBBase obj)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(null);
   }
  }

public void removePreConditions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>the number of elements in PreConditions</returns>
public int countPreConditions()
  {
  return allPreConditions().Count;
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns an element from the
/// collection in PreConditions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public PreCondition getPreConditions(int idx)
{
  return (PreCondition) ( allPreConditions()[idx]);
}

private System.Collections.ArrayList aActions;

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
public System.Collections.ArrayList allActions()
  {
if (aActions == null){
    setAllActions( new System.Collections.ArrayList() );
} // If
    return aActions;
  }

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
private System.Collections.ArrayList getActions()
  {
    return allActions();
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Actions's current content.</param>
public void setAllActions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
    NotifyControllers(null);
  }
public void setAllActions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="el">a Action to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(System.Collections.IList)"/>
public void appendActions(Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendActions(Lock aLock,Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection ofActions to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(Action)"/>
public void appendActions(System.Collections.IList coll)
  {
  __setDirty(true);
  allActions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendActions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allActions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This insertion function inserts a new element in the
/// collection in Actions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertActions(int idx, Action el)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertActions(int idx, Action el,Lock aLock)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfActions(IXmlBBase el)
  {
  return ((System.Collections.IList) allActions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteActions(int idx)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteActions(int idx,Lock aLock)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeActions(IXmlBBase obj)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(null);
   }
  }

public void removeActions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Actions</summary>
/// <returns>the number of elements in Actions</returns>
public int countActions()
  {
  return allActions().Count;
  }

/// <summary>Part of the list interface for Actions
/// This function returns an element from the
/// collection in Actions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Action getActions(int idx)
{
  return (Action) ( allActions()[idx]);
}

private System.Collections.ArrayList aSubRules;

/// <summary>Part of the list interface for SubRules</summary>
/// <returns>a collection of all the elements in SubRules</returns>
public System.Collections.ArrayList allSubRules()
  {
if (aSubRules == null){
    setAllSubRules( new System.Collections.ArrayList() );
} // If
    return aSubRules;
  }

/// <summary>Part of the list interface for SubRules</summary>
/// <returns>a collection of all the elements in SubRules</returns>
private System.Collections.ArrayList getSubRules()
  {
    return allSubRules();
  }

/// <summary>Part of the list interface for SubRules</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubRules's current content.</param>
public void setAllSubRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubRules = coll;
    NotifyControllers(null);
  }
public void setAllSubRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules</summary>
/// <param name="el">a Rule to add to the collection in 
///           SubRules</param>
/// <seealso cref="appendSubRules(System.Collections.IList)"/>
public void appendSubRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubRules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           SubRules</param>
/// <seealso cref="appendSubRules(Rule)"/>
public void appendSubRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubRules().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules
/// This insertion function inserts a new element in the
/// collection in SubRules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubRules(int idx, Rule el)
  {
  __setDirty(true);
  allSubRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allSubRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubRules
/// This deletion function removes an element from the
/// collection in SubRules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubRules(int idx)
  {
  __setDirty(true);
  allSubRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules
/// This deletion function removes an element from the
/// collection in SubRules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubRules(IXmlBBase obj)
  {
  int idx = indexOfSubRules(obj);
  if (idx >= 0) { deleteSubRules(idx);
NotifyControllers(null);
   }
  }

public void removeSubRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubRules(obj);
  if (idx >= 0) { deleteSubRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubRules</summary>
/// <returns>the number of elements in SubRules</returns>
public int countSubRules()
  {
  return allSubRules().Count;
  }

/// <summary>Part of the list interface for SubRules
/// This function returns an element from the
/// collection in SubRules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getSubRules(int idx)
{
  return (Rule) ( allSubRules()[idx]);
}

public RuleCondition()
{
RuleCondition obj = this;
aPreConditions=(null);
aActions=(null);
aSubRules=(null);
}

public void copyTo(RuleCondition other)
{
base.copyTo(other);
other.aPreConditions = aPreConditions;
other.aActions = aActions;
other.aSubRules = aSubRules;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl883;
PreCondition fl885;
bool fl896;
Action fl898;
bool fl909;
Rule fl911;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<PreConditions")){
ctxt.skipWhiteSpace();
fl883 = true ; 
while (fl883) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl883 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl885 = null;
while(ctxt.lookAheadOpeningTag ("<PreCondition")) {
fl885 = acceptor.lAccept_PreCondition(ctxt, "</PreCondition>");
appendPreConditions(fl885);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</PreConditions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Actions")){
ctxt.skipWhiteSpace();
fl896 = true ; 
while (fl896) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl896 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl898 = null;
while(ctxt.lookAheadOpeningTag ("<Action")) {
fl898 = acceptor.lAccept_Action(ctxt, "</Action>");
appendActions(fl898);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Actions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubRules")){
ctxt.skipWhiteSpace();
fl909 = true ; 
while (fl909) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl909 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl911 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl911 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendSubRules(fl911);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubRules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl922;
bool fl923;
bool fl924;
bool fl925;
bool fl926;
bool fl927;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl922 = false ; 
fl923 = false ; 
fl924 = false ; 
fl925 = false ; 
fl926 = false ; 
fl927 = true ; 
while (fl927) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 923;
} else {
indicator = 928;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 924;
} else {
indicator = 928;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 925;
} else {
indicator = 928;
} // If
break;
} // Case
default:
indicator = 928;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 922;
} else {
indicator = 928;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 926;
} else {
indicator = 928;
} // If
break;
} // Case
default:
indicator = 928;
break;
} // Switch
switch (indicator) {
case 922: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl922){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl922 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 923: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl923){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl923 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 924: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl924){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl924 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 925: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl925){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl925 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 926: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl926){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl926 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 928: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl922){
this.setImplemented( false);
} // If
if (!fl923){
this.setVerified( false);
} // If
if (!fl924){
this.setNeedsRequirement( true);
} // If
fl927 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RuleCondition";
  endingTag = "</RuleCondition>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RuleCondition\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
pw.Write("<PreConditions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getPreConditions(), false, "<PreCondition", "</PreCondition>");
pw.Write("</PreConditions>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<Actions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getActions(), false, "<Action", "</Action>");
pw.Write("</Actions>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: SubRules
if (countSubRules() > 0){
pw.Write("<SubRules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubRules(), false, "<Rule", "</Rule>");
pw.Write("</SubRules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubRules
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countPreConditions(); i++) {
  l.Add(getPreConditions(i));
}
for (int i = 0; i < countActions(); i++) {
  l.Add(getActions(i));
}
for (int i = 0; i < countSubRules(); i++) {
  l.Add(getSubRules(i));
}
}

}
public partial class PreCondition
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getCondition().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.PreConditionController.alertChange(aLock, this);
}
private   string  aCondition;

public   string  getCondition() { return aCondition;}

public  void setCondition( string  v) {
  aCondition = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public PreCondition()
{
PreCondition obj = this;
aCondition=(null);
aComment=(null);
}

public void copyTo(PreCondition other)
{
base.copyTo(other);
other.aCondition = aCondition;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl936;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl936 = true ; 
while (fl936) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl936 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
// Indicator
// Parse PC data
this.setCondition(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl937;
bool fl938;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl937 = false ; 
fl938 = true ; 
while (fl938) { // BeginLoop 
if (ctxt.lookAheadString("Guid=")){
indicator = 937;
} else {
indicator = 939;
} // If
switch (indicator) {
case 937: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl937){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl937 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 939: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl938 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<PreCondition";
  endingTag = "</PreCondition>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"PreCondition\"");
} // If
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing PcData
acceptor.unParsePcData(pw, this.getCondition());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Action
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getExpression().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ActionController.alertChange(aLock, this);
}
private   string  aExpression;

public   string  getExpression() { return aExpression;}

public  void setExpression( string  v) {
  aExpression = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Action()
{
Action obj = this;
aExpression=(null);
aComment=(null);
}

public void copyTo(Action other)
{
base.copyTo(other);
other.aExpression = aExpression;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl941;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl941 = true ; 
while (fl941) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl941 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
// Indicator
// Parse PC data
this.setExpression(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl942;
bool fl943;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl942 = false ; 
fl943 = true ; 
while (fl943) { // BeginLoop 
if (ctxt.lookAheadString("Guid=")){
indicator = 942;
} else {
indicator = 944;
} // If
switch (indicator) {
case 942: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl942){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl942 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 944: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl943 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Action";
  endingTag = "</Action>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Action\"");
} // If
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing PcData
acceptor.unParsePcData(pw, this.getExpression());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class FrameRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FrameRefController.alertChange(aLock, this);
}
public FrameRef()
{
FrameRef obj = this;
}

public void copyTo(FrameRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl946;
bool fl947;
bool fl948;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl946 = false ; 
fl947 = false ; 
fl948 = true ; 
while (fl948) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 946;
} else {
indicator = 949;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 947;
} else {
indicator = 949;
} // If
break;
} // Case
default:
indicator = 949;
break;
} // Switch
switch (indicator) {
case 946: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl946){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl946 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 947: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl947){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl947 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 949: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl948 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<FrameRef";
  endingTag = "</FrameRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"FrameRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Frame
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getCycleDuration().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FrameController.alertChange(aLock, this);
}
private   string  aCycleDuration;

public   string  getCycleDuration() { return aCycleDuration;}

public  void setCycleDuration( string  v) {
  aCycleDuration = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSubSequences;

/// <summary>Part of the list interface for SubSequences</summary>
/// <returns>a collection of all the elements in SubSequences</returns>
public System.Collections.ArrayList allSubSequences()
  {
if (aSubSequences == null){
    setAllSubSequences( new System.Collections.ArrayList() );
} // If
    return aSubSequences;
  }

/// <summary>Part of the list interface for SubSequences</summary>
/// <returns>a collection of all the elements in SubSequences</returns>
private System.Collections.ArrayList getSubSequences()
  {
    return allSubSequences();
  }

/// <summary>Part of the list interface for SubSequences</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSequences's current content.</param>
public void setAllSubSequences(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSequences = coll;
    NotifyControllers(null);
  }
public void setAllSubSequences(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSequences = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences</summary>
/// <param name="el">a SubSequence to add to the collection in 
///           SubSequences</param>
/// <seealso cref="appendSubSequences(System.Collections.IList)"/>
public void appendSubSequences(SubSequence el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSequences().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSequences(Lock aLock,SubSequence el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSequences().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSequences</summary>
/// <param name="coll">a collection ofSubSequences to add to the collection in 
///           SubSequences</param>
/// <seealso cref="appendSubSequences(SubSequence)"/>
public void appendSubSequences(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSequences().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSequences(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSequences().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences
/// This insertion function inserts a new element in the
/// collection in SubSequences</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSequences(int idx, SubSequence el)
  {
  __setDirty(true);
  allSubSequences().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSequences(int idx, SubSequence el,Lock aLock)
  {
  __setDirty(true);
  allSubSequences().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSequences(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSequences()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSequences
/// This deletion function removes an element from the
/// collection in SubSequences</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSequences(int idx)
  {
  __setDirty(true);
  allSubSequences().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSequences(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSequences().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences
/// This deletion function removes an element from the
/// collection in SubSequences
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSequences(IXmlBBase obj)
  {
  int idx = indexOfSubSequences(obj);
  if (idx >= 0) { deleteSubSequences(idx);
NotifyControllers(null);
   }
  }

public void removeSubSequences(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSequences(obj);
  if (idx >= 0) { deleteSubSequences(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSequences</summary>
/// <returns>the number of elements in SubSequences</returns>
public int countSubSequences()
  {
  return allSubSequences().Count;
  }

/// <summary>Part of the list interface for SubSequences
/// This function returns an element from the
/// collection in SubSequences based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SubSequence getSubSequences(int idx)
{
  return (SubSequence) ( allSubSequences()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Frame()
{
Frame obj = this;
aCycleDuration=(null);
aSubSequences=(null);
aComment=(null);
}

public void copyTo(Frame other)
{
base.copyTo(other);
other.aCycleDuration = aCycleDuration;
other.aSubSequences = aSubSequences;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl953;
bool fl954;
SubSequence fl956;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl953 = true ; 
while (fl953) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl953 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubSequences")){
ctxt.skipWhiteSpace();
fl954 = true ; 
while (fl954) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl954 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl956 = null;
while(ctxt.lookAheadOpeningTag ("<SubSequence")) {
fl956 = acceptor.lAccept_SubSequence(ctxt, "</SubSequence>");
appendSubSequences(fl956);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSequences>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl967;
bool fl968;
bool fl969;
bool fl970;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl967 = false ; 
fl968 = false ; 
fl969 = false ; 
fl970 = true ; 
while (fl970) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 968;
} else {
indicator = 971;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 969;
} else {
indicator = 971;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ycleDuration=")){
indicator = 967;
} else {
indicator = 971;
} // If
break;
} // Case
default:
indicator = 971;
break;
} // Switch
switch (indicator) {
case 967: {
// Handling attribute CycleDuration
// Also handles alien attributes with prefix CycleDuration
if (fl967){
ctxt.fail ("Duplicate attribute: CycleDuration");
} // If
fl967 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCycleDuration((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 968: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl968){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl968 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 969: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl969){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl969 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 971: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl967){
this.setCycleDuration("0.1");
} // If
fl970 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Frame";
  endingTag = "</Frame>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Frame\"");
} // If
pw.Write('\n');
if (this.getCycleDuration() != null){
pw.Write(" CycleDuration=\"");
acceptor.unParsePcData(pw, this.getCycleDuration());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: SubSequences
if (countSubSequences() > 0){
pw.Write("<SubSequences>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSequences(), false, "<SubSequence", "</SubSequence>");
pw.Write("</SubSequences>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubSequences
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSubSequences(); i++) {
  l.Add(getSubSequences(i));
}
}

}
public partial class SubSequence
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getD_LRBG().CompareTo((String) search) == 0)return true;
if(getLevel().CompareTo((String) search) == 0)return true;
if(getMode().CompareTo((String) search) == 0)return true;
if(getNID_LRBG().CompareTo((String) search) == 0)return true;
if(getQ_DIRLRBG().CompareTo((String) search) == 0)return true;
if(getQ_DIRTRAIN().CompareTo((String) search) == 0)return true;
if(getQ_DLRBG().CompareTo((String) search) == 0)return true;
if(getRBC_ID().CompareTo((String) search) == 0)return true;
if(getRBCPhone().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SubSequenceController.alertChange(aLock, this);
}
private   string  aD_LRBG;

public   string  getD_LRBG() { return aD_LRBG;}

public  void setD_LRBG( string  v) {
  aD_LRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aLevel;

public   string  getLevel() { return aLevel;}

public  void setLevel( string  v) {
  aLevel = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMode;

public   string  getMode() { return aMode;}

public  void setMode( string  v) {
  aMode = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aNID_LRBG;

public   string  getNID_LRBG() { return aNID_LRBG;}

public  void setNID_LRBG( string  v) {
  aNID_LRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aQ_DIRLRBG;

public   string  getQ_DIRLRBG() { return aQ_DIRLRBG;}

public  void setQ_DIRLRBG( string  v) {
  aQ_DIRLRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aQ_DIRTRAIN;

public   string  getQ_DIRTRAIN() { return aQ_DIRTRAIN;}

public  void setQ_DIRTRAIN( string  v) {
  aQ_DIRTRAIN = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aQ_DLRBG;

public   string  getQ_DLRBG() { return aQ_DLRBG;}

public  void setQ_DLRBG( string  v) {
  aQ_DLRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aRBC_ID;

public   string  getRBC_ID() { return aRBC_ID;}

public  void setRBC_ID( string  v) {
  aRBC_ID = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aRBCPhone;

public   string  getRBCPhone() { return aRBCPhone;}

public  void setRBCPhone( string  v) {
  aRBCPhone = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aTestCases;

/// <summary>Part of the list interface for TestCases</summary>
/// <returns>a collection of all the elements in TestCases</returns>
public System.Collections.ArrayList allTestCases()
  {
if (aTestCases == null){
    setAllTestCases( new System.Collections.ArrayList() );
} // If
    return aTestCases;
  }

/// <summary>Part of the list interface for TestCases</summary>
/// <returns>a collection of all the elements in TestCases</returns>
private System.Collections.ArrayList getTestCases()
  {
    return allTestCases();
  }

/// <summary>Part of the list interface for TestCases</summary>
/// <param name="coll">a collection of elements which replaces 
///        TestCases's current content.</param>
public void setAllTestCases(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestCases = coll;
    NotifyControllers(null);
  }
public void setAllTestCases(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestCases = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases</summary>
/// <param name="el">a TestCase to add to the collection in 
///           TestCases</param>
/// <seealso cref="appendTestCases(System.Collections.IList)"/>
public void appendTestCases(TestCase el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTestCases(Lock aLock,TestCase el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TestCases</summary>
/// <param name="coll">a collection ofTestCases to add to the collection in 
///           TestCases</param>
/// <seealso cref="appendTestCases(TestCase)"/>
public void appendTestCases(System.Collections.IList coll)
  {
  __setDirty(true);
  allTestCases().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTestCases(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTestCases().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases
/// This insertion function inserts a new element in the
/// collection in TestCases</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTestCases(int idx, TestCase el)
  {
  __setDirty(true);
  allTestCases().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTestCases(int idx, TestCase el,Lock aLock)
  {
  __setDirty(true);
  allTestCases().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTestCases(IXmlBBase el)
  {
  return ((System.Collections.IList) allTestCases()).IndexOf (el);
  }

/// <summary>Part of the list interface for TestCases
/// This deletion function removes an element from the
/// collection in TestCases</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTestCases(int idx)
  {
  __setDirty(true);
  allTestCases().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTestCases(int idx,Lock aLock)
  {
  __setDirty(true);
  allTestCases().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases
/// This deletion function removes an element from the
/// collection in TestCases
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTestCases(IXmlBBase obj)
  {
  int idx = indexOfTestCases(obj);
  if (idx >= 0) { deleteTestCases(idx);
NotifyControllers(null);
   }
  }

public void removeTestCases(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTestCases(obj);
  if (idx >= 0) { deleteTestCases(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TestCases</summary>
/// <returns>the number of elements in TestCases</returns>
public int countTestCases()
  {
  return allTestCases().Count;
  }

/// <summary>Part of the list interface for TestCases
/// This function returns an element from the
/// collection in TestCases based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public TestCase getTestCases(int idx)
{
  return (TestCase) ( allTestCases()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public SubSequence()
{
SubSequence obj = this;
aD_LRBG=(null);
aLevel=(null);
aMode=(null);
aNID_LRBG=(null);
aQ_DIRLRBG=(null);
aQ_DIRTRAIN=(null);
aQ_DLRBG=(null);
aRBC_ID=(null);
aRBCPhone=(null);
aTestCases=(null);
aComment=(null);
}

public void copyTo(SubSequence other)
{
base.copyTo(other);
other.aD_LRBG = aD_LRBG;
other.aLevel = aLevel;
other.aMode = aMode;
other.aNID_LRBG = aNID_LRBG;
other.aQ_DIRLRBG = aQ_DIRLRBG;
other.aQ_DIRTRAIN = aQ_DIRTRAIN;
other.aQ_DLRBG = aQ_DLRBG;
other.aRBC_ID = aRBC_ID;
other.aRBCPhone = aRBCPhone;
other.aTestCases = aTestCases;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl976;
bool fl977;
TestCase fl979;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl976 = true ; 
while (fl976) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl976 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<TestCases")){
ctxt.skipWhiteSpace();
fl977 = true ; 
while (fl977) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl977 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl979 = null;
while(ctxt.lookAheadOpeningTag ("<TestCase")) {
fl979 = acceptor.lAccept_TestCase(ctxt, "</TestCase>");
appendTestCases(fl979);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</TestCases>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl990;
bool fl991;
bool fl992;
bool fl993;
bool fl994;
bool fl995;
bool fl996;
bool fl997;
bool fl998;
bool fl999;
bool fl1000;
bool fl1001;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl990 = false ; 
fl991 = false ; 
fl992 = false ; 
fl993 = false ; 
fl994 = false ; 
fl995 = false ; 
fl996 = false ; 
fl997 = false ; 
fl998 = false ; 
fl999 = false ; 
fl1000 = false ; 
fl1001 = true ; 
while (fl1001) { // BeginLoop 
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('B','C')){
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
if (ctxt.lookAhead3('I','D','=')){
indicator = 997;
} else {
indicator = 1002;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("hone=")){
indicator = 998;
} else {
indicator = 1002;
} // If
break;
} // Case
default:
indicator = 1002;
break;
} // Switch
} else {
indicator = 1002;
} // If
break;
} // Case
case 'Q':
{
ctxt.advance();
if (ctxt.lookAhead2('_','D')){
switch (ctxt.current()) {
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("RBG=")){
indicator = 996;
} else {
indicator = 1002;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('R')){
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("RAIN=")){
indicator = 995;
} else {
indicator = 1002;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("RBG=")){
indicator = 994;
} else {
indicator = 1002;
} // If
break;
} // Case
default:
indicator = 1002;
break;
} // Switch
} else {
indicator = 1002;
} // If
break;
} // Case
default:
indicator = 1002;
break;
} // Switch
} else {
indicator = 1002;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 999;
} else {
indicator = 1002;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("D_LRBG=")){
indicator = 993;
} else {
indicator = 1002;
} // If
break;
} // Case
default:
indicator = 1002;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("ode=")){
indicator = 992;
} else {
indicator = 1002;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("evel=")){
indicator = 991;
} else {
indicator = 1002;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1000;
} else {
indicator = 1002;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("_LRBG=")){
indicator = 990;
} else {
indicator = 1002;
} // If
break;
} // Case
default:
indicator = 1002;
break;
} // Switch
switch (indicator) {
case 990: {
// Handling attribute D_LRBG
// Also handles alien attributes with prefix D_LRBG
if (fl990){
ctxt.fail ("Duplicate attribute: D_LRBG");
} // If
fl990 = true ; 
quoteChar = ctxt.acceptQuote();
this.setD_LRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 991: {
// Handling attribute Level
// Also handles alien attributes with prefix Level
if (fl991){
ctxt.fail ("Duplicate attribute: Level");
} // If
fl991 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLevel((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 992: {
// Handling attribute Mode
// Also handles alien attributes with prefix Mode
if (fl992){
ctxt.fail ("Duplicate attribute: Mode");
} // If
fl992 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMode((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 993: {
// Handling attribute NID_LRBG
// Also handles alien attributes with prefix NID_LRBG
if (fl993){
ctxt.fail ("Duplicate attribute: NID_LRBG");
} // If
fl993 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNID_LRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 994: {
// Handling attribute Q_DIRLRBG
// Also handles alien attributes with prefix Q_DIRLRBG
if (fl994){
ctxt.fail ("Duplicate attribute: Q_DIRLRBG");
} // If
fl994 = true ; 
quoteChar = ctxt.acceptQuote();
this.setQ_DIRLRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 995: {
// Handling attribute Q_DIRTRAIN
// Also handles alien attributes with prefix Q_DIRTRAIN
if (fl995){
ctxt.fail ("Duplicate attribute: Q_DIRTRAIN");
} // If
fl995 = true ; 
quoteChar = ctxt.acceptQuote();
this.setQ_DIRTRAIN((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 996: {
// Handling attribute Q_DLRBG
// Also handles alien attributes with prefix Q_DLRBG
if (fl996){
ctxt.fail ("Duplicate attribute: Q_DLRBG");
} // If
fl996 = true ; 
quoteChar = ctxt.acceptQuote();
this.setQ_DLRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 997: {
// Handling attribute RBC_ID
// Also handles alien attributes with prefix RBC_ID
if (fl997){
ctxt.fail ("Duplicate attribute: RBC_ID");
} // If
fl997 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRBC_ID((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 998: {
// Handling attribute RBCPhone
// Also handles alien attributes with prefix RBCPhone
if (fl998){
ctxt.fail ("Duplicate attribute: RBCPhone");
} // If
fl998 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRBCPhone((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 999: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl999){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl999 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1000: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1000){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1000 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1002: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl990){
this.setD_LRBG("");
} // If
if (!fl991){
this.setLevel("");
} // If
if (!fl992){
this.setMode("");
} // If
if (!fl993){
this.setNID_LRBG("");
} // If
if (!fl994){
this.setQ_DIRLRBG("");
} // If
if (!fl995){
this.setQ_DIRTRAIN("");
} // If
if (!fl996){
this.setQ_DLRBG("");
} // If
if (!fl997){
this.setRBC_ID("");
} // If
if (!fl998){
this.setRBCPhone("");
} // If
fl1001 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SubSequence";
  endingTag = "</SubSequence>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SubSequence\"");
} // If
pw.Write('\n');
if (this.getD_LRBG() != null){
pw.Write(" D_LRBG=\"");
acceptor.unParsePcData(pw, this.getD_LRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getLevel() != null){
pw.Write(" Level=\"");
acceptor.unParsePcData(pw, this.getLevel());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMode() != null){
pw.Write(" Mode=\"");
acceptor.unParsePcData(pw, this.getMode());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getNID_LRBG() != null){
pw.Write(" NID_LRBG=\"");
acceptor.unParsePcData(pw, this.getNID_LRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getQ_DIRLRBG() != null){
pw.Write(" Q_DIRLRBG=\"");
acceptor.unParsePcData(pw, this.getQ_DIRLRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getQ_DIRTRAIN() != null){
pw.Write(" Q_DIRTRAIN=\"");
acceptor.unParsePcData(pw, this.getQ_DIRTRAIN());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getQ_DLRBG() != null){
pw.Write(" Q_DLRBG=\"");
acceptor.unParsePcData(pw, this.getQ_DLRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getRBC_ID() != null){
pw.Write(" RBC_ID=\"");
acceptor.unParsePcData(pw, this.getRBC_ID());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getRBCPhone() != null){
pw.Write(" RBCPhone=\"");
acceptor.unParsePcData(pw, this.getRBCPhone());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: TestCases
if (countTestCases() > 0){
pw.Write("<TestCases>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTestCases(), false, "<TestCase", "</TestCase>");
pw.Write("</TestCases>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: TestCases
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countTestCases(); i++) {
  l.Add(getTestCases(i));
}
}

}
public partial class TestCase
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TestCaseController.alertChange(aLock, this);
}
private  int aFeature;

public  int getFeature() { return aFeature;}

public  void setFeature(int v) {
  aFeature = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aCase;

public  int getCase() { return aCase;}

public  void setCase(int v) {
  aCase = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSteps;

/// <summary>Part of the list interface for Steps</summary>
/// <returns>a collection of all the elements in Steps</returns>
public System.Collections.ArrayList allSteps()
  {
if (aSteps == null){
    setAllSteps( new System.Collections.ArrayList() );
} // If
    return aSteps;
  }

/// <summary>Part of the list interface for Steps</summary>
/// <returns>a collection of all the elements in Steps</returns>
private System.Collections.ArrayList getSteps()
  {
    return allSteps();
  }

/// <summary>Part of the list interface for Steps</summary>
/// <param name="coll">a collection of elements which replaces 
///        Steps's current content.</param>
public void setAllSteps(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSteps = coll;
    NotifyControllers(null);
  }
public void setAllSteps(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSteps = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps</summary>
/// <param name="el">a Step to add to the collection in 
///           Steps</param>
/// <seealso cref="appendSteps(System.Collections.IList)"/>
public void appendSteps(Step el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSteps(Lock aLock,Step el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Steps</summary>
/// <param name="coll">a collection ofSteps to add to the collection in 
///           Steps</param>
/// <seealso cref="appendSteps(Step)"/>
public void appendSteps(System.Collections.IList coll)
  {
  __setDirty(true);
  allSteps().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSteps(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSteps().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps
/// This insertion function inserts a new element in the
/// collection in Steps</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSteps(int idx, Step el)
  {
  __setDirty(true);
  allSteps().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSteps(int idx, Step el,Lock aLock)
  {
  __setDirty(true);
  allSteps().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSteps(IXmlBBase el)
  {
  return ((System.Collections.IList) allSteps()).IndexOf (el);
  }

/// <summary>Part of the list interface for Steps
/// This deletion function removes an element from the
/// collection in Steps</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSteps(int idx)
  {
  __setDirty(true);
  allSteps().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSteps(int idx,Lock aLock)
  {
  __setDirty(true);
  allSteps().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps
/// This deletion function removes an element from the
/// collection in Steps
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSteps(IXmlBBase obj)
  {
  int idx = indexOfSteps(obj);
  if (idx >= 0) { deleteSteps(idx);
NotifyControllers(null);
   }
  }

public void removeSteps(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSteps(obj);
  if (idx >= 0) { deleteSteps(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Steps</summary>
/// <returns>the number of elements in Steps</returns>
public int countSteps()
  {
  return allSteps().Count;
  }

/// <summary>Part of the list interface for Steps
/// This function returns an element from the
/// collection in Steps based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Step getSteps(int idx)
{
  return (Step) ( allSteps()[idx]);
}

public TestCase()
{
TestCase obj = this;
aFeature=(0);
aCase=(0);
aSteps=(null);
}

public void copyTo(TestCase other)
{
base.copyTo(other);
other.aFeature = aFeature;
other.aCase = aCase;
other.aSteps = aSteps;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1019;
bool fl1020;
Step fl1022;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1019 = true ; 
while (fl1019) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1019 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Steps")){
ctxt.skipWhiteSpace();
fl1020 = true ; 
while (fl1020) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1020 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1022 = null;
while(ctxt.lookAheadOpeningTag ("<Step")) {
fl1022 = acceptor.lAccept_Step(ctxt, "</Step>");
appendSteps(fl1022);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Steps>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1033;
bool fl1034;
bool fl1035;
bool fl1036;
bool fl1037;
bool fl1038;
bool fl1039;
bool fl1040;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1033 = false ; 
fl1034 = false ; 
fl1035 = false ; 
fl1036 = false ; 
fl1037 = false ; 
fl1038 = false ; 
fl1039 = false ; 
fl1040 = true ; 
while (fl1040) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 1036;
} else {
indicator = 1041;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 1037;
} else {
indicator = 1041;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1038;
} else {
indicator = 1041;
} // If
break;
} // Case
default:
indicator = 1041;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1035;
} else {
indicator = 1041;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1039;
} else {
indicator = 1041;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("eature=")){
indicator = 1033;
} else {
indicator = 1041;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ase=")){
indicator = 1034;
} else {
indicator = 1041;
} // If
break;
} // Case
default:
indicator = 1041;
break;
} // Switch
switch (indicator) {
case 1033: {
// Handling attribute Feature
// Also handles alien attributes with prefix Feature
if (fl1033){
ctxt.fail ("Duplicate attribute: Feature");
} // If
fl1033 = true ; 
quoteChar = ctxt.acceptQuote();
this.setFeature(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1034: {
// Handling attribute Case
// Also handles alien attributes with prefix Case
if (fl1034){
ctxt.fail ("Duplicate attribute: Case");
} // If
fl1034 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCase(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1035: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1035){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1035 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1036: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl1036){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl1036 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1037: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl1037){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl1037 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1038: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1038){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1038 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1039: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1039){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1039 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1041: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1033){
this.setFeature(9999);
} // If
if (!fl1034){
this.setCase(9999);
} // If
if (!fl1035){
this.setImplemented( false);
} // If
if (!fl1036){
this.setVerified( false);
} // If
if (!fl1037){
this.setNeedsRequirement( true);
} // If
fl1040 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<TestCase";
  endingTag = "</TestCase>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"TestCase\"");
} // If
pw.Write('\n');
if (this.getFeature() != 9999){
pw.Write(" Feature=\"");
acceptor.unParsePcData(pw, this.getFeature());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getCase() != 9999){
pw.Write(" Case=\"");
acceptor.unParsePcData(pw, this.getCase());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: Steps
if (countSteps() > 0){
pw.Write("<Steps>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSteps(), false, "<Step", "</Step>");
pw.Write("</Steps>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Steps
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSteps(); i++) {
  l.Add(getSteps(i));
}
}

}
public partial class Step
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getDescription().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
if(getUserComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StepController.alertChange(aLock, this);
}
private  int aTCS_Order;

public  int getTCS_Order() { return aTCS_Order;}

public  void setTCS_Order(int v) {
  aTCS_Order = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aDistance;

public  int getDistance() { return aDistance;}

public  void setDistance(int v) {
  aDistance = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDescription;

public   string  getDescription() { return aDescription;}

public  void setDescription( string  v) {
  aDescription = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aUserComment;

public   string  getUserComment() { return aUserComment;}

public  void setUserComment( string  v) {
  aUserComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.ST_IO aIO;

public  acceptor.ST_IO getIO() { return aIO;}

public  void setIO(acceptor.ST_IO v) {
  aIO = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getIO_AsString()
{
  return acceptor.Enum_ST_IO_ToString (aIO);
}

public  bool setIO_AsString( string  v)
{
 acceptor.ST_IO  temp = acceptor.StringTo_Enum_ST_IO(v);
if (temp >= 0){
  aIO = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_INTERFACE aInterface;

public  acceptor.ST_INTERFACE getInterface() { return aInterface;}

public  void setInterface(acceptor.ST_INTERFACE v) {
  aInterface = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getInterface_AsString()
{
  return acceptor.Enum_ST_INTERFACE_ToString (aInterface);
}

public  bool setInterface_AsString( string  v)
{
 acceptor.ST_INTERFACE  temp = acceptor.StringTo_Enum_ST_INTERFACE(v);
if (temp >= 0){
  aInterface = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_LEVEL aLevelIN;

public  acceptor.ST_LEVEL getLevelIN() { return aLevelIN;}

public  void setLevelIN(acceptor.ST_LEVEL v) {
  aLevelIN = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getLevelIN_AsString()
{
  return acceptor.Enum_ST_LEVEL_ToString (aLevelIN);
}

public  bool setLevelIN_AsString( string  v)
{
 acceptor.ST_LEVEL  temp = acceptor.StringTo_Enum_ST_LEVEL(v);
if (temp >= 0){
  aLevelIN = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_LEVEL aLevelOUT;

public  acceptor.ST_LEVEL getLevelOUT() { return aLevelOUT;}

public  void setLevelOUT(acceptor.ST_LEVEL v) {
  aLevelOUT = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getLevelOUT_AsString()
{
  return acceptor.Enum_ST_LEVEL_ToString (aLevelOUT);
}

public  bool setLevelOUT_AsString( string  v)
{
 acceptor.ST_LEVEL  temp = acceptor.StringTo_Enum_ST_LEVEL(v);
if (temp >= 0){
  aLevelOUT = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_MODE aModeIN;

public  acceptor.ST_MODE getModeIN() { return aModeIN;}

public  void setModeIN(acceptor.ST_MODE v) {
  aModeIN = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getModeIN_AsString()
{
  return acceptor.Enum_ST_MODE_ToString (aModeIN);
}

public  bool setModeIN_AsString( string  v)
{
 acceptor.ST_MODE  temp = acceptor.StringTo_Enum_ST_MODE(v);
if (temp >= 0){
  aModeIN = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_MODE aModeOUT;

public  acceptor.ST_MODE getModeOUT() { return aModeOUT;}

public  void setModeOUT(acceptor.ST_MODE v) {
  aModeOUT = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getModeOUT_AsString()
{
  return acceptor.Enum_ST_MODE_ToString (aModeOUT);
}

public  bool setModeOUT_AsString( string  v)
{
 acceptor.ST_MODE  temp = acceptor.StringTo_Enum_ST_MODE(v);
if (temp >= 0){
  aModeOUT = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  bool aTranslationRequired;

public  bool getTranslationRequired() { return aTranslationRequired;}

public  void setTranslationRequired(bool v) {
  aTranslationRequired = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aTranslated;

public  bool getTranslated() { return aTranslated;}

public  void setTranslated(bool v) {
  aTranslated = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSubSteps;

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
public System.Collections.ArrayList allSubSteps()
  {
if (aSubSteps == null){
    setAllSubSteps( new System.Collections.ArrayList() );
} // If
    return aSubSteps;
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
private System.Collections.ArrayList getSubSteps()
  {
    return allSubSteps();
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSteps's current content.</param>
public void setAllSubSteps(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
    NotifyControllers(null);
  }
public void setAllSubSteps(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="el">a SubStep to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(System.Collections.IList)"/>
public void appendSubSteps(SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSteps(Lock aLock,SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection ofSubSteps to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(SubStep)"/>
public void appendSubSteps(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSteps().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSteps(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This insertion function inserts a new element in the
/// collection in SubSteps</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSteps(int idx, SubStep el)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSteps(int idx, SubStep el,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSteps(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSteps()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSteps(int idx)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSteps(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSteps(IXmlBBase obj)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(null);
   }
  }

public void removeSubSteps(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>the number of elements in SubSteps</returns>
public int countSubSteps()
  {
  return allSubSteps().Count;
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns an element from the
/// collection in SubSteps based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SubStep getSubSteps(int idx)
{
  return (SubStep) ( allSubSteps()[idx]);
}

private System.Collections.ArrayList aMessages;

/// <summary>Part of the list interface for Messages</summary>
/// <returns>a collection of all the elements in Messages</returns>
public System.Collections.ArrayList allMessages()
  {
if (aMessages == null){
    setAllMessages( new System.Collections.ArrayList() );
} // If
    return aMessages;
  }

/// <summary>Part of the list interface for Messages</summary>
/// <returns>a collection of all the elements in Messages</returns>
private System.Collections.ArrayList getMessages()
  {
    return allMessages();
  }

/// <summary>Part of the list interface for Messages</summary>
/// <param name="coll">a collection of elements which replaces 
///        Messages's current content.</param>
public void setAllMessages(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMessages = coll;
    NotifyControllers(null);
  }
public void setAllMessages(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMessages = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages</summary>
/// <param name="el">a DBMessage to add to the collection in 
///           Messages</param>
/// <seealso cref="appendMessages(System.Collections.IList)"/>
public void appendMessages(DBMessage el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMessages().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendMessages(Lock aLock,DBMessage el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMessages().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Messages</summary>
/// <param name="coll">a collection ofDBMessages to add to the collection in 
///           Messages</param>
/// <seealso cref="appendMessages(DBMessage)"/>
public void appendMessages(System.Collections.IList coll)
  {
  __setDirty(true);
  allMessages().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendMessages(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allMessages().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages
/// This insertion function inserts a new element in the
/// collection in Messages</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertMessages(int idx, DBMessage el)
  {
  __setDirty(true);
  allMessages().Insert (idx, el);
NotifyControllers(null);
  }

public void insertMessages(int idx, DBMessage el,Lock aLock)
  {
  __setDirty(true);
  allMessages().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfMessages(IXmlBBase el)
  {
  return ((System.Collections.IList) allMessages()).IndexOf (el);
  }

/// <summary>Part of the list interface for Messages
/// This deletion function removes an element from the
/// collection in Messages</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteMessages(int idx)
  {
  __setDirty(true);
  allMessages().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteMessages(int idx,Lock aLock)
  {
  __setDirty(true);
  allMessages().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages
/// This deletion function removes an element from the
/// collection in Messages
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeMessages(IXmlBBase obj)
  {
  int idx = indexOfMessages(obj);
  if (idx >= 0) { deleteMessages(idx);
NotifyControllers(null);
   }
  }

public void removeMessages(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfMessages(obj);
  if (idx >= 0) { deleteMessages(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Messages</summary>
/// <returns>the number of elements in Messages</returns>
public int countMessages()
  {
  return allMessages().Count;
  }

/// <summary>Part of the list interface for Messages
/// This function returns an element from the
/// collection in Messages based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBMessage getMessages(int idx)
{
  return (DBMessage) ( allMessages()[idx]);
}

public Step()
{
Step obj = this;
aTCS_Order=(0);
aDistance=(0);
aDescription=(null);
aComment=(null);
aUserComment=(null);
aIO=(0);
aInterface=(0);
aLevelIN=(0);
aLevelOUT=(0);
aModeIN=(0);
aModeOUT=(0);
aTranslationRequired=(false);
aTranslated=(false);
aSubSteps=(null);
aMessages=(null);
}

public void copyTo(Step other)
{
base.copyTo(other);
other.aTCS_Order = aTCS_Order;
other.aDistance = aDistance;
other.aDescription = aDescription;
other.aComment = aComment;
other.aUserComment = aUserComment;
other.aIO = aIO;
other.aInterface = aInterface;
other.aLevelIN = aLevelIN;
other.aLevelOUT = aLevelOUT;
other.aModeIN = aModeIN;
other.aModeOUT = aModeOUT;
other.aTranslationRequired = aTranslationRequired;
other.aTranslated = aTranslated;
other.aSubSteps = aSubSteps;
other.aMessages = aMessages;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1051;
bool fl1052;
bool fl1053;
bool fl1054;
SubStep fl1056;
bool fl1067;
DBMessage fl1069;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Description")){
ctxt.skipWhiteSpace();
fl1051 = true ; 
while (fl1051) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1051 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setDescription(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Description>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1052 = true ; 
while (fl1052) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1052 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<UserComment")){
ctxt.skipWhiteSpace();
fl1053 = true ; 
while (fl1053) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1053 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setUserComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</UserComment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubSteps")){
ctxt.skipWhiteSpace();
fl1054 = true ; 
while (fl1054) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1054 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1056 = null;
while(ctxt.lookAheadOpeningTag ("<SubStep")) {
fl1056 = acceptor.lAccept_SubStep(ctxt, "</SubStep>");
appendSubSteps(fl1056);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSteps>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Messsages")){
ctxt.skipWhiteSpace();
fl1067 = true ; 
while (fl1067) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1067 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1069 = null;
while(ctxt.lookAheadOpeningTag ("<DBMessage")) {
fl1069 = acceptor.lAccept_DBMessage(ctxt, "</DBMessage>");
appendMessages(fl1069);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Messsages>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1080;
bool fl1081;
bool fl1082;
bool fl1083;
bool fl1084;
bool fl1085;
bool fl1086;
bool fl1087;
bool fl1088;
bool fl1089;
bool fl1090;
bool fl1091;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1080 = false ; 
fl1081 = false ; 
fl1082 = false ; 
fl1083 = false ; 
fl1084 = false ; 
fl1085 = false ; 
fl1086 = false ; 
fl1087 = false ; 
fl1088 = false ; 
fl1089 = false ; 
fl1090 = false ; 
fl1091 = true ; 
while (fl1091) { // BeginLoop 
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslat")){
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("onRequired=")){
indicator = 1087;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 1088;
} else {
indicator = 1092;
} // If
break;
} // Case
default:
indicator = 1092;
break;
} // Switch
} else {
indicator = 1092;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("S_Order=")){
indicator = 1080;
} else {
indicator = 1092;
} // If
break;
} // Case
default:
indicator = 1092;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1089;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAhead3('o','d','e')){
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead3('U','T','=')){
indicator = 1086;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('N','=')){
indicator = 1085;
} else {
indicator = 1092;
} // If
break;
} // Case
default:
indicator = 1092;
break;
} // Switch
} else {
indicator = 1092;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("evel")){
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead3('U','T','=')){
indicator = 1084;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('N','=')){
indicator = 1083;
} else {
indicator = 1092;
} // If
break;
} // Case
default:
indicator = 1092;
break;
} // Switch
} else {
indicator = 1092;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('O','=')){
indicator = 1082;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1090;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("istance=")){
indicator = 1081;
} else {
indicator = 1092;
} // If
break;
} // Case
default:
indicator = 1092;
break;
} // Switch
switch (indicator) {
case 1080: {
// Handling attribute TCS_Order
// Also handles alien attributes with prefix TCS_Order
if (fl1080){
ctxt.fail ("Duplicate attribute: TCS_Order");
} // If
fl1080 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTCS_Order(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1081: {
// Handling attribute Distance
// Also handles alien attributes with prefix Distance
if (fl1081){
ctxt.fail ("Duplicate attribute: Distance");
} // If
fl1081 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDistance(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1082: {
// Handling attribute IO
// Also handles alien attributes with prefix IO
if (fl1082){
ctxt.fail ("Duplicate attribute: IO");
} // If
fl1082 = true ; 
quoteChar = ctxt.acceptQuote();
this.setIO(acceptor.lAcceptEnum_ST_IO(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1083: {
// Handling attribute LevelIN
// Also handles alien attributes with prefix LevelIN
if (fl1083){
ctxt.fail ("Duplicate attribute: LevelIN");
} // If
fl1083 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLevelIN(acceptor.lAcceptEnum_ST_LEVEL(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1084: {
// Handling attribute LevelOUT
// Also handles alien attributes with prefix LevelOUT
if (fl1084){
ctxt.fail ("Duplicate attribute: LevelOUT");
} // If
fl1084 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLevelOUT(acceptor.lAcceptEnum_ST_LEVEL(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1085: {
// Handling attribute ModeIN
// Also handles alien attributes with prefix ModeIN
if (fl1085){
ctxt.fail ("Duplicate attribute: ModeIN");
} // If
fl1085 = true ; 
quoteChar = ctxt.acceptQuote();
this.setModeIN(acceptor.lAcceptEnum_ST_MODE(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1086: {
// Handling attribute ModeOUT
// Also handles alien attributes with prefix ModeOUT
if (fl1086){
ctxt.fail ("Duplicate attribute: ModeOUT");
} // If
fl1086 = true ; 
quoteChar = ctxt.acceptQuote();
this.setModeOUT(acceptor.lAcceptEnum_ST_MODE(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1087: {
// Handling attribute TranslationRequired
// Also handles alien attributes with prefix TranslationRequired
if (fl1087){
ctxt.fail ("Duplicate attribute: TranslationRequired");
} // If
fl1087 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTranslationRequired(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1088: {
// Handling attribute Translated
// Also handles alien attributes with prefix Translated
if (fl1088){
ctxt.fail ("Duplicate attribute: Translated");
} // If
fl1088 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTranslated(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1089: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1089){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1089 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1090: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1090){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1090 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1092: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1080){
this.setTCS_Order(0);
} // If
if (!fl1081){
this.setDistance(0);
} // If
if (!fl1082){
this.setIO(acceptor.ST_IO.StIO_NA);
} // If
if (!fl1083){
this.setLevelIN(acceptor.ST_LEVEL.StLevel_NA);
} // If
if (!fl1084){
this.setLevelOUT(acceptor.ST_LEVEL.StLevel_NA);
} // If
if (!fl1085){
this.setModeIN(acceptor.ST_MODE.Mode_NA);
} // If
if (!fl1086){
this.setModeOUT(acceptor.ST_MODE.Mode_NA);
} // If
if (!fl1087){
this.setTranslationRequired( true);
} // If
if (!fl1088){
this.setTranslated( false);
} // If
fl1091 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Step";
  endingTag = "</Step>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Step\"");
} // If
pw.Write('\n');
if (this.getTCS_Order() != 0){
pw.Write(" TCS_Order=\"");
acceptor.unParsePcData(pw, this.getTCS_Order());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDistance() != 0){
pw.Write(" Distance=\"");
acceptor.unParsePcData(pw, this.getDistance());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getIO() != 0){
pw.Write(" IO=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_IO_ToString(this.getIO()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getLevelIN() != 0){
pw.Write(" LevelIN=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_LEVEL_ToString(this.getLevelIN()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getLevelOUT() != 0){
pw.Write(" LevelOUT=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_LEVEL_ToString(this.getLevelOUT()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getModeIN() != 0){
pw.Write(" ModeIN=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_MODE_ToString(this.getModeIN()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getModeOUT() != 0){
pw.Write(" ModeOUT=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_MODE_ToString(this.getModeOUT()));
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getTranslationRequired()){
pw.Write(" TranslationRequired=\"");
acceptor.unParsePcData(pw, this.getTranslationRequired());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getTranslated()){
pw.Write(" Translated=\"");
acceptor.unParsePcData(pw, this.getTranslated());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Description
if (this.getDescription() != null){
pw.Write("<Description>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getDescription());
pw.Write("</Description>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Description
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: UserComment
if (this.getUserComment() != null){
pw.Write("<UserComment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getUserComment());
pw.Write("</UserComment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: UserComment
// Unparsing Enclosed
// Testing for empty content: SubSteps
if (countSubSteps() > 0){
pw.Write("<SubSteps>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSteps(), false, "<SubStep", "</SubStep>");
pw.Write("</SubSteps>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubSteps
// Unparsing Enclosed
// Testing for empty content: Messages
if (countMessages() > 0){
pw.Write("<Messsages>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getMessages(), false, "<DBMessage", "</DBMessage>");
pw.Write("</Messsages>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Messages
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSubSteps(); i++) {
  l.Add(getSubSteps(i));
}
for (int i = 0; i < countMessages(); i++) {
  l.Add(getMessages(i));
}
}

}
public partial class SubStep
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SubStepController.alertChange(aLock, this);
}
private System.Collections.ArrayList aActions;

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
public System.Collections.ArrayList allActions()
  {
if (aActions == null){
    setAllActions( new System.Collections.ArrayList() );
} // If
    return aActions;
  }

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
private System.Collections.ArrayList getActions()
  {
    return allActions();
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Actions's current content.</param>
public void setAllActions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
    NotifyControllers(null);
  }
public void setAllActions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="el">a Action to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(System.Collections.IList)"/>
public void appendActions(Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendActions(Lock aLock,Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection ofActions to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(Action)"/>
public void appendActions(System.Collections.IList coll)
  {
  __setDirty(true);
  allActions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendActions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allActions().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This insertion function inserts a new element in the
/// collection in Actions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertActions(int idx, Action el)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertActions(int idx, Action el,Lock aLock)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfActions(IXmlBBase el)
  {
  return ((System.Collections.IList) allActions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteActions(int idx)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteActions(int idx,Lock aLock)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeActions(IXmlBBase obj)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(null);
   }
  }

public void removeActions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Actions</summary>
/// <returns>the number of elements in Actions</returns>
public int countActions()
  {
  return allActions().Count;
  }

/// <summary>Part of the list interface for Actions
/// This function returns an element from the
/// collection in Actions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Action getActions(int idx)
{
  return (Action) ( allActions()[idx]);
}

private System.Collections.ArrayList aExpectations;

/// <summary>Part of the list interface for Expectations</summary>
/// <returns>a collection of all the elements in Expectations</returns>
public System.Collections.ArrayList allExpectations()
  {
if (aExpectations == null){
    setAllExpectations( new System.Collections.ArrayList() );
} // If
    return aExpectations;
  }

/// <summary>Part of the list interface for Expectations</summary>
/// <returns>a collection of all the elements in Expectations</returns>
private System.Collections.ArrayList getExpectations()
  {
    return allExpectations();
  }

/// <summary>Part of the list interface for Expectations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Expectations's current content.</param>
public void setAllExpectations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aExpectations = coll;
    NotifyControllers(null);
  }
public void setAllExpectations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aExpectations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations</summary>
/// <param name="el">a Expectation to add to the collection in 
///           Expectations</param>
/// <seealso cref="appendExpectations(System.Collections.IList)"/>
public void appendExpectations(Expectation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allExpectations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendExpectations(Lock aLock,Expectation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allExpectations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Expectations</summary>
/// <param name="coll">a collection ofExpectations to add to the collection in 
///           Expectations</param>
/// <seealso cref="appendExpectations(Expectation)"/>
public void appendExpectations(System.Collections.IList coll)
  {
  __setDirty(true);
  allExpectations().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendExpectations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allExpectations().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations
/// This insertion function inserts a new element in the
/// collection in Expectations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertExpectations(int idx, Expectation el)
  {
  __setDirty(true);
  allExpectations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertExpectations(int idx, Expectation el,Lock aLock)
  {
  __setDirty(true);
  allExpectations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfExpectations(IXmlBBase el)
  {
  return ((System.Collections.IList) allExpectations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Expectations
/// This deletion function removes an element from the
/// collection in Expectations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteExpectations(int idx)
  {
  __setDirty(true);
  allExpectations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteExpectations(int idx,Lock aLock)
  {
  __setDirty(true);
  allExpectations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations
/// This deletion function removes an element from the
/// collection in Expectations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeExpectations(IXmlBBase obj)
  {
  int idx = indexOfExpectations(obj);
  if (idx >= 0) { deleteExpectations(idx);
NotifyControllers(null);
   }
  }

public void removeExpectations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfExpectations(obj);
  if (idx >= 0) { deleteExpectations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Expectations</summary>
/// <returns>the number of elements in Expectations</returns>
public int countExpectations()
  {
  return allExpectations().Count;
  }

/// <summary>Part of the list interface for Expectations
/// This function returns an element from the
/// collection in Expectations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Expectation getExpectations(int idx)
{
  return (Expectation) ( allExpectations()[idx]);
}

private  bool aSkipEngine;

public  bool getSkipEngine() { return aSkipEngine;}

public  void setSkipEngine(bool v) {
  aSkipEngine = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public SubStep()
{
SubStep obj = this;
aActions=(null);
aExpectations=(null);
aSkipEngine=(false);
aComment=(null);
}

public void copyTo(SubStep other)
{
base.copyTo(other);
other.aActions = aActions;
other.aExpectations = aExpectations;
other.aSkipEngine = aSkipEngine;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1109;
bool fl1110;
Action fl1112;
bool fl1123;
Expectation fl1125;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1109 = true ; 
while (fl1109) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1109 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Actions")){
ctxt.skipWhiteSpace();
fl1110 = true ; 
while (fl1110) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1110 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1112 = null;
while(ctxt.lookAheadOpeningTag ("<Action")) {
fl1112 = acceptor.lAccept_Action(ctxt, "</Action>");
appendActions(fl1112);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Actions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Expectations")){
ctxt.skipWhiteSpace();
fl1123 = true ; 
while (fl1123) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1123 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1125 = null;
while(ctxt.lookAheadOpeningTag ("<Expectation")) {
fl1125 = acceptor.lAccept_Expectation(ctxt, "</Expectation>");
appendExpectations(fl1125);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Expectations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1136;
bool fl1137;
bool fl1138;
bool fl1139;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1136 = false ; 
fl1137 = false ; 
fl1138 = false ; 
fl1139 = true ; 
while (fl1139) { // BeginLoop 
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
if (ctxt.lookAheadString("kipEngine=")){
indicator = 1136;
} else {
indicator = 1140;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1137;
} else {
indicator = 1140;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1138;
} else {
indicator = 1140;
} // If
break;
} // Case
default:
indicator = 1140;
break;
} // Switch
switch (indicator) {
case 1136: {
// Handling attribute SkipEngine
// Also handles alien attributes with prefix SkipEngine
if (fl1136){
ctxt.fail ("Duplicate attribute: SkipEngine");
} // If
fl1136 = true ; 
quoteChar = ctxt.acceptQuote();
this.setSkipEngine(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1137: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1137){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1137 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1138: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1138){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1138 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1140: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1136){
this.setSkipEngine( false);
} // If
fl1139 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SubStep";
  endingTag = "</SubStep>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SubStep\"");
} // If
pw.Write('\n');
if (this.getSkipEngine()){
pw.Write(" SkipEngine=\"");
acceptor.unParsePcData(pw, this.getSkipEngine());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: Actions
if (countActions() > 0){
pw.Write("<Actions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getActions(), false, "<Action", "</Action>");
pw.Write("</Actions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Actions
// Unparsing Enclosed
// Testing for empty content: Expectations
if (countExpectations() > 0){
pw.Write("<Expectations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getExpectations(), false, "<Expectation", "</Expectation>");
pw.Write("</Expectations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Expectations
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countActions(); i++) {
  l.Add(getActions(i));
}
for (int i = 0; i < countExpectations(); i++) {
  l.Add(getExpectations(i));
}
}

}
public partial class Expectation
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
if(getCondition().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ExpectationController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aBlocking;

public  bool getBlocking() { return aBlocking;}

public  void setBlocking(bool v) {
  aBlocking = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.ExpectationKind aKind;

public  acceptor.ExpectationKind getKind() { return aKind;}

public  void setKind(acceptor.ExpectationKind v) {
  aKind = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getKind_AsString()
{
  return acceptor.Enum_ExpectationKind_ToString (aKind);
}

public  bool setKind_AsString( string  v)
{
 acceptor.ExpectationKind  temp = acceptor.StringTo_Enum_ExpectationKind(v);
if (temp >= 0){
  aKind = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  double aDeadLine;

public  double getDeadLine() { return aDeadLine;}

public  void setDeadLine(double v) {
  aDeadLine = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aCondition;

public   string  getCondition() { return aCondition;}

public  void setCondition( string  v) {
  aCondition = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.RulePriority aCyclePhase;

public  acceptor.RulePriority getCyclePhase() { return aCyclePhase;}

public  void setCyclePhase(acceptor.RulePriority v) {
  aCyclePhase = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getCyclePhase_AsString()
{
  return acceptor.Enum_RulePriority_ToString (aCyclePhase);
}

public  bool setCyclePhase_AsString( string  v)
{
 acceptor.RulePriority  temp = acceptor.StringTo_Enum_RulePriority(v);
if (temp >= 0){
  aCyclePhase = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public Expectation()
{
Expectation obj = this;
aValue=(null);
aBlocking=(false);
aKind=(0);
aDeadLine=(0.0);
aCondition=(null);
aComment=(null);
aCyclePhase=(0);
}

public void copyTo(Expectation other)
{
base.copyTo(other);
other.aValue = aValue;
other.aBlocking = aBlocking;
other.aKind = aKind;
other.aDeadLine = aDeadLine;
other.aCondition = aCondition;
other.aComment = aComment;
other.aCyclePhase = aCyclePhase;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1145;
bool fl1146;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1145 = true ; 
while (fl1145) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1145 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Condition")){
ctxt.skipWhiteSpace();
fl1146 = true ; 
while (fl1146) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1146 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setCondition(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Condition>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1147;
bool fl1148;
bool fl1149;
bool fl1150;
bool fl1151;
bool fl1152;
bool fl1153;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1147 = false ; 
fl1148 = false ; 
fl1149 = false ; 
fl1150 = false ; 
fl1151 = false ; 
fl1152 = false ; 
fl1153 = true ; 
while (fl1153) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1151;
} else {
indicator = 1154;
} // If
break;
} // Case
case 'K':
{
ctxt.advance();
if (ctxt.lookAheadString("ind=")){
indicator = 1147;
} else {
indicator = 1154;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1152;
} else {
indicator = 1154;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("eadLine=")){
indicator = 1149;
} else {
indicator = 1154;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("yclePhase=")){
indicator = 1150;
} else {
indicator = 1154;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
if (ctxt.lookAheadString("locking=")){
indicator = 1148;
} else {
indicator = 1154;
} // If
break;
} // Case
default:
indicator = 1154;
break;
} // Switch
switch (indicator) {
case 1147: {
// Handling attribute Kind
// Also handles alien attributes with prefix Kind
if (fl1147){
ctxt.fail ("Duplicate attribute: Kind");
} // If
fl1147 = true ; 
quoteChar = ctxt.acceptQuote();
this.setKind(acceptor.lAcceptEnum_ExpectationKind(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1148: {
// Handling attribute Blocking
// Also handles alien attributes with prefix Blocking
if (fl1148){
ctxt.fail ("Duplicate attribute: Blocking");
} // If
fl1148 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBlocking(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1149: {
// Handling attribute DeadLine
// Also handles alien attributes with prefix DeadLine
if (fl1149){
ctxt.fail ("Duplicate attribute: DeadLine");
} // If
fl1149 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDeadLine(ctxt.fetchDouble());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1150: {
// Handling attribute CyclePhase
// Also handles alien attributes with prefix CyclePhase
if (fl1150){
ctxt.fail ("Duplicate attribute: CyclePhase");
} // If
fl1150 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCyclePhase(acceptor.lAcceptEnum_RulePriority(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1151: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1151){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1151 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1152: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1152){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1152 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1154: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1147){
this.setKind(acceptor.ExpectationKind.aInstantaneous);
} // If
if (!fl1148){
this.setBlocking( true);
} // If
if (!fl1149){
this.setDeadLine(0.0);
} // If
fl1153 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Expectation";
  endingTag = "</Expectation>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Expectation\"");
} // If
pw.Write('\n');
if (this.getKind() != 0){
pw.Write(" Kind=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ExpectationKind_ToString(this.getKind()));
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getBlocking()){
pw.Write(" Blocking=\"");
acceptor.unParsePcData(pw, this.getBlocking());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDeadLine() != 0){
pw.Write(" DeadLine=\"");
acceptor.unParsePcData(pw, this.getDeadLine());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getCyclePhase() != 0){
pw.Write(" CyclePhase=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_RulePriority_ToString(this.getCyclePhase()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
// Unparsing Enclosed
// Testing for empty content: Condition
if (this.getCondition() != null){
pw.Write("<Condition>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getCondition());
pw.Write("</Condition>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Condition
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class DBMessage
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DBMessageController.alertChange(aLock, this);
}
private  int aMessageOrder;

public  int getMessageOrder() { return aMessageOrder;}

public  void setMessageOrder(int v) {
  aMessageOrder = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.DBMessageType aMessageType;

public  acceptor.DBMessageType getMessageType() { return aMessageType;}

public  void setMessageType(acceptor.DBMessageType v) {
  aMessageType = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMessageType_AsString()
{
  return acceptor.Enum_DBMessageType_ToString (aMessageType);
}

public  bool setMessageType_AsString( string  v)
{
 acceptor.DBMessageType  temp = acceptor.StringTo_Enum_DBMessageType(v);
if (temp >= 0){
  aMessageType = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aFields;

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
public System.Collections.ArrayList allFields()
  {
if (aFields == null){
    setAllFields( new System.Collections.ArrayList() );
} // If
    return aFields;
  }

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
private System.Collections.ArrayList getFields()
  {
    return allFields();
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection of elements which replaces 
///        Fields's current content.</param>
public void setAllFields(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
    NotifyControllers(null);
  }
public void setAllFields(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="el">a DBField to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(System.Collections.IList)"/>
public void appendFields(DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFields(Lock aLock,DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection ofDBFields to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(DBField)"/>
public void appendFields(System.Collections.IList coll)
  {
  __setDirty(true);
  allFields().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFields(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFields().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This insertion function inserts a new element in the
/// collection in Fields</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFields(int idx, DBField el)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFields(int idx, DBField el,Lock aLock)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFields(IXmlBBase el)
  {
  return ((System.Collections.IList) allFields()).IndexOf (el);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFields(int idx)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFields(int idx,Lock aLock)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFields(IXmlBBase obj)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(null);
   }
  }

public void removeFields(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Fields</summary>
/// <returns>the number of elements in Fields</returns>
public int countFields()
  {
  return allFields().Count;
  }

/// <summary>Part of the list interface for Fields
/// This function returns an element from the
/// collection in Fields based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBField getFields(int idx)
{
  return (DBField) ( allFields()[idx]);
}

private System.Collections.ArrayList aPackets;

/// <summary>Part of the list interface for Packets</summary>
/// <returns>a collection of all the elements in Packets</returns>
public System.Collections.ArrayList allPackets()
  {
if (aPackets == null){
    setAllPackets( new System.Collections.ArrayList() );
} // If
    return aPackets;
  }

/// <summary>Part of the list interface for Packets</summary>
/// <returns>a collection of all the elements in Packets</returns>
private System.Collections.ArrayList getPackets()
  {
    return allPackets();
  }

/// <summary>Part of the list interface for Packets</summary>
/// <param name="coll">a collection of elements which replaces 
///        Packets's current content.</param>
public void setAllPackets(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPackets = coll;
    NotifyControllers(null);
  }
public void setAllPackets(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPackets = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets</summary>
/// <param name="el">a DBPacket to add to the collection in 
///           Packets</param>
/// <seealso cref="appendPackets(System.Collections.IList)"/>
public void appendPackets(DBPacket el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPackets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendPackets(Lock aLock,DBPacket el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPackets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Packets</summary>
/// <param name="coll">a collection ofDBPackets to add to the collection in 
///           Packets</param>
/// <seealso cref="appendPackets(DBPacket)"/>
public void appendPackets(System.Collections.IList coll)
  {
  __setDirty(true);
  allPackets().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendPackets(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allPackets().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets
/// This insertion function inserts a new element in the
/// collection in Packets</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertPackets(int idx, DBPacket el)
  {
  __setDirty(true);
  allPackets().Insert (idx, el);
NotifyControllers(null);
  }

public void insertPackets(int idx, DBPacket el,Lock aLock)
  {
  __setDirty(true);
  allPackets().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfPackets(IXmlBBase el)
  {
  return ((System.Collections.IList) allPackets()).IndexOf (el);
  }

/// <summary>Part of the list interface for Packets
/// This deletion function removes an element from the
/// collection in Packets</summary>
/// <param name="idx">the index of the element to remove</param>
public void deletePackets(int idx)
  {
  __setDirty(true);
  allPackets().RemoveAt(idx);
NotifyControllers(null);
  }

public void deletePackets(int idx,Lock aLock)
  {
  __setDirty(true);
  allPackets().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets
/// This deletion function removes an element from the
/// collection in Packets
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removePackets(IXmlBBase obj)
  {
  int idx = indexOfPackets(obj);
  if (idx >= 0) { deletePackets(idx);
NotifyControllers(null);
   }
  }

public void removePackets(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfPackets(obj);
  if (idx >= 0) { deletePackets(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Packets</summary>
/// <returns>the number of elements in Packets</returns>
public int countPackets()
  {
  return allPackets().Count;
  }

/// <summary>Part of the list interface for Packets
/// This function returns an element from the
/// collection in Packets based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBPacket getPackets(int idx)
{
  return (DBPacket) ( allPackets()[idx]);
}

public DBMessage()
{
DBMessage obj = this;
aMessageOrder=(0);
aMessageType=(0);
aFields=(null);
aPackets=(null);
}

public void copyTo(DBMessage other)
{
base.copyTo(other);
other.aMessageOrder = aMessageOrder;
other.aMessageType = aMessageType;
other.aFields = aFields;
other.aPackets = aPackets;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1162;
DBField fl1164;
bool fl1175;
DBPacket fl1177;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Fields")){
ctxt.skipWhiteSpace();
fl1162 = true ; 
while (fl1162) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1162 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1164 = null;
while(ctxt.lookAheadOpeningTag ("<DBField")) {
fl1164 = acceptor.lAccept_DBField(ctxt, "</DBField>");
appendFields(fl1164);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Fields>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Packets")){
ctxt.skipWhiteSpace();
fl1175 = true ; 
while (fl1175) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1175 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1177 = null;
while(ctxt.lookAheadOpeningTag ("<DBPacket")) {
fl1177 = acceptor.lAccept_DBPacket(ctxt, "</DBPacket>");
appendPackets(fl1177);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Packets>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1188;
bool fl1189;
bool fl1190;
bool fl1191;
bool fl1192;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1188 = false ; 
fl1189 = false ; 
fl1190 = false ; 
fl1191 = false ; 
fl1192 = true ; 
while (fl1192) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1190;
} else {
indicator = 1193;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("essage")){
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 1189;
} else {
indicator = 1193;
} // If
break;
} // Case
case 'O':
{
ctxt.advance();
if (ctxt.lookAheadString("rder=")){
indicator = 1188;
} else {
indicator = 1193;
} // If
break;
} // Case
default:
indicator = 1193;
break;
} // Switch
} else {
indicator = 1193;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1191;
} else {
indicator = 1193;
} // If
break;
} // Case
default:
indicator = 1193;
break;
} // Switch
switch (indicator) {
case 1188: {
// Handling attribute MessageOrder
// Also handles alien attributes with prefix MessageOrder
if (fl1188){
ctxt.fail ("Duplicate attribute: MessageOrder");
} // If
fl1188 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMessageOrder(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1189: {
// Handling attribute MessageType
// Also handles alien attributes with prefix MessageType
if (fl1189){
ctxt.fail ("Duplicate attribute: MessageType");
} // If
fl1189 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMessageType(acceptor.lAcceptEnum_DBMessageType(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1190: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1190){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1190 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1191: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1191){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1191 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1193: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1188){
this.setMessageOrder(0);
} // If
if (!fl1189){
this.setMessageType(acceptor.DBMessageType.aEUROBALISE);
} // If
fl1192 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<DBMessage";
  endingTag = "</DBMessage>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"DBMessage\"");
} // If
pw.Write('\n');
if (this.getMessageOrder() != 0){
pw.Write(" MessageOrder=\"");
acceptor.unParsePcData(pw, this.getMessageOrder());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMessageType() != 0){
pw.Write(" MessageType=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_DBMessageType_ToString(this.getMessageType()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Fields
if (countFields() > 0){
pw.Write("<Fields>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFields(), false, "<DBField", "</DBField>");
pw.Write("</Fields>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Fields
// Unparsing Enclosed
// Testing for empty content: Packets
if (countPackets() > 0){
pw.Write("<Packets>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getPackets(), false, "<DBPacket", "</DBPacket>");
pw.Write("</Packets>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Packets
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFields(); i++) {
  l.Add(getFields(i));
}
for (int i = 0; i < countPackets(); i++) {
  l.Add(getPackets(i));
}
}

}
public partial class DBPacket
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DBPacketController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFields;

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
public System.Collections.ArrayList allFields()
  {
if (aFields == null){
    setAllFields( new System.Collections.ArrayList() );
} // If
    return aFields;
  }

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
private System.Collections.ArrayList getFields()
  {
    return allFields();
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection of elements which replaces 
///        Fields's current content.</param>
public void setAllFields(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
    NotifyControllers(null);
  }
public void setAllFields(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="el">a DBField to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(System.Collections.IList)"/>
public void appendFields(DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFields(Lock aLock,DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection ofDBFields to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(DBField)"/>
public void appendFields(System.Collections.IList coll)
  {
  __setDirty(true);
  allFields().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFields(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFields().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This insertion function inserts a new element in the
/// collection in Fields</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFields(int idx, DBField el)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFields(int idx, DBField el,Lock aLock)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFields(IXmlBBase el)
  {
  return ((System.Collections.IList) allFields()).IndexOf (el);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFields(int idx)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFields(int idx,Lock aLock)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFields(IXmlBBase obj)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(null);
   }
  }

public void removeFields(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Fields</summary>
/// <returns>the number of elements in Fields</returns>
public int countFields()
  {
  return allFields().Count;
  }

/// <summary>Part of the list interface for Fields
/// This function returns an element from the
/// collection in Fields based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBField getFields(int idx)
{
  return (DBField) ( allFields()[idx]);
}

public DBPacket()
{
DBPacket obj = this;
aFields=(null);
}

public void copyTo(DBPacket other)
{
base.copyTo(other);
other.aFields = aFields;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1200;
DBField fl1202;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Fields")){
ctxt.skipWhiteSpace();
fl1200 = true ; 
while (fl1200) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1200 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1202 = null;
while(ctxt.lookAheadOpeningTag ("<DBField")) {
fl1202 = acceptor.lAccept_DBField(ctxt, "</DBField>");
appendFields(fl1202);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Fields>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1213;
bool fl1214;
bool fl1215;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1213 = false ; 
fl1214 = false ; 
fl1215 = true ; 
while (fl1215) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1213;
} else {
indicator = 1216;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1214;
} else {
indicator = 1216;
} // If
break;
} // Case
default:
indicator = 1216;
break;
} // Switch
switch (indicator) {
case 1213: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1213){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1213 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1214: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1214){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1214 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1216: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1215 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<DBPacket";
  endingTag = "</DBPacket>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"DBPacket\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Fields
if (countFields() > 0){
pw.Write("<Fields>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFields(), false, "<DBField", "</DBField>");
pw.Write("</Fields>");
// No formula father defined
pw.Write('\n');
} // If
// After Testing for empty content: Fields
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFields(); i++) {
  l.Add(getFields(i));
}
}

}
public partial class DBField
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getVariable().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DBFieldController.alertChange(aLock, this);
}
private   string  aVariable;

public   string  getVariable() { return aVariable;}

public  void setVariable( string  v) {
  aVariable = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aValue;

public  int getValue() { return aValue;}

public  void setValue(int v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public DBField()
{
DBField obj = this;
aVariable=(null);
aValue=(0);
}

public void copyTo(DBField other)
{
base.copyTo(other);
other.aVariable = aVariable;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1220;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Variable")){
ctxt.skipWhiteSpace();
fl1220 = true ; 
while (fl1220) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1220 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setVariable(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Variable>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1221;
bool fl1222;
bool fl1223;
bool fl1224;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1221 = false ; 
fl1222 = false ; 
fl1223 = false ; 
fl1224 = true ; 
while (fl1224) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue=")){
indicator = 1221;
} else {
indicator = 1225;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1222;
} else {
indicator = 1225;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1223;
} else {
indicator = 1225;
} // If
break;
} // Case
default:
indicator = 1225;
break;
} // Switch
switch (indicator) {
case 1221: {
// Handling attribute Value
// Also handles alien attributes with prefix Value
if (fl1221){
ctxt.fail ("Duplicate attribute: Value");
} // If
fl1221 = true ; 
quoteChar = ctxt.acceptQuote();
this.setValue(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1222: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1222){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1222 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1223: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1223){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1223 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1225: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1221){
this.setValue(0);
} // If
fl1224 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<DBField";
  endingTag = "</DBField>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"DBField\"");
} // If
pw.Write('\n');
if (this.getValue() != 0){
pw.Write(" Value=\"");
acceptor.unParsePcData(pw, this.getValue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Variable
if (this.getVariable() != null){
pw.Write("<Variable>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getVariable());
pw.Write("</Variable>");
// No formula father defined
pw.Write('\n');
} // If
// After Testing for empty content: Variable
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class TranslationDictionary
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TranslationDictionaryController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a Folder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(Folder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, Folder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, Folder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Folder getFolders(int idx)
{
  return (Folder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aTranslations;

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
public System.Collections.ArrayList allTranslations()
  {
if (aTranslations == null){
    setAllTranslations( new System.Collections.ArrayList() );
} // If
    return aTranslations;
  }

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
private System.Collections.ArrayList getTranslations()
  {
    return allTranslations();
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Translations's current content.</param>
public void setAllTranslations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
    NotifyControllers(null);
  }
public void setAllTranslations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="el">a Translation to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(System.Collections.IList)"/>
public void appendTranslations(Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTranslations(Lock aLock,Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection ofTranslations to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(Translation)"/>
public void appendTranslations(System.Collections.IList coll)
  {
  __setDirty(true);
  allTranslations().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTranslations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTranslations().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This insertion function inserts a new element in the
/// collection in Translations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTranslations(int idx, Translation el)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTranslations(int idx, Translation el,Lock aLock)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTranslations(IXmlBBase el)
  {
  return ((System.Collections.IList) allTranslations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTranslations(int idx)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTranslations(int idx,Lock aLock)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTranslations(IXmlBBase obj)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(null);
   }
  }

public void removeTranslations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Translations</summary>
/// <returns>the number of elements in Translations</returns>
public int countTranslations()
  {
  return allTranslations().Count;
  }

/// <summary>Part of the list interface for Translations
/// This function returns an element from the
/// collection in Translations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Translation getTranslations(int idx)
{
  return (Translation) ( allTranslations()[idx]);
}

public TranslationDictionary()
{
TranslationDictionary obj = this;
aFolders=(null);
aTranslations=(null);
}

public void copyTo(TranslationDictionary other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aTranslations = aTranslations;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1230;
Folder fl1232;
bool fl1243;
Translation fl1245;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1230 = true ; 
while (fl1230) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1230 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1232 = null;
while(ctxt.lookAheadOpeningTag ("<Folder")) {
fl1232 = acceptor.lAccept_Folder(ctxt, "</Folder>");
appendFolders(fl1232);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Translations")){
ctxt.skipWhiteSpace();
fl1243 = true ; 
while (fl1243) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1243 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1245 = null;
while(ctxt.lookAheadOpeningTag ("<Translation")) {
fl1245 = acceptor.lAccept_Translation(ctxt, "</Translation>");
appendTranslations(fl1245);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Translations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1256;
bool fl1257;
bool fl1258;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1256 = false ; 
fl1257 = false ; 
fl1258 = true ; 
while (fl1258) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1256;
} else {
indicator = 1259;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1257;
} else {
indicator = 1259;
} // If
break;
} // Case
default:
indicator = 1259;
break;
} // Switch
switch (indicator) {
case 1256: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1256){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1256 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1257: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1257){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1257 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1259: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1258 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<TranslationDictionary";
  endingTag = "</TranslationDictionary>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"TranslationDictionary\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<Folder", "</Folder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Translations
if (countTranslations() > 0){
pw.Write("<Translations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTranslations(), false, "<Translation", "</Translation>");
pw.Write("</Translations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Translations
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countTranslations(); i++) {
  l.Add(getTranslations(i));
}
}

}
public partial class Folder
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FolderController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a Folder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(Folder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, Folder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, Folder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Folder getFolders(int idx)
{
  return (Folder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aTranslations;

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
public System.Collections.ArrayList allTranslations()
  {
if (aTranslations == null){
    setAllTranslations( new System.Collections.ArrayList() );
} // If
    return aTranslations;
  }

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
private System.Collections.ArrayList getTranslations()
  {
    return allTranslations();
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Translations's current content.</param>
public void setAllTranslations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
    NotifyControllers(null);
  }
public void setAllTranslations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="el">a Translation to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(System.Collections.IList)"/>
public void appendTranslations(Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTranslations(Lock aLock,Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection ofTranslations to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(Translation)"/>
public void appendTranslations(System.Collections.IList coll)
  {
  __setDirty(true);
  allTranslations().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTranslations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTranslations().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This insertion function inserts a new element in the
/// collection in Translations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTranslations(int idx, Translation el)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTranslations(int idx, Translation el,Lock aLock)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTranslations(IXmlBBase el)
  {
  return ((System.Collections.IList) allTranslations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTranslations(int idx)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTranslations(int idx,Lock aLock)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTranslations(IXmlBBase obj)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(null);
   }
  }

public void removeTranslations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Translations</summary>
/// <returns>the number of elements in Translations</returns>
public int countTranslations()
  {
  return allTranslations().Count;
  }

/// <summary>Part of the list interface for Translations
/// This function returns an element from the
/// collection in Translations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Translation getTranslations(int idx)
{
  return (Translation) ( allTranslations()[idx]);
}

public Folder()
{
Folder obj = this;
aFolders=(null);
aTranslations=(null);
}

public void copyTo(Folder other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aTranslations = aTranslations;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1263;
Folder fl1265;
bool fl1276;
Translation fl1278;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1263 = true ; 
while (fl1263) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1263 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1265 = null;
while(ctxt.lookAheadOpeningTag ("<Folder")) {
fl1265 = acceptor.lAccept_Folder(ctxt, "</Folder>");
appendFolders(fl1265);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Translations")){
ctxt.skipWhiteSpace();
fl1276 = true ; 
while (fl1276) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1276 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1278 = null;
while(ctxt.lookAheadOpeningTag ("<Translation")) {
fl1278 = acceptor.lAccept_Translation(ctxt, "</Translation>");
appendTranslations(fl1278);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Translations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1289;
bool fl1290;
bool fl1291;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1289 = false ; 
fl1290 = false ; 
fl1291 = true ; 
while (fl1291) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1289;
} else {
indicator = 1292;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1290;
} else {
indicator = 1292;
} // If
break;
} // Case
default:
indicator = 1292;
break;
} // Switch
switch (indicator) {
case 1289: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1289){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1289 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1290: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1290){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1290 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1292: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1291 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Folder";
  endingTag = "</Folder>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Folder\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<Folder", "</Folder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Translations
if (countTranslations() > 0){
pw.Write("<Translations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTranslations(), false, "<Translation", "</Translation>");
pw.Write("</Translations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Translations
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countTranslations(); i++) {
  l.Add(getTranslations(i));
}
}

}
public partial class Translation
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TranslationController.alertChange(aLock, this);
}
private System.Collections.ArrayList aSourceTexts;

/// <summary>Part of the list interface for SourceTexts</summary>
/// <returns>a collection of all the elements in SourceTexts</returns>
public System.Collections.ArrayList allSourceTexts()
  {
if (aSourceTexts == null){
    setAllSourceTexts( new System.Collections.ArrayList() );
} // If
    return aSourceTexts;
  }

/// <summary>Part of the list interface for SourceTexts</summary>
/// <returns>a collection of all the elements in SourceTexts</returns>
private System.Collections.ArrayList getSourceTexts()
  {
    return allSourceTexts();
  }

/// <summary>Part of the list interface for SourceTexts</summary>
/// <param name="coll">a collection of elements which replaces 
///        SourceTexts's current content.</param>
public void setAllSourceTexts(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSourceTexts = coll;
    NotifyControllers(null);
  }
public void setAllSourceTexts(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSourceTexts = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts</summary>
/// <param name="el">a SourceText to add to the collection in 
///           SourceTexts</param>
/// <seealso cref="appendSourceTexts(System.Collections.IList)"/>
public void appendSourceTexts(SourceText el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSourceTexts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSourceTexts(Lock aLock,SourceText el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSourceTexts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SourceTexts</summary>
/// <param name="coll">a collection ofSourceTexts to add to the collection in 
///           SourceTexts</param>
/// <seealso cref="appendSourceTexts(SourceText)"/>
public void appendSourceTexts(System.Collections.IList coll)
  {
  __setDirty(true);
  allSourceTexts().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSourceTexts(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSourceTexts().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts
/// This insertion function inserts a new element in the
/// collection in SourceTexts</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSourceTexts(int idx, SourceText el)
  {
  __setDirty(true);
  allSourceTexts().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSourceTexts(int idx, SourceText el,Lock aLock)
  {
  __setDirty(true);
  allSourceTexts().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSourceTexts(IXmlBBase el)
  {
  return ((System.Collections.IList) allSourceTexts()).IndexOf (el);
  }

/// <summary>Part of the list interface for SourceTexts
/// This deletion function removes an element from the
/// collection in SourceTexts</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSourceTexts(int idx)
  {
  __setDirty(true);
  allSourceTexts().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSourceTexts(int idx,Lock aLock)
  {
  __setDirty(true);
  allSourceTexts().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts
/// This deletion function removes an element from the
/// collection in SourceTexts
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSourceTexts(IXmlBBase obj)
  {
  int idx = indexOfSourceTexts(obj);
  if (idx >= 0) { deleteSourceTexts(idx);
NotifyControllers(null);
   }
  }

public void removeSourceTexts(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSourceTexts(obj);
  if (idx >= 0) { deleteSourceTexts(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SourceTexts</summary>
/// <returns>the number of elements in SourceTexts</returns>
public int countSourceTexts()
  {
  return allSourceTexts().Count;
  }

/// <summary>Part of the list interface for SourceTexts
/// This function returns an element from the
/// collection in SourceTexts based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SourceText getSourceTexts(int idx)
{
  return (SourceText) ( allSourceTexts()[idx]);
}

private  bool aImplemented;

public  bool getImplemented() { return aImplemented;}

public  void setImplemented(bool v) {
  aImplemented = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSubSteps;

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
public System.Collections.ArrayList allSubSteps()
  {
if (aSubSteps == null){
    setAllSubSteps( new System.Collections.ArrayList() );
} // If
    return aSubSteps;
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
private System.Collections.ArrayList getSubSteps()
  {
    return allSubSteps();
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSteps's current content.</param>
public void setAllSubSteps(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
    NotifyControllers(null);
  }
public void setAllSubSteps(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="el">a SubStep to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(System.Collections.IList)"/>
public void appendSubSteps(SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSteps(Lock aLock,SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection ofSubSteps to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(SubStep)"/>
public void appendSubSteps(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSteps().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSteps(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This insertion function inserts a new element in the
/// collection in SubSteps</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSteps(int idx, SubStep el)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSteps(int idx, SubStep el,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSteps(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSteps()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSteps(int idx)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSteps(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSteps(IXmlBBase obj)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(null);
   }
  }

public void removeSubSteps(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>the number of elements in SubSteps</returns>
public int countSubSteps()
  {
  return allSubSteps().Count;
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns an element from the
/// collection in SubSteps based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SubStep getSubSteps(int idx)
{
  return (SubStep) ( allSubSteps()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Translation()
{
Translation obj = this;
aSourceTexts=(null);
aImplemented=(false);
aSubSteps=(null);
aComment=(null);
}

public void copyTo(Translation other)
{
base.copyTo(other);
other.aSourceTexts = aSourceTexts;
other.aImplemented = aImplemented;
other.aSubSteps = aSubSteps;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1296;
SourceText fl1298;
bool fl1309;
SubStep fl1311;
bool fl1322;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SourceTexts")){
ctxt.skipWhiteSpace();
fl1296 = true ; 
while (fl1296) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1296 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1298 = null;
while(ctxt.lookAheadOpeningTag ("<SourceText")) {
fl1298 = acceptor.lAccept_SourceText(ctxt, "</SourceText>");
appendSourceTexts(fl1298);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SourceTexts>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubSteps")){
ctxt.skipWhiteSpace();
fl1309 = true ; 
while (fl1309) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1309 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1311 = null;
while(ctxt.lookAheadOpeningTag ("<SubStep")) {
fl1311 = acceptor.lAccept_SubStep(ctxt, "</SubStep>");
appendSubSteps(fl1311);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSteps>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1322 = true ; 
while (fl1322) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1322 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1323;
bool fl1324;
bool fl1325;
bool fl1326;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1323 = false ; 
fl1324 = false ; 
fl1325 = false ; 
fl1326 = true ; 
while (fl1326) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1324;
} else {
indicator = 1327;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1323;
} else {
indicator = 1327;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1325;
} else {
indicator = 1327;
} // If
break;
} // Case
default:
indicator = 1327;
break;
} // Switch
switch (indicator) {
case 1323: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1323){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1323 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1324: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1324){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1324 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1325: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1325){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1325 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1327: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1323){
this.setImplemented( false);
} // If
fl1326 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Translation";
  endingTag = "</Translation>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Translation\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: SourceTexts
if (countSourceTexts() > 0){
pw.Write("<SourceTexts>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSourceTexts(), false, "<SourceText", "</SourceText>");
pw.Write("</SourceTexts>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SourceTexts
// Unparsing Enclosed
// Testing for empty content: SubSteps
if (countSubSteps() > 0){
pw.Write("<SubSteps>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSteps(), false, "<SubStep", "</SubStep>");
pw.Write("</SubSteps>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubSteps
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSourceTexts(); i++) {
  l.Add(getSourceTexts(i));
}
for (int i = 0; i < countSubSteps(); i++) {
  l.Add(getSubSteps(i));
}
}

}
public partial class SourceText
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SourceTextController.alertChange(aLock, this);
}
public SourceText()
{
SourceText obj = this;
}

public void copyTo(SourceText other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1332;
bool fl1333;
bool fl1334;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1332 = false ; 
fl1333 = false ; 
fl1334 = true ; 
while (fl1334) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1332;
} else {
indicator = 1335;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1333;
} else {
indicator = 1335;
} // If
break;
} // Case
default:
indicator = 1335;
break;
} // Switch
switch (indicator) {
case 1332: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1332){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1332 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1333: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1333){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1333 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1335: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1334 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SourceText";
  endingTag = "</SourceText>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SourceText\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class ShortcutDictionary
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ShortcutDictionaryController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a ShortcutFolder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofShortcutFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(ShortcutFolder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, ShortcutFolder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, ShortcutFolder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ShortcutFolder getFolders(int idx)
{
  return (ShortcutFolder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aShortcuts;

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
public System.Collections.ArrayList allShortcuts()
  {
if (aShortcuts == null){
    setAllShortcuts( new System.Collections.ArrayList() );
} // If
    return aShortcuts;
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
private System.Collections.ArrayList getShortcuts()
  {
    return allShortcuts();
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection of elements which replaces 
///        Shortcuts's current content.</param>
public void setAllShortcuts(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
    NotifyControllers(null);
  }
public void setAllShortcuts(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="el">a Shortcut to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(System.Collections.IList)"/>
public void appendShortcuts(Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendShortcuts(Lock aLock,Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection ofShortcuts to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(Shortcut)"/>
public void appendShortcuts(System.Collections.IList coll)
  {
  __setDirty(true);
  allShortcuts().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendShortcuts(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This insertion function inserts a new element in the
/// collection in Shortcuts</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertShortcuts(int idx, Shortcut el)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(null);
  }

public void insertShortcuts(int idx, Shortcut el,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfShortcuts(IXmlBBase el)
  {
  return ((System.Collections.IList) allShortcuts()).IndexOf (el);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteShortcuts(int idx)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteShortcuts(int idx,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeShortcuts(IXmlBBase obj)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(null);
   }
  }

public void removeShortcuts(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>the number of elements in Shortcuts</returns>
public int countShortcuts()
  {
  return allShortcuts().Count;
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns an element from the
/// collection in Shortcuts based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Shortcut getShortcuts(int idx)
{
  return (Shortcut) ( allShortcuts()[idx]);
}

public ShortcutDictionary()
{
ShortcutDictionary obj = this;
aFolders=(null);
aShortcuts=(null);
}

public void copyTo(ShortcutDictionary other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aShortcuts = aShortcuts;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1339;
ShortcutFolder fl1341;
bool fl1352;
Shortcut fl1354;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1339 = true ; 
while (fl1339) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1339 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1341 = null;
while(ctxt.lookAheadOpeningTag ("<ShortcutFolder")) {
fl1341 = acceptor.lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
appendFolders(fl1341);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Shortcuts")){
ctxt.skipWhiteSpace();
fl1352 = true ; 
while (fl1352) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1352 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1354 = null;
while(ctxt.lookAheadOpeningTag ("<Shortcut")) {
fl1354 = acceptor.lAccept_Shortcut(ctxt, "</Shortcut>");
appendShortcuts(fl1354);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Shortcuts>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1365;
bool fl1366;
bool fl1367;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1365 = false ; 
fl1366 = false ; 
fl1367 = true ; 
while (fl1367) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1365;
} else {
indicator = 1368;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1366;
} else {
indicator = 1368;
} // If
break;
} // Case
default:
indicator = 1368;
break;
} // Switch
switch (indicator) {
case 1365: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1365){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1365 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1366: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1366){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1366 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1368: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1367 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ShortcutDictionary";
  endingTag = "</ShortcutDictionary>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ShortcutDictionary\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<ShortcutFolder", "</ShortcutFolder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Shortcuts
if (countShortcuts() > 0){
pw.Write("<Shortcuts>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getShortcuts(), false, "<Shortcut", "</Shortcut>");
pw.Write("</Shortcuts>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Shortcuts
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countShortcuts(); i++) {
  l.Add(getShortcuts(i));
}
}

}
public partial class ShortcutFolder
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ShortcutFolderController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a ShortcutFolder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofShortcutFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(ShortcutFolder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, ShortcutFolder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, ShortcutFolder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ShortcutFolder getFolders(int idx)
{
  return (ShortcutFolder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aShortcuts;

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
public System.Collections.ArrayList allShortcuts()
  {
if (aShortcuts == null){
    setAllShortcuts( new System.Collections.ArrayList() );
} // If
    return aShortcuts;
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
private System.Collections.ArrayList getShortcuts()
  {
    return allShortcuts();
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection of elements which replaces 
///        Shortcuts's current content.</param>
public void setAllShortcuts(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
    NotifyControllers(null);
  }
public void setAllShortcuts(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="el">a Shortcut to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(System.Collections.IList)"/>
public void appendShortcuts(Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendShortcuts(Lock aLock,Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection ofShortcuts to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(Shortcut)"/>
public void appendShortcuts(System.Collections.IList coll)
  {
  __setDirty(true);
  allShortcuts().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendShortcuts(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This insertion function inserts a new element in the
/// collection in Shortcuts</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertShortcuts(int idx, Shortcut el)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(null);
  }

public void insertShortcuts(int idx, Shortcut el,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfShortcuts(IXmlBBase el)
  {
  return ((System.Collections.IList) allShortcuts()).IndexOf (el);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteShortcuts(int idx)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteShortcuts(int idx,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeShortcuts(IXmlBBase obj)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(null);
   }
  }

public void removeShortcuts(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>the number of elements in Shortcuts</returns>
public int countShortcuts()
  {
  return allShortcuts().Count;
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns an element from the
/// collection in Shortcuts based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Shortcut getShortcuts(int idx)
{
  return (Shortcut) ( allShortcuts()[idx]);
}

public ShortcutFolder()
{
ShortcutFolder obj = this;
aFolders=(null);
aShortcuts=(null);
}

public void copyTo(ShortcutFolder other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aShortcuts = aShortcuts;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1372;
ShortcutFolder fl1374;
bool fl1385;
Shortcut fl1387;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1372 = true ; 
while (fl1372) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1372 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1374 = null;
while(ctxt.lookAheadOpeningTag ("<ShortcutFolder")) {
fl1374 = acceptor.lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
appendFolders(fl1374);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Shortcuts")){
ctxt.skipWhiteSpace();
fl1385 = true ; 
while (fl1385) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1385 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1387 = null;
while(ctxt.lookAheadOpeningTag ("<Shortcut")) {
fl1387 = acceptor.lAccept_Shortcut(ctxt, "</Shortcut>");
appendShortcuts(fl1387);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Shortcuts>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1398;
bool fl1399;
bool fl1400;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1398 = false ; 
fl1399 = false ; 
fl1400 = true ; 
while (fl1400) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1398;
} else {
indicator = 1401;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1399;
} else {
indicator = 1401;
} // If
break;
} // Case
default:
indicator = 1401;
break;
} // Switch
switch (indicator) {
case 1398: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1398){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1398 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1399: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1399){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1399 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1401: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1400 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ShortcutFolder";
  endingTag = "</ShortcutFolder>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ShortcutFolder\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<ShortcutFolder", "</ShortcutFolder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Shortcuts
if (countShortcuts() > 0){
pw.Write("<Shortcuts>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getShortcuts(), false, "<Shortcut", "</Shortcut>");
pw.Write("</Shortcuts>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Shortcuts
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countShortcuts(); i++) {
  l.Add(getShortcuts(i));
}
}

}
public partial class Shortcut
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getShortcutName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ShortcutController.alertChange(aLock, this);
}
private   string  aShortcutName;

public   string  getShortcutName() { return aShortcutName;}

public  void setShortcutName( string  v) {
  aShortcutName = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Shortcut()
{
Shortcut obj = this;
aShortcutName=(null);
}

public void copyTo(Shortcut other)
{
base.copyTo(other);
other.aShortcutName = aShortcutName;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1405;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<ShortcutName")){
ctxt.skipWhiteSpace();
fl1405 = true ; 
while (fl1405) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1405 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setShortcutName(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</ShortcutName>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1406;
bool fl1407;
bool fl1408;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1406 = false ; 
fl1407 = false ; 
fl1408 = true ; 
while (fl1408) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1406;
} else {
indicator = 1409;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1407;
} else {
indicator = 1409;
} // If
break;
} // Case
default:
indicator = 1409;
break;
} // Switch
switch (indicator) {
case 1406: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1406){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1406 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1407: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1407){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1407 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1409: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1408 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Shortcut";
  endingTag = "</Shortcut>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Shortcut\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: ShortcutName
if (this.getShortcutName() != null){
pw.Write("<ShortcutName>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getShortcutName());
pw.Write("</ShortcutName>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: ShortcutName
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Specification
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getVersion().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SpecificationController.alertChange(aLock, this);
}
private   string  aVersion;

public   string  getVersion() { return aVersion;}

public  void setVersion( string  v) {
  aVersion = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aChapters;

/// <summary>Part of the list interface for Chapters</summary>
/// <returns>a collection of all the elements in Chapters</returns>
public System.Collections.ArrayList allChapters()
  {
if (aChapters == null){
    setAllChapters( new System.Collections.ArrayList() );
} // If
    return aChapters;
  }

/// <summary>Part of the list interface for Chapters</summary>
/// <returns>a collection of all the elements in Chapters</returns>
private System.Collections.ArrayList getChapters()
  {
    return allChapters();
  }

/// <summary>Part of the list interface for Chapters</summary>
/// <param name="coll">a collection of elements which replaces 
///        Chapters's current content.</param>
public void setAllChapters(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapters = coll;
    NotifyControllers(null);
  }
public void setAllChapters(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapters = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters</summary>
/// <param name="el">a Chapter to add to the collection in 
///           Chapters</param>
/// <seealso cref="appendChapters(System.Collections.IList)"/>
public void appendChapters(Chapter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendChapters(Lock aLock,Chapter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Chapters</summary>
/// <param name="coll">a collection ofChapters to add to the collection in 
///           Chapters</param>
/// <seealso cref="appendChapters(Chapter)"/>
public void appendChapters(System.Collections.IList coll)
  {
  __setDirty(true);
  allChapters().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendChapters(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allChapters().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters
/// This insertion function inserts a new element in the
/// collection in Chapters</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertChapters(int idx, Chapter el)
  {
  __setDirty(true);
  allChapters().Insert (idx, el);
NotifyControllers(null);
  }

public void insertChapters(int idx, Chapter el,Lock aLock)
  {
  __setDirty(true);
  allChapters().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfChapters(IXmlBBase el)
  {
  return ((System.Collections.IList) allChapters()).IndexOf (el);
  }

/// <summary>Part of the list interface for Chapters
/// This deletion function removes an element from the
/// collection in Chapters</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteChapters(int idx)
  {
  __setDirty(true);
  allChapters().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteChapters(int idx,Lock aLock)
  {
  __setDirty(true);
  allChapters().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters
/// This deletion function removes an element from the
/// collection in Chapters
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeChapters(IXmlBBase obj)
  {
  int idx = indexOfChapters(obj);
  if (idx >= 0) { deleteChapters(idx);
NotifyControllers(null);
   }
  }

public void removeChapters(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfChapters(obj);
  if (idx >= 0) { deleteChapters(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Chapters</summary>
/// <returns>the number of elements in Chapters</returns>
public int countChapters()
  {
  return allChapters().Count;
  }

/// <summary>Part of the list interface for Chapters
/// This function returns an element from the
/// collection in Chapters based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Chapter getChapters(int idx)
{
  return (Chapter) ( allChapters()[idx]);
}

private System.Collections.ArrayList aChapterRefs;

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <returns>a collection of all the elements in ChapterRefs</returns>
public System.Collections.ArrayList allChapterRefs()
  {
if (aChapterRefs == null){
    setAllChapterRefs( new System.Collections.ArrayList() );
} // If
    return aChapterRefs;
  }

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <returns>a collection of all the elements in ChapterRefs</returns>
private System.Collections.ArrayList getChapterRefs()
  {
    return allChapterRefs();
  }

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        ChapterRefs's current content.</param>
public void setAllChapterRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapterRefs = coll;
    NotifyControllers(null);
  }
public void setAllChapterRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapterRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <param name="el">a ChapterRef to add to the collection in 
///           ChapterRefs</param>
/// <seealso cref="appendChapterRefs(System.Collections.IList)"/>
public void appendChapterRefs(ChapterRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapterRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendChapterRefs(Lock aLock,ChapterRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapterRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for ChapterRefs</summary>
/// <param name="coll">a collection ofChapterRefs to add to the collection in 
///           ChapterRefs</param>
/// <seealso cref="appendChapterRefs(ChapterRef)"/>
public void appendChapterRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allChapterRefs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendChapterRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allChapterRefs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This insertion function inserts a new element in the
/// collection in ChapterRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertChapterRefs(int idx, ChapterRef el)
  {
  __setDirty(true);
  allChapterRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertChapterRefs(int idx, ChapterRef el,Lock aLock)
  {
  __setDirty(true);
  allChapterRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfChapterRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allChapterRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This deletion function removes an element from the
/// collection in ChapterRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteChapterRefs(int idx)
  {
  __setDirty(true);
  allChapterRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteChapterRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allChapterRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This deletion function removes an element from the
/// collection in ChapterRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeChapterRefs(IXmlBBase obj)
  {
  int idx = indexOfChapterRefs(obj);
  if (idx >= 0) { deleteChapterRefs(idx);
NotifyControllers(null);
   }
  }

public void removeChapterRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfChapterRefs(obj);
  if (idx >= 0) { deleteChapterRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <returns>the number of elements in ChapterRefs</returns>
public int countChapterRefs()
  {
  return allChapterRefs().Count;
  }

/// <summary>Part of the list interface for ChapterRefs
/// This function returns an element from the
/// collection in ChapterRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ChapterRef getChapterRefs(int idx)
{
  return (ChapterRef) ( allChapterRefs()[idx]);
}

public Specification()
{
Specification obj = this;
aVersion=(null);
aChapters=(null);
aChapterRefs=(null);
}

public void copyTo(Specification other)
{
base.copyTo(other);
other.aVersion = aVersion;
other.aChapters = aChapters;
other.aChapterRefs = aChapterRefs;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
Chapter fl1414;
ChapterRef fl1426;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl1414 = null;
while(ctxt.lookAheadOpeningTag ("<Chapter")) {
fl1414 = acceptor.lAccept_Chapter(ctxt, "</Chapter>");
appendChapters(fl1414);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl1426 = null;
while(ctxt.lookAheadOpeningTag ("<ChapterRef")) {
fl1426 = acceptor.lAccept_ChapterRef(ctxt, "</ChapterRef>");
appendChapterRefs(fl1426);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1437;
bool fl1438;
bool fl1439;
bool fl1440;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1437 = false ; 
fl1438 = false ; 
fl1439 = false ; 
fl1440 = true ; 
while (fl1440) { // BeginLoop 
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
if (ctxt.lookAheadString("ersion=")){
indicator = 1437;
} else {
indicator = 1441;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1438;
} else {
indicator = 1441;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1439;
} else {
indicator = 1441;
} // If
break;
} // Case
default:
indicator = 1441;
break;
} // Switch
switch (indicator) {
case 1437: {
// Handling attribute version
// Also handles alien attributes with prefix version
if (fl1437){
ctxt.fail ("Duplicate attribute: version");
} // If
fl1437 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVersion((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1438: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1438){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1438 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1439: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1439){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1439 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1441: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1440 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Specification";
  endingTag = "</Specification>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Specification\"");
} // If
pw.Write('\n');
if (this.getVersion() != null){
pw.Write(" version=\"");
acceptor.unParsePcData(pw, this.getVersion());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getChapters(), false, "<Chapter", "</Chapter>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getChapterRefs(), false, "<ChapterRef", "</ChapterRef>");
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countChapters(); i++) {
  l.Add(getChapters(i));
}
for (int i = 0; i < countChapterRefs(); i++) {
  l.Add(getChapterRefs(i));
}
}

}
public partial class ChapterRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ChapterRefController.alertChange(aLock, this);
}
public ChapterRef()
{
ChapterRef obj = this;
}

public void copyTo(ChapterRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1446;
bool fl1447;
bool fl1448;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1446 = false ; 
fl1447 = false ; 
fl1448 = true ; 
while (fl1448) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1446;
} else {
indicator = 1449;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1447;
} else {
indicator = 1449;
} // If
break;
} // Case
default:
indicator = 1449;
break;
} // Switch
switch (indicator) {
case 1446: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1446){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1446 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1447: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1447){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1447 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1449: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1448 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ChapterRef";
  endingTag = "</ChapterRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ChapterRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Chapter
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getId().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ChapterController.alertChange(aLock, this);
}
private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aParagraphs;

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
public System.Collections.ArrayList allParagraphs()
  {
if (aParagraphs == null){
    setAllParagraphs( new System.Collections.ArrayList() );
} // If
    return aParagraphs;
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
private System.Collections.ArrayList getParagraphs()
  {
    return allParagraphs();
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection of elements which replaces 
///        Paragraphs's current content.</param>
public void setAllParagraphs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
    NotifyControllers(null);
  }
public void setAllParagraphs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="el">a Paragraph to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(System.Collections.IList)"/>
public void appendParagraphs(Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParagraphs(Lock aLock,Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection ofParagraphs to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(Paragraph)"/>
public void appendParagraphs(System.Collections.IList coll)
  {
  __setDirty(true);
  allParagraphs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParagraphs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This insertion function inserts a new element in the
/// collection in Paragraphs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParagraphs(int idx, Paragraph el)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParagraphs(int idx, Paragraph el,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParagraphs(IXmlBBase el)
  {
  return ((System.Collections.IList) allParagraphs()).IndexOf (el);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParagraphs(int idx)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParagraphs(int idx,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParagraphs(IXmlBBase obj)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(null);
   }
  }

public void removeParagraphs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>the number of elements in Paragraphs</returns>
public int countParagraphs()
  {
  return allParagraphs().Count;
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns an element from the
/// collection in Paragraphs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Paragraph getParagraphs(int idx)
{
  return (Paragraph) ( allParagraphs()[idx]);
}

private System.Collections.ArrayList aTypeSpecs;

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
public System.Collections.ArrayList allTypeSpecs()
  {
if (aTypeSpecs == null){
    setAllTypeSpecs( new System.Collections.ArrayList() );
} // If
    return aTypeSpecs;
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
private System.Collections.ArrayList getTypeSpecs()
  {
    return allTypeSpecs();
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection of elements which replaces 
///        TypeSpecs's current content.</param>
public void setAllTypeSpecs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
    NotifyControllers(null);
  }
public void setAllTypeSpecs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="el">a TypeSpec to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(System.Collections.IList)"/>
public void appendTypeSpecs(TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTypeSpecs(Lock aLock,TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection ofTypeSpecs to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(TypeSpec)"/>
public void appendTypeSpecs(System.Collections.IList coll)
  {
  __setDirty(true);
  allTypeSpecs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTypeSpecs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This insertion function inserts a new element in the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTypeSpecs(int idx, TypeSpec el)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTypeSpecs(int idx, TypeSpec el,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTypeSpecs(IXmlBBase el)
  {
  return ((System.Collections.IList) allTypeSpecs()).IndexOf (el);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTypeSpecs(int idx)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTypeSpecs(int idx,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTypeSpecs(IXmlBBase obj)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(null);
   }
  }

public void removeTypeSpecs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>the number of elements in TypeSpecs</returns>
public int countTypeSpecs()
  {
  return allTypeSpecs().Count;
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns an element from the
/// collection in TypeSpecs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public TypeSpec getTypeSpecs(int idx)
{
  return (TypeSpec) ( allTypeSpecs()[idx]);
}

public Chapter()
{
Chapter obj = this;
aId=(null);
aParagraphs=(null);
aTypeSpecs=(null);
}

public void copyTo(Chapter other)
{
base.copyTo(other);
other.aId = aId;
other.aParagraphs = aParagraphs;
other.aTypeSpecs = aTypeSpecs;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
Paragraph fl1454;
TypeSpec fl1466;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl1454 = null;
while(ctxt.lookAheadOpeningTag ("<Paragraph")) {
fl1454 = acceptor.lAccept_Paragraph(ctxt, "</Paragraph>");
appendParagraphs(fl1454);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl1466 = null;
while(ctxt.lookAheadOpeningTag ("<TypeSpec")) {
fl1466 = acceptor.lAccept_TypeSpec(ctxt, null);
appendTypeSpecs(fl1466);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1477;
bool fl1478;
bool fl1479;
bool fl1480;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1477 = false ; 
fl1478 = false ; 
fl1479 = false ; 
fl1480 = true ; 
while (fl1480) { // BeginLoop 
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 1477;
} else {
indicator = 1481;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1478;
} else {
indicator = 1481;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1479;
} else {
indicator = 1481;
} // If
break;
} // Case
default:
indicator = 1481;
break;
} // Switch
switch (indicator) {
case 1477: {
// Handling attribute id
// Also handles alien attributes with prefix id
if (fl1477){
ctxt.fail ("Duplicate attribute: id");
} // If
fl1477 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1478: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1478){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1478 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1479: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1479){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1479 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1481: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1477){
ctxt.fail ("Mandatory attribute missing: id in Chapter");
} // If
fl1480 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Chapter";
  endingTag = "</Chapter>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Chapter\"");
} // If
pw.Write('\n');
pw.Write(" id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParagraphs(), false, "<Paragraph", "</Paragraph>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTypeSpecs(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countParagraphs(); i++) {
  l.Add(getParagraphs(i));
}
for (int i = 0; i < countTypeSpecs(); i++) {
  l.Add(getTypeSpecs(i));
}
}

}
public partial class Paragraph
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
if(getId().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
if(getText().CompareTo((String) search) == 0)return true;
if(getVersion().CompareTo((String) search) == 0)return true;
if(getFunctionalBlockName().CompareTo((String) search) == 0)return true;
if(getObsoleteGuid().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ParagraphController.alertChange(aLock, this);
}
private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.Paragraph_type aType;

public  acceptor.Paragraph_type getType() { return aType;}

public  void setType(acceptor.Paragraph_type v) {
  aType = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getType_AsString()
{
  return acceptor.Enum_Paragraph_type_ToString (aType);
}

public  bool setType_AsString( string  v)
{
 acceptor.Paragraph_type  temp = acceptor.StringTo_Enum_Paragraph_type(v);
if (temp >= 0){
  aType = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.Paragraph_scope aScope;

public  acceptor.Paragraph_scope getScope() { return aScope;}

public  void setScope(acceptor.Paragraph_scope v) {
  aScope = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getScope_AsString()
{
  return acceptor.Enum_Paragraph_scope_ToString (aScope);
}

public  bool setScope_AsString( string  v)
{
 acceptor.Paragraph_scope  temp = acceptor.StringTo_Enum_Paragraph_scope(v);
if (temp >= 0){
  aScope = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  bool aScopeOnBoard;

public  bool getScopeOnBoard() { return aScopeOnBoard;}

public  void setScopeOnBoard(bool v) {
  aScopeOnBoard = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aScopeTrackside;

public  bool getScopeTrackside() { return aScopeTrackside;}

public  void setScopeTrackside(bool v) {
  aScopeTrackside = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aScopeRollingStock;

public  bool getScopeRollingStock() { return aScopeRollingStock;}

public  void setScopeRollingStock(bool v) {
  aScopeRollingStock = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aOptional;

public  bool getOptional() { return aOptional;}

public  void setOptional(bool v) {
  aOptional = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aTypeSpecs;

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
public System.Collections.ArrayList allTypeSpecs()
  {
if (aTypeSpecs == null){
    setAllTypeSpecs( new System.Collections.ArrayList() );
} // If
    return aTypeSpecs;
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
private System.Collections.ArrayList getTypeSpecs()
  {
    return allTypeSpecs();
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection of elements which replaces 
///        TypeSpecs's current content.</param>
public void setAllTypeSpecs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
    NotifyControllers(null);
  }
public void setAllTypeSpecs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="el">a TypeSpec to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(System.Collections.IList)"/>
public void appendTypeSpecs(TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTypeSpecs(Lock aLock,TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection ofTypeSpecs to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(TypeSpec)"/>
public void appendTypeSpecs(System.Collections.IList coll)
  {
  __setDirty(true);
  allTypeSpecs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTypeSpecs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This insertion function inserts a new element in the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTypeSpecs(int idx, TypeSpec el)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTypeSpecs(int idx, TypeSpec el,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTypeSpecs(IXmlBBase el)
  {
  return ((System.Collections.IList) allTypeSpecs()).IndexOf (el);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTypeSpecs(int idx)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTypeSpecs(int idx,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTypeSpecs(IXmlBBase obj)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(null);
   }
  }

public void removeTypeSpecs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>the number of elements in TypeSpecs</returns>
public int countTypeSpecs()
  {
  return allTypeSpecs().Count;
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns an element from the
/// collection in TypeSpecs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public TypeSpec getTypeSpecs(int idx)
{
  return (TypeSpec) ( allTypeSpecs()[idx]);
}

private   string  aText;

public   string  getText() { return aText;}

public  void setText( string  v) {
  aText = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aVersion;

public   string  getVersion() { return aVersion;}

public  void setVersion( string  v) {
  aVersion = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aReviewed;

public  bool getReviewed() { return aReviewed;}

public  void setReviewed(bool v) {
  aReviewed = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.SPEC_IMPLEMENTED_ENUM aImplementationStatus;

public  acceptor.SPEC_IMPLEMENTED_ENUM getImplementationStatus() { return aImplementationStatus;}

public  void setImplementationStatus(acceptor.SPEC_IMPLEMENTED_ENUM v) {
  aImplementationStatus = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getImplementationStatus_AsString()
{
  return acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString (aImplementationStatus);
}

public  bool setImplementationStatus_AsString( string  v)
{
 acceptor.SPEC_IMPLEMENTED_ENUM  temp = acceptor.StringTo_Enum_SPEC_IMPLEMENTED_ENUM(v);
if (temp >= 0){
  aImplementationStatus = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aParagraphs;

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
public System.Collections.ArrayList allParagraphs()
  {
if (aParagraphs == null){
    setAllParagraphs( new System.Collections.ArrayList() );
} // If
    return aParagraphs;
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
private System.Collections.ArrayList getParagraphs()
  {
    return allParagraphs();
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection of elements which replaces 
///        Paragraphs's current content.</param>
public void setAllParagraphs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
    NotifyControllers(null);
  }
public void setAllParagraphs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="el">a Paragraph to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(System.Collections.IList)"/>
public void appendParagraphs(Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParagraphs(Lock aLock,Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection ofParagraphs to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(Paragraph)"/>
public void appendParagraphs(System.Collections.IList coll)
  {
  __setDirty(true);
  allParagraphs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParagraphs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This insertion function inserts a new element in the
/// collection in Paragraphs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParagraphs(int idx, Paragraph el)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParagraphs(int idx, Paragraph el,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParagraphs(IXmlBBase el)
  {
  return ((System.Collections.IList) allParagraphs()).IndexOf (el);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParagraphs(int idx)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParagraphs(int idx,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParagraphs(IXmlBBase obj)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(null);
   }
  }

public void removeParagraphs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>the number of elements in Paragraphs</returns>
public int countParagraphs()
  {
  return allParagraphs().Count;
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns an element from the
/// collection in Paragraphs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Paragraph getParagraphs(int idx)
{
  return (Paragraph) ( allParagraphs()[idx]);
}

private  ParagraphRevision aRevision;

public  ParagraphRevision getRevision() { return aRevision;}

public  void setRevision(ParagraphRevision v) {
  aRevision = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  Message aMessage;

public  Message getMessage() { return aMessage;}

public  void setMessage(Message v) {
  aMessage = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aMoreInfoRequired;

public  bool getMoreInfoRequired() { return aMoreInfoRequired;}

public  void setMoreInfoRequired(bool v) {
  aMoreInfoRequired = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aSpecIssue;

public  bool getSpecIssue() { return aSpecIssue;}

public  void setSpecIssue(bool v) {
  aSpecIssue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aFunctionalBlock;

public  bool getFunctionalBlock() { return aFunctionalBlock;}

public  void setFunctionalBlock(bool v) {
  aFunctionalBlock = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aFunctionalBlockName;

public   string  getFunctionalBlockName() { return aFunctionalBlockName;}

public  void setFunctionalBlockName( string  v) {
  aFunctionalBlockName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aObsoleteGuid;

public   string  getObsoleteGuid() { return aObsoleteGuid;}

public  void setObsoleteGuid( string  v) {
  aObsoleteGuid = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aTested;

public  bool getTested() { return aTested;}

public  void setTested(bool v) {
  aTested = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Paragraph()
{
Paragraph obj = this;
aId=(null);
aType=(0);
aScope=(0);
aScopeOnBoard=(false);
aScopeTrackside=(false);
aScopeRollingStock=(false);
aBl=(null);
aOptional=(false);
aTypeSpecs=(null);
aText=(null);
aVersion=(null);
aReviewed=(false);
aImplementationStatus=(0);
aParagraphs=(null);
aRevision=(null);
aMessage=(null);
aMoreInfoRequired=(false);
aSpecIssue=(false);
aFunctionalBlock=(false);
aFunctionalBlockName=(null);
aObsoleteGuid=(null);
aTested=(false);
}

public void copyTo(Paragraph other)
{
base.copyTo(other);
other.aId = aId;
other.aType = aType;
other.aScope = aScope;
other.aScopeOnBoard = aScopeOnBoard;
other.aScopeTrackside = aScopeTrackside;
other.aScopeRollingStock = aScopeRollingStock;
other.aBl = aBl;
other.aOptional = aOptional;
other.aTypeSpecs = aTypeSpecs;
other.aText = aText;
other.aVersion = aVersion;
other.aReviewed = aReviewed;
other.aImplementationStatus = aImplementationStatus;
other.aParagraphs = aParagraphs;
other.aRevision = aRevision;
other.aMessage = aMessage;
other.aMoreInfoRequired = aMoreInfoRequired;
other.aSpecIssue = aSpecIssue;
other.aFunctionalBlock = aFunctionalBlock;
other.aFunctionalBlockName = aFunctionalBlockName;
other.aObsoleteGuid = aObsoleteGuid;
other.aTested = aTested;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1486;
Paragraph fl1488;
TypeSpec fl1500;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Indicator
// Parse PC data
this.setText(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
// Element Ref : Message
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<Message")){
// Parsing sub element
this.setMessage(acceptor.lAccept_Message(ctxt,null));
setSon(this.getMessage());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Element Ref : ParagraphRevision
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<ParagraphRevision")){
// Parsing sub element
this.setRevision(acceptor.lAccept_ParagraphRevision(ctxt,"</ParagraphRevision>"));
setSon(this.getRevision());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Sub")){
ctxt.skipWhiteSpace();
fl1486 = true ; 
while (fl1486) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1486 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1488 = null;
while(ctxt.lookAheadOpeningTag ("<Paragraph")) {
fl1488 = acceptor.lAccept_Paragraph(ctxt, "</Paragraph>");
appendParagraphs(fl1488);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Sub>");
} // If
} // If
// End enclosed
// Repeat
ctxt.skipWhiteSpace();
fl1500 = null;
while(ctxt.lookAheadOpeningTag ("<TypeSpec")) {
fl1500 = acceptor.lAccept_TypeSpec(ctxt, null);
appendTypeSpecs(fl1500);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1511;
bool fl1512;
bool fl1513;
bool fl1514;
bool fl1515;
bool fl1516;
bool fl1517;
bool fl1518;
bool fl1519;
bool fl1520;
bool fl1521;
bool fl1522;
bool fl1523;
bool fl1524;
bool fl1525;
bool fl1526;
bool fl1527;
bool fl1528;
bool fl1529;
bool fl1530;
bool fl1531;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1511 = false ; 
fl1512 = false ; 
fl1513 = false ; 
fl1514 = false ; 
fl1515 = false ; 
fl1516 = false ; 
fl1517 = false ; 
fl1518 = false ; 
fl1519 = false ; 
fl1520 = false ; 
fl1521 = false ; 
fl1522 = false ; 
fl1523 = false ; 
fl1524 = false ; 
fl1525 = false ; 
fl1526 = false ; 
fl1527 = false ; 
fl1528 = false ; 
fl1529 = false ; 
fl1530 = false ; 
fl1531 = true ; 
while (fl1531) { // BeginLoop 
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
if (ctxt.lookAheadString("ersion=")){
indicator = 1521;
} else {
indicator = 1532;
} // If
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'y':
{
ctxt.advance();
if (ctxt.lookAhead3('p','e','=')){
indicator = 1513;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ackside=")){
indicator = 1527;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("sted=")){
indicator = 1520;
} else {
indicator = 1532;
} // If
break;
} // Case
default:
indicator = 1532;
break;
} // Switch
break;
} // Case
case 's':
{
ctxt.advance();
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAheadString("atus=")){
indicator = 1519;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("ecIssue=")){
indicator = 1523;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("ope=")){
indicator = 1514;
} else {
indicator = 1532;
} // If
break;
} // Case
default:
indicator = 1532;
break;
} // Switch
break;
} // Case
case 'r':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("llinkstock=")){
indicator = 1528;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("viewed=")){
indicator = 1518;
} else {
indicator = 1532;
} // If
break;
} // Case
default:
indicator = 1532;
break;
} // Switch
break;
} // Case
case 'o':
{
ctxt.advance();
switch (ctxt.current()) {
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("tional=")){
indicator = 1516;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("board=")){
indicator = 1526;
} else {
indicator = 1532;
} // If
break;
} // Case
default:
indicator = 1532;
break;
} // Switch
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1517;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("foRequired=")){
indicator = 1522;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'd':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1511;
} else {
indicator = 1532;
} // If
break;
} // Case
default:
indicator = 1532;
break;
} // Switch
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1512;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'f':
{
ctxt.advance();
if (ctxt.lookAheadString("unctionalBlock")){
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1525;
} else {
indicator = 1532;
} // If
break;
} // Case
case '=':
{
ctxt.advance();
indicator = 1524;
break;
} // Case
default:
indicator = 1532;
break;
} // Switch
} else {
indicator = 1532;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1515;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1529;
} else {
indicator = 1532;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1530;
} else {
indicator = 1532;
} // If
break;
} // Case
default:
indicator = 1532;
break;
} // Switch
switch (indicator) {
case 1511: {
// Handling attribute id
// Also handles alien attributes with prefix id
if (fl1511){
ctxt.fail ("Duplicate attribute: id");
} // If
fl1511 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1512: {
// Handling attribute guid
// Also handles alien attributes with prefix guid
if (fl1512){
ctxt.fail ("Duplicate attribute: guid");
} // If
fl1512 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1513: {
// Handling attribute type
// Also handles alien attributes with prefix type
if (fl1513){
ctxt.fail ("Duplicate attribute: type");
} // If
fl1513 = true ; 
quoteChar = ctxt.acceptQuote();
this.setType(acceptor.lAcceptEnum_Paragraph_type(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1514: {
// Handling attribute scope
// Also handles alien attributes with prefix scope
if (fl1514){
ctxt.fail ("Duplicate attribute: scope");
} // If
fl1514 = true ; 
quoteChar = ctxt.acceptQuote();
this.setScope(acceptor.lAcceptEnum_Paragraph_scope(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1515: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1515){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1515 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1516: {
// Handling attribute optional
// Also handles alien attributes with prefix optional
if (fl1516){
ctxt.fail ("Duplicate attribute: optional");
} // If
fl1516 = true ; 
quoteChar = ctxt.acceptQuote();
this.setOptional(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1517: {
// Handling attribute name
// Also handles alien attributes with prefix name
if (fl1517){
ctxt.fail ("Duplicate attribute: name");
} // If
fl1517 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1518: {
// Handling attribute reviewed
// Also handles alien attributes with prefix reviewed
if (fl1518){
ctxt.fail ("Duplicate attribute: reviewed");
} // If
fl1518 = true ; 
quoteChar = ctxt.acceptQuote();
this.setReviewed(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1519: {
// Handling attribute status
// Also handles alien attributes with prefix status
if (fl1519){
ctxt.fail ("Duplicate attribute: status");
} // If
fl1519 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplementationStatus(acceptor.lAcceptEnum_SPEC_IMPLEMENTED_ENUM(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1520: {
// Handling attribute tested
// Also handles alien attributes with prefix tested
if (fl1520){
ctxt.fail ("Duplicate attribute: tested");
} // If
fl1520 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTested(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1521: {
// Handling attribute version
// Also handles alien attributes with prefix version
if (fl1521){
ctxt.fail ("Duplicate attribute: version");
} // If
fl1521 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVersion((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1522: {
// Handling attribute infoRequired
// Also handles alien attributes with prefix infoRequired
if (fl1522){
ctxt.fail ("Duplicate attribute: infoRequired");
} // If
fl1522 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMoreInfoRequired(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1523: {
// Handling attribute specIssue
// Also handles alien attributes with prefix specIssue
if (fl1523){
ctxt.fail ("Duplicate attribute: specIssue");
} // If
fl1523 = true ; 
quoteChar = ctxt.acceptQuote();
this.setSpecIssue(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1524: {
// Handling attribute functionalBlock
// Also handles alien attributes with prefix functionalBlock
if (fl1524){
ctxt.fail ("Duplicate attribute: functionalBlock");
} // If
fl1524 = true ; 
quoteChar = ctxt.acceptQuote();
this.setFunctionalBlock(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1525: {
// Handling attribute functionalBlockName
// Also handles alien attributes with prefix functionalBlockName
if (fl1525){
ctxt.fail ("Duplicate attribute: functionalBlockName");
} // If
fl1525 = true ; 
quoteChar = ctxt.acceptQuote();
this.setFunctionalBlockName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1526: {
// Handling attribute onboard
// Also handles alien attributes with prefix onboard
if (fl1526){
ctxt.fail ("Duplicate attribute: onboard");
} // If
fl1526 = true ; 
quoteChar = ctxt.acceptQuote();
this.setScopeOnBoard(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1527: {
// Handling attribute trackside
// Also handles alien attributes with prefix trackside
if (fl1527){
ctxt.fail ("Duplicate attribute: trackside");
} // If
fl1527 = true ; 
quoteChar = ctxt.acceptQuote();
this.setScopeTrackside(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1528: {
// Handling attribute rollinkstock
// Also handles alien attributes with prefix rollinkstock
if (fl1528){
ctxt.fail ("Duplicate attribute: rollinkstock");
} // If
fl1528 = true ; 
quoteChar = ctxt.acceptQuote();
this.setScopeRollingStock(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1529: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1529){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1529 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1530: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1530){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1530 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1532: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1511){
ctxt.fail ("Mandatory attribute missing: id in Paragraph");
} // If
if (!fl1512){
this.setObsoleteGuid("");
} // If
if (!fl1513){
this.setType(acceptor.Paragraph_type.aREQUIREMENT);
} // If
if (!fl1514){
this.setScope(acceptor.Paragraph_scope.aOBU_AND_TRACK);
} // If
if (!fl1515){
this.setBl("");
} // If
if (!fl1516){
this.setOptional( true);
} // If
if (!fl1517){
this.setName("");
} // If
if (!fl1518){
this.setReviewed( false);
} // If
if (!fl1519){
this.setImplementationStatus(acceptor.SPEC_IMPLEMENTED_ENUM.Impl_NA);
} // If
if (!fl1520){
this.setTested( false);
} // If
if (!fl1521){
this.setVersion("3.0.0");
} // If
if (!fl1522){
this.setMoreInfoRequired( false);
} // If
if (!fl1523){
this.setSpecIssue( false);
} // If
if (!fl1524){
this.setFunctionalBlock( false);
} // If
if (!fl1525){
this.setFunctionalBlockName("");
} // If
if (!fl1526){
this.setScopeOnBoard( false);
} // If
if (!fl1527){
this.setScopeTrackside( false);
} // If
if (!fl1528){
this.setScopeRollingStock( false);
} // If
fl1531 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Paragraph";
  endingTag = "</Paragraph>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Paragraph\"");
} // If
pw.Write('\n');
pw.Write(" id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
if (this.getObsoleteGuid() != null){
pw.Write(" guid=\"");
acceptor.unParsePcData(pw, this.getObsoleteGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getType() != 0){
pw.Write(" type=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_Paragraph_type_ToString(this.getType()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getScope() != 0){
pw.Write(" scope=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_Paragraph_scope_ToString(this.getScope()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getOptional()){
pw.Write(" optional=\"");
acceptor.unParsePcData(pw, this.getOptional());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getReviewed()){
pw.Write(" reviewed=\"");
acceptor.unParsePcData(pw, this.getReviewed());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplementationStatus() != 0){
pw.Write(" status=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString(this.getImplementationStatus()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getTested()){
pw.Write(" tested=\"");
acceptor.unParsePcData(pw, this.getTested());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVersion() != null){
pw.Write(" version=\"");
acceptor.unParsePcData(pw, this.getVersion());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMoreInfoRequired()){
pw.Write(" infoRequired=\"");
acceptor.unParsePcData(pw, this.getMoreInfoRequired());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getSpecIssue()){
pw.Write(" specIssue=\"");
acceptor.unParsePcData(pw, this.getSpecIssue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getFunctionalBlock()){
pw.Write(" functionalBlock=\"");
acceptor.unParsePcData(pw, this.getFunctionalBlock());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getFunctionalBlockName() != null){
pw.Write(" functionalBlockName=\"");
acceptor.unParsePcData(pw, this.getFunctionalBlockName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getScopeOnBoard()){
pw.Write(" onboard=\"");
acceptor.unParsePcData(pw, this.getScopeOnBoard());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getScopeTrackside()){
pw.Write(" trackside=\"");
acceptor.unParsePcData(pw, this.getScopeTrackside());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getScopeRollingStock()){
pw.Write(" rollinkstock=\"");
acceptor.unParsePcData(pw, this.getScopeRollingStock());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing PcData
acceptor.unParsePcData(pw, this.getText());
// Unparsing ElementRef
if (this.getMessage() != null){
unParse(pw, this.getMessage(), false, null, null);
} // If
// Unparsing ElementRef
if (this.getRevision() != null){
unParse(pw, this.getRevision(),false,"<ParagraphRevision","</ParagraphRevision>");
} // If
// Unparsing Enclosed
// Testing for empty content: Paragraphs
if (countParagraphs() > 0){
pw.Write("<Sub>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParagraphs(), false, "<Paragraph", "</Paragraph>");
pw.Write("</Sub>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Paragraphs
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTypeSpecs(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countTypeSpecs(); i++) {
  l.Add(getTypeSpecs(i));
}
for (int i = 0; i < countParagraphs(); i++) {
  l.Add(getParagraphs(i));
}
l.Add(this.getRevision());
l.Add(this.getMessage());
}

}
public partial class Message
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getDescription().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.MessageController.alertChange(aLock, this);
}
private   string  aDescription;

public   string  getDescription() { return aDescription;}

public  void setDescription( string  v) {
  aDescription = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.Message_media aMedia;

public  acceptor.Message_media getMedia() { return aMedia;}

public  void setMedia(acceptor.Message_media v) {
  aMedia = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMedia_AsString()
{
  return acceptor.Enum_Message_media_ToString (aMedia);
}

public  bool setMedia_AsString( string  v)
{
 acceptor.Message_media  temp = acceptor.StringTo_Enum_Message_media(v);
if (temp >= 0){
  aMedia = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aMsgVariables;

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
public System.Collections.ArrayList allMsgVariables()
  {
if (aMsgVariables == null){
    setAllMsgVariables( new System.Collections.ArrayList() );
} // If
    return aMsgVariables;
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
private System.Collections.ArrayList getMsgVariables()
  {
    return allMsgVariables();
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection of elements which replaces 
///        MsgVariables's current content.</param>
public void setAllMsgVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
    NotifyControllers(null);
  }
public void setAllMsgVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="el">a MsgVariable to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(System.Collections.IList)"/>
public void appendMsgVariables(MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendMsgVariables(Lock aLock,MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection ofMsgVariables to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(MsgVariable)"/>
public void appendMsgVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allMsgVariables().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendMsgVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This insertion function inserts a new element in the
/// collection in MsgVariables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertMsgVariables(int idx, MsgVariable el)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertMsgVariables(int idx, MsgVariable el,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfMsgVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allMsgVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteMsgVariables(int idx)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteMsgVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeMsgVariables(IXmlBBase obj)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(null);
   }
  }

public void removeMsgVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>the number of elements in MsgVariables</returns>
public int countMsgVariables()
  {
  return allMsgVariables().Count;
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns an element from the
/// collection in MsgVariables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public MsgVariable getMsgVariables(int idx)
{
  return (MsgVariable) ( allMsgVariables()[idx]);
}

public Message()
{
Message obj = this;
aDescription=(null);
aMedia=(0);
aBl=(null);
aMsgVariables=(null);
}

public void copyTo(Message other)
{
other.aDescription = aDescription;
other.aMedia = aMedia;
other.aBl = aBl;
other.aMsgVariables = aMsgVariables;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
MsgVariable fl1561;

ctxt.skipWhiteSpace();
// Repeat
ctxt.skipWhiteSpace();
fl1561 = null;
while(ctxt.lookAheadOpeningTag ("<MsgVariable")) {
fl1561 = acceptor.lAccept_MsgVariable(ctxt, null);
appendMsgVariables(fl1561);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1572;
bool fl1573;
bool fl1574;
bool fl1575;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1572 = false ; 
fl1573 = false ; 
fl1574 = false ; 
fl1575 = true ; 
while (fl1575) { // BeginLoop 
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("edia=")){
indicator = 1573;
} else {
indicator = 1576;
} // If
break;
} // Case
case 'd':
{
ctxt.advance();
if (ctxt.lookAheadString("escription=")){
indicator = 1572;
} else {
indicator = 1576;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1574;
} else {
indicator = 1576;
} // If
break;
} // Case
default:
indicator = 1576;
break;
} // Switch
switch (indicator) {
case 1572: {
// Handling attribute description
// Also handles alien attributes with prefix description
if (fl1572){
ctxt.fail ("Duplicate attribute: description");
} // If
fl1572 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDescription((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1573: {
// Handling attribute media
// Also handles alien attributes with prefix media
if (fl1573){
ctxt.fail ("Duplicate attribute: media");
} // If
fl1573 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMedia(acceptor.lAcceptEnum_Message_media(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1574: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1574){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1574 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1576: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1572){
ctxt.fail ("Mandatory attribute missing: description in Message");
} // If
if (!fl1573){
ctxt.fail ("Mandatory attribute missing: media in Message");
} // If
fl1575 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</Message>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<Message");
if (typeId){
pw.Write(" xsi:type=\"Message\"");
} // If
pw.Write('\n');
pw.Write(" description=\"");
acceptor.unParsePcData(pw, this.getDescription());
pw.Write('"');
pw.Write('\n');
pw.Write(" media=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_Message_media_ToString(this.getMedia()));
pw.Write('"');
pw.Write('\n');
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</Message>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getMsgVariables(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
for (int i = 0; i < countMsgVariables(); i++) {
  l.Add(getMsgVariables(i));
}
}

}
public partial class MsgVariable
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getName().CompareTo((String) search) == 0)return true;
if(getLength().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.MsgVariableController.alertChange(aLock, this);
}
private   string  aName;

public   string  getName() { return aName;}

public  void setName( string  v) {
  aName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aLength;

public   string  getLength() { return aLength;}

public  void setLength( string  v) {
  aLength = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aMsgVariables;

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
public System.Collections.ArrayList allMsgVariables()
  {
if (aMsgVariables == null){
    setAllMsgVariables( new System.Collections.ArrayList() );
} // If
    return aMsgVariables;
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
private System.Collections.ArrayList getMsgVariables()
  {
    return allMsgVariables();
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection of elements which replaces 
///        MsgVariables's current content.</param>
public void setAllMsgVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
    NotifyControllers(null);
  }
public void setAllMsgVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="el">a MsgVariable to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(System.Collections.IList)"/>
public void appendMsgVariables(MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendMsgVariables(Lock aLock,MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection ofMsgVariables to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(MsgVariable)"/>
public void appendMsgVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allMsgVariables().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendMsgVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This insertion function inserts a new element in the
/// collection in MsgVariables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertMsgVariables(int idx, MsgVariable el)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertMsgVariables(int idx, MsgVariable el,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfMsgVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allMsgVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteMsgVariables(int idx)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteMsgVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeMsgVariables(IXmlBBase obj)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(null);
   }
  }

public void removeMsgVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>the number of elements in MsgVariables</returns>
public int countMsgVariables()
  {
  return allMsgVariables().Count;
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns an element from the
/// collection in MsgVariables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public MsgVariable getMsgVariables(int idx)
{
  return (MsgVariable) ( allMsgVariables()[idx]);
}

public MsgVariable()
{
MsgVariable obj = this;
aName=(null);
aLength=(null);
aComment=(null);
aBl=(null);
aMsgVariables=(null);
}

public void copyTo(MsgVariable other)
{
other.aName = aName;
other.aLength = aLength;
other.aComment = aComment;
other.aBl = aBl;
other.aMsgVariables = aMsgVariables;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
MsgVariable fl1582;

ctxt.skipWhiteSpace();
// Repeat
ctxt.skipWhiteSpace();
fl1582 = null;
while(ctxt.lookAheadOpeningTag ("<MsgVariable")) {
fl1582 = acceptor.lAccept_MsgVariable(ctxt, null);
appendMsgVariables(fl1582);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1593;
bool fl1594;
bool fl1595;
bool fl1596;
bool fl1597;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1593 = false ; 
fl1594 = false ; 
fl1595 = false ; 
fl1596 = false ; 
fl1597 = true ; 
while (fl1597) { // BeginLoop 
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1593;
} else {
indicator = 1598;
} // If
break;
} // Case
case 'l':
{
ctxt.advance();
if (ctxt.lookAheadString("ength=")){
indicator = 1594;
} else {
indicator = 1598;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("omment=")){
indicator = 1595;
} else {
indicator = 1598;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1596;
} else {
indicator = 1598;
} // If
break;
} // Case
default:
indicator = 1598;
break;
} // Switch
switch (indicator) {
case 1593: {
// Handling attribute name
// Also handles alien attributes with prefix name
if (fl1593){
ctxt.fail ("Duplicate attribute: name");
} // If
fl1593 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1594: {
// Handling attribute length
// Also handles alien attributes with prefix length
if (fl1594){
ctxt.fail ("Duplicate attribute: length");
} // If
fl1594 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLength((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1595: {
// Handling attribute comment
// Also handles alien attributes with prefix comment
if (fl1595){
ctxt.fail ("Duplicate attribute: comment");
} // If
fl1595 = true ; 
quoteChar = ctxt.acceptQuote();
this.setComment((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1596: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1596){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1596 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1598: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1593){
ctxt.fail ("Mandatory attribute missing: name in MsgVariable");
} // If
if (!fl1595){
ctxt.fail ("Mandatory attribute missing: comment in MsgVariable");
} // If
fl1597 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</MsgVariable>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<MsgVariable");
if (typeId){
pw.Write(" xsi:type=\"MsgVariable\"");
} // If
pw.Write('\n');
pw.Write(" name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
if (this.getLength() != null){
pw.Write(" length=\"");
acceptor.unParsePcData(pw, this.getLength());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write(" comment=\"");
acceptor.unParsePcData(pw, this.getComment());
pw.Write('"');
pw.Write('\n');
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</MsgVariable>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getMsgVariables(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
for (int i = 0; i < countMsgVariables(); i++) {
  l.Add(getMsgVariables(i));
}
}

}
public partial class TypeSpec
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getMinimum_value().CompareTo((String) search) == 0)return true;
if(getMaximum_value().CompareTo((String) search) == 0)return true;
if(getResolution_formula().CompareTo((String) search) == 0)return true;
if(getId().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
if(getDescription().CompareTo((String) search) == 0)return true;
if(getShort_description().CompareTo((String) search) == 0)return true;
if(getReference().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TypeSpecController.alertChange(aLock, this);
}
private  int aLength;

public  int getLength() { return aLength;}

public  void setLength(int v) {
  aLength = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMinimum_value;

public   string  getMinimum_value() { return aMinimum_value;}

public  void setMinimum_value( string  v) {
  aMinimum_value = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMaximum_value;

public   string  getMaximum_value() { return aMaximum_value;}

public  void setMaximum_value( string  v) {
  aMaximum_value = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aResolution_formula;

public   string  getResolution_formula() { return aResolution_formula;}

public  void setResolution_formula( string  v) {
  aResolution_formula = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.TypeSpec_ertms_type aErtms_type;

public  acceptor.TypeSpec_ertms_type getErtms_type() { return aErtms_type;}

public  void setErtms_type(acceptor.TypeSpec_ertms_type v) {
  aErtms_type = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getErtms_type_AsString()
{
  return acceptor.Enum_TypeSpec_ertms_type_ToString (aErtms_type);
}

public  bool setErtms_type_AsString( string  v)
{
 acceptor.TypeSpec_ertms_type  temp = acceptor.StringTo_Enum_TypeSpec_ertms_type(v);
if (temp >= 0){
  aErtms_type = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  Values aValues;

public  Values getValues() { return aValues;}

public  void setValues(Values v) {
  aValues = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  char_value aChar_value;

public  char_value getChar_value() { return aChar_value;}

public  void setChar_value(char_value v) {
  aChar_value = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDescription;

public   string  getDescription() { return aDescription;}

public  void setDescription( string  v) {
  aDescription = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aShort_description;

public   string  getShort_description() { return aShort_description;}

public  void setShort_description( string  v) {
  aShort_description = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aReference;

public   string  getReference() { return aReference;}

public  void setReference( string  v) {
  aReference = v;
  __setDirty(true);
  NotifyControllers(null);
}


public TypeSpec()
{
TypeSpec obj = this;
aLength=(0);
aMinimum_value=(null);
aMaximum_value=(null);
aResolution_formula=(null);
aId=(null);
aErtms_type=(0);
aBl=(null);
aValues=(null);
aChar_value=(null);
aDescription=(null);
aShort_description=(null);
aReference=(null);
}

public void copyTo(TypeSpec other)
{
other.aLength = aLength;
other.aMinimum_value = aMinimum_value;
other.aMaximum_value = aMaximum_value;
other.aResolution_formula = aResolution_formula;
other.aId = aId;
other.aErtms_type = aErtms_type;
other.aBl = aBl;
other.aValues = aValues;
other.aChar_value = aChar_value;
other.aDescription = aDescription;
other.aShort_description = aShort_description;
other.aReference = aReference;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1604;
bool fl1605;
bool fl1606;
int fl1609;

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<short-description")){
ctxt.skipWhiteSpace();
fl1604 = true ; 
while (fl1604) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1604 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setShort_description(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</short-description>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Description")){
ctxt.skipWhiteSpace();
fl1605 = true ; 
while (fl1605) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1605 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Indicator
// Parse PC data
this.setDescription(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Description>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<reference")){
ctxt.skipWhiteSpace();
fl1606 = true ; 
while (fl1606) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1606 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setReference(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</reference>");
} // If
// End enclosed
// Disjunct
ctxt.skipWhiteSpace();
// Nullable formula
fl1609 = ctxt.getPtr();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
switch (ctxt.current()) {
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("har-value")){
indicator = 1608;
} else {
ctxt.moveBack(1);
indicator = 1610;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alues")){
indicator = 1607;
} else {
ctxt.moveBack(1);
indicator = 1610;
} // If
break;
} // Case
default:
indicator = 1610;
break;
} // Switch
break;
} // Case
default:
indicator = 1610;
break;
} // Switch
switch (indicator) {
// Dispatch Lablel
case 1607: {
ctxt.moveBack(7);
// Element Ref : Values
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<Values")){
// Parsing sub element
this.setValues(acceptor.lAccept_Values(ctxt,null));
setSon(this.getValues());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Dispatch Lablel
case 1608: {
ctxt.moveBack(11);
// Element Ref : char-value
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<char-value")){
// Parsing sub element
this.setChar_value(acceptor.lAccept_char_value(ctxt,null));
setSon(this.getChar_value());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Optional of PCdata
case 1610: {
ctxt.setPtr(fl1609);
// Doing nothing, optional disj
break;
} // End of dispatch label
} // Dispatch
// End Disjunct
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1615;
bool fl1616;
bool fl1617;
bool fl1618;
bool fl1619;
bool fl1620;
bool fl1621;
bool fl1622;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1615 = false ; 
fl1616 = false ; 
fl1617 = false ; 
fl1618 = false ; 
fl1619 = false ; 
fl1620 = false ; 
fl1621 = false ; 
fl1622 = true ; 
while (fl1622) { // BeginLoop 
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("esolution_formula=")){
indicator = 1618;
} else {
indicator = 1623;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nimum_value=")){
indicator = 1616;
} else {
indicator = 1623;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("ximum_value=")){
indicator = 1617;
} else {
indicator = 1623;
} // If
break;
} // Case
default:
indicator = 1623;
break;
} // Switch
break;
} // Case
case 'l':
{
ctxt.advance();
if (ctxt.lookAheadString("ength=")){
indicator = 1615;
} else {
indicator = 1623;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 1619;
} else {
indicator = 1623;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("rtms-type=")){
indicator = 1620;
} else {
indicator = 1623;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1621;
} else {
indicator = 1623;
} // If
break;
} // Case
default:
indicator = 1623;
break;
} // Switch
switch (indicator) {
case 1615: {
// Handling attribute length
// Also handles alien attributes with prefix length
if (fl1615){
ctxt.fail ("Duplicate attribute: length");
} // If
fl1615 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLength(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1616: {
// Handling attribute minimum_value
// Also handles alien attributes with prefix minimum_value
if (fl1616){
ctxt.fail ("Duplicate attribute: minimum_value");
} // If
fl1616 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMinimum_value((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1617: {
// Handling attribute maximum_value
// Also handles alien attributes with prefix maximum_value
if (fl1617){
ctxt.fail ("Duplicate attribute: maximum_value");
} // If
fl1617 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMaximum_value((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1618: {
// Handling attribute resolution_formula
// Also handles alien attributes with prefix resolution_formula
if (fl1618){
ctxt.fail ("Duplicate attribute: resolution_formula");
} // If
fl1618 = true ; 
quoteChar = ctxt.acceptQuote();
this.setResolution_formula((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1619: {
// Handling attribute id
// Also handles alien attributes with prefix id
if (fl1619){
ctxt.fail ("Duplicate attribute: id");
} // If
fl1619 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1620: {
// Handling attribute ertms-type
// Also handles alien attributes with prefix ertms-type
if (fl1620){
ctxt.fail ("Duplicate attribute: ertms-type");
} // If
fl1620 = true ; 
quoteChar = ctxt.acceptQuote();
this.setErtms_type(acceptor.lAcceptEnum_TypeSpec_ertms_type(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1621: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1621){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1621 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1623: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1615){
ctxt.fail ("Mandatory attribute missing: length in TypeSpec");
} // If
fl1622 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</TypeSpec>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<TypeSpec");
if (typeId){
pw.Write(" xsi:type=\"TypeSpec\"");
} // If
pw.Write('\n');
pw.Write(" length=\"");
acceptor.unParsePcData(pw, this.getLength());
pw.Write('"');
pw.Write('\n');
if (this.getMinimum_value() != null){
pw.Write(" minimum_value=\"");
acceptor.unParsePcData(pw, this.getMinimum_value());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMaximum_value() != null){
pw.Write(" maximum_value=\"");
acceptor.unParsePcData(pw, this.getMaximum_value());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getResolution_formula() != null){
pw.Write(" resolution_formula=\"");
acceptor.unParsePcData(pw, this.getResolution_formula());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getId() != null){
pw.Write(" id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getErtms_type() != 0){
pw.Write(" ertms-type=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_TypeSpec_ertms_type_ToString(this.getErtms_type()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</TypeSpec>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Enclosed
// Testing for empty content: Short-description
if (this.getShort_description() != null){
pw.Write("<short-description>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getShort_description());
pw.Write("</short-description>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Short-description
// Unparsing Enclosed
// Testing for empty content: Description
if (this.getDescription() != null){
pw.Write("<Description>");
// Unparsing PcData
if (this.getDescription() != null){
acceptor.unParsePcData(pw, this.getDescription());
} // If
pw.Write("</Description>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Description
// Unparsing Enclosed
// Testing for empty content: Reference
if (this.getReference() != null){
pw.Write("<reference>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getReference());
pw.Write("</reference>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Reference
// Unparsing Disjunct
if (this.getValues() != null){
// Unparsing ElementRef
if (this.getValues() != null){
unParse(pw, this.getValues(), false, null, null);
} // If
} else {
if (this.getChar_value() != null){
// Unparsing ElementRef
if (this.getChar_value() != null){
unParse(pw, this.getChar_value(), false, null, null);
} // If
} // If
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
l.Add(this.getValues());
l.Add(this.getChar_value());
}

}
public partial class Values
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ValuesController.alertChange(aLock, this);
}
private  resolution_formula aResolution_formula_1;

public  resolution_formula getResolution_formula_1() { return aResolution_formula_1;}

public  void setResolution_formula_1(resolution_formula v) {
  aResolution_formula_1 = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  special_or_reserved_values aSpecial_or_reserved_values;

public  special_or_reserved_values getSpecial_or_reserved_values() { return aSpecial_or_reserved_values;}

public  void setSpecial_or_reserved_values(special_or_reserved_values v) {
  aSpecial_or_reserved_values = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  special_or_reserved_value aSpecial_or_reserved_value;

public  special_or_reserved_value getSpecial_or_reserved_value() { return aSpecial_or_reserved_value;}

public  void setSpecial_or_reserved_value(special_or_reserved_value v) {
  aSpecial_or_reserved_value = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


public Values()
{
Values obj = this;
aResolution_formula_1=(null);
aSpecial_or_reserved_values=(null);
aSpecial_or_reserved_value=(null);
}

public void copyTo(Values other)
{
other.aResolution_formula_1 = aResolution_formula_1;
other.aSpecial_or_reserved_values = aSpecial_or_reserved_values;
other.aSpecial_or_reserved_value = aSpecial_or_reserved_value;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
int fl1635;

ctxt.skipWhiteSpace();
// Element Ref : resolution-formula
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<resolution-formula")){
// Parsing sub element
this.setResolution_formula_1(acceptor.lAccept_resolution_formula(ctxt,null));
setSon(this.getResolution_formula_1());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Disjunct
ctxt.skipWhiteSpace();
// Nullable formula
fl1635 = ctxt.getPtr();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
if (ctxt.lookAheadString("special-or-reserved-value")){
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
indicator = 1633;
break;
} // Case
default:
indicator = 1634;
break;
} // Switch
} else {
ctxt.moveBack(1);
indicator = 1636;
} // If
break;
} // Case
default:
indicator = 1636;
break;
} // Switch
switch (indicator) {
// Dispatch Lablel
case 1633: {
ctxt.moveBack(27);
// Element Ref : special-or-reserved-values
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<special-or-reserved-values")){
// Parsing sub element
this.setSpecial_or_reserved_values(acceptor.lAccept_special_or_reserved_values(ctxt,null));
setSon(this.getSpecial_or_reserved_values());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Dispatch Lablel
case 1634: {
ctxt.moveBack(26);
// Element Ref : special-or-reserved-value
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<special-or-reserved-value")){
// Parsing sub element
this.setSpecial_or_reserved_value(acceptor.lAccept_special_or_reserved_value(ctxt,null));
setSon(this.getSpecial_or_reserved_value());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Optional of PCdata
case 1636: {
ctxt.setPtr(fl1635);
// Doing nothing, optional disj
break;
} // End of dispatch label
} // Dispatch
// End Disjunct
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1640;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1640 = true ; 
while (fl1640) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1640 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</Values>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<Values");
if (typeId){
pw.Write(" xsi:type=\"Values\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</Values>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing ElementRef
if (this.getResolution_formula_1() != null){
unParse(pw, this.getResolution_formula_1(), false, null, null);
} // If
// Unparsing Disjunct
if (this.getSpecial_or_reserved_values() != null){
// Unparsing ElementRef
if (this.getSpecial_or_reserved_values() != null){
unParse(pw, this.getSpecial_or_reserved_values(), false, null, null);
} // If
} else {
if (this.getSpecial_or_reserved_value() != null){
// Unparsing ElementRef
if (this.getSpecial_or_reserved_value() != null){
unParse(pw, this.getSpecial_or_reserved_value(), false, null, null);
} // If
} // If
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
l.Add(this.getResolution_formula_1());
l.Add(this.getSpecial_or_reserved_values());
l.Add(this.getSpecial_or_reserved_value());
}

}
public partial class special_or_reserved_values
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.special_or_reserved_valuesController.alertChange(aLock, this);
}
private System.Collections.ArrayList aSpecial_or_reserved_values;

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <returns>a collection of all the elements in Special_or_reserved_values</returns>
public System.Collections.ArrayList allSpecial_or_reserved_values()
  {
if (aSpecial_or_reserved_values == null){
    setAllSpecial_or_reserved_values( new System.Collections.ArrayList() );
} // If
    return aSpecial_or_reserved_values;
  }

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <returns>a collection of all the elements in Special_or_reserved_values</returns>
private System.Collections.ArrayList getSpecial_or_reserved_values()
  {
    return allSpecial_or_reserved_values();
  }

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <param name="coll">a collection of elements which replaces 
///        Special_or_reserved_values's current content.</param>
public void setAllSpecial_or_reserved_values(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecial_or_reserved_values = coll;
    NotifyControllers(null);
  }
public void setAllSpecial_or_reserved_values(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecial_or_reserved_values = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <param name="el">a special_or_reserved_value to add to the collection in 
///           Special_or_reserved_values</param>
/// <seealso cref="appendSpecial_or_reserved_values(System.Collections.IList)"/>
public void appendSpecial_or_reserved_values(special_or_reserved_value el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecial_or_reserved_values().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSpecial_or_reserved_values(Lock aLock,special_or_reserved_value el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecial_or_reserved_values().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <param name="coll">a collection ofspecial_or_reserved_values to add to the collection in 
///           Special_or_reserved_values</param>
/// <seealso cref="appendSpecial_or_reserved_values(special_or_reserved_value)"/>
public void appendSpecial_or_reserved_values(System.Collections.IList coll)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSpecial_or_reserved_values(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().AddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This insertion function inserts a new element in the
/// collection in Special_or_reserved_values</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSpecial_or_reserved_values(int idx, special_or_reserved_value el)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSpecial_or_reserved_values(int idx, special_or_reserved_value el,Lock aLock)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSpecial_or_reserved_values(IXmlBBase el)
  {
  return ((System.Collections.IList) allSpecial_or_reserved_values()).IndexOf (el);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This deletion function removes an element from the
/// collection in Special_or_reserved_values</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSpecial_or_reserved_values(int idx)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSpecial_or_reserved_values(int idx,Lock aLock)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This deletion function removes an element from the
/// collection in Special_or_reserved_values
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSpecial_or_reserved_values(IXmlBBase obj)
  {
  int idx = indexOfSpecial_or_reserved_values(obj);
  if (idx >= 0) { deleteSpecial_or_reserved_values(idx);
NotifyControllers(null);
   }
  }

public void removeSpecial_or_reserved_values(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSpecial_or_reserved_values(obj);
  if (idx >= 0) { deleteSpecial_or_reserved_values(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <returns>the number of elements in Special_or_reserved_values</returns>
public int countSpecial_or_reserved_values()
  {
  return allSpecial_or_reserved_values().Count;
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This function returns an element from the
/// collection in Special_or_reserved_values based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public special_or_reserved_value getSpecial_or_reserved_values(int idx)
{
  return (special_or_reserved_value) ( allSpecial_or_reserved_values()[idx]);
}

public special_or_reserved_values()
{
special_or_reserved_values obj = this;
aSpecial_or_reserved_values=(null);
}

public void copyTo(special_or_reserved_values other)
{
other.aSpecial_or_reserved_values = aSpecial_or_reserved_values;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
special_or_reserved_value fl1642;

ctxt.skipWhiteSpace();
// Repeat
ctxt.skipWhiteSpace();
fl1642 = null;
while(ctxt.lookAheadOpeningTag ("<special-or-reserved-value")) {
fl1642 = acceptor.lAccept_special_or_reserved_value(ctxt, null);
appendSpecial_or_reserved_values(fl1642);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
if (fl1642 == null){
ctxt.fail ("At least one element expected in repetition");
} // If
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1653;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1653 = true ; 
while (fl1653) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1653 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</special-or-reserved-values>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<special-or-reserved-values");
if (typeId){
pw.Write(" xsi:type=\"special-or-reserved-values\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</special-or-reserved-values>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSpecial_or_reserved_values(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
for (int i = 0; i < countSpecial_or_reserved_values(); i++) {
  l.Add(getSpecial_or_reserved_values(i));
}
}

}
public partial class special_or_reserved_value
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.special_or_reserved_valueController.alertChange(aLock, this);
}
private  mask aMask;

public  mask getMask() { return aMask;}

public  void setMask(mask v) {
  aMask = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  match aMatch;

public  match getMatch() { return aMatch;}

public  void setMatch(match v) {
  aMatch = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  match_range aMatch_range;

public  match_range getMatch_range() { return aMatch_range;}

public  void setMatch_range(match_range v) {
  aMatch_range = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  meaning aMeaning;

public  meaning getMeaning() { return aMeaning;}

public  void setMeaning(meaning v) {
  aMeaning = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  value aValue;

public  value getValue() { return aValue;}

public  void setValue(value v) {
  aValue = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


public special_or_reserved_value()
{
special_or_reserved_value obj = this;
aMask=(null);
aMatch=(null);
aMatch_range=(null);
aMeaning=(null);
aValue=(null);
}

public void copyTo(special_or_reserved_value other)
{
other.aMask = aMask;
other.aMatch = aMatch;
other.aMatch_range = aMatch_range;
other.aMeaning = aMeaning;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
int fl1656;

ctxt.skipWhiteSpace();
// Element Ref : mask
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<mask")){
// Parsing sub element
this.setMask(acceptor.lAccept_mask(ctxt,null));
setSon(this.getMask());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Disjunct
ctxt.skipWhiteSpace();
// Nullable formula
fl1656 = ctxt.getPtr();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
if (ctxt.lookAheadString("match")){
switch (ctxt.current()) {
case '-':
{
ctxt.advance();
if (ctxt.lookAheadString("range")){
indicator = 1655;
} else {
ctxt.moveBack(1);
indicator = 1654;
} // If
break;
} // Case
default:
indicator = 1654;
break;
} // Switch
} else {
ctxt.moveBack(1);
indicator = 1657;
} // If
break;
} // Case
default:
indicator = 1657;
break;
} // Switch
switch (indicator) {
// Dispatch Lablel
case 1654: {
ctxt.moveBack(6);
// Element Ref : match
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<match")){
// Parsing sub element
this.setMatch(acceptor.lAccept_match(ctxt,null));
setSon(this.getMatch());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Dispatch Lablel
case 1655: {
ctxt.moveBack(12);
// Element Ref : match-range
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<match-range")){
// Parsing sub element
this.setMatch_range(acceptor.lAccept_match_range(ctxt,null));
setSon(this.getMatch_range());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Optional of PCdata
case 1657: {
ctxt.setPtr(fl1656);
// Doing nothing, optional disj
break;
} // End of dispatch label
} // Dispatch
// End Disjunct
// Element Ref : meaning
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<meaning")){
// Parsing sub element
this.setMeaning(acceptor.lAccept_meaning(ctxt,null));
setSon(this.getMeaning());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Element Ref : value
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<value")){
// Parsing sub element
this.setValue(acceptor.lAccept_value(ctxt,null));
setSon(this.getValue());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1661;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1661 = true ; 
while (fl1661) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1661 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</special-or-reserved-value>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<special-or-reserved-value");
if (typeId){
pw.Write(" xsi:type=\"special-or-reserved-value\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</special-or-reserved-value>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing ElementRef
if (this.getMask() != null){
unParse(pw, this.getMask(), false, null, null);
} // If
// Unparsing Disjunct
if (this.getMatch() != null){
// Unparsing ElementRef
if (this.getMatch() != null){
unParse(pw, this.getMatch(), false, null, null);
} // If
} else {
if (this.getMatch_range() != null){
// Unparsing ElementRef
if (this.getMatch_range() != null){
unParse(pw, this.getMatch_range(), false, null, null);
} // If
} // If
} // If
// Unparsing ElementRef
if (this.getMeaning() != null){
unParse(pw, this.getMeaning(), false, null, null);
} // If
// Unparsing ElementRef
if (this.getValue() != null){
unParse(pw, this.getValue(), false, null, null);
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
l.Add(this.getMask());
l.Add(this.getMatch());
l.Add(this.getMatch_range());
l.Add(this.getMeaning());
l.Add(this.getValue());
}

}
public partial class mask
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.maskController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public mask()
{
mask obj = this;
aValue=(null);
}

public void copyTo(mask other)
{
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1662;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1662 = true ; 
while (fl1662) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1662 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</mask>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<mask");
if (typeId){
pw.Write(" xsi:type=\"mask\"");
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</mask>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class match
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.matchController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public match()
{
match obj = this;
aValue=(null);
}

public void copyTo(match other)
{
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1663;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1663 = true ; 
while (fl1663) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1663 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</match>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<match");
if (typeId){
pw.Write(" xsi:type=\"match\"");
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</match>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class meaning
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getBl().CompareTo((String) search) == 0)return true;
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.meaningController.alertChange(aLock, this);
}
private  acceptor.meaning_type aType;

public  acceptor.meaning_type getType() { return aType;}

public  void setType(acceptor.meaning_type v) {
  aType = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getType_AsString()
{
  return acceptor.Enum_meaning_type_ToString (aType);
}

public  bool setType_AsString( string  v)
{
 acceptor.meaning_type  temp = acceptor.StringTo_Enum_meaning_type(v);
if (temp >= 0){
  aType = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public meaning()
{
meaning obj = this;
aType=(0);
aBl=(null);
aValue=(null);
}

public void copyTo(meaning other)
{
other.aType = aType;
other.aBl = aBl;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1664;
bool fl1665;
bool fl1666;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1664 = false ; 
fl1665 = false ; 
fl1666 = true ; 
while (fl1666) { // BeginLoop 
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 1664;
} else {
indicator = 1667;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1665;
} else {
indicator = 1667;
} // If
break;
} // Case
default:
indicator = 1667;
break;
} // Switch
switch (indicator) {
case 1664: {
// Handling attribute type
// Also handles alien attributes with prefix type
if (fl1664){
ctxt.fail ("Duplicate attribute: type");
} // If
fl1664 = true ; 
quoteChar = ctxt.acceptQuote();
this.setType(acceptor.lAcceptEnum_meaning_type(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1665: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1665){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1665 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1667: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1664){
ctxt.fail ("Mandatory attribute missing: type in meaning");
} // If
fl1666 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</meaning>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<meaning");
if (typeId){
pw.Write(" xsi:type=\"meaning\"");
} // If
pw.Write('\n');
pw.Write(" type=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_meaning_type_ToString(this.getType()));
pw.Write('"');
pw.Write('\n');
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</meaning>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
if (this.getValue() != null){
acceptor.unParsePcData(pw, this.getValue());
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class match_range
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getMinimum().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.match_rangeController.alertChange(aLock, this);
}
private   string  aMinimum;

public   string  getMinimum() { return aMinimum;}

public  void setMinimum( string  v) {
  aMinimum = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.maximum_Value aMaximum;

public  acceptor.maximum_Value getMaximum() { return aMaximum;}

public  void setMaximum(acceptor.maximum_Value v) {
  aMaximum = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMaximum_AsString()
{
  return acceptor.Enum_maximum_Value_ToString (aMaximum);
}

public  bool setMaximum_AsString( string  v)
{
 acceptor.maximum_Value  temp = acceptor.StringTo_Enum_maximum_Value(v);
if (temp >= 0){
  aMaximum = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public match_range()
{
match_range obj = this;
aMinimum=(null);
aMaximum=(0);
}

public void copyTo(match_range other)
{
other.aMinimum = aMinimum;
other.aMaximum = aMaximum;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1671;
bool fl1672;

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<minimum");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl1671 = true ; 
while (fl1671) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1671 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setMinimum(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</minimum>");
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<maximum");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl1672 = true ; 
while (fl1672) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1672 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
ctxt.skipWhiteSpace();
// Parse PC data
this.setMaximum(acceptor.lAcceptEnum_maximum_Value(ctxt));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</maximum>");
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1673;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1673 = true ; 
while (fl1673) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1673 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</match-range>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<match-range");
if (typeId){
pw.Write(" xsi:type=\"match-range\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</match-range>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Enclosed
pw.Write("<minimum>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getMinimum());
pw.Write("</minimum>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<maximum>");
// Unparsing PcData
acceptor.unParsePcData(pw,
  acceptor.Enum_maximum_Value_ToString(this.getMaximum()));
pw.Write("</maximum>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class resolution_formula
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.resolution_formulaController.alertChange(aLock, this);
}
private  acceptor.resolution_formula_units aUnits;

public  acceptor.resolution_formula_units getUnits() { return aUnits;}

public  void setUnits(acceptor.resolution_formula_units v) {
  aUnits = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getUnits_AsString()
{
  return acceptor.Enum_resolution_formula_units_ToString (aUnits);
}

public  bool setUnits_AsString( string  v)
{
 acceptor.resolution_formula_units  temp = acceptor.StringTo_Enum_resolution_formula_units(v);
if (temp >= 0){
  aUnits = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.resolution_formula_Value aValue;

public  acceptor.resolution_formula_Value getValue() { return aValue;}

public  void setValue(acceptor.resolution_formula_Value v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getValue_AsString()
{
  return acceptor.Enum_resolution_formula_Value_ToString (aValue);
}

public  bool setValue_AsString( string  v)
{
 acceptor.resolution_formula_Value  temp = acceptor.StringTo_Enum_resolution_formula_Value(v);
if (temp >= 0){
  aValue = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public resolution_formula()
{
resolution_formula obj = this;
aUnits=(0);
aValue=(0);
}

public void copyTo(resolution_formula other)
{
other.aUnits = aUnits;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
ctxt.skipWhiteSpace();
// Parse PC data
this.setValue(acceptor.lAcceptEnum_resolution_formula_Value(ctxt));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1674;
bool fl1675;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1674 = false ; 
fl1675 = true ; 
while (fl1675) { // BeginLoop 
if (ctxt.lookAheadString("units=")){
indicator = 1674;
} else {
indicator = 1676;
} // If
switch (indicator) {
case 1674: {
// Handling attribute units
// Also handles alien attributes with prefix units
if (fl1674){
ctxt.fail ("Duplicate attribute: units");
} // If
fl1674 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUnits(acceptor.lAcceptEnum_resolution_formula_units(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1676: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1675 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</resolution-formula>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<resolution-formula");
if (typeId){
pw.Write(" xsi:type=\"resolution-formula\"");
} // If
pw.Write('\n');
if (this.getUnits() != 0){
pw.Write(" units=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_resolution_formula_units_ToString(this.getUnits()));
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</resolution-formula>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw,
  acceptor.Enum_resolution_formula_Value_ToString(this.getValue()));
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class value
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getUnits().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.valueController.alertChange(aLock, this);
}
private   string  aUnits;

public   string  getUnits() { return aUnits;}

public  void setUnits( string  v) {
  aUnits = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aValue;

public  int getValue() { return aValue;}

public  void setValue(int v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public value()
{
value obj = this;
aUnits=(null);
aValue=(0);
}

public void copyTo(value other)
{
other.aUnits = aUnits;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
ctxt.skipWhiteSpace();
// Parse PC data
this.setValue(ctxt.fetchInteger());
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1678;
bool fl1679;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1678 = false ; 
fl1679 = true ; 
while (fl1679) { // BeginLoop 
if (ctxt.lookAheadString("units=")){
indicator = 1678;
} else {
indicator = 1680;
} // If
switch (indicator) {
case 1678: {
// Handling attribute units
// Also handles alien attributes with prefix units
if (fl1678){
ctxt.fail ("Duplicate attribute: units");
} // If
fl1678 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUnits((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1680: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1678){
ctxt.fail ("Mandatory attribute missing: units in value");
} // If
fl1679 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</value>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<value");
if (typeId){
pw.Write(" xsi:type=\"value\"");
} // If
pw.Write('\n');
pw.Write(" units=\"");
acceptor.unParsePcData(pw, this.getUnits());
pw.Write('"');
pw.Write('\n');
pw.Write('>');
unParseBody(pw);
pw.Write("</value>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class char_value
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getEncoding().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.char_valueController.alertChange(aLock, this);
}
private   string  aEncoding;

public   string  getEncoding() { return aEncoding;}

public  void setEncoding( string  v) {
  aEncoding = v;
  __setDirty(true);
  NotifyControllers(null);
}


public char_value()
{
char_value obj = this;
aEncoding=(null);
}

public void copyTo(char_value other)
{
other.aEncoding = aEncoding;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1682;
bool fl1683;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1682 = false ; 
fl1683 = true ; 
while (fl1683) { // BeginLoop 
if (ctxt.lookAheadString("encoding=")){
indicator = 1682;
} else {
indicator = 1684;
} // If
switch (indicator) {
case 1682: {
// Handling attribute encoding
// Also handles alien attributes with prefix encoding
if (fl1682){
ctxt.fail ("Duplicate attribute: encoding");
} // If
fl1682 = true ; 
quoteChar = ctxt.acceptQuote();
this.setEncoding((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1684: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1682){
ctxt.fail ("Mandatory attribute missing: encoding in char-value");
} // If
fl1683 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</char-value>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<char-value");
if (typeId){
pw.Write(" xsi:type=\"char-value\"");
} // If
pw.Write('\n');
pw.Write(" encoding=\"");
acceptor.unParsePcData(pw, this.getEncoding());
pw.Write('"');
pw.Write('\n');
pw.Write("/>");
pw.Write('\n');
unParseBody(pw);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class ParagraphRevision
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getText().CompareTo((String) search) == 0)return true;
if(getVersion().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ParagraphRevisionController.alertChange(aLock, this);
}
private   string  aText;

public   string  getText() { return aText;}

public  void setText( string  v) {
  aText = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aVersion;

public   string  getVersion() { return aVersion;}

public  void setVersion( string  v) {
  aVersion = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ParagraphRevision()
{
ParagraphRevision obj = this;
aText=(null);
aVersion=(null);
}

public void copyTo(ParagraphRevision other)
{
base.copyTo(other);
other.aText = aText;
other.aVersion = aVersion;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Indicator
// Parse PC data
this.setText(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1686;
bool fl1687;
bool fl1688;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1686 = false ; 
fl1687 = false ; 
fl1688 = true ; 
while (fl1688) { // BeginLoop 
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
if (ctxt.lookAheadString("ersion=")){
indicator = 1686;
} else {
indicator = 1689;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1687;
} else {
indicator = 1689;
} // If
break;
} // Case
default:
indicator = 1689;
break;
} // Switch
switch (indicator) {
case 1686: {
// Handling attribute version
// Also handles alien attributes with prefix version
if (fl1686){
ctxt.fail ("Duplicate attribute: version");
} // If
fl1686 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVersion((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1687: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1687){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1687 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1689: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1686){
ctxt.fail ("Mandatory attribute missing: version in ParagraphRevision");
} // If
fl1688 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ParagraphRevision";
  endingTag = "</ParagraphRevision>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ParagraphRevision\"");
} // If
pw.Write('\n');
pw.Write(" version=\"");
acceptor.unParsePcData(pw, this.getVersion());
pw.Write('"');
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing PcData
acceptor.unParsePcData(pw, this.getText());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class ControllersManager
{
//BaseModelElement  BaseModelElement
public static Controller<BaseModelElement, IListener<BaseModelElement>> BaseModelElementController = new Controller<BaseModelElement, IListener<BaseModelElement>>();
//Namable  Namable
public static Controller<Namable, IListener<Namable>> NamableController = new Controller<Namable, IListener<Namable>>();
//ReferencesParagraph  ReferencesParagraph
public static Controller<ReferencesParagraph, IListener<ReferencesParagraph>> ReferencesParagraphController = new Controller<ReferencesParagraph, IListener<ReferencesParagraph>>();
//ReqRelated  ReqRelated
public static Controller<ReqRelated, IListener<ReqRelated>> ReqRelatedController = new Controller<ReqRelated, IListener<ReqRelated>>();
//Dictionary  Dictionary
public static Controller<Dictionary, IListener<Dictionary>> DictionaryController = new Controller<Dictionary, IListener<Dictionary>>();
//RuleDisabling  RuleDisabling
public static Controller<RuleDisabling, IListener<RuleDisabling>> RuleDisablingController = new Controller<RuleDisabling, IListener<RuleDisabling>>();
//NameSpaceRef  NameSpaceRef
public static Controller<NameSpaceRef, IListener<NameSpaceRef>> NameSpaceRefController = new Controller<NameSpaceRef, IListener<NameSpaceRef>>();
//NameSpace  NameSpace
public static Controller<NameSpace, IListener<NameSpace>> NameSpaceController = new Controller<NameSpace, IListener<NameSpace>>();
//ReqRef  ReqRef
public static Controller<ReqRef, IListener<ReqRef>> ReqRefController = new Controller<ReqRef, IListener<ReqRef>>();
//Type  Type
public static Controller<Type, IListener<Type>> TypeController = new Controller<Type, IListener<Type>>();
//Enum  Enum
public static Controller<Enum, IListener<Enum>> EnumController = new Controller<Enum, IListener<Enum>>();
//EnumValue  EnumValue
public static Controller<EnumValue, IListener<EnumValue>> EnumValueController = new Controller<EnumValue, IListener<EnumValue>>();
//Range  Range
public static Controller<Range, IListener<Range>> RangeController = new Controller<Range, IListener<Range>>();
//Structure  Structure
public static Controller<Structure, IListener<Structure>> StructureController = new Controller<Structure, IListener<Structure>>();
//StructureElement  StructureElement
public static Controller<StructureElement, IListener<StructureElement>> StructureElementController = new Controller<StructureElement, IListener<StructureElement>>();
//Collection  Collection
public static Controller<Collection, IListener<Collection>> CollectionController = new Controller<Collection, IListener<Collection>>();
//Function  Function
public static Controller<Function, IListener<Function>> FunctionController = new Controller<Function, IListener<Function>>();
//Parameter  Parameter
public static Controller<Parameter, IListener<Parameter>> ParameterController = new Controller<Parameter, IListener<Parameter>>();
//Case  Case
public static Controller<Case, IListener<Case>> CaseController = new Controller<Case, IListener<Case>>();
//Procedure  Procedure
public static Controller<Procedure, IListener<Procedure>> ProcedureController = new Controller<Procedure, IListener<Procedure>>();
//StateMachine  StateMachine
public static Controller<StateMachine, IListener<StateMachine>> StateMachineController = new Controller<StateMachine, IListener<StateMachine>>();
//State  State
public static Controller<State, IListener<State>> StateController = new Controller<State, IListener<State>>();
//Variable  Variable
public static Controller<Variable, IListener<Variable>> VariableController = new Controller<Variable, IListener<Variable>>();
//Rule  Rule
public static Controller<Rule, IListener<Rule>> RuleController = new Controller<Rule, IListener<Rule>>();
//RuleCondition  RuleCondition
public static Controller<RuleCondition, IListener<RuleCondition>> RuleConditionController = new Controller<RuleCondition, IListener<RuleCondition>>();
//PreCondition  PreCondition
public static Controller<PreCondition, IListener<PreCondition>> PreConditionController = new Controller<PreCondition, IListener<PreCondition>>();
//Action  Action
public static Controller<Action, IListener<Action>> ActionController = new Controller<Action, IListener<Action>>();
//FrameRef  FrameRef
public static Controller<FrameRef, IListener<FrameRef>> FrameRefController = new Controller<FrameRef, IListener<FrameRef>>();
//Frame  Frame
public static Controller<Frame, IListener<Frame>> FrameController = new Controller<Frame, IListener<Frame>>();
//SubSequence  SubSequence
public static Controller<SubSequence, IListener<SubSequence>> SubSequenceController = new Controller<SubSequence, IListener<SubSequence>>();
//TestCase  TestCase
public static Controller<TestCase, IListener<TestCase>> TestCaseController = new Controller<TestCase, IListener<TestCase>>();
//Step  Step
public static Controller<Step, IListener<Step>> StepController = new Controller<Step, IListener<Step>>();
//SubStep  SubStep
public static Controller<SubStep, IListener<SubStep>> SubStepController = new Controller<SubStep, IListener<SubStep>>();
//Expectation  Expectation
public static Controller<Expectation, IListener<Expectation>> ExpectationController = new Controller<Expectation, IListener<Expectation>>();
//DBMessage  DBMessage
public static Controller<DBMessage, IListener<DBMessage>> DBMessageController = new Controller<DBMessage, IListener<DBMessage>>();
//DBPacket  DBPacket
public static Controller<DBPacket, IListener<DBPacket>> DBPacketController = new Controller<DBPacket, IListener<DBPacket>>();
//DBField  DBField
public static Controller<DBField, IListener<DBField>> DBFieldController = new Controller<DBField, IListener<DBField>>();
//TranslationDictionary  TranslationDictionary
public static Controller<TranslationDictionary, IListener<TranslationDictionary>> TranslationDictionaryController = new Controller<TranslationDictionary, IListener<TranslationDictionary>>();
//Folder  Folder
public static Controller<Folder, IListener<Folder>> FolderController = new Controller<Folder, IListener<Folder>>();
//Translation  Translation
public static Controller<Translation, IListener<Translation>> TranslationController = new Controller<Translation, IListener<Translation>>();
//SourceText  SourceText
public static Controller<SourceText, IListener<SourceText>> SourceTextController = new Controller<SourceText, IListener<SourceText>>();
//ShortcutDictionary  ShortcutDictionary
public static Controller<ShortcutDictionary, IListener<ShortcutDictionary>> ShortcutDictionaryController = new Controller<ShortcutDictionary, IListener<ShortcutDictionary>>();
//ShortcutFolder  ShortcutFolder
public static Controller<ShortcutFolder, IListener<ShortcutFolder>> ShortcutFolderController = new Controller<ShortcutFolder, IListener<ShortcutFolder>>();
//Shortcut  Shortcut
public static Controller<Shortcut, IListener<Shortcut>> ShortcutController = new Controller<Shortcut, IListener<Shortcut>>();
//Specification  Specification
public static Controller<Specification, IListener<Specification>> SpecificationController = new Controller<Specification, IListener<Specification>>();
//ChapterRef  ChapterRef
public static Controller<ChapterRef, IListener<ChapterRef>> ChapterRefController = new Controller<ChapterRef, IListener<ChapterRef>>();
//Chapter  Chapter
public static Controller<Chapter, IListener<Chapter>> ChapterController = new Controller<Chapter, IListener<Chapter>>();
//Paragraph  Paragraph
public static Controller<Paragraph, IListener<Paragraph>> ParagraphController = new Controller<Paragraph, IListener<Paragraph>>();
//Message  Message
public static Controller<Message, IListener<Message>> MessageController = new Controller<Message, IListener<Message>>();
//MsgVariable  MsgVariable
public static Controller<MsgVariable, IListener<MsgVariable>> MsgVariableController = new Controller<MsgVariable, IListener<MsgVariable>>();
//TypeSpec  TypeSpec
public static Controller<TypeSpec, IListener<TypeSpec>> TypeSpecController = new Controller<TypeSpec, IListener<TypeSpec>>();
//Values  Values
public static Controller<Values, IListener<Values>> ValuesController = new Controller<Values, IListener<Values>>();
//special-or-reserved-values  special_or_reserved_values
public static Controller<special_or_reserved_values, IListener<special_or_reserved_values>> special_or_reserved_valuesController = new Controller<special_or_reserved_values, IListener<special_or_reserved_values>>();
//special-or-reserved-value  special_or_reserved_value
public static Controller<special_or_reserved_value, IListener<special_or_reserved_value>> special_or_reserved_valueController = new Controller<special_or_reserved_value, IListener<special_or_reserved_value>>();
//mask  mask
public static Controller<mask, IListener<mask>> maskController = new Controller<mask, IListener<mask>>();
//match  match
public static Controller<match, IListener<match>> matchController = new Controller<match, IListener<match>>();
//meaning  meaning
public static Controller<meaning, IListener<meaning>> meaningController = new Controller<meaning, IListener<meaning>>();
//match-range  match_range
public static Controller<match_range, IListener<match_range>> match_rangeController = new Controller<match_range, IListener<match_range>>();
//resolution-formula  resolution_formula
public static Controller<resolution_formula, IListener<resolution_formula>> resolution_formulaController = new Controller<resolution_formula, IListener<resolution_formula>>();
//value  value
public static Controller<value, IListener<value>> valueController = new Controller<value, IListener<value>>();
//char-value  char_value
public static Controller<char_value, IListener<char_value>> char_valueController = new Controller<char_value, IListener<char_value>>();
//ParagraphRevision  ParagraphRevision
public static Controller<ParagraphRevision, IListener<ParagraphRevision>> ParagraphRevisionController = new Controller<ParagraphRevision, IListener<ParagraphRevision>>();
public static void ActivateAllNotifications(){
BaseModelElementController.ActivateNotification();
NamableController.ActivateNotification();
ReferencesParagraphController.ActivateNotification();
ReqRelatedController.ActivateNotification();
DictionaryController.ActivateNotification();
RuleDisablingController.ActivateNotification();
NameSpaceRefController.ActivateNotification();
NameSpaceController.ActivateNotification();
ReqRefController.ActivateNotification();
TypeController.ActivateNotification();
EnumController.ActivateNotification();
EnumValueController.ActivateNotification();
RangeController.ActivateNotification();
StructureController.ActivateNotification();
StructureElementController.ActivateNotification();
CollectionController.ActivateNotification();
FunctionController.ActivateNotification();
ParameterController.ActivateNotification();
CaseController.ActivateNotification();
ProcedureController.ActivateNotification();
StateMachineController.ActivateNotification();
StateController.ActivateNotification();
VariableController.ActivateNotification();
RuleController.ActivateNotification();
RuleConditionController.ActivateNotification();
PreConditionController.ActivateNotification();
ActionController.ActivateNotification();
FrameRefController.ActivateNotification();
FrameController.ActivateNotification();
SubSequenceController.ActivateNotification();
TestCaseController.ActivateNotification();
StepController.ActivateNotification();
SubStepController.ActivateNotification();
ExpectationController.ActivateNotification();
DBMessageController.ActivateNotification();
DBPacketController.ActivateNotification();
DBFieldController.ActivateNotification();
TranslationDictionaryController.ActivateNotification();
FolderController.ActivateNotification();
TranslationController.ActivateNotification();
SourceTextController.ActivateNotification();
ShortcutDictionaryController.ActivateNotification();
ShortcutFolderController.ActivateNotification();
ShortcutController.ActivateNotification();
SpecificationController.ActivateNotification();
ChapterRefController.ActivateNotification();
ChapterController.ActivateNotification();
ParagraphController.ActivateNotification();
MessageController.ActivateNotification();
MsgVariableController.ActivateNotification();
TypeSpecController.ActivateNotification();
ValuesController.ActivateNotification();
special_or_reserved_valuesController.ActivateNotification();
special_or_reserved_valueController.ActivateNotification();
maskController.ActivateNotification();
matchController.ActivateNotification();
meaningController.ActivateNotification();
match_rangeController.ActivateNotification();
resolution_formulaController.ActivateNotification();
valueController.ActivateNotification();
char_valueController.ActivateNotification();
ParagraphRevisionController.ActivateNotification();
}
public static void DesactivateAllNotifications(){
BaseModelElementController.DesactivateNotification();
NamableController.DesactivateNotification();
ReferencesParagraphController.DesactivateNotification();
ReqRelatedController.DesactivateNotification();
DictionaryController.DesactivateNotification();
RuleDisablingController.DesactivateNotification();
NameSpaceRefController.DesactivateNotification();
NameSpaceController.DesactivateNotification();
ReqRefController.DesactivateNotification();
TypeController.DesactivateNotification();
EnumController.DesactivateNotification();
EnumValueController.DesactivateNotification();
RangeController.DesactivateNotification();
StructureController.DesactivateNotification();
StructureElementController.DesactivateNotification();
CollectionController.DesactivateNotification();
FunctionController.DesactivateNotification();
ParameterController.DesactivateNotification();
CaseController.DesactivateNotification();
ProcedureController.DesactivateNotification();
StateMachineController.DesactivateNotification();
StateController.DesactivateNotification();
VariableController.DesactivateNotification();
RuleController.DesactivateNotification();
RuleConditionController.DesactivateNotification();
PreConditionController.DesactivateNotification();
ActionController.DesactivateNotification();
FrameRefController.DesactivateNotification();
FrameController.DesactivateNotification();
SubSequenceController.DesactivateNotification();
TestCaseController.DesactivateNotification();
StepController.DesactivateNotification();
SubStepController.DesactivateNotification();
ExpectationController.DesactivateNotification();
DBMessageController.DesactivateNotification();
DBPacketController.DesactivateNotification();
DBFieldController.DesactivateNotification();
TranslationDictionaryController.DesactivateNotification();
FolderController.DesactivateNotification();
TranslationController.DesactivateNotification();
SourceTextController.DesactivateNotification();
ShortcutDictionaryController.DesactivateNotification();
ShortcutFolderController.DesactivateNotification();
ShortcutController.DesactivateNotification();
SpecificationController.DesactivateNotification();
ChapterRefController.DesactivateNotification();
ChapterController.DesactivateNotification();
ParagraphController.DesactivateNotification();
MessageController.DesactivateNotification();
MsgVariableController.DesactivateNotification();
TypeSpecController.DesactivateNotification();
ValuesController.DesactivateNotification();
special_or_reserved_valuesController.DesactivateNotification();
special_or_reserved_valueController.DesactivateNotification();
maskController.DesactivateNotification();
matchController.DesactivateNotification();
meaningController.DesactivateNotification();
match_rangeController.DesactivateNotification();
resolution_formulaController.DesactivateNotification();
valueController.DesactivateNotification();
char_valueController.DesactivateNotification();
ParagraphRevisionController.DesactivateNotification();
}
}
public partial class acceptor
: XmlBBaseAcceptor
{

public enum Paragraph_type {
     defaultParagraph_type,
     aTITLE,
     aDEFINITION,
     aNOTE,
     aDELETED,
     aREQUIREMENT,
     aTABLE_HEADER,
     aPROBLEM
};

public enum Paragraph_scope {
     defaultParagraph_scope,
     aOBU_AND_TRACK,
     aTRACK,
     aOBU,
     aROLLING_STOCK,
     aFLAGS
};

public enum Message_media {
     defaultMessage_media,
     aBalise_RBC,
     aAny,
     aRBC,
     aBalise,
     aBalise_loop_RIU,
     aLoop,
     aBalise_RBC_RIU,
     aAny_,
     aRIU,
     aRBC_RIU,
     aBalise_loop
};

public enum TypeSpec_ertms_type {
     defaultTypeSpec_ertms_type,
     adistance,
     agradient,
     alength,
     amiscellaneous,
     aclass_number,
     aidentity_number,
     aqualifier,
     atime_or_date,
     aspeed,
     atext
};

public enum meaning_type {
     defaultmeaning_type,
     ainvalid,
     aenum,
     aunknown,
     ainfinite
};

public enum maximum_Value {
     defaultmaximum_Value,
     a11,
     a15,
     a127,
     a1022,
     a255,
     aC_7,
     a1_55,
     a126,
     aE,
     a254,
     a125
};

public enum resolution_formula_units {
     defaultresolution_formula_units,
     m_s2,
     q_scale,
     percent,
     abyte,
     abit,
     text_string_element,
     m,
     A,
     s,
     ms,
     km_h
};

public enum resolution_formula_Value {
     defaultresolution_formula_Value,
     a0_05,
     aC_1,
     a10,
     a0_02,
     aintegers,
     aNumbers,
     aBinary_Coded_Decimal,
     aNumber,
     aBitset,
     aC_5
};

public enum VariableModeEnumType {
     defaultVariableModeEnumType,
     aIncoming,
     aOutgoing,
     aInternal,
     aInOut,
     aConstant
};

public enum MessageEnumType {
     defaultMessageEnumType,
     aEurobalise,
     aEuroloop,
     aValidatedTrainData,
     aRequestForShunting,
     aMARequest,
     aTrainPositionReport,
     aRequestToShortenMAIsGranted,
     aRequestToShortenMAIsRejected,
     aAcknowledgement,
     aAcknowledgementOfEmergencyStop,
     aTrackAheadFreeGranted,
     aEndOfMission,
     aRadioInFillRequest,
     aTrain_NoCompatibleVersionSupported,
     aTrain_InitiationOfACommunicationSession,
     aTrain_TerminationOfACommunicationSession,
     aSoMPositionReport,
     aTrain_SessionEstablished,
     aSRAuthorization,
     aMovementAuthority,
     aRecognitionOfExitFromTripMode,
     aAcknowledgementOfTrainData,
     aRequestToShortenMA,
     aConditionalEmergencyStop,
     aUnconditionalEmergencyStop,
     aRevocationOfEmergencyStop,
     aGeneralMessage,
     aSHRefused,
     aSHAuthorized,
     aRBCRIUSystemVersion,
     aMAWithShiftedLocationReference,
     aTrackAheadFreeRequest,
     aInFillMA,
     aTrack_InitiationOfACommunicationSession,
     aAcknowledgementOfTerminationOfACommunicationSession,
     aTrainRejected,
     aTrainAccepted,
     aSomPositionReportConfirmedByRBC,
     aAssignmentOfCoordinateSystem
};

public enum MessageDirectionEnumType {
     defaultMessageDirectionEnumType,
     aTrainToTrack,
     aTrackToTrain
};

public enum SPEC_IMPLEMENTED_ENUM {
     defaultSPEC_IMPLEMENTED_ENUM,
     Impl_NA,
     Impl_Implemented,
     Impl_NotImplementable,
     Impl_NewRevisionAvailable
};

public enum ST_IO {
     defaultST_IO,
     StIO_NA,
     StIO_In,
     StIO_Out
};

public enum ST_INTERFACE {
     defaultST_INTERFACE,
     StInterface_NA,
     StInterface_DMI,
     StInterface_RTM,
     StInterface_JRU,
     StInterface_TIU
};

public enum ST_LEVEL {
     defaultST_LEVEL,
     StLevel_NA,
     StLevel_L0,
     StLevel_L1,
     StLevel_LSTM,
     StLevel_L2,
     StLevel_L3
};

public enum ST_MODE {
     defaultST_MODE,
     Mode_NA,
     Mode_IS,
     Mode_NP,
     Mode_SF,
     Mode_SL,
     Mode_SB,
     Mode_SH,
     Mode_FS,
     Mode_UF,
     Mode_SR,
     Mode_OS,
     Mode_TR,
     Mode_PT,
     Mode_NL,
     Mode_SN,
     Mode_RE,
     Mode_LS,
     Mode_PSH
};

public enum RulePriority {
     defaultRulePriority,
     aVerification,
     aUpdateINTERNAL,
     aProcessing,
     aUpdateOUT,
     aCleanUp
};

public enum PrecisionEnum {
     defaultPrecisionEnum,
     aIntegerPrecision,
     aDoublePrecision
};

public enum DBMessageType {
     defaultDBMessageType,
     aEUROBALISE,
     aEUROLOOP,
     aEURORADIO
};

public enum ExpectationKind {
     defaultExpectationKind,
     aInstantaneous,
     aContinuous
};

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Paragraph_type lAcceptEnum_Paragraph_type (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  Paragraph_type res = Paragraph_type.defaultParagraph_type;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
ctxt.accept3('T','L','E');
res = Paragraph_type.aTITLE;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("BLE_HEADER");
res = Paragraph_type.aTABLE_HEADER;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1696)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("EQUIREMENT")){
res = Paragraph_type.aREQUIREMENT;
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("ROBLEM")){
res = Paragraph_type.aPROBLEM;
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead3('O','T','E')){
res = Paragraph_type.aNOTE;
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAhead1('E')){
switch (ctxt.current()) {
case 'L':
{
ctxt.advance();
ctxt.acceptString ("ETED");
res = Paragraph_type.aDELETED;
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.acceptString ("INITION");
res = Paragraph_type.aDEFINITION;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1703)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
default:
res = Paragraph_type.aREQUIREMENT;
break;
} // Switch
return res;
}

public static  string  Enum_Paragraph_type_ToString (Paragraph_type v)
{
switch (v) {
 case Paragraph_type.aTITLE: return "TITLE";
 case Paragraph_type.aDEFINITION: return "DEFINITION";
 case Paragraph_type.aNOTE: return "NOTE";
 case Paragraph_type.aDELETED: return "DELETED";
 case Paragraph_type.aREQUIREMENT: return "REQUIREMENT";
 case Paragraph_type.aTABLE_HEADER: return "TABLE_HEADER";
 case Paragraph_type.aPROBLEM: return "PROBLEM";
} return "";
}

public static Paragraph_type StringTo_Enum_Paragraph_type( string  str)
{
if (str.Equals("TITLE")){
  return Paragraph_type.aTITLE;
} // If
if (str.Equals("DEFINITION")){
  return Paragraph_type.aDEFINITION;
} // If
if (str.Equals("NOTE")){
  return Paragraph_type.aNOTE;
} // If
if (str.Equals("DELETED")){
  return Paragraph_type.aDELETED;
} // If
if (str.Equals("REQUIREMENT")){
  return Paragraph_type.aREQUIREMENT;
} // If
if (str.Equals("TABLE_HEADER")){
  return Paragraph_type.aTABLE_HEADER;
} // If
if (str.Equals("PROBLEM")){
  return Paragraph_type.aPROBLEM;
} // If
return Paragraph_type.defaultParagraph_type;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Paragraph_scope lAcceptEnum_Paragraph_scope (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  Paragraph_scope res = Paragraph_scope.defaultParagraph_scope;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("RACK")){
res = Paragraph_scope.aTRACK;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("OLLING_STOCK")){
res = Paragraph_scope.aROLLING_STOCK;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead2('B','U')){
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
if (ctxt.lookAheadString("AND_TRACK")){
res = Paragraph_scope.aOBU_AND_TRACK;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU;
} // If
break;
} // Case
default:
res = Paragraph_scope.aOBU;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("LAGS")){
res = Paragraph_scope.aFLAGS;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
default:
res = Paragraph_scope.aOBU_AND_TRACK;
break;
} // Switch
return res;
}

public static  string  Enum_Paragraph_scope_ToString (Paragraph_scope v)
{
switch (v) {
 case Paragraph_scope.aOBU_AND_TRACK: return "OBU_AND_TRACK";
 case Paragraph_scope.aTRACK: return "TRACK";
 case Paragraph_scope.aOBU: return "OBU";
 case Paragraph_scope.aROLLING_STOCK: return "ROLLING_STOCK";
 case Paragraph_scope.aFLAGS: return "FLAGS";
} return "";
}

public static Paragraph_scope StringTo_Enum_Paragraph_scope( string  str)
{
if (str.Equals("OBU_AND_TRACK")){
  return Paragraph_scope.aOBU_AND_TRACK;
} // If
if (str.Equals("TRACK")){
  return Paragraph_scope.aTRACK;
} // If
if (str.Equals("OBU")){
  return Paragraph_scope.aOBU;
} // If
if (str.Equals("ROLLING_STOCK")){
  return Paragraph_scope.aROLLING_STOCK;
} // If
if (str.Equals("FLAGS")){
  return Paragraph_scope.aFLAGS;
} // If
return Paragraph_scope.defaultParagraph_scope;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Message_media lAcceptEnum_Message_media (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  Message_media res = Message_media.defaultMessage_media;
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
ctxt.accept('U');
res = Message_media.aRIU;
break;
} // Case
case 'B':
{
ctxt.advance();
ctxt.accept('C');
switch (ctxt.current()) {
case ',':
{
ctxt.advance();
if (ctxt.lookAheadString(" RIU")){
res = Message_media.aRBC_RIU;
} else {
ctxt.moveBack(1);
res = Message_media.aRBC;
} // If
break;
} // Case
default:
res = Message_media.aRBC;
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1713)");
break;
} // Switch
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAhead3('o','o','p')){
res = Message_media.aLoop;
} else {
ctxt.moveBack(1);
res = Message_media.aAny_;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
if (ctxt.lookAheadString("alise")){
switch (ctxt.current()) {
case ',':
{
ctxt.advance();
if (ctxt.lookAhead1(' ')){
switch (ctxt.current()) {
case 'l':
{
ctxt.advance();
ctxt.acceptString ("oop, RIU");
res = Message_media.aBalise_loop_RIU;
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.accept2('B','C');
switch (ctxt.current()) {
case ',':
{
ctxt.advance();
if (ctxt.lookAheadString(" RIU")){
res = Message_media.aBalise_RBC_RIU;
} else {
ctxt.moveBack(1);
res = Message_media.aBalise_RBC;
} // If
break;
} // Case
default:
res = Message_media.aBalise_RBC;
break;
} // Switch
break;
} // Case
case 'L':
{
ctxt.advance();
ctxt.accept3('o','o','p');
res = Message_media.aBalise_loop;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1721)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Message_media.aBalise;
} // If
break;
} // Case
default:
res = Message_media.aBalise;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Message_media.aAny_;
} // If
break;
} // Case
case 'A':
{
ctxt.advance();
if (ctxt.lookAhead2('n','y')){
switch (ctxt.current()) {
case ' ':
{
ctxt.advance();
res = Message_media.aAny_;
break;
} // Case
default:
res = Message_media.aAny;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Message_media.aAny_;
} // If
break;
} // Case
default:
res = Message_media.aAny_;
break;
} // Switch
return res;
}

public static  string  Enum_Message_media_ToString (Message_media v)
{
switch (v) {
 case Message_media.aBalise_RBC: return "Balise, RBC";
 case Message_media.aAny: return "Any";
 case Message_media.aRBC: return "RBC";
 case Message_media.aBalise: return "Balise";
 case Message_media.aBalise_loop_RIU: return "Balise, loop, RIU";
 case Message_media.aLoop: return "Loop";
 case Message_media.aBalise_RBC_RIU: return "Balise, RBC, RIU";
 case Message_media.aAny_: return "Any ";
 case Message_media.aRIU: return "RIU";
 case Message_media.aRBC_RIU: return "RBC, RIU";
 case Message_media.aBalise_loop: return "Balise, Loop";
} return "";
}

public static Message_media StringTo_Enum_Message_media( string  str)
{
if (str.Equals("Balise, RBC")){
  return Message_media.aBalise_RBC;
} // If
if (str.Equals("Any")){
  return Message_media.aAny;
} // If
if (str.Equals("RBC")){
  return Message_media.aRBC;
} // If
if (str.Equals("Balise")){
  return Message_media.aBalise;
} // If
if (str.Equals("Balise, loop, RIU")){
  return Message_media.aBalise_loop_RIU;
} // If
if (str.Equals("Loop")){
  return Message_media.aLoop;
} // If
if (str.Equals("Balise, RBC, RIU")){
  return Message_media.aBalise_RBC_RIU;
} // If
if (str.Equals("Any ")){
  return Message_media.aAny_;
} // If
if (str.Equals("RIU")){
  return Message_media.aRIU;
} // If
if (str.Equals("RBC, RIU")){
  return Message_media.aRBC_RIU;
} // If
if (str.Equals("Balise, Loop")){
  return Message_media.aBalise_loop;
} // If
return Message_media.defaultMessage_media;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TypeSpec_ertms_type lAcceptEnum_TypeSpec_ertms_type (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  TypeSpec_ertms_type res = TypeSpec_ertms_type.defaultTypeSpec_ertms_type;
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.acceptString ("me-or-date");
res = TypeSpec_ertms_type.atime_or_date;
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.accept2('x','t');
res = TypeSpec_ertms_type.atext;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1727)");
break;
} // Switch
break;
} // Case
case 's':
{
ctxt.advance();
if (ctxt.lookAheadString("peed")){
res = TypeSpec_ertms_type.aspeed;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'q':
{
ctxt.advance();
if (ctxt.lookAheadString("ualifier")){
res = TypeSpec_ertms_type.aqualifier;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("iscellaneous")){
res = TypeSpec_ertms_type.amiscellaneous;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'l':
{
ctxt.advance();
if (ctxt.lookAheadString("ength")){
res = TypeSpec_ertms_type.alength;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dentity-number")){
res = TypeSpec_ertms_type.aidentity_number;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("radient")){
res = TypeSpec_ertms_type.agradient;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'd':
{
ctxt.advance();
if (ctxt.lookAheadString("istance")){
res = TypeSpec_ertms_type.adistance;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("lass-number")){
res = TypeSpec_ertms_type.aclass_number;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_TypeSpec_ertms_type_ToString (TypeSpec_ertms_type v)
{
switch (v) {
 case TypeSpec_ertms_type.adistance: return "distance";
 case TypeSpec_ertms_type.agradient: return "gradient";
 case TypeSpec_ertms_type.alength: return "length";
 case TypeSpec_ertms_type.amiscellaneous: return "miscellaneous";
 case TypeSpec_ertms_type.aclass_number: return "class-number";
 case TypeSpec_ertms_type.aidentity_number: return "identity-number";
 case TypeSpec_ertms_type.aqualifier: return "qualifier";
 case TypeSpec_ertms_type.atime_or_date: return "time-or-date";
 case TypeSpec_ertms_type.aspeed: return "speed";
 case TypeSpec_ertms_type.atext: return "text";
} return "";
}

public static TypeSpec_ertms_type StringTo_Enum_TypeSpec_ertms_type( string  str)
{
if (str.Equals("distance")){
  return TypeSpec_ertms_type.adistance;
} // If
if (str.Equals("gradient")){
  return TypeSpec_ertms_type.agradient;
} // If
if (str.Equals("length")){
  return TypeSpec_ertms_type.alength;
} // If
if (str.Equals("miscellaneous")){
  return TypeSpec_ertms_type.amiscellaneous;
} // If
if (str.Equals("class-number")){
  return TypeSpec_ertms_type.aclass_number;
} // If
if (str.Equals("identity-number")){
  return TypeSpec_ertms_type.aidentity_number;
} // If
if (str.Equals("qualifier")){
  return TypeSpec_ertms_type.aqualifier;
} // If
if (str.Equals("time-or-date")){
  return TypeSpec_ertms_type.atime_or_date;
} // If
if (str.Equals("speed")){
  return TypeSpec_ertms_type.aspeed;
} // If
if (str.Equals("text")){
  return TypeSpec_ertms_type.atext;
} // If
return TypeSpec_ertms_type.defaultTypeSpec_ertms_type;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static meaning_type lAcceptEnum_meaning_type (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  meaning_type res = meaning_type.defaultmeaning_type;
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("nknown")){
res = meaning_type.aunknown;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAhead1('n')){
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
ctxt.acceptString ("alid");
res = meaning_type.ainvalid;
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.acceptString ("inite");
res = meaning_type.ainfinite;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1740)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
res = meaning_type.aenum;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_meaning_type_ToString (meaning_type v)
{
switch (v) {
 case meaning_type.ainvalid: return "invalid";
 case meaning_type.aenum: return "enum";
 case meaning_type.aunknown: return "unknown";
 case meaning_type.ainfinite: return "infinite";
} return "";
}

public static meaning_type StringTo_Enum_meaning_type( string  str)
{
if (str.Equals("invalid")){
  return meaning_type.ainvalid;
} // If
if (str.Equals("enum")){
  return meaning_type.aenum;
} // If
if (str.Equals("unknown")){
  return meaning_type.aunknown;
} // If
if (str.Equals("infinite")){
  return meaning_type.ainfinite;
} // If
return meaning_type.defaultmeaning_type;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static maximum_Value lAcceptEnum_maximum_Value (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  maximum_Value res = maximum_Value.defaultmaximum_Value;
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
res = maximum_Value.aE;
break;
} // Case
case '7':
{
ctxt.advance();
res = maximum_Value.aC_7;
break;
} // Case
case '2':
{
ctxt.advance();
if (ctxt.lookAhead1('5')){
switch (ctxt.current()) {
case '5':
{
ctxt.advance();
res = maximum_Value.a255;
break;
} // Case
case '4':
{
ctxt.advance();
res = maximum_Value.a254;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1747)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case '1':
{
ctxt.advance();
switch (ctxt.current()) {
case '5':
{
ctxt.advance();
res = maximum_Value.a15;
break;
} // Case
case '2':
{
ctxt.advance();
switch (ctxt.current()) {
case '7':
{
ctxt.advance();
res = maximum_Value.a127;
break;
} // Case
case '6':
{
ctxt.advance();
res = maximum_Value.a126;
break;
} // Case
case '5':
{
ctxt.advance();
res = maximum_Value.a125;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1754)");
break;
} // Switch
break;
} // Case
case '1':
{
ctxt.advance();
res = maximum_Value.a11;
break;
} // Case
case '0':
{
ctxt.advance();
ctxt.accept2('2','2');
res = maximum_Value.a1022;
break;
} // Case
case '.':
{
ctxt.advance();
ctxt.accept2('5','5');
res = maximum_Value.a1_55;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1758)");
break;
} // Switch
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_maximum_Value_ToString (maximum_Value v)
{
switch (v) {
 case maximum_Value.a11: return "11";
 case maximum_Value.a15: return "15";
 case maximum_Value.a127: return "127";
 case maximum_Value.a1022: return "1022";
 case maximum_Value.a255: return "255";
 case maximum_Value.aC_7: return "7";
 case maximum_Value.a1_55: return "1.55";
 case maximum_Value.a126: return "126";
 case maximum_Value.aE: return "E";
 case maximum_Value.a254: return "254";
 case maximum_Value.a125: return "125";
} return "";
}

public static maximum_Value StringTo_Enum_maximum_Value( string  str)
{
if (str.Equals("11")){
  return maximum_Value.a11;
} // If
if (str.Equals("15")){
  return maximum_Value.a15;
} // If
if (str.Equals("127")){
  return maximum_Value.a127;
} // If
if (str.Equals("1022")){
  return maximum_Value.a1022;
} // If
if (str.Equals("255")){
  return maximum_Value.a255;
} // If
if (str.Equals("7")){
  return maximum_Value.aC_7;
} // If
if (str.Equals("1.55")){
  return maximum_Value.a1_55;
} // If
if (str.Equals("126")){
  return maximum_Value.a126;
} // If
if (str.Equals("E")){
  return maximum_Value.aE;
} // If
if (str.Equals("254")){
  return maximum_Value.a254;
} // If
if (str.Equals("125")){
  return maximum_Value.a125;
} // If
return maximum_Value.defaultmaximum_Value;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static resolution_formula_units lAcceptEnum_resolution_formula_units (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  resolution_formula_units res = resolution_formula_units.defaultresolution_formula_units;
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAheadString("ext-string-element")){
res = resolution_formula_units.text_string_element;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 's':
{
ctxt.advance();
res = resolution_formula_units.s;
break;
} // Case
case 'q':
{
ctxt.advance();
if (ctxt.lookAheadString("_scale")){
res = resolution_formula_units.q_scale;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
res = resolution_formula_units.ms;
break;
} // Case
case '/':
{
ctxt.advance();
if (ctxt.lookAhead2('s','2')){
res = resolution_formula_units.m_s2;
} else {
ctxt.moveBack(1);
res = resolution_formula_units.m;
} // If
break;
} // Case
default:
res = resolution_formula_units.m;
break;
} // Switch
break;
} // Case
case 'k':
{
ctxt.advance();
if (ctxt.lookAhead3('m','/','h')){
res = resolution_formula_units.km_h;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
switch (ctxt.current()) {
case 'y':
{
ctxt.advance();
ctxt.accept2('t','e');
res = resolution_formula_units.abyte;
break;
} // Case
case 'i':
{
ctxt.advance();
ctxt.accept('t');
res = resolution_formula_units.abit;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1769)");
break;
} // Switch
break;
} // Case
case 'A':
{
ctxt.advance();
res = resolution_formula_units.A;
break;
} // Case
case '%':
{
ctxt.advance();
res = resolution_formula_units.percent;
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_resolution_formula_units_ToString (resolution_formula_units v)
{
switch (v) {
 case resolution_formula_units.m_s2: return "m/s2";
 case resolution_formula_units.q_scale: return "q_scale";
 case resolution_formula_units.percent: return "%";
 case resolution_formula_units.abyte: return "byte";
 case resolution_formula_units.abit: return "bit";
 case resolution_formula_units.text_string_element: return "text-string-element";
 case resolution_formula_units.m: return "m";
 case resolution_formula_units.A: return "A";
 case resolution_formula_units.s: return "s";
 case resolution_formula_units.ms: return "ms";
 case resolution_formula_units.km_h: return "km/h";
} return "";
}

public static resolution_formula_units StringTo_Enum_resolution_formula_units( string  str)
{
if (str.Equals("m/s2")){
  return resolution_formula_units.m_s2;
} // If
if (str.Equals("q_scale")){
  return resolution_formula_units.q_scale;
} // If
if (str.Equals("%")){
  return resolution_formula_units.percent;
} // If
if (str.Equals("byte")){
  return resolution_formula_units.abyte;
} // If
if (str.Equals("bit")){
  return resolution_formula_units.abit;
} // If
if (str.Equals("text-string-element")){
  return resolution_formula_units.text_string_element;
} // If
if (str.Equals("m")){
  return resolution_formula_units.m;
} // If
if (str.Equals("A")){
  return resolution_formula_units.A;
} // If
if (str.Equals("s")){
  return resolution_formula_units.s;
} // If
if (str.Equals("ms")){
  return resolution_formula_units.ms;
} // If
if (str.Equals("km/h")){
  return resolution_formula_units.km_h;
} // If
return resolution_formula_units.defaultresolution_formula_units;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static resolution_formula_Value lAcceptEnum_resolution_formula_Value (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  resolution_formula_Value res = resolution_formula_Value.defaultresolution_formula_Value;
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("ntegers")){
res = resolution_formula_Value.aintegers;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("umber")){
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
res = resolution_formula_Value.aNumbers;
break;
} // Case
default:
res = resolution_formula_Value.aNumber;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
if (ctxt.lookAhead1('i')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
ctxt.accept3('s','e','t');
res = resolution_formula_Value.aBitset;
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.acceptString ("ary Coded Decimal");
res = resolution_formula_Value.aBinary_Coded_Decimal;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1778)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case '5':
{
ctxt.advance();
res = resolution_formula_Value.aC_5;
break;
} // Case
case '1':
{
ctxt.advance();
switch (ctxt.current()) {
case '0':
{
ctxt.advance();
res = resolution_formula_Value.a10;
break;
} // Case
default:
res = resolution_formula_Value.aC_1;
break;
} // Switch
break;
} // Case
case '0':
{
ctxt.advance();
if (ctxt.lookAhead2('.','0')){
switch (ctxt.current()) {
case '5':
{
ctxt.advance();
res = resolution_formula_Value.a0_05;
break;
} // Case
case '2':
{
ctxt.advance();
res = resolution_formula_Value.a0_02;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1785)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_resolution_formula_Value_ToString (resolution_formula_Value v)
{
switch (v) {
 case resolution_formula_Value.a0_05: return "0.05";
 case resolution_formula_Value.aC_1: return "1";
 case resolution_formula_Value.a10: return "10";
 case resolution_formula_Value.a0_02: return "0.02";
 case resolution_formula_Value.aintegers: return "integers";
 case resolution_formula_Value.aNumbers: return "Numbers";
 case resolution_formula_Value.aBinary_Coded_Decimal: return "Binary Coded Decimal";
 case resolution_formula_Value.aNumber: return "Number";
 case resolution_formula_Value.aBitset: return "Bitset";
 case resolution_formula_Value.aC_5: return "5";
} return "";
}

public static resolution_formula_Value StringTo_Enum_resolution_formula_Value( string  str)
{
if (str.Equals("0.05")){
  return resolution_formula_Value.a0_05;
} // If
if (str.Equals("1")){
  return resolution_formula_Value.aC_1;
} // If
if (str.Equals("10")){
  return resolution_formula_Value.a10;
} // If
if (str.Equals("0.02")){
  return resolution_formula_Value.a0_02;
} // If
if (str.Equals("integers")){
  return resolution_formula_Value.aintegers;
} // If
if (str.Equals("Numbers")){
  return resolution_formula_Value.aNumbers;
} // If
if (str.Equals("Binary Coded Decimal")){
  return resolution_formula_Value.aBinary_Coded_Decimal;
} // If
if (str.Equals("Number")){
  return resolution_formula_Value.aNumber;
} // If
if (str.Equals("Bitset")){
  return resolution_formula_Value.aBitset;
} // If
if (str.Equals("5")){
  return resolution_formula_Value.aC_5;
} // If
return resolution_formula_Value.defaultresolution_formula_Value;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static VariableModeEnumType lAcceptEnum_VariableModeEnumType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  VariableModeEnumType res = VariableModeEnumType.defaultVariableModeEnumType;
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAheadString("utgoing")){
res = VariableModeEnumType.aOutgoing;
} else {
ctxt.moveBack(1);
res = VariableModeEnumType.aInternal;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('n')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
ctxt.acceptString ("ernal");
res = VariableModeEnumType.aInternal;
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("oming");
res = VariableModeEnumType.aIncoming;
break;
} // Case
case 'O':
{
ctxt.advance();
ctxt.accept2('u','t');
res = VariableModeEnumType.aInOut;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1791)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = VariableModeEnumType.aInternal;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("onstant")){
res = VariableModeEnumType.aConstant;
} else {
ctxt.moveBack(1);
res = VariableModeEnumType.aInternal;
} // If
break;
} // Case
default:
res = VariableModeEnumType.aInternal;
break;
} // Switch
return res;
}

public static  string  Enum_VariableModeEnumType_ToString (VariableModeEnumType v)
{
switch (v) {
 case VariableModeEnumType.aIncoming: return "Incoming";
 case VariableModeEnumType.aOutgoing: return "Outgoing";
 case VariableModeEnumType.aInternal: return "Internal";
 case VariableModeEnumType.aInOut: return "InOut";
 case VariableModeEnumType.aConstant: return "Constant";
} return "";
}

public static VariableModeEnumType StringTo_Enum_VariableModeEnumType( string  str)
{
if (str.Equals("Incoming")){
  return VariableModeEnumType.aIncoming;
} // If
if (str.Equals("Outgoing")){
  return VariableModeEnumType.aOutgoing;
} // If
if (str.Equals("Internal")){
  return VariableModeEnumType.aInternal;
} // If
if (str.Equals("InOut")){
  return VariableModeEnumType.aInOut;
} // If
if (str.Equals("Constant")){
  return VariableModeEnumType.aConstant;
} // If
return VariableModeEnumType.defaultVariableModeEnumType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static MessageEnumType lAcceptEnum_MessageEnumType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  MessageEnumType res = MessageEnumType.defaultMessageEnumType;
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alidatedTrainData")){
res = MessageEnumType.aValidatedTrainData;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("nconditionalEmergencyStop")){
res = MessageEnumType.aUnconditionalEmergencyStop;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.accept('n');
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
ctxt.acceptString ("erminationOfACommunicationSession");
res = MessageEnumType.aTrain_TerminationOfACommunicationSession;
break;
} // Case
case 'S':
{
ctxt.advance();
ctxt.acceptString ("essionEstablished");
res = MessageEnumType.aTrain_SessionEstablished;
break;
} // Case
case 'N':
{
ctxt.advance();
ctxt.acceptString ("oCompatibleVersionSupported");
res = MessageEnumType.aTrain_NoCompatibleVersionSupported;
break;
} // Case
case 'I':
{
ctxt.advance();
ctxt.acceptString ("nitiationOfACommunicationSession");
res = MessageEnumType.aTrain_InitiationOfACommunicationSession;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1802)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.acceptString ("ejected");
res = MessageEnumType.aTrainRejected;
break;
} // Case
case 'P':
{
ctxt.advance();
ctxt.acceptString ("ositionReport");
res = MessageEnumType.aTrainPositionReport;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("ccepted");
res = MessageEnumType.aTrainAccepted;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1806)");
break;
} // Switch
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.accept('k');
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
ctxt.acceptString ("InitiationOfACommunicationSession");
res = MessageEnumType.aTrack_InitiationOfACommunicationSession;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("headFree");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("equest");
res = MessageEnumType.aTrackAheadFreeRequest;
break;
} // Case
case 'G':
{
ctxt.advance();
ctxt.acceptString ("ranted");
res = MessageEnumType.aTrackAheadFreeGranted;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1812)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1813)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1814)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
ctxt.acceptString ("PositionReportConfirmedByRBC");
res = MessageEnumType.aSomPositionReportConfirmedByRBC;
break;
} // Case
case 'M':
{
ctxt.advance();
ctxt.acceptString ("PositionReport");
res = MessageEnumType.aSoMPositionReport;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1819)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.acceptString ("Authorization");
res = MessageEnumType.aSRAuthorization;
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("efused");
res = MessageEnumType.aSHRefused;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("uthorized");
res = MessageEnumType.aSHAuthorized;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1824)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1825)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
ctxt.acceptString ("ocationOfEmergencyStop");
res = MessageEnumType.aRevocationOfEmergencyStop;
break;
} // Case
case 'q':
{
ctxt.advance();
ctxt.acceptString ("uest");
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
ctxt.acceptString ("oShortenMA");
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('s')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("ejected");
res = MessageEnumType.aRequestToShortenMAIsRejected;
break;
} // Case
case 'G':
{
ctxt.advance();
ctxt.acceptString ("ranted");
res = MessageEnumType.aRequestToShortenMAIsGranted;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1834)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = MessageEnumType.aRequestToShortenMA;
} // If
break;
} // Case
default:
res = MessageEnumType.aRequestToShortenMA;
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.acceptString ("orShunting");
res = MessageEnumType.aRequestForShunting;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1836)");
break;
} // Switch
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("ognitionOfExitFromTripMode");
res = MessageEnumType.aRecognitionOfExitFromTripMode;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1838)");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.acceptString ("dioInFillRequest");
res = MessageEnumType.aRadioInFillRequest;
break;
} // Case
case 'B':
{
ctxt.advance();
ctxt.acceptString ("CRIUSystemVersion");
res = MessageEnumType.aRBCRIUSystemVersion;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1841)");
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("vementAuthority");
res = MessageEnumType.aMovementAuthority;
break;
} // Case
case 'A':
{
ctxt.advance();
switch (ctxt.current()) {
case 'W':
{
ctxt.advance();
ctxt.acceptString ("ithShiftedLocationReference");
res = MessageEnumType.aMAWithShiftedLocationReference;
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.acceptString ("equest");
res = MessageEnumType.aMARequest;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1847)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1848)");
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("nFillMA")){
res = MessageEnumType.aInFillMA;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("eneralMessage")){
res = MessageEnumType.aGeneralMessage;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.accept2('r','o');
switch (ctxt.current()) {
case 'l':
{
ctxt.advance();
ctxt.accept3('o','o','p');
res = MessageEnumType.aEuroloop;
break;
} // Case
case 'b':
{
ctxt.advance();
ctxt.acceptString ("alise");
res = MessageEnumType.aEurobalise;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1855)");
break;
} // Switch
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.acceptString ("dOfMission");
res = MessageEnumType.aEndOfMission;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1857)");
break;
} // Switch
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("onditionalEmergencyStop")){
res = MessageEnumType.aConditionalEmergencyStop;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'A':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
ctxt.acceptString ("signmentOfCoordinateSystem");
res = MessageEnumType.aAssignmentOfCoordinateSystem;
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("knowledgement");
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead1('f')){
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.acceptString ("ainData");
res = MessageEnumType.aAcknowledgementOfTrainData;
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("rminationOfACommunicationSession");
res = MessageEnumType.aAcknowledgementOfTerminationOfACommunicationSession;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1866)");
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
ctxt.acceptString ("mergencyStop");
res = MessageEnumType.aAcknowledgementOfEmergencyStop;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1868)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = MessageEnumType.aAcknowledgement;
} // If
break;
} // Case
default:
res = MessageEnumType.aAcknowledgement;
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1869)");
break;
} // Switch
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_MessageEnumType_ToString (MessageEnumType v)
{
switch (v) {
 case MessageEnumType.aEurobalise: return "Eurobalise";
 case MessageEnumType.aEuroloop: return "Euroloop";
 case MessageEnumType.aValidatedTrainData: return "ValidatedTrainData";
 case MessageEnumType.aRequestForShunting: return "RequestForShunting";
 case MessageEnumType.aMARequest: return "MARequest";
 case MessageEnumType.aTrainPositionReport: return "TrainPositionReport";
 case MessageEnumType.aRequestToShortenMAIsGranted: return "RequestToShortenMAIsGranted";
 case MessageEnumType.aRequestToShortenMAIsRejected: return "RequestToShortenMAIsRejected";
 case MessageEnumType.aAcknowledgement: return "Acknowledgement";
 case MessageEnumType.aAcknowledgementOfEmergencyStop: return "AcknowledgementOfEmergencyStop";
 case MessageEnumType.aTrackAheadFreeGranted: return "TrackAheadFreeGranted";
 case MessageEnumType.aEndOfMission: return "EndOfMission";
 case MessageEnumType.aRadioInFillRequest: return "RadioInFillRequest";
 case MessageEnumType.aTrain_NoCompatibleVersionSupported: return "Train_NoCompatibleVersionSupported";
 case MessageEnumType.aTrain_InitiationOfACommunicationSession: return "Train_InitiationOfACommunicationSession";
 case MessageEnumType.aTrain_TerminationOfACommunicationSession: return "Train_TerminationOfACommunicationSession";
 case MessageEnumType.aSoMPositionReport: return "SoMPositionReport";
 case MessageEnumType.aTrain_SessionEstablished: return "Train_SessionEstablished";
 case MessageEnumType.aSRAuthorization: return "SRAuthorization";
 case MessageEnumType.aMovementAuthority: return "MovementAuthority";
 case MessageEnumType.aRecognitionOfExitFromTripMode: return "RecognitionOfExitFromTripMode";
 case MessageEnumType.aAcknowledgementOfTrainData: return "AcknowledgementOfTrainData";
 case MessageEnumType.aRequestToShortenMA: return "RequestToShortenMA";
 case MessageEnumType.aConditionalEmergencyStop: return "ConditionalEmergencyStop";
 case MessageEnumType.aUnconditionalEmergencyStop: return "UnconditionalEmergencyStop";
 case MessageEnumType.aRevocationOfEmergencyStop: return "RevocationOfEmergencyStop";
 case MessageEnumType.aGeneralMessage: return "GeneralMessage";
 case MessageEnumType.aSHRefused: return "SHRefused";
 case MessageEnumType.aSHAuthorized: return "SHAuthorized";
 case MessageEnumType.aRBCRIUSystemVersion: return "RBCRIUSystemVersion";
 case MessageEnumType.aMAWithShiftedLocationReference: return "MAWithShiftedLocationReference";
 case MessageEnumType.aTrackAheadFreeRequest: return "TrackAheadFreeRequest";
 case MessageEnumType.aInFillMA: return "InFillMA";
 case MessageEnumType.aTrack_InitiationOfACommunicationSession: return "Track_InitiationOfACommunicationSession";
 case MessageEnumType.aAcknowledgementOfTerminationOfACommunicationSession: return "AcknowledgementOfTerminationOfACommunicationSession";
 case MessageEnumType.aTrainRejected: return "TrainRejected";
 case MessageEnumType.aTrainAccepted: return "TrainAccepted";
 case MessageEnumType.aSomPositionReportConfirmedByRBC: return "SomPositionReportConfirmedByRBC";
 case MessageEnumType.aAssignmentOfCoordinateSystem: return "AssignmentOfCoordinateSystem";
} return "";
}

public static MessageEnumType StringTo_Enum_MessageEnumType( string  str)
{
if (str.Equals("Eurobalise")){
  return MessageEnumType.aEurobalise;
} // If
if (str.Equals("Euroloop")){
  return MessageEnumType.aEuroloop;
} // If
if (str.Equals("ValidatedTrainData")){
  return MessageEnumType.aValidatedTrainData;
} // If
if (str.Equals("RequestForShunting")){
  return MessageEnumType.aRequestForShunting;
} // If
if (str.Equals("MARequest")){
  return MessageEnumType.aMARequest;
} // If
if (str.Equals("TrainPositionReport")){
  return MessageEnumType.aTrainPositionReport;
} // If
if (str.Equals("RequestToShortenMAIsGranted")){
  return MessageEnumType.aRequestToShortenMAIsGranted;
} // If
if (str.Equals("RequestToShortenMAIsRejected")){
  return MessageEnumType.aRequestToShortenMAIsRejected;
} // If
if (str.Equals("Acknowledgement")){
  return MessageEnumType.aAcknowledgement;
} // If
if (str.Equals("AcknowledgementOfEmergencyStop")){
  return MessageEnumType.aAcknowledgementOfEmergencyStop;
} // If
if (str.Equals("TrackAheadFreeGranted")){
  return MessageEnumType.aTrackAheadFreeGranted;
} // If
if (str.Equals("EndOfMission")){
  return MessageEnumType.aEndOfMission;
} // If
if (str.Equals("RadioInFillRequest")){
  return MessageEnumType.aRadioInFillRequest;
} // If
if (str.Equals("Train_NoCompatibleVersionSupported")){
  return MessageEnumType.aTrain_NoCompatibleVersionSupported;
} // If
if (str.Equals("Train_InitiationOfACommunicationSession")){
  return MessageEnumType.aTrain_InitiationOfACommunicationSession;
} // If
if (str.Equals("Train_TerminationOfACommunicationSession")){
  return MessageEnumType.aTrain_TerminationOfACommunicationSession;
} // If
if (str.Equals("SoMPositionReport")){
  return MessageEnumType.aSoMPositionReport;
} // If
if (str.Equals("Train_SessionEstablished")){
  return MessageEnumType.aTrain_SessionEstablished;
} // If
if (str.Equals("SRAuthorization")){
  return MessageEnumType.aSRAuthorization;
} // If
if (str.Equals("MovementAuthority")){
  return MessageEnumType.aMovementAuthority;
} // If
if (str.Equals("RecognitionOfExitFromTripMode")){
  return MessageEnumType.aRecognitionOfExitFromTripMode;
} // If
if (str.Equals("AcknowledgementOfTrainData")){
  return MessageEnumType.aAcknowledgementOfTrainData;
} // If
if (str.Equals("RequestToShortenMA")){
  return MessageEnumType.aRequestToShortenMA;
} // If
if (str.Equals("ConditionalEmergencyStop")){
  return MessageEnumType.aConditionalEmergencyStop;
} // If
if (str.Equals("UnconditionalEmergencyStop")){
  return MessageEnumType.aUnconditionalEmergencyStop;
} // If
if (str.Equals("RevocationOfEmergencyStop")){
  return MessageEnumType.aRevocationOfEmergencyStop;
} // If
if (str.Equals("GeneralMessage")){
  return MessageEnumType.aGeneralMessage;
} // If
if (str.Equals("SHRefused")){
  return MessageEnumType.aSHRefused;
} // If
if (str.Equals("SHAuthorized")){
  return MessageEnumType.aSHAuthorized;
} // If
if (str.Equals("RBCRIUSystemVersion")){
  return MessageEnumType.aRBCRIUSystemVersion;
} // If
if (str.Equals("MAWithShiftedLocationReference")){
  return MessageEnumType.aMAWithShiftedLocationReference;
} // If
if (str.Equals("TrackAheadFreeRequest")){
  return MessageEnumType.aTrackAheadFreeRequest;
} // If
if (str.Equals("InFillMA")){
  return MessageEnumType.aInFillMA;
} // If
if (str.Equals("Track_InitiationOfACommunicationSession")){
  return MessageEnumType.aTrack_InitiationOfACommunicationSession;
} // If
if (str.Equals("AcknowledgementOfTerminationOfACommunicationSession")){
  return MessageEnumType.aAcknowledgementOfTerminationOfACommunicationSession;
} // If
if (str.Equals("TrainRejected")){
  return MessageEnumType.aTrainRejected;
} // If
if (str.Equals("TrainAccepted")){
  return MessageEnumType.aTrainAccepted;
} // If
if (str.Equals("SomPositionReportConfirmedByRBC")){
  return MessageEnumType.aSomPositionReportConfirmedByRBC;
} // If
if (str.Equals("AssignmentOfCoordinateSystem")){
  return MessageEnumType.aAssignmentOfCoordinateSystem;
} // If
return MessageEnumType.defaultMessageEnumType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static MessageDirectionEnumType lAcceptEnum_MessageDirectionEnumType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  MessageDirectionEnumType res = MessageDirectionEnumType.defaultMessageDirectionEnumType;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.acceptString ("nToTrack");
res = MessageDirectionEnumType.aTrainToTrack;
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("kToTrain");
res = MessageDirectionEnumType.aTrackToTrain;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1873)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_MessageDirectionEnumType_ToString (MessageDirectionEnumType v)
{
switch (v) {
 case MessageDirectionEnumType.aTrainToTrack: return "TrainToTrack";
 case MessageDirectionEnumType.aTrackToTrain: return "TrackToTrain";
} return "";
}

public static MessageDirectionEnumType StringTo_Enum_MessageDirectionEnumType( string  str)
{
if (str.Equals("TrainToTrack")){
  return MessageDirectionEnumType.aTrainToTrack;
} // If
if (str.Equals("TrackToTrain")){
  return MessageDirectionEnumType.aTrackToTrain;
} // If
return MessageDirectionEnumType.defaultMessageDirectionEnumType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SPEC_IMPLEMENTED_ENUM lAcceptEnum_SPEC_IMPLEMENTED_ENUM (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  SPEC_IMPLEMENTED_ENUM res = SPEC_IMPLEMENTED_ENUM.defaultSPEC_IMPLEMENTED_ENUM;
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("tImplementable");
res = SPEC_IMPLEMENTED_ENUM.Impl_NotImplementable;
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("wRevisionAvailable");
res = SPEC_IMPLEMENTED_ENUM.Impl_NewRevisionAvailable;
break;
} // Case
case 'A':
{
ctxt.advance();
res = SPEC_IMPLEMENTED_ENUM.Impl_NA;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1878)");
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented")){
res = SPEC_IMPLEMENTED_ENUM.Impl_Implemented;
} else {
ctxt.moveBack(1);
res = SPEC_IMPLEMENTED_ENUM.Impl_NA;
} // If
break;
} // Case
default:
res = SPEC_IMPLEMENTED_ENUM.Impl_NA;
break;
} // Switch
return res;
}

public static  string  Enum_SPEC_IMPLEMENTED_ENUM_ToString (SPEC_IMPLEMENTED_ENUM v)
{
switch (v) {
 case SPEC_IMPLEMENTED_ENUM.Impl_NA: return "NA";
 case SPEC_IMPLEMENTED_ENUM.Impl_Implemented: return "Implemented";
 case SPEC_IMPLEMENTED_ENUM.Impl_NotImplementable: return "NotImplementable";
 case SPEC_IMPLEMENTED_ENUM.Impl_NewRevisionAvailable: return "NewRevisionAvailable";
} return "";
}

public static SPEC_IMPLEMENTED_ENUM StringTo_Enum_SPEC_IMPLEMENTED_ENUM( string  str)
{
if (str.Equals("NA")){
  return SPEC_IMPLEMENTED_ENUM.Impl_NA;
} // If
if (str.Equals("Implemented")){
  return SPEC_IMPLEMENTED_ENUM.Impl_Implemented;
} // If
if (str.Equals("NotImplementable")){
  return SPEC_IMPLEMENTED_ENUM.Impl_NotImplementable;
} // If
if (str.Equals("NewRevisionAvailable")){
  return SPEC_IMPLEMENTED_ENUM.Impl_NewRevisionAvailable;
} // If
return SPEC_IMPLEMENTED_ENUM.defaultSPEC_IMPLEMENTED_ENUM;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_IO lAcceptEnum_ST_IO (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_IO res = ST_IO.defaultST_IO;
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead2('u','t')){
res = ST_IO.StIO_Out;
} else {
ctxt.moveBack(1);
res = ST_IO.StIO_NA;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead1('A')){
res = ST_IO.StIO_NA;
} else {
ctxt.moveBack(1);
res = ST_IO.StIO_NA;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('n')){
res = ST_IO.StIO_In;
} else {
ctxt.moveBack(1);
res = ST_IO.StIO_NA;
} // If
break;
} // Case
default:
res = ST_IO.StIO_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_IO_ToString (ST_IO v)
{
switch (v) {
 case ST_IO.StIO_NA: return "NA";
 case ST_IO.StIO_In: return "In";
 case ST_IO.StIO_Out: return "Out";
} return "";
}

public static ST_IO StringTo_Enum_ST_IO( string  str)
{
if (str.Equals("NA")){
  return ST_IO.StIO_NA;
} // If
if (str.Equals("In")){
  return ST_IO.StIO_In;
} // If
if (str.Equals("Out")){
  return ST_IO.StIO_Out;
} // If
return ST_IO.defaultST_IO;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_INTERFACE lAcceptEnum_ST_INTERFACE (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_INTERFACE res = ST_INTERFACE.defaultST_INTERFACE;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead2('I','U')){
res = ST_INTERFACE.StInterface_TIU;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('T','M')){
res = ST_INTERFACE.StInterface_RTM;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead1('A')){
res = ST_INTERFACE.StInterface_NA;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'J':
{
ctxt.advance();
if (ctxt.lookAhead2('R','U')){
res = ST_INTERFACE.StInterface_JRU;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAhead2('M','I')){
res = ST_INTERFACE.StInterface_DMI;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
default:
res = ST_INTERFACE.StInterface_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_INTERFACE_ToString (ST_INTERFACE v)
{
switch (v) {
 case ST_INTERFACE.StInterface_NA: return "NA";
 case ST_INTERFACE.StInterface_DMI: return "DMI";
 case ST_INTERFACE.StInterface_RTM: return "RTM";
 case ST_INTERFACE.StInterface_JRU: return "JRU";
 case ST_INTERFACE.StInterface_TIU: return "TIU";
} return "";
}

public static ST_INTERFACE StringTo_Enum_ST_INTERFACE( string  str)
{
if (str.Equals("NA")){
  return ST_INTERFACE.StInterface_NA;
} // If
if (str.Equals("DMI")){
  return ST_INTERFACE.StInterface_DMI;
} // If
if (str.Equals("RTM")){
  return ST_INTERFACE.StInterface_RTM;
} // If
if (str.Equals("JRU")){
  return ST_INTERFACE.StInterface_JRU;
} // If
if (str.Equals("TIU")){
  return ST_INTERFACE.StInterface_TIU;
} // If
return ST_INTERFACE.defaultST_INTERFACE;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_LEVEL lAcceptEnum_ST_LEVEL (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_LEVEL res = ST_LEVEL.defaultST_LEVEL;
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead1('A')){
res = ST_LEVEL.StLevel_NA;
} else {
ctxt.moveBack(1);
res = ST_LEVEL.StLevel_NA;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
ctxt.accept2('T','M');
res = ST_LEVEL.StLevel_LSTM;
break;
} // Case
case '3':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L3;
break;
} // Case
case '2':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L2;
break;
} // Case
case '1':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L1;
break;
} // Case
case '0':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L0;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1895)");
break;
} // Switch
break;
} // Case
default:
res = ST_LEVEL.StLevel_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_LEVEL_ToString (ST_LEVEL v)
{
switch (v) {
 case ST_LEVEL.StLevel_NA: return "NA";
 case ST_LEVEL.StLevel_L0: return "L0";
 case ST_LEVEL.StLevel_L1: return "L1";
 case ST_LEVEL.StLevel_LSTM: return "LSTM";
 case ST_LEVEL.StLevel_L2: return "L2";
 case ST_LEVEL.StLevel_L3: return "L3";
} return "";
}

public static ST_LEVEL StringTo_Enum_ST_LEVEL( string  str)
{
if (str.Equals("NA")){
  return ST_LEVEL.StLevel_NA;
} // If
if (str.Equals("L0")){
  return ST_LEVEL.StLevel_L0;
} // If
if (str.Equals("L1")){
  return ST_LEVEL.StLevel_L1;
} // If
if (str.Equals("LSTM")){
  return ST_LEVEL.StLevel_LSTM;
} // If
if (str.Equals("L2")){
  return ST_LEVEL.StLevel_L2;
} // If
if (str.Equals("L3")){
  return ST_LEVEL.StLevel_L3;
} // If
return ST_LEVEL.defaultST_LEVEL;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_MODE lAcceptEnum_ST_MODE (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_MODE res = ST_MODE.defaultST_MODE;
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAhead1('F')){
res = ST_MODE.Mode_UF;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead1('R')){
res = ST_MODE.Mode_TR;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
res = ST_MODE.Mode_SR;
break;
} // Case
case 'N':
{
ctxt.advance();
res = ST_MODE.Mode_SN;
break;
} // Case
case 'L':
{
ctxt.advance();
res = ST_MODE.Mode_SL;
break;
} // Case
case 'H':
{
ctxt.advance();
res = ST_MODE.Mode_SH;
break;
} // Case
case 'F':
{
ctxt.advance();
res = ST_MODE.Mode_SF;
break;
} // Case
case 'B':
{
ctxt.advance();
res = ST_MODE.Mode_SB;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1905)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead1('E')){
res = ST_MODE.Mode_RE;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
res = ST_MODE.Mode_PT;
break;
} // Case
case 'S':
{
ctxt.advance();
ctxt.accept('H');
res = ST_MODE.Mode_PSH;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1910)");
break;
} // Switch
break;
} // Case
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_OS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
res = ST_MODE.Mode_NP;
break;
} // Case
case 'L':
{
ctxt.advance();
res = ST_MODE.Mode_NL;
break;
} // Case
case 'A':
{
ctxt.advance();
res = ST_MODE.Mode_NA;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1916)");
break;
} // Switch
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_LS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_IS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_FS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
default:
res = ST_MODE.Mode_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_MODE_ToString (ST_MODE v)
{
switch (v) {
 case ST_MODE.Mode_NA: return "NA";
 case ST_MODE.Mode_IS: return "IS";
 case ST_MODE.Mode_NP: return "NP";
 case ST_MODE.Mode_SF: return "SF";
 case ST_MODE.Mode_SL: return "SL";
 case ST_MODE.Mode_SB: return "SB";
 case ST_MODE.Mode_SH: return "SH";
 case ST_MODE.Mode_FS: return "FS";
 case ST_MODE.Mode_UF: return "UF";
 case ST_MODE.Mode_SR: return "SR";
 case ST_MODE.Mode_OS: return "OS";
 case ST_MODE.Mode_TR: return "TR";
 case ST_MODE.Mode_PT: return "PT";
 case ST_MODE.Mode_NL: return "NL";
 case ST_MODE.Mode_SN: return "SN";
 case ST_MODE.Mode_RE: return "RE";
 case ST_MODE.Mode_LS: return "LS";
 case ST_MODE.Mode_PSH: return "PSH";
} return "";
}

public static ST_MODE StringTo_Enum_ST_MODE( string  str)
{
if (str.Equals("NA")){
  return ST_MODE.Mode_NA;
} // If
if (str.Equals("IS")){
  return ST_MODE.Mode_IS;
} // If
if (str.Equals("NP")){
  return ST_MODE.Mode_NP;
} // If
if (str.Equals("SF")){
  return ST_MODE.Mode_SF;
} // If
if (str.Equals("SL")){
  return ST_MODE.Mode_SL;
} // If
if (str.Equals("SB")){
  return ST_MODE.Mode_SB;
} // If
if (str.Equals("SH")){
  return ST_MODE.Mode_SH;
} // If
if (str.Equals("FS")){
  return ST_MODE.Mode_FS;
} // If
if (str.Equals("UF")){
  return ST_MODE.Mode_UF;
} // If
if (str.Equals("SR")){
  return ST_MODE.Mode_SR;
} // If
if (str.Equals("OS")){
  return ST_MODE.Mode_OS;
} // If
if (str.Equals("TR")){
  return ST_MODE.Mode_TR;
} // If
if (str.Equals("PT")){
  return ST_MODE.Mode_PT;
} // If
if (str.Equals("NL")){
  return ST_MODE.Mode_NL;
} // If
if (str.Equals("SN")){
  return ST_MODE.Mode_SN;
} // If
if (str.Equals("RE")){
  return ST_MODE.Mode_RE;
} // If
if (str.Equals("LS")){
  return ST_MODE.Mode_LS;
} // If
if (str.Equals("PSH")){
  return ST_MODE.Mode_PSH;
} // If
return ST_MODE.defaultST_MODE;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RulePriority lAcceptEnum_RulePriority (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  RulePriority res = RulePriority.defaultRulePriority;
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erification")){
res = RulePriority.aVerification;
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdate")){
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
ctxt.accept2('U','T');
res = RulePriority.aUpdateOUT;
break;
} // Case
case 'I':
{
ctxt.advance();
ctxt.acceptString ("NTERNAL");
res = RulePriority.aUpdateINTERNAL;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1924)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("rocessing")){
res = RulePriority.aProcessing;
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("leanUp")){
res = RulePriority.aCleanUp;
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
default:
res = RulePriority.aProcessing;
break;
} // Switch
return res;
}

public static  string  Enum_RulePriority_ToString (RulePriority v)
{
switch (v) {
 case RulePriority.aVerification: return "Verification";
 case RulePriority.aUpdateINTERNAL: return "UpdateINTERNAL";
 case RulePriority.aProcessing: return "Processing";
 case RulePriority.aUpdateOUT: return "UpdateOUT";
 case RulePriority.aCleanUp: return "CleanUp";
} return "";
}

public static RulePriority StringTo_Enum_RulePriority( string  str)
{
if (str.Equals("Verification")){
  return RulePriority.aVerification;
} // If
if (str.Equals("UpdateINTERNAL")){
  return RulePriority.aUpdateINTERNAL;
} // If
if (str.Equals("Processing")){
  return RulePriority.aProcessing;
} // If
if (str.Equals("UpdateOUT")){
  return RulePriority.aUpdateOUT;
} // If
if (str.Equals("CleanUp")){
  return RulePriority.aCleanUp;
} // If
return RulePriority.defaultRulePriority;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static PrecisionEnum lAcceptEnum_PrecisionEnum (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  PrecisionEnum res = PrecisionEnum.defaultPrecisionEnum;
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("ntegerPrecision")){
res = PrecisionEnum.aIntegerPrecision;
} else {
ctxt.moveBack(1);
res = PrecisionEnum.aIntegerPrecision;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("oublePrecision")){
res = PrecisionEnum.aDoublePrecision;
} else {
ctxt.moveBack(1);
res = PrecisionEnum.aIntegerPrecision;
} // If
break;
} // Case
default:
res = PrecisionEnum.aIntegerPrecision;
break;
} // Switch
return res;
}

public static  string  Enum_PrecisionEnum_ToString (PrecisionEnum v)
{
switch (v) {
 case PrecisionEnum.aIntegerPrecision: return "IntegerPrecision";
 case PrecisionEnum.aDoublePrecision: return "DoublePrecision";
} return "";
}

public static PrecisionEnum StringTo_Enum_PrecisionEnum( string  str)
{
if (str.Equals("IntegerPrecision")){
  return PrecisionEnum.aIntegerPrecision;
} // If
if (str.Equals("DoublePrecision")){
  return PrecisionEnum.aDoublePrecision;
} // If
return PrecisionEnum.defaultPrecisionEnum;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBMessageType lAcceptEnum_DBMessageType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  DBMessageType res = DBMessageType.defaultDBMessageType;
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('U','R','O')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("ADIO");
res = DBMessageType.aEURORADIO;
break;
} // Case
case 'L':
{
ctxt.advance();
ctxt.accept3('O','O','P');
res = DBMessageType.aEUROLOOP;
break;
} // Case
case 'B':
{
ctxt.advance();
ctxt.acceptString ("ALISE");
res = DBMessageType.aEUROBALISE;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1933)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_DBMessageType_ToString (DBMessageType v)
{
switch (v) {
 case DBMessageType.aEUROBALISE: return "EUROBALISE";
 case DBMessageType.aEUROLOOP: return "EUROLOOP";
 case DBMessageType.aEURORADIO: return "EURORADIO";
} return "";
}

public static DBMessageType StringTo_Enum_DBMessageType( string  str)
{
if (str.Equals("EUROBALISE")){
  return DBMessageType.aEUROBALISE;
} // If
if (str.Equals("EUROLOOP")){
  return DBMessageType.aEUROLOOP;
} // If
if (str.Equals("EURORADIO")){
  return DBMessageType.aEURORADIO;
} // If
return DBMessageType.defaultDBMessageType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ExpectationKind lAcceptEnum_ExpectationKind (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ExpectationKind res = ExpectationKind.defaultExpectationKind;
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("nstantaneous")){
res = ExpectationKind.aInstantaneous;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ontinuous")){
res = ExpectationKind.aContinuous;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_ExpectationKind_ToString (ExpectationKind v)
{
switch (v) {
 case ExpectationKind.aInstantaneous: return "Instantaneous";
 case ExpectationKind.aContinuous: return "Continuous";
} return "";
}

public static ExpectationKind StringTo_Enum_ExpectationKind( string  str)
{
if (str.Equals("Instantaneous")){
  return ExpectationKind.aInstantaneous;
} // If
if (str.Equals("Continuous")){
  return ExpectationKind.aContinuous;
} // If
return ExpectationKind.defaultExpectationKind;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static bool lAcceptBoolean (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator = 0;
#pragma warning restore 0168, 0219
  bool res = false;
switch (ctxt.current()) {
case 'y':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('s')){
res = true;
} else {
res = true;
} // If
break;
} // Case
default:
res = true;
break;
} // Switch
break;
} // Case
case 't':
{
ctxt.advance();
ctxt.accept3('r','u','e');
res = true;
break;
} // Case
case 'o':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
res = true;
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.accept('f');
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1942)");
break;
} // Switch
break;
} // Case
case 'n':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
res = false;
break;
} // Case
default:
res = false;
break;
} // Switch
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.acceptString ("alse");
res = false;
break;
} // Case
case 'Y':
{
ctxt.advance();
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = true;
} else {
res = true;
} // If
break;
} // Case
default:
res = true;
break;
} // Switch
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.accept2('u','e');
res = true;
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.accept2('U','E');
res = true;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1951)");
break;
} // Switch
break;
} // Case
case 'O':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
res = true;
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.accept('f');
res = false;
break;
} // Case
case 'N':
{
ctxt.advance();
res = true;
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.accept('F');
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1957)");
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
res = false;
break;
} // Case
default:
res = false;
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'a':
{
ctxt.advance();
ctxt.accept3('l','s','e');
res = false;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.accept3('L','S','E');
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1963)");
break;
} // Switch
break;
} // Case
case '1':
{
ctxt.advance();
res = true;
break;
} // Case
case '0':
{
ctxt.advance();
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1966)");
break;
} // Switch
return res;
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static BaseModelElement lAccept_Poly_BaseModelElement (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    BaseModelElement res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslation")){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_TranslationDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("stCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('b','S')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAhead2('e','p')){
ctxt.accept(quoteChar);
res = lAccept_SubStep(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("quence")){
ctxt.accept(quoteChar);
res = lAccept_SubSequence(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('p')){
ctxt.accept(quoteChar);
res = lAccept_Step(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("ecification")){
ctxt.accept(quoteChar);
res = lAccept_Specification(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("urceText")){
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("ortcut")){
switch (ctxt.current()) {
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("older")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutFolder(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("qRef")){
ctxt.accept(quoteChar);
res = lAccept_ReqRef(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("cedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("Condition")){
ctxt.accept(quoteChar);
res = lAccept_PreCondition(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("eter")){
ctxt.accept(quoteChar);
res = lAccept_Parameter(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("raph")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("evision")){
ctxt.accept(quoteChar);
res = lAccept_ParagraphRevision(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ameSpace")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_NameSpaceRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("nction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'r':
{
ctxt.advance();
if (ctxt.lookAhead3('a','m','e')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_FrameRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("lder")){
ctxt.accept(quoteChar);
res = lAccept_Folder(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
if (ctxt.lookAheadString("pectation")){
ctxt.accept(quoteChar);
res = lAccept_Expectation(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAhead2('u','m')){
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue")){
ctxt.accept(quoteChar);
res = lAccept_EnumValue(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'D':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("ctionary")){
ctxt.accept(quoteChar);
res = lAccept_Dictionary(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("acket")){
ctxt.accept(quoteChar);
res = lAccept_DBPacket(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("essage")){
ctxt.accept(quoteChar);
res = lAccept_DBMessage(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("ield")){
ctxt.accept(quoteChar);
res = lAccept_DBField(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'C':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("llection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("apter")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_ChapterRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('s','e')){
ctxt.accept(quoteChar);
res = lAccept_Case(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'A':
{
ctxt.advance();
if (ctxt.lookAheadString("ction")){
ctxt.accept(quoteChar);
res = lAccept_Action(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Namable lAccept_Poly_Namable (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    Namable res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslation")){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_TranslationDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("stCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('b','S')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAhead2('e','p')){
ctxt.accept(quoteChar);
res = lAccept_SubStep(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("quence")){
ctxt.accept(quoteChar);
res = lAccept_SubSequence(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('p')){
ctxt.accept(quoteChar);
res = lAccept_Step(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("ecification")){
ctxt.accept(quoteChar);
res = lAccept_Specification(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("urceText")){
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("ortcut")){
switch (ctxt.current()) {
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("older")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutFolder(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ocedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("eter")){
ctxt.accept(quoteChar);
res = lAccept_Parameter(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("raph")){
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ameSpace")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_NameSpaceRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("nction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'r':
{
ctxt.advance();
if (ctxt.lookAhead3('a','m','e')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_FrameRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("lder")){
ctxt.accept(quoteChar);
res = lAccept_Folder(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
if (ctxt.lookAheadString("pectation")){
ctxt.accept(quoteChar);
res = lAccept_Expectation(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAhead2('u','m')){
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue")){
ctxt.accept(quoteChar);
res = lAccept_EnumValue(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAhead1('B')){
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("acket")){
ctxt.accept(quoteChar);
res = lAccept_DBPacket(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("essage")){
ctxt.accept(quoteChar);
res = lAccept_DBMessage(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("ield")){
ctxt.accept(quoteChar);
res = lAccept_DBField(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("llection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("apter")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_ChapterRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('s','e')){
ctxt.accept(quoteChar);
res = lAccept_Case(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ReferencesParagraph lAccept_Poly_ReferencesParagraph (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    ReferencesParagraph res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("estCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
if (ctxt.lookAhead1('t')){
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ocedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("ragraph")){
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("unction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ollection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ReqRelated lAccept_Poly_ReqRelated (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    ReqRelated res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("estCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
if (ctxt.lookAhead1('t')){
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("rocedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("unction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ollection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Dictionary lAccept_Dictionary (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Dictionary>";
  Dictionary res = aFactory.createDictionary();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RuleDisabling lAccept_RuleDisabling (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RuleDisabling>";
  RuleDisabling res = aFactory.createRuleDisabling();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static NameSpaceRef lAccept_NameSpaceRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</NameSpaceRef>";
  NameSpaceRef res = aFactory.createNameSpaceRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static NameSpace lAccept_NameSpace (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</NameSpace>";
  NameSpace res = aFactory.createNameSpace();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ReqRef lAccept_ReqRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ReqRef>";
  ReqRef res = aFactory.createReqRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Type lAccept_Poly_Type (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    Type res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
if (ctxt.lookAhead1('t')){
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("teMachine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("ange")){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("unction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ollection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Enum lAccept_Enum (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Enum>";
  Enum res = aFactory.createEnum();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static EnumValue lAccept_EnumValue (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</EnumValue>";
  EnumValue res = aFactory.createEnumValue();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Range lAccept_Range (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Range>";
  Range res = aFactory.createRange();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Structure lAccept_Structure (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Structure>";
  Structure res = aFactory.createStructure();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static StructureElement lAccept_StructureElement (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</StructureElement>";
  StructureElement res = aFactory.createStructureElement();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Collection lAccept_Collection (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Collection>";
  Collection res = aFactory.createCollection();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Function lAccept_Function (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Function>";
  Function res = aFactory.createFunction();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Parameter lAccept_Parameter (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Parameter>";
  Parameter res = aFactory.createParameter();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Case lAccept_Case (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Case>";
  Case res = aFactory.createCase();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Procedure lAccept_Procedure (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Procedure>";
  Procedure res = aFactory.createProcedure();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static StateMachine lAccept_StateMachine (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</StateMachine>";
  StateMachine res = aFactory.createStateMachine();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static State lAccept_State (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</State>";
  State res = aFactory.createState();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Variable lAccept_Variable (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Variable>";
  Variable res = aFactory.createVariable();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Rule lAccept_Rule (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Rule>";
  Rule res = aFactory.createRule();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RuleCondition lAccept_RuleCondition (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RuleCondition>";
  RuleCondition res = aFactory.createRuleCondition();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static PreCondition lAccept_PreCondition (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</PreCondition>";
  PreCondition res = aFactory.createPreCondition();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Action lAccept_Action (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Action>";
  Action res = aFactory.createAction();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static FrameRef lAccept_FrameRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</FrameRef>";
  FrameRef res = aFactory.createFrameRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Frame lAccept_Frame (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Frame>";
  Frame res = aFactory.createFrame();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SubSequence lAccept_SubSequence (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SubSequence>";
  SubSequence res = aFactory.createSubSequence();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TestCase lAccept_TestCase (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</TestCase>";
  TestCase res = aFactory.createTestCase();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Step lAccept_Step (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Step>";
  Step res = aFactory.createStep();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SubStep lAccept_SubStep (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SubStep>";
  SubStep res = aFactory.createSubStep();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Expectation lAccept_Expectation (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Expectation>";
  Expectation res = aFactory.createExpectation();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBMessage lAccept_DBMessage (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</DBMessage>";
  DBMessage res = aFactory.createDBMessage();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBPacket lAccept_DBPacket (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</DBPacket>";
  DBPacket res = aFactory.createDBPacket();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBField lAccept_DBField (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</DBField>";
  DBField res = aFactory.createDBField();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TranslationDictionary lAccept_TranslationDictionary (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</TranslationDictionary>";
  TranslationDictionary res = aFactory.createTranslationDictionary();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Folder lAccept_Folder (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Folder>";
  Folder res = aFactory.createFolder();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Translation lAccept_Translation (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Translation>";
  Translation res = aFactory.createTranslation();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SourceText lAccept_SourceText (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SourceText>";
  SourceText res = aFactory.createSourceText();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ShortcutDictionary lAccept_ShortcutDictionary (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ShortcutDictionary>";
  ShortcutDictionary res = aFactory.createShortcutDictionary();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ShortcutFolder lAccept_ShortcutFolder (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ShortcutFolder>";
  ShortcutFolder res = aFactory.createShortcutFolder();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Shortcut lAccept_Shortcut (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Shortcut>";
  Shortcut res = aFactory.createShortcut();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Specification lAccept_Specification (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Specification>";
  Specification res = aFactory.createSpecification();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ChapterRef lAccept_ChapterRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ChapterRef>";
  ChapterRef res = aFactory.createChapterRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Chapter lAccept_Chapter (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Chapter>";
  Chapter res = aFactory.createChapter();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Paragraph lAccept_Paragraph (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Paragraph>";
  Paragraph res = aFactory.createParagraph();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Message lAccept_Message (XmlBContext ctxt, 
                          string  endingTag)

  {
  Message res = aFactory.createMessage();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static MsgVariable lAccept_MsgVariable (XmlBContext ctxt, 
                          string  endingTag)

  {
  MsgVariable res = aFactory.createMsgVariable();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TypeSpec lAccept_TypeSpec (XmlBContext ctxt, 
                          string  endingTag)

  {
  TypeSpec res = aFactory.createTypeSpec();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Values lAccept_Values (XmlBContext ctxt, 
                          string  endingTag)

  {
  Values res = aFactory.createValues();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static special_or_reserved_values lAccept_special_or_reserved_values (XmlBContext ctxt, 
                          string  endingTag)

  {
  special_or_reserved_values res = aFactory.createspecial_or_reserved_values();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static special_or_reserved_value lAccept_special_or_reserved_value (XmlBContext ctxt, 
                          string  endingTag)

  {
  special_or_reserved_value res = aFactory.createspecial_or_reserved_value();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static mask lAccept_mask (XmlBContext ctxt, 
                          string  endingTag)

  {
  mask res = aFactory.createmask();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static match lAccept_match (XmlBContext ctxt, 
                          string  endingTag)

  {
  match res = aFactory.creatematch();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static meaning lAccept_meaning (XmlBContext ctxt, 
                          string  endingTag)

  {
  meaning res = aFactory.createmeaning();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static match_range lAccept_match_range (XmlBContext ctxt, 
                          string  endingTag)

  {
  match_range res = aFactory.creatematch_range();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static resolution_formula lAccept_resolution_formula (XmlBContext ctxt, 
                          string  endingTag)

  {
  resolution_formula res = aFactory.createresolution_formula();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static value lAccept_value (XmlBContext ctxt, 
                          string  endingTag)

  {
  value res = aFactory.createvalue();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static char_value lAccept_char_value (XmlBContext ctxt, 
                          string  endingTag)

  {
  char_value res = aFactory.createchar_value();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ParagraphRevision lAccept_ParagraphRevision (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ParagraphRevision>";
  ParagraphRevision res = aFactory.createParagraphRevision();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <summary>Utility function which parse an entity character 
/// as defined in the XMLBooster configuration.</summary>
/// <param name="ctxt">the context from which the data must be parsed</param>
static char lAcceptPcDataChr(XmlBContext ctxt)

{
    char c = (char)0;
    int indicator=0;
switch (ctxt.current()) {
case 'q':
{
ctxt.advance();
ctxt.acceptString ("uot;");
indicator = 2119;
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.acceptString ("bsp;");
indicator = 2118;
break;
} // Case
case 'l':
{
ctxt.advance();
ctxt.accept2('t',';');
indicator = 2116;
break;
} // Case
case 'g':
{
ctxt.advance();
ctxt.accept2('t',';');
indicator = 2117;
break;
} // Case
case 'a':
{
ctxt.advance();
switch (ctxt.current()) {
case 'p':
{
ctxt.advance();
ctxt.accept3('o','s',';');
indicator = 2120;
break;
} // Case
case 'm':
{
ctxt.advance();
ctxt.accept2('p',';');
indicator = 2115;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2128)");
break;
} // Switch
break;
} // Case
case '#':
{
ctxt.advance();
ctxt.accept('x');
indicator = 2121;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2130)");
break;
} // Switch
switch (indicator) {
case 2115: {
c = XMLB_AMPERSAND;
break;
} // End of dispatch label
case 2116: {
c = XMLB_LESS;
break;
} // End of dispatch label
case 2117: {
c = XMLB_GREATER;
break;
} // End of dispatch label
case 2118: {
c = XMLB_NBSP;
break;
} // End of dispatch label
case 2119: {
c = XMLB_QUOT;
break;
} // End of dispatch label
case 2120: {
c = XMLB_APOS;
break;
} // End of dispatch label
case 2121: {
c = (char) ctxt.acceptHexa();
ctxt.accept(';');
break;
} // End of dispatch label
} // Dispatch
return c;
}
/// <summary>Utility function which parse a PCDATA component 
/// from a context. It takes the entities defined in the
/// in the configuration into account.</summary>
/// <param name="ctxt">the context from which the data must be 
///        parsed</param>
/// <param name="maxLen">the maximal number of characters that 
///        can be read.</param>
/// <param name="closingCh">a character on which parsing must stop
///        in addition to the standard &lt; character.</param>
/// <param name="wsMode">indicates PRESERVE (default), REPLACE or COLLAPSE.</param>
public static  string  lAcceptPcData(XmlBContext ctxt, 
                                   int maxLen,
                                   char closingCh,
                                   int wsMode)

 {
    char ch;
    char lastch = '.';
    System.Text.StringBuilder buff;
     string  res;

  buff = new System.Text.StringBuilder();
  bool go_on = true;
  while (go_on) 
{
  go_on = false;
  while ((ctxt.current() != '<') && (ctxt.current() != closingCh)) // while 1 
{
    ch = ctxt.current();
ctxt.advance();
if (ch == '&'){
ch = lAcceptPcDataChr(ctxt);
} else {
if (wsMode >= WS_REPLACE){
if (ch == '\t' || ch == '\n' || ch == '\r'){
ch = ' ';
} // If
if (wsMode == WS_COLLAPSE){
if ((ch == ' ') && ((lastch == ' ') || (buff.Length == 0))){
ch = (char)0;
} else {
lastch = ch;
} // If
} else {
lastch = ch;
} // If
} // If
} // If
if (ch != '\0'){
buff.Append (ch);
} // If
}
// end while
if (ctxt.current() == '<'){
if (ctxt.lookAheadString("<![CDATA[")){
     string  cdata = ctxt.acceptUntil("]]>", true);
    buff.Append (cdata);
    go_on = true;
} else {
if (ctxt.lookAhead2('<','?')){
ctxt.skipTill ('?');
ctxt.accept2('?','>');
go_on = true;
} else {
} // If
} // If
} // If
}
if (wsMode == WS_COLLAPSE && lastch == ' ' && buff. Length > 0){
res = buff.ToString (0, buff.Length -1);
} else {
res = buff.ToString();
} // If
if ((maxLen > 0) && (res.Length > maxLen)){
ctxt.recoverableFail ("Maximum length exceeded");
} // If
return res;
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  private static bool requiresEscape (char a)
  {
    switch (a)
    {
      case XMLB_AMPERSAND:
      case XMLB_LESS:
      case XMLB_GREATER:
      case XMLB_QUOT:
      case XMLB_APOS:
        return true;
      default: break;
    }
    return false;
  }
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  private static bool requiresEscape ( string  a)
  {
    for (int i=0; i < a.Length; i++)
    {
      if (requiresEscape(a[i]))
        return true;
    }
    return false	;
  }
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw,  string  a)
    {
      bool escaped = false;
      
      if (a == null)
      {
          return;
      }
      escaped = requiresEscape (a);
      if (! escaped)
        pw.Write (a);
      else
      {
        char c;
        for (int i = 0; i < a.Length; i++)
        {
          c = a[i];
          switch (c)
            {
              case XMLB_AMPERSAND:
                  pw.Write("&amp;"); 
                  break;
              case XMLB_LESS:
                  pw.Write("&lt;"); 
                  break;
              case XMLB_GREATER:
                  pw.Write("&gt;"); 
                  break;
              case XMLB_QUOT:
                  pw.Write("&quot;"); 
                  break;
              case XMLB_APOS:
                  pw.Write("&apos;"); 
                  break;
               default: 
                   pw.Write(c);
                   break;
            }
        }
      }
    }
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, bool flag)
    {
      if (flag)
// TrueString is: TRUE
// FalseString is: FALSE
        pw.Write ("TRUE");
       else
        pw.Write("FALSE");
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, object obj)
    {
      if (obj != null)
        unParsePcData (pw, obj.ToString());
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, int val)
    {
      pw.Write (val);
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, long val)
    {
      pw.Write (val);
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, double val)
    {
      XmlBConverter conv;
      conv = getConverter();
      if(conv != null)
        pw.Write(conv.doubleToString(val));
       else
        pw.Write (val);
    }



private static Factory aFactory;
/// <summary>Sets the factory to introduce an indirection level
/// so that the user can externally define derived classes
/// to be used in place of the XMLBooster-generated 
/// classes.</summary>
public static void setFactory (Factory f) { aFactory = f; }

/// <returns>the currently active factory.</returns>
public static Factory getFactory () { return aFactory; }
static private acceptor theOne = null;
static public acceptor getUnique()
{
  if (theOne == null) { theOne = new acceptor(); }
  return theOne;
}

static public void setUnique(acceptor acc)
{
  theOne = acc;
}


/// <summary>Top level function to parse an Dictionary from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Dictionary acceptDictionary(XmlBContext ctxt)

  {
Dictionary res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Dictionary");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Dictionary(ctxt, "</Dictionary>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RuleDisabling from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RuleDisabling acceptRuleDisabling(XmlBContext ctxt)

  {
RuleDisabling res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RuleDisabling");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RuleDisabling(ctxt, "</RuleDisabling>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an NameSpace from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static NameSpace acceptNameSpace(XmlBContext ctxt)

  {
NameSpace res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<NameSpace");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_NameSpace(ctxt, "</NameSpace>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ReqRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ReqRef acceptReqRef(XmlBContext ctxt)

  {
ReqRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ReqRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ReqRef(ctxt, "</ReqRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Enum from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Enum acceptEnum(XmlBContext ctxt)

  {
Enum res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Enum");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Enum(ctxt, "</Enum>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an EnumValue from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static EnumValue acceptEnumValue(XmlBContext ctxt)

  {
EnumValue res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<EnumValue");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_EnumValue(ctxt, "</EnumValue>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Range from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Range acceptRange(XmlBContext ctxt)

  {
Range res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Range");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Range(ctxt, "</Range>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Structure from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Structure acceptStructure(XmlBContext ctxt)

  {
Structure res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Structure");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Structure(ctxt, "</Structure>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an StructureElement from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static StructureElement acceptStructureElement(XmlBContext ctxt)

  {
StructureElement res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<StructureElement");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_StructureElement(ctxt, "</StructureElement>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Collection from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Collection acceptCollection(XmlBContext ctxt)

  {
Collection res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Collection");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Collection(ctxt, "</Collection>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Function from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Function acceptFunction(XmlBContext ctxt)

  {
Function res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Function");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Function(ctxt, "</Function>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Parameter from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Parameter acceptParameter(XmlBContext ctxt)

  {
Parameter res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Parameter");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Parameter(ctxt, "</Parameter>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Case from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Case acceptCase(XmlBContext ctxt)

  {
Case res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Case");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Case(ctxt, "</Case>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Procedure from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Procedure acceptProcedure(XmlBContext ctxt)

  {
Procedure res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Procedure");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Procedure(ctxt, "</Procedure>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an StateMachine from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static StateMachine acceptStateMachine(XmlBContext ctxt)

  {
StateMachine res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<StateMachine");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_StateMachine(ctxt, "</StateMachine>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an State from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static State acceptState(XmlBContext ctxt)

  {
State res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<State");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_State(ctxt, "</State>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Variable from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Variable acceptVariable(XmlBContext ctxt)

  {
Variable res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Variable");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Variable(ctxt, "</Variable>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Rule from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Rule acceptRule(XmlBContext ctxt)

  {
Rule res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Rule");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Rule(ctxt, "</Rule>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RuleCondition from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RuleCondition acceptRuleCondition(XmlBContext ctxt)

  {
RuleCondition res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RuleCondition");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RuleCondition(ctxt, "</RuleCondition>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an PreCondition from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static PreCondition acceptPreCondition(XmlBContext ctxt)

  {
PreCondition res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<PreCondition");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_PreCondition(ctxt, "</PreCondition>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Action from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Action acceptAction(XmlBContext ctxt)

  {
Action res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Action");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Action(ctxt, "</Action>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Frame from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Frame acceptFrame(XmlBContext ctxt)

  {
Frame res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Frame");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Frame(ctxt, "</Frame>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SubSequence from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SubSequence acceptSubSequence(XmlBContext ctxt)

  {
SubSequence res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SubSequence");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SubSequence(ctxt, "</SubSequence>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an TestCase from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static TestCase acceptTestCase(XmlBContext ctxt)

  {
TestCase res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<TestCase");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_TestCase(ctxt, "</TestCase>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Step from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Step acceptStep(XmlBContext ctxt)

  {
Step res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Step");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Step(ctxt, "</Step>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SubStep from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SubStep acceptSubStep(XmlBContext ctxt)

  {
SubStep res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SubStep");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SubStep(ctxt, "</SubStep>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Expectation from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Expectation acceptExpectation(XmlBContext ctxt)

  {
Expectation res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Expectation");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Expectation(ctxt, "</Expectation>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an DBMessage from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static DBMessage acceptDBMessage(XmlBContext ctxt)

  {
DBMessage res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<DBMessage");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_DBMessage(ctxt, "</DBMessage>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an DBPacket from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static DBPacket acceptDBPacket(XmlBContext ctxt)

  {
DBPacket res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<DBPacket");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_DBPacket(ctxt, "</DBPacket>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an DBField from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static DBField acceptDBField(XmlBContext ctxt)

  {
DBField res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<DBField");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_DBField(ctxt, "</DBField>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an TranslationDictionary from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static TranslationDictionary acceptTranslationDictionary(XmlBContext ctxt)

  {
TranslationDictionary res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<TranslationDictionary");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_TranslationDictionary(ctxt, "</TranslationDictionary>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Folder from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Folder acceptFolder(XmlBContext ctxt)

  {
Folder res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Folder");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Folder(ctxt, "</Folder>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Translation from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Translation acceptTranslation(XmlBContext ctxt)

  {
Translation res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Translation");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Translation(ctxt, "</Translation>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SourceText from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SourceText acceptSourceText(XmlBContext ctxt)

  {
SourceText res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SourceText");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SourceText(ctxt, "</SourceText>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ShortcutDictionary from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ShortcutDictionary acceptShortcutDictionary(XmlBContext ctxt)

  {
ShortcutDictionary res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ShortcutDictionary");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ShortcutDictionary(ctxt, "</ShortcutDictionary>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ShortcutFolder from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ShortcutFolder acceptShortcutFolder(XmlBContext ctxt)

  {
ShortcutFolder res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ShortcutFolder");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Shortcut from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Shortcut acceptShortcut(XmlBContext ctxt)

  {
Shortcut res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Shortcut");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Shortcut(ctxt, "</Shortcut>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Specification from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Specification acceptSpecification(XmlBContext ctxt)

  {
Specification res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Specification");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Specification(ctxt, "</Specification>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Chapter from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Chapter acceptChapter(XmlBContext ctxt)

  {
Chapter res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Chapter");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Chapter(ctxt, "</Chapter>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Paragraph from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Paragraph acceptParagraph(XmlBContext ctxt)

  {
Paragraph res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Paragraph");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Paragraph(ctxt, "</Paragraph>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ParagraphRevision from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ParagraphRevision acceptParagraphRevision(XmlBContext ctxt)

  {
ParagraphRevision res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ParagraphRevision");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ParagraphRevision(ctxt, "</ParagraphRevision>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an NameSpaceRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static NameSpaceRef acceptNameSpaceRef(XmlBContext ctxt)

  {
NameSpaceRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<NameSpaceRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an FrameRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static FrameRef acceptFrameRef(XmlBContext ctxt)

  {
FrameRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<FrameRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_FrameRef(ctxt, "</FrameRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ChapterRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ChapterRef acceptChapterRef(XmlBContext ctxt)

  {
ChapterRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ChapterRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ChapterRef(ctxt, "</ChapterRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

public static IXmlBBase accept(XmlBContext ctxt)

{
  IXmlBBase res = null;
ctxt.skipWhiteSpace();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
ctxt.acceptString ("ariable");
  res =  lAccept_Variable(ctxt, "</Variable>");
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.acceptString ("anslation");
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
  res =  lAccept_TranslationDictionary(ctxt, "</TranslationDictionary>");
} else {
  res =  lAccept_Translation(ctxt, "</Translation>");
} // If
break;
} // Case
default:
  res =  lAccept_Translation(ctxt, "</Translation>");
break;
} // Switch
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("stCase");
  res =  lAccept_TestCase(ctxt, "</TestCase>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2138)");
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.accept2('b','S');
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
ctxt.accept2('e','p');
  res =  lAccept_SubStep(ctxt, "</SubStep>");
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("quence");
  res =  lAccept_SubSequence(ctxt, "</SubSequence>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2143)");
break;
} // Switch
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.acceptString ("ucture");
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
  res =  lAccept_StructureElement(ctxt, "</StructureElement>");
} else {
  res =  lAccept_Structure(ctxt, "</Structure>");
} // If
break;
} // Case
default:
  res =  lAccept_Structure(ctxt, "</Structure>");
break;
} // Switch
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.accept('p');
  res =  lAccept_Step(ctxt, "</Step>");
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept2('t','e');
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
  res =  lAccept_StateMachine(ctxt, "</StateMachine>");
} else {
  res =  lAccept_State(ctxt, "</State>");
} // If
break;
} // Case
default:
  res =  lAccept_State(ctxt, "</State>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2150)");
break;
} // Switch
break;
} // Case
case 'p':
{
ctxt.advance();
ctxt.acceptString ("ecification");
  res =  lAccept_Specification(ctxt, "</Specification>");
break;
} // Case
case 'o':
{
ctxt.advance();
ctxt.acceptString ("urceText");
  res =  lAccept_SourceText(ctxt, "</SourceText>");
break;
} // Case
case 'h':
{
ctxt.advance();
ctxt.acceptString ("ortcut");
switch (ctxt.current()) {
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("older")){
  res =  lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
} else {
  res =  lAccept_Shortcut(ctxt, "</Shortcut>");
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
  res =  lAccept_ShortcutDictionary(ctxt, "</ShortcutDictionary>");
} else {
  res =  lAccept_Shortcut(ctxt, "</Shortcut>");
} // If
break;
} // Case
default:
  res =  lAccept_Shortcut(ctxt, "</Shortcut>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2156)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.accept2('l','e');
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
  res =  lAccept_RuleDisabling(ctxt, "</RuleDisabling>");
} else {
  res =  lAccept_Rule(ctxt, "</Rule>");
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
  res =  lAccept_RuleCondition(ctxt, "</RuleCondition>");
} else {
  res =  lAccept_Rule(ctxt, "</Rule>");
} // If
break;
} // Case
default:
  res =  lAccept_Rule(ctxt, "</Rule>");
break;
} // Switch
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("qRef");
  res =  lAccept_ReqRef(ctxt, "</ReqRef>");
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept3('n','g','e');
  res =  lAccept_Range(ctxt, "</Range>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2163)");
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("cedure");
  res =  lAccept_Procedure(ctxt, "</Procedure>");
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("Condition");
  res =  lAccept_PreCondition(ctxt, "</PreCondition>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2168)");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept2('r','a');
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
ctxt.acceptString ("eter");
  res =  lAccept_Parameter(ctxt, "</Parameter>");
break;
} // Case
case 'g':
{
ctxt.advance();
ctxt.acceptString ("raph");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("evision")){
  res =  lAccept_ParagraphRevision(ctxt, "</ParagraphRevision>");
} else {
  res =  lAccept_Paragraph(ctxt, "</Paragraph>");
} // If
break;
} // Case
default:
  res =  lAccept_Paragraph(ctxt, "</Paragraph>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2173)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2174)");
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
ctxt.acceptString ("ameSpace");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
} else {
  res =  lAccept_NameSpace(ctxt, "</NameSpace>");
} // If
break;
} // Case
default:
  res =  lAccept_NameSpace(ctxt, "</NameSpace>");
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.acceptString ("nction");
  res =  lAccept_Function(ctxt, "</Function>");
break;
} // Case
case 'r':
{
ctxt.advance();
ctxt.accept3('a','m','e');
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_FrameRef(ctxt, "</FrameRef>");
} else {
  res =  lAccept_Frame(ctxt, "</Frame>");
} // If
break;
} // Case
default:
  res =  lAccept_Frame(ctxt, "</Frame>");
break;
} // Switch
break;
} // Case
case 'o':
{
ctxt.advance();
ctxt.acceptString ("lder");
  res =  lAccept_Folder(ctxt, "</Folder>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2182)");
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
ctxt.acceptString ("pectation");
  res =  lAccept_Expectation(ctxt, "</Expectation>");
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.accept2('u','m');
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue")){
  res =  lAccept_EnumValue(ctxt, "</EnumValue>");
} else {
  res =  lAccept_Enum(ctxt, "</Enum>");
} // If
break;
} // Case
default:
  res =  lAccept_Enum(ctxt, "</Enum>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2187)");
break;
} // Switch
break;
} // Case
case 'D':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.acceptString ("ctionary");
  res =  lAccept_Dictionary(ctxt, "</Dictionary>");
break;
} // Case
case 'B':
{
ctxt.advance();
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
ctxt.acceptString ("acket");
  res =  lAccept_DBPacket(ctxt, "</DBPacket>");
break;
} // Case
case 'M':
{
ctxt.advance();
ctxt.acceptString ("essage");
  res =  lAccept_DBMessage(ctxt, "</DBMessage>");
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.acceptString ("ield");
  res =  lAccept_DBField(ctxt, "</DBField>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2194)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2195)");
break;
} // Switch
break;
} // Case
case 'C':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("llection");
  res =  lAccept_Collection(ctxt, "</Collection>");
break;
} // Case
case 'h':
{
ctxt.advance();
ctxt.acceptString ("apter");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_ChapterRef(ctxt, "</ChapterRef>");
} else {
  res =  lAccept_Chapter(ctxt, "</Chapter>");
} // If
break;
} // Case
default:
  res =  lAccept_Chapter(ctxt, "</Chapter>");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept2('s','e');
  res =  lAccept_Case(ctxt, "</Case>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2201)");
break;
} // Switch
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("ction");
  res =  lAccept_Action(ctxt, "</Action>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2203)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2204)");
break;
} // Switch
return res;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override bool genericUnParse(TextWriter pw, IXmlBBase obj)
{
  ((XmlBBase ) obj).unParse(pw, false);
  return true;
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static IXmlBBase[] subElements(IXmlBBase obj)
{
  return ((XmlBBase ) obj).subElements();
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  IXmlBBase[] genericSubElements(IXmlBBase obj)
{
  return ((XmlBBase ) obj).subElements();
}
public  override IXmlBBase genericAccept (XmlBContext ctxt)

  {
    return accept(ctxt);
  }
}
public abstract partial class Factory
{
public abstract Dictionary createDictionary();
public abstract RuleDisabling createRuleDisabling();
public abstract NameSpaceRef createNameSpaceRef();
public abstract NameSpace createNameSpace();
public abstract ReqRef createReqRef();
public abstract Enum createEnum();
public abstract EnumValue createEnumValue();
public abstract Range createRange();
public abstract Structure createStructure();
public abstract StructureElement createStructureElement();
public abstract Collection createCollection();
public abstract Function createFunction();
public abstract Parameter createParameter();
public abstract Case createCase();
public abstract Procedure createProcedure();
public abstract StateMachine createStateMachine();
public abstract State createState();
public abstract Variable createVariable();
public abstract Rule createRule();
public abstract RuleCondition createRuleCondition();
public abstract PreCondition createPreCondition();
public abstract Action createAction();
public abstract FrameRef createFrameRef();
public abstract Frame createFrame();
public abstract SubSequence createSubSequence();
public abstract TestCase createTestCase();
public abstract Step createStep();
public abstract SubStep createSubStep();
public abstract Expectation createExpectation();
public abstract DBMessage createDBMessage();
public abstract DBPacket createDBPacket();
public abstract DBField createDBField();
public abstract TranslationDictionary createTranslationDictionary();
public abstract Folder createFolder();
public abstract Translation createTranslation();
public abstract SourceText createSourceText();
public abstract ShortcutDictionary createShortcutDictionary();
public abstract ShortcutFolder createShortcutFolder();
public abstract Shortcut createShortcut();
public abstract Specification createSpecification();
public abstract ChapterRef createChapterRef();
public abstract Chapter createChapter();
public abstract Paragraph createParagraph();
public abstract Message createMessage();
public abstract MsgVariable createMsgVariable();
public abstract TypeSpec createTypeSpec();
public abstract Values createValues();
public abstract special_or_reserved_values createspecial_or_reserved_values();
public abstract special_or_reserved_value createspecial_or_reserved_value();
public abstract mask createmask();
public abstract match creatematch();
public abstract meaning createmeaning();
public abstract match_range creatematch_range();
public abstract resolution_formula createresolution_formula();
public abstract value createvalue();
public abstract char_value createchar_value();
public abstract ParagraphRevision createParagraphRevision();
}

public partial class TestParser
{
public static void main( string [] args)
  {
   XmlBTester tester = new  XmlBTester();
   tester.performTest (acceptor.getUnique(), args);
  }
}

public partial class Visitor
: XmlBBaseVisitor
{
public virtual void visit(BaseModelElement obj)
{
  visit(obj, true);
}

public virtual void visit(BaseModelElement obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Namable obj)
{
  visit(obj, true);
}

public virtual void visit(Namable obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ReferencesParagraph obj)
{
  visit(obj, true);
}

public virtual void visit(ReferencesParagraph obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ReqRelated obj)
{
  visit(obj, true);
}

public virtual void visit(ReqRelated obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Dictionary obj)
{
  visit(obj, true);
}

public virtual void visit(Dictionary obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RuleDisabling obj)
{
  visit(obj, true);
}

public virtual void visit(RuleDisabling obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(NameSpaceRef obj)
{
  visit(obj, true);
}

public virtual void visit(NameSpaceRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(NameSpace obj)
{
  visit(obj, true);
}

public virtual void visit(NameSpace obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ReqRef obj)
{
  visit(obj, true);
}

public virtual void visit(ReqRef obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Type obj)
{
  visit(obj, true);
}

public virtual void visit(Type obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Enum obj)
{
  visit(obj, true);
}

public virtual void visit(Enum obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(EnumValue obj)
{
  visit(obj, true);
}

public virtual void visit(EnumValue obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Range obj)
{
  visit(obj, true);
}

public virtual void visit(Range obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Structure obj)
{
  visit(obj, true);
}

public virtual void visit(Structure obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(StructureElement obj)
{
  visit(obj, true);
}

public virtual void visit(StructureElement obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Collection obj)
{
  visit(obj, true);
}

public virtual void visit(Collection obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Function obj)
{
  visit(obj, true);
}

public virtual void visit(Function obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Parameter obj)
{
  visit(obj, true);
}

public virtual void visit(Parameter obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Case obj)
{
  visit(obj, true);
}

public virtual void visit(Case obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Procedure obj)
{
  visit(obj, true);
}

public virtual void visit(Procedure obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(StateMachine obj)
{
  visit(obj, true);
}

public virtual void visit(StateMachine obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(State obj)
{
  visit(obj, true);
}

public virtual void visit(State obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Variable obj)
{
  visit(obj, true);
}

public virtual void visit(Variable obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Rule obj)
{
  visit(obj, true);
}

public virtual void visit(Rule obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RuleCondition obj)
{
  visit(obj, true);
}

public virtual void visit(RuleCondition obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(PreCondition obj)
{
  visit(obj, true);
}

public virtual void visit(PreCondition obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Action obj)
{
  visit(obj, true);
}

public virtual void visit(Action obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(FrameRef obj)
{
  visit(obj, true);
}

public virtual void visit(FrameRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Frame obj)
{
  visit(obj, true);
}

public virtual void visit(Frame obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SubSequence obj)
{
  visit(obj, true);
}

public virtual void visit(SubSequence obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(TestCase obj)
{
  visit(obj, true);
}

public virtual void visit(TestCase obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Step obj)
{
  visit(obj, true);
}

public virtual void visit(Step obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SubStep obj)
{
  visit(obj, true);
}

public virtual void visit(SubStep obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Expectation obj)
{
  visit(obj, true);
}

public virtual void visit(Expectation obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(DBMessage obj)
{
  visit(obj, true);
}

public virtual void visit(DBMessage obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(DBPacket obj)
{
  visit(obj, true);
}

public virtual void visit(DBPacket obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(DBField obj)
{
  visit(obj, true);
}

public virtual void visit(DBField obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(TranslationDictionary obj)
{
  visit(obj, true);
}

public virtual void visit(TranslationDictionary obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Folder obj)
{
  visit(obj, true);
}

public virtual void visit(Folder obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Translation obj)
{
  visit(obj, true);
}

public virtual void visit(Translation obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SourceText obj)
{
  visit(obj, true);
}

public virtual void visit(SourceText obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ShortcutDictionary obj)
{
  visit(obj, true);
}

public virtual void visit(ShortcutDictionary obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ShortcutFolder obj)
{
  visit(obj, true);
}

public virtual void visit(ShortcutFolder obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Shortcut obj)
{
  visit(obj, true);
}

public virtual void visit(Shortcut obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Specification obj)
{
  visit(obj, true);
}

public virtual void visit(Specification obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ChapterRef obj)
{
  visit(obj, true);
}

public virtual void visit(ChapterRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Chapter obj)
{
  visit(obj, true);
}

public virtual void visit(Chapter obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Paragraph obj)
{
  visit(obj, true);
}

public virtual void visit(Paragraph obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Message obj)
{
  visit(obj, true);
}

public virtual void visit(Message obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(MsgVariable obj)
{
  visit(obj, true);
}

public virtual void visit(MsgVariable obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(TypeSpec obj)
{
  visit(obj, true);
}

public virtual void visit(TypeSpec obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Values obj)
{
  visit(obj, true);
}

public virtual void visit(Values obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(special_or_reserved_values obj)
{
  visit(obj, true);
}

public virtual void visit(special_or_reserved_values obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(special_or_reserved_value obj)
{
  visit(obj, true);
}

public virtual void visit(special_or_reserved_value obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(mask obj)
{
  visit(obj, true);
}

public virtual void visit(mask obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(match obj)
{
  visit(obj, true);
}

public virtual void visit(match obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(meaning obj)
{
  visit(obj, true);
}

public virtual void visit(meaning obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(match_range obj)
{
  visit(obj, true);
}

public virtual void visit(match_range obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(resolution_formula obj)
{
  visit(obj, true);
}

public virtual void visit(resolution_formula obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(value obj)
{
  visit(obj, true);
}

public virtual void visit(value obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(char_value obj)
{
  visit(obj, true);
}

public virtual void visit(char_value obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ParagraphRevision obj)
{
  visit(obj, true);
}

public virtual void visit(ParagraphRevision obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public  override  void dispatch(IXmlBBase obj)
{
  dispatch (obj, true);
}

public  override  void dispatch(IXmlBBase obj, bool visitSubNodes)
{
if (obj == null){
return;
} // If
((XmlBBase)obj).dispatch(this, visitSubNodes);
} // End of dispatch methods

}
}
