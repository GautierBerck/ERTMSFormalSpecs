
using XmlBooster;
using System.IO;
using System.Collections;
using System;

/// <remarks>XMLBooster-generated code (Version 2.22.12.0)
/// This code is generated automatically. It is not meant
/// to be maintained or even read. As it is generated, 
/// it does not follow any coding standard. Please refrain
/// from performing any change directly on this generated 
/// code, as it might be overwritten anytime.
/// This documentation is provided for information purposes
/// only, in order to make the generated API somewhat more
/// understandable. It is meant to be a maintenance guide,
/// as this code is not meant to be maintained at all.</remarks>
namespace DataDictionary.Generated{
public abstract partial class BaseModelElement
: Utils.ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getGuid().CompareTo((String) search) == 0)return true;
if(getUpdates().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.BaseModelElementController.alertChange(aLock, this);
}
private   string  aGuid;

public   string  getGuid() { return aGuid;}

public  void setGuid( string  v) {
  aGuid = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aUpdates;

public   string  getUpdates() { return aUpdates;}

public  void setUpdates( string  v) {
  aUpdates = v;
  __setDirty(true);
  NotifyControllers(null);
}


public BaseModelElement()
{
BaseModelElement obj = this;
aGuid=(null);
aUpdates=(null);
}

public void copyTo(BaseModelElement other)
{
other.aGuid = aGuid;
other.aUpdates = aUpdates;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl101;
bool fl102;
bool fl103;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl101 = false ; 
fl102 = false ; 
fl103 = true ; 
while (fl103) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 102;
} else {
indicator = 104;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 101;
} else {
indicator = 104;
} // If
break;
} // Case
default:
indicator = 104;
break;
} // Switch
switch (indicator) {
case 101: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl101){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl101 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 102: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl102){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl102 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 104: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl103 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<BaseModelElement";
  endingTag = "</BaseModelElement>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"BaseModelElement\"");
} // If
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write("/>");
pw.Write('\n');
unParseBody(pw);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public abstract partial class Namable
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.NamableController.alertChange(aLock, this);
}
private   string  aName;

public   string  getName() { return aName;}

public  void setName( string  v) {
  aName = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Namable()
{
Namable obj = this;
aName=(null);
}

public void copyTo(Namable other)
{
base.copyTo(other);
other.aName = aName;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl108;
bool fl109;
bool fl110;
bool fl111;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl108 = false ; 
fl109 = false ; 
fl110 = false ; 
fl111 = true ; 
while (fl111) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 110;
} else {
indicator = 112;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 108;
} else {
indicator = 112;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 109;
} else {
indicator = 112;
} // If
break;
} // Case
default:
indicator = 112;
break;
} // Switch
switch (indicator) {
case 108: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl108){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl108 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 109: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl109){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl109 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 110: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl110){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl110 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 112: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl111 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Namable";
  endingTag = "</Namable>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Namable\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public abstract partial class ReferencesParagraph
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ReferencesParagraphController.alertChange(aLock, this);
}
private System.Collections.ArrayList aRequirements;

/// <summary>Part of the list interface for Requirements</summary>
/// <returns>a collection of all the elements in Requirements</returns>
public System.Collections.ArrayList allRequirements()
  {
if (aRequirements == null){
    setAllRequirements( new System.Collections.ArrayList() );
} // If
    return aRequirements;
  }

/// <summary>Part of the list interface for Requirements</summary>
/// <returns>a collection of all the elements in Requirements</returns>
private System.Collections.ArrayList getRequirements()
  {
    return allRequirements();
  }

/// <summary>Part of the list interface for Requirements</summary>
/// <param name="coll">a collection of elements which replaces 
///        Requirements's current content.</param>
public void setAllRequirements(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirements = coll;
    NotifyControllers(null);
  }
public void setAllRequirements(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirements = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements</summary>
/// <param name="el">a ReqRef to add to the collection in 
///           Requirements</param>
/// <seealso cref="appendRequirements(System.Collections.IList)"/>
public void appendRequirements(ReqRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRequirements(Lock aLock,ReqRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Requirements</summary>
/// <param name="coll">a collection ofReqRefs to add to the collection in 
///           Requirements</param>
/// <seealso cref="appendRequirements(ReqRef)"/>
public void appendRequirements(System.Collections.IList coll)
  {
  __setDirty(true);
  allRequirements().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRequirements(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRequirements().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements
/// This insertion function inserts a new element in the
/// collection in Requirements</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRequirements(int idx, ReqRef el)
  {
  __setDirty(true);
  allRequirements().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRequirements(int idx, ReqRef el,Lock aLock)
  {
  __setDirty(true);
  allRequirements().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRequirements(IXmlBBase el)
  {
  return ((System.Collections.IList) allRequirements()).IndexOf (el);
  }

/// <summary>Part of the list interface for Requirements
/// This deletion function removes an element from the
/// collection in Requirements</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRequirements(int idx)
  {
  __setDirty(true);
  allRequirements().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRequirements(int idx,Lock aLock)
  {
  __setDirty(true);
  allRequirements().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements
/// This deletion function removes an element from the
/// collection in Requirements
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRequirements(IXmlBBase obj)
  {
  int idx = indexOfRequirements(obj);
  if (idx >= 0) { deleteRequirements(idx);
NotifyControllers(null);
   }
  }

public void removeRequirements(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRequirements(obj);
  if (idx >= 0) { deleteRequirements(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Requirements</summary>
/// <returns>the number of elements in Requirements</returns>
public int countRequirements()
  {
  return allRequirements().Count;
  }

/// <summary>Part of the list interface for Requirements
/// This function returns an element from the
/// collection in Requirements based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ReqRef getRequirements(int idx)
{
  return (ReqRef) ( allRequirements()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ReferencesParagraph()
{
ReferencesParagraph obj = this;
aRequirements=(null);
aComment=(null);
}

public void copyTo(ReferencesParagraph other)
{
base.copyTo(other);
other.aRequirements = aRequirements;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
ReqRef fl118;
bool fl129;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl118 = null;
while(ctxt.lookAheadOpeningTag ("<ReqRef")) {
fl118 = acceptor.lAccept_ReqRef(ctxt, "</ReqRef>");
appendRequirements(fl118);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl129 = true ; 
while (fl129) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl129 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl130;
bool fl131;
bool fl132;
bool fl133;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl130 = false ; 
fl131 = false ; 
fl132 = false ; 
fl133 = true ; 
while (fl133) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 132;
} else {
indicator = 134;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 130;
} else {
indicator = 134;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 131;
} else {
indicator = 134;
} // If
break;
} // Case
default:
indicator = 134;
break;
} // Switch
switch (indicator) {
case 130: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl130){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl130 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 131: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl131){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl131 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 132: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl132){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl132 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 134: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl133 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ReferencesParagraph";
  endingTag = "</ReferencesParagraph>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ReferencesParagraph\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRequirements(), false, "<ReqRef", "</ReqRef>");
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countRequirements(); i++) {
  l.Add(getRequirements(i));
}
}

}
public abstract partial class ReqRelated
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ReqRelatedController.alertChange(aLock, this);
}
private  bool aImplemented;

public  bool getImplemented() { return aImplemented;}

public  void setImplemented(bool v) {
  aImplemented = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aVerified;

public  bool getVerified() { return aVerified;}

public  void setVerified(bool v) {
  aVerified = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aNeedsRequirement;

public  bool getNeedsRequirement() { return aNeedsRequirement;}

public  void setNeedsRequirement(bool v) {
  aNeedsRequirement = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ReqRelated()
{
ReqRelated obj = this;
aImplemented=(false);
aVerified=(false);
aNeedsRequirement=(false);
}

public void copyTo(ReqRelated other)
{
base.copyTo(other);
other.aImplemented = aImplemented;
other.aVerified = aVerified;
other.aNeedsRequirement = aNeedsRequirement;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl139;
bool fl140;
bool fl141;
bool fl142;
bool fl143;
bool fl144;
bool fl145;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl139 = false ; 
fl140 = false ; 
fl141 = false ; 
fl142 = false ; 
fl143 = false ; 
fl144 = false ; 
fl145 = true ; 
while (fl145) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 140;
} else {
indicator = 146;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 144;
} else {
indicator = 146;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 141;
} else {
indicator = 146;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 142;
} else {
indicator = 146;
} // If
break;
} // Case
default:
indicator = 146;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 139;
} else {
indicator = 146;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 143;
} else {
indicator = 146;
} // If
break;
} // Case
default:
indicator = 146;
break;
} // Switch
switch (indicator) {
case 139: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl139){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl139 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 140: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl140){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl140 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 141: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl141){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl141 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 142: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl142){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl142 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 143: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl143){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl143 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 144: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl144){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl144 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 146: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl139){
this.setImplemented( false);
} // If
if (!fl140){
this.setVerified( false);
} // If
if (!fl141){
this.setNeedsRequirement( true);
} // If
fl145 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ReqRelated";
  endingTag = "</ReqRelated>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ReqRelated\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Dictionary
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getXsi().CompareTo((String) search) == 0)return true;
if(getXsiLocation().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DictionaryController.alertChange(aLock, this);
}
private System.Collections.ArrayList aSpecifications;

/// <summary>Part of the list interface for Specifications</summary>
/// <returns>a collection of all the elements in Specifications</returns>
public System.Collections.ArrayList allSpecifications()
  {
if (aSpecifications == null){
    setAllSpecifications( new System.Collections.ArrayList() );
} // If
    return aSpecifications;
  }

/// <summary>Part of the list interface for Specifications</summary>
/// <returns>a collection of all the elements in Specifications</returns>
private System.Collections.ArrayList getSpecifications()
  {
    return allSpecifications();
  }

/// <summary>Part of the list interface for Specifications</summary>
/// <param name="coll">a collection of elements which replaces 
///        Specifications's current content.</param>
public void setAllSpecifications(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecifications = coll;
    NotifyControllers(null);
  }
public void setAllSpecifications(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecifications = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications</summary>
/// <param name="el">a Specification to add to the collection in 
///           Specifications</param>
/// <seealso cref="appendSpecifications(System.Collections.IList)"/>
public void appendSpecifications(Specification el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecifications().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSpecifications(Lock aLock,Specification el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecifications().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Specifications</summary>
/// <param name="coll">a collection ofSpecifications to add to the collection in 
///           Specifications</param>
/// <seealso cref="appendSpecifications(Specification)"/>
public void appendSpecifications(System.Collections.IList coll)
  {
  __setDirty(true);
  allSpecifications().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSpecifications(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSpecifications().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications
/// This insertion function inserts a new element in the
/// collection in Specifications</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSpecifications(int idx, Specification el)
  {
  __setDirty(true);
  allSpecifications().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSpecifications(int idx, Specification el,Lock aLock)
  {
  __setDirty(true);
  allSpecifications().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSpecifications(IXmlBBase el)
  {
  return ((System.Collections.IList) allSpecifications()).IndexOf (el);
  }

/// <summary>Part of the list interface for Specifications
/// This deletion function removes an element from the
/// collection in Specifications</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSpecifications(int idx)
  {
  __setDirty(true);
  allSpecifications().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSpecifications(int idx,Lock aLock)
  {
  __setDirty(true);
  allSpecifications().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications
/// This deletion function removes an element from the
/// collection in Specifications
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSpecifications(IXmlBBase obj)
  {
  int idx = indexOfSpecifications(obj);
  if (idx >= 0) { deleteSpecifications(idx);
NotifyControllers(null);
   }
  }

public void removeSpecifications(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSpecifications(obj);
  if (idx >= 0) { deleteSpecifications(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Specifications</summary>
/// <returns>the number of elements in Specifications</returns>
public int countSpecifications()
  {
  return allSpecifications().Count;
  }

/// <summary>Part of the list interface for Specifications
/// This function returns an element from the
/// collection in Specifications based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Specification getSpecifications(int idx)
{
  return (Specification) ( allSpecifications()[idx]);
}

private System.Collections.ArrayList aRequirementSets;

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>a collection of all the elements in RequirementSets</returns>
public System.Collections.ArrayList allRequirementSets()
  {
if (aRequirementSets == null){
    setAllRequirementSets( new System.Collections.ArrayList() );
} // If
    return aRequirementSets;
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>a collection of all the elements in RequirementSets</returns>
private System.Collections.ArrayList getRequirementSets()
  {
    return allRequirementSets();
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="coll">a collection of elements which replaces 
///        RequirementSets's current content.</param>
public void setAllRequirementSets(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirementSets = coll;
    NotifyControllers(null);
  }
public void setAllRequirementSets(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirementSets = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="el">a RequirementSet to add to the collection in 
///           RequirementSets</param>
/// <seealso cref="appendRequirementSets(System.Collections.IList)"/>
public void appendRequirementSets(RequirementSet el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirementSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRequirementSets(Lock aLock,RequirementSet el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirementSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="coll">a collection ofRequirementSets to add to the collection in 
///           RequirementSets</param>
/// <seealso cref="appendRequirementSets(RequirementSet)"/>
public void appendRequirementSets(System.Collections.IList coll)
  {
  __setDirty(true);
  allRequirementSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRequirementSets(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This insertion function inserts a new element in the
/// collection in RequirementSets</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRequirementSets(int idx, RequirementSet el)
  {
  __setDirty(true);
  allRequirementSets().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRequirementSets(int idx, RequirementSet el,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRequirementSets(IXmlBBase el)
  {
  return ((System.Collections.IList) allRequirementSets()).IndexOf (el);
  }

/// <summary>Part of the list interface for RequirementSets
/// This deletion function removes an element from the
/// collection in RequirementSets</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRequirementSets(int idx)
  {
  __setDirty(true);
  allRequirementSets().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRequirementSets(int idx,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This deletion function removes an element from the
/// collection in RequirementSets
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRequirementSets(IXmlBBase obj)
  {
  int idx = indexOfRequirementSets(obj);
  if (idx >= 0) { deleteRequirementSets(idx);
NotifyControllers(null);
   }
  }

public void removeRequirementSets(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRequirementSets(obj);
  if (idx >= 0) { deleteRequirementSets(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>the number of elements in RequirementSets</returns>
public int countRequirementSets()
  {
  return allRequirementSets().Count;
  }

/// <summary>Part of the list interface for RequirementSets
/// This function returns an element from the
/// collection in RequirementSets based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RequirementSet getRequirementSets(int idx)
{
  return (RequirementSet) ( allRequirementSets()[idx]);
}

private System.Collections.ArrayList aRuleDisablings;

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <returns>a collection of all the elements in RuleDisablings</returns>
public System.Collections.ArrayList allRuleDisablings()
  {
if (aRuleDisablings == null){
    setAllRuleDisablings( new System.Collections.ArrayList() );
} // If
    return aRuleDisablings;
  }

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <returns>a collection of all the elements in RuleDisablings</returns>
private System.Collections.ArrayList getRuleDisablings()
  {
    return allRuleDisablings();
  }

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <param name="coll">a collection of elements which replaces 
///        RuleDisablings's current content.</param>
public void setAllRuleDisablings(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRuleDisablings = coll;
    NotifyControllers(null);
  }
public void setAllRuleDisablings(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRuleDisablings = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <param name="el">a RuleDisabling to add to the collection in 
///           RuleDisablings</param>
/// <seealso cref="appendRuleDisablings(System.Collections.IList)"/>
public void appendRuleDisablings(RuleDisabling el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRuleDisablings().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRuleDisablings(Lock aLock,RuleDisabling el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRuleDisablings().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for RuleDisablings</summary>
/// <param name="coll">a collection ofRuleDisablings to add to the collection in 
///           RuleDisablings</param>
/// <seealso cref="appendRuleDisablings(RuleDisabling)"/>
public void appendRuleDisablings(System.Collections.IList coll)
  {
  __setDirty(true);
  allRuleDisablings().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRuleDisablings(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRuleDisablings().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This insertion function inserts a new element in the
/// collection in RuleDisablings</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRuleDisablings(int idx, RuleDisabling el)
  {
  __setDirty(true);
  allRuleDisablings().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRuleDisablings(int idx, RuleDisabling el,Lock aLock)
  {
  __setDirty(true);
  allRuleDisablings().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRuleDisablings(IXmlBBase el)
  {
  return ((System.Collections.IList) allRuleDisablings()).IndexOf (el);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This deletion function removes an element from the
/// collection in RuleDisablings</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRuleDisablings(int idx)
  {
  __setDirty(true);
  allRuleDisablings().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRuleDisablings(int idx,Lock aLock)
  {
  __setDirty(true);
  allRuleDisablings().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This deletion function removes an element from the
/// collection in RuleDisablings
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRuleDisablings(IXmlBBase obj)
  {
  int idx = indexOfRuleDisablings(obj);
  if (idx >= 0) { deleteRuleDisablings(idx);
NotifyControllers(null);
   }
  }

public void removeRuleDisablings(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRuleDisablings(obj);
  if (idx >= 0) { deleteRuleDisablings(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <returns>the number of elements in RuleDisablings</returns>
public int countRuleDisablings()
  {
  return allRuleDisablings().Count;
  }

/// <summary>Part of the list interface for RuleDisablings
/// This function returns an element from the
/// collection in RuleDisablings based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RuleDisabling getRuleDisablings(int idx)
{
  return (RuleDisabling) ( allRuleDisablings()[idx]);
}

private System.Collections.ArrayList aNameSpaces;

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
public System.Collections.ArrayList allNameSpaces()
  {
if (aNameSpaces == null){
    setAllNameSpaces( new System.Collections.ArrayList() );
} // If
    return aNameSpaces;
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
private System.Collections.ArrayList getNameSpaces()
  {
    return allNameSpaces();
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaces's current content.</param>
public void setAllNameSpaces(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaces(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="el">a NameSpace to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(System.Collections.IList)"/>
public void appendNameSpaces(NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaces(Lock aLock,NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection ofNameSpaces to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(NameSpace)"/>
public void appendNameSpaces(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaces(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This insertion function inserts a new element in the
/// collection in NameSpaces</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaces(int idx, NameSpace el)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaces(int idx, NameSpace el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaces(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaces()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaces(int idx)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaces(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaces(IXmlBBase obj)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaces(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>the number of elements in NameSpaces</returns>
public int countNameSpaces()
  {
  return allNameSpaces().Count;
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns an element from the
/// collection in NameSpaces based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpace getNameSpaces(int idx)
{
  return (NameSpace) ( allNameSpaces()[idx]);
}

private System.Collections.ArrayList aNameSpaceRefs;

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
public System.Collections.ArrayList allNameSpaceRefs()
  {
if (aNameSpaceRefs == null){
    setAllNameSpaceRefs( new System.Collections.ArrayList() );
} // If
    return aNameSpaceRefs;
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
private System.Collections.ArrayList getNameSpaceRefs()
  {
    return allNameSpaceRefs();
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaceRefs's current content.</param>
public void setAllNameSpaceRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaceRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="el">a NameSpaceRef to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(System.Collections.IList)"/>
public void appendNameSpaceRefs(NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(Lock aLock,NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection ofNameSpaceRefs to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(NameSpaceRef)"/>
public void appendNameSpaceRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaceRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This insertion function inserts a new element in the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaceRefs(int idx, NameSpaceRef el)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaceRefs(int idx, NameSpaceRef el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaceRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaceRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaceRefs(int idx)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaceRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaceRefs(IXmlBBase obj)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaceRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>the number of elements in NameSpaceRefs</returns>
public int countNameSpaceRefs()
  {
  return allNameSpaceRefs().Count;
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns an element from the
/// collection in NameSpaceRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpaceRef getNameSpaceRefs(int idx)
{
  return (NameSpaceRef) ( allNameSpaceRefs()[idx]);
}

private System.Collections.ArrayList aTests;

/// <summary>Part of the list interface for Tests</summary>
/// <returns>a collection of all the elements in Tests</returns>
public System.Collections.ArrayList allTests()
  {
if (aTests == null){
    setAllTests( new System.Collections.ArrayList() );
} // If
    return aTests;
  }

/// <summary>Part of the list interface for Tests</summary>
/// <returns>a collection of all the elements in Tests</returns>
private System.Collections.ArrayList getTests()
  {
    return allTests();
  }

/// <summary>Part of the list interface for Tests</summary>
/// <param name="coll">a collection of elements which replaces 
///        Tests's current content.</param>
public void setAllTests(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTests = coll;
    NotifyControllers(null);
  }
public void setAllTests(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTests = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests</summary>
/// <param name="el">a Frame to add to the collection in 
///           Tests</param>
/// <seealso cref="appendTests(System.Collections.IList)"/>
public void appendTests(Frame el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTests().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTests(Lock aLock,Frame el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTests().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Tests</summary>
/// <param name="coll">a collection ofFrames to add to the collection in 
///           Tests</param>
/// <seealso cref="appendTests(Frame)"/>
public void appendTests(System.Collections.IList coll)
  {
  __setDirty(true);
  allTests().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTests(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTests().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests
/// This insertion function inserts a new element in the
/// collection in Tests</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTests(int idx, Frame el)
  {
  __setDirty(true);
  allTests().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTests(int idx, Frame el,Lock aLock)
  {
  __setDirty(true);
  allTests().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTests(IXmlBBase el)
  {
  return ((System.Collections.IList) allTests()).IndexOf (el);
  }

/// <summary>Part of the list interface for Tests
/// This deletion function removes an element from the
/// collection in Tests</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTests(int idx)
  {
  __setDirty(true);
  allTests().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTests(int idx,Lock aLock)
  {
  __setDirty(true);
  allTests().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests
/// This deletion function removes an element from the
/// collection in Tests
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTests(IXmlBBase obj)
  {
  int idx = indexOfTests(obj);
  if (idx >= 0) { deleteTests(idx);
NotifyControllers(null);
   }
  }

public void removeTests(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTests(obj);
  if (idx >= 0) { deleteTests(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Tests</summary>
/// <returns>the number of elements in Tests</returns>
public int countTests()
  {
  return allTests().Count;
  }

/// <summary>Part of the list interface for Tests
/// This function returns an element from the
/// collection in Tests based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Frame getTests(int idx)
{
  return (Frame) ( allTests()[idx]);
}

private System.Collections.ArrayList aTestRefs;

/// <summary>Part of the list interface for TestRefs</summary>
/// <returns>a collection of all the elements in TestRefs</returns>
public System.Collections.ArrayList allTestRefs()
  {
if (aTestRefs == null){
    setAllTestRefs( new System.Collections.ArrayList() );
} // If
    return aTestRefs;
  }

/// <summary>Part of the list interface for TestRefs</summary>
/// <returns>a collection of all the elements in TestRefs</returns>
private System.Collections.ArrayList getTestRefs()
  {
    return allTestRefs();
  }

/// <summary>Part of the list interface for TestRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        TestRefs's current content.</param>
public void setAllTestRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestRefs = coll;
    NotifyControllers(null);
  }
public void setAllTestRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs</summary>
/// <param name="el">a FrameRef to add to the collection in 
///           TestRefs</param>
/// <seealso cref="appendTestRefs(System.Collections.IList)"/>
public void appendTestRefs(FrameRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTestRefs(Lock aLock,FrameRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TestRefs</summary>
/// <param name="coll">a collection ofFrameRefs to add to the collection in 
///           TestRefs</param>
/// <seealso cref="appendTestRefs(FrameRef)"/>
public void appendTestRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allTestRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTestRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTestRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs
/// This insertion function inserts a new element in the
/// collection in TestRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTestRefs(int idx, FrameRef el)
  {
  __setDirty(true);
  allTestRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTestRefs(int idx, FrameRef el,Lock aLock)
  {
  __setDirty(true);
  allTestRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTestRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allTestRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for TestRefs
/// This deletion function removes an element from the
/// collection in TestRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTestRefs(int idx)
  {
  __setDirty(true);
  allTestRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTestRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allTestRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs
/// This deletion function removes an element from the
/// collection in TestRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTestRefs(IXmlBBase obj)
  {
  int idx = indexOfTestRefs(obj);
  if (idx >= 0) { deleteTestRefs(idx);
NotifyControllers(null);
   }
  }

public void removeTestRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTestRefs(obj);
  if (idx >= 0) { deleteTestRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TestRefs</summary>
/// <returns>the number of elements in TestRefs</returns>
public int countTestRefs()
  {
  return allTestRefs().Count;
  }

/// <summary>Part of the list interface for TestRefs
/// This function returns an element from the
/// collection in TestRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public FrameRef getTestRefs(int idx)
{
  return (FrameRef) ( allTestRefs()[idx]);
}

private  TranslationDictionary aTranslationDictionary;

public  TranslationDictionary getTranslationDictionary() { return aTranslationDictionary;}

public  void setTranslationDictionary(TranslationDictionary v) {
  aTranslationDictionary = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  ShortcutDictionary aShortcutDictionary;

public  ShortcutDictionary getShortcutDictionary() { return aShortcutDictionary;}

public  void setShortcutDictionary(ShortcutDictionary v) {
  aShortcutDictionary = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aXsi;

public   string  getXsi() { return aXsi;}

public  void setXsi( string  v) {
  aXsi = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aXsiLocation;

public   string  getXsiLocation() { return aXsiLocation;}

public  void setXsiLocation( string  v) {
  aXsiLocation = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Dictionary()
{
Dictionary obj = this;
aSpecifications=(null);
aRequirementSets=(null);
aRuleDisablings=(null);
aNameSpaces=(null);
aNameSpaceRefs=(null);
aTests=(null);
aTestRefs=(null);
aTranslationDictionary=(null);
aShortcutDictionary=(null);
aXsi=(null);
aXsiLocation=(null);
}

public void copyTo(Dictionary other)
{
base.copyTo(other);
other.aSpecifications = aSpecifications;
other.aRequirementSets = aRequirementSets;
other.aRuleDisablings = aRuleDisablings;
other.aNameSpaces = aNameSpaces;
other.aNameSpaceRefs = aNameSpaceRefs;
other.aTests = aTests;
other.aTestRefs = aTestRefs;
other.aTranslationDictionary = aTranslationDictionary;
other.aShortcutDictionary = aShortcutDictionary;
other.aXsi = aXsi;
other.aXsiLocation = aXsiLocation;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
Specification fl156;
bool fl167;
RequirementSet fl169;
bool fl180;
RuleDisabling fl182;
bool fl193;
NameSpace fl195;
NameSpaceRef fl207;
bool fl218;
Frame fl220;
FrameRef fl232;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl156 = null;
while(ctxt.lookAheadOpeningTag ("<Specification")) {
fl156 = acceptor.lAccept_Specification(ctxt, "</Specification>");
appendSpecifications(fl156);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<RequirementSets")){
ctxt.skipWhiteSpace();
fl167 = true ; 
while (fl167) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl167 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl169 = null;
while(ctxt.lookAheadOpeningTag ("<RequirementSet")) {
fl169 = acceptor.lAccept_RequirementSet(ctxt, "</RequirementSet>");
appendRequirementSets(fl169);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</RequirementSets>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<RuleDisabling")){
ctxt.skipWhiteSpace();
fl180 = true ; 
while (fl180) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl180 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl182 = null;
while(ctxt.lookAheadOpeningTag ("<RuleDisabling")) {
fl182 = acceptor.lAccept_RuleDisabling(ctxt, "</RuleDisabling>");
appendRuleDisablings(fl182);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</RuleDisabling>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<NameSpaces");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl193 = true ; 
while (fl193) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl193 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl195 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpace")) {
fl195 = acceptor.lAccept_NameSpace(ctxt, "</NameSpace>");
appendNameSpaces(fl195);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl207 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpaceRef")) {
fl207 = acceptor.lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
appendNameSpaceRefs(fl207);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</NameSpaces>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Tests")){
ctxt.skipWhiteSpace();
fl218 = true ; 
while (fl218) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl218 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl220 = null;
while(ctxt.lookAheadOpeningTag ("<Frame")) {
fl220 = acceptor.lAccept_Frame(ctxt, "</Frame>");
appendTests(fl220);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl232 = null;
while(ctxt.lookAheadOpeningTag ("<FrameRef")) {
fl232 = acceptor.lAccept_FrameRef(ctxt, "</FrameRef>");
appendTestRefs(fl232);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Tests>");
} // If
} // If
// End enclosed
// Element Ref : TranslationDictionary
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<TranslationDictionary")){
// Parsing sub element
this.setTranslationDictionary(acceptor.lAccept_TranslationDictionary(ctxt,"</TranslationDictionary>"));
setSon(this.getTranslationDictionary());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Element Ref : ShortcutDictionary
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<ShortcutDictionary")){
// Parsing sub element
this.setShortcutDictionary(acceptor.lAccept_ShortcutDictionary(ctxt,"</ShortcutDictionary>"));
setSon(this.getShortcutDictionary());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl243;
bool fl244;
bool fl245;
bool fl246;
bool fl247;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl243 = false ; 
fl244 = false ; 
fl245 = false ; 
fl246 = false ; 
fl247 = true ; 
while (fl247) { // BeginLoop 
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
if (ctxt.lookAheadString("i:noNamespaceSchemaLocation=")){
indicator = 244;
} else {
indicator = 248;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("lns:xsi=")){
indicator = 243;
} else {
indicator = 248;
} // If
break;
} // Case
default:
indicator = 248;
break;
} // Switch
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 246;
} else {
indicator = 248;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 245;
} else {
indicator = 248;
} // If
break;
} // Case
default:
indicator = 248;
break;
} // Switch
switch (indicator) {
case 243: {
// Handling attribute xmlns:xsi
// Also handles alien attributes with prefix xmlns:xsi
if (fl243){
ctxt.fail ("Duplicate attribute: xmlns:xsi");
} // If
fl243 = true ; 
quoteChar = ctxt.acceptQuote();
this.setXsi((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 244: {
// Handling attribute xsi:noNamespaceSchemaLocation
// Also handles alien attributes with prefix xsi:noNamespaceSchemaLocation
if (fl244){
ctxt.fail ("Duplicate attribute: xsi:noNamespaceSchemaLocation");
} // If
fl244 = true ; 
quoteChar = ctxt.acceptQuote();
this.setXsiLocation((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 245: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl245){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl245 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 246: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl246){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl246 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 248: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl243){
ctxt.fail ("Mandatory attribute missing: xmlns:xsi in Dictionary");
} // If
if (!fl244){
ctxt.fail ("Mandatory attribute missing: xsi:noNamespaceSchemaLocation in Dictionary");
} // If
fl247 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Dictionary";
  endingTag = "</Dictionary>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Dictionary\"");
} // If
pw.Write('\n');
pw.Write(" xmlns:xsi=\"");
acceptor.unParsePcData(pw, this.getXsi());
pw.Write('"');
pw.Write('\n');
pw.Write(" xsi:noNamespaceSchemaLocation=\"");
acceptor.unParsePcData(pw, this.getXsiLocation());
pw.Write('"');
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSpecifications(), false, "<Specification", "</Specification>");
// Unparsing Enclosed
// Testing for empty content: RequirementSets
if (countRequirementSets() > 0){
pw.Write("<RequirementSets>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRequirementSets(), false, "<RequirementSet", "</RequirementSet>");
pw.Write("</RequirementSets>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: RequirementSets
// Unparsing Enclosed
// Testing for empty content: RuleDisablings
if (countRuleDisablings() > 0){
pw.Write("<RuleDisabling>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRuleDisablings(), false, "<RuleDisabling", "</RuleDisabling>");
pw.Write("</RuleDisabling>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: RuleDisablings
// Unparsing Enclosed
pw.Write("<NameSpaces>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaces(), false, "<NameSpace", "</NameSpace>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaceRefs(), false, "<NameSpaceRef", "</NameSpaceRef>");
pw.Write("</NameSpaces>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<Tests>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTests(), false, "<Frame", "</Frame>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTestRefs(), false, "<FrameRef", "</FrameRef>");
pw.Write("</Tests>");
// Father is not a mixed
pw.Write('\n');
// Unparsing ElementRef
if (this.getTranslationDictionary() != null){
unParse(pw, this.getTranslationDictionary(),false,"<TranslationDictionary","</TranslationDictionary>");
} // If
// Unparsing ElementRef
if (this.getShortcutDictionary() != null){
unParse(pw, this.getShortcutDictionary(),false,"<ShortcutDictionary","</ShortcutDictionary>");
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSpecifications(); i++) {
  l.Add(getSpecifications(i));
}
for (int i = 0; i < countRequirementSets(); i++) {
  l.Add(getRequirementSets(i));
}
for (int i = 0; i < countRuleDisablings(); i++) {
  l.Add(getRuleDisablings(i));
}
for (int i = 0; i < countNameSpaces(); i++) {
  l.Add(getNameSpaces(i));
}
for (int i = 0; i < countNameSpaceRefs(); i++) {
  l.Add(getNameSpaceRefs(i));
}
for (int i = 0; i < countTests(); i++) {
  l.Add(getTests(i));
}
for (int i = 0; i < countTestRefs(); i++) {
  l.Add(getTestRefs(i));
}
l.Add(this.getTranslationDictionary());
l.Add(this.getShortcutDictionary());
}

}
public partial class RuleDisabling
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getRule().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RuleDisablingController.alertChange(aLock, this);
}
private   string  aRule;

public   string  getRule() { return aRule;}

public  void setRule( string  v) {
  aRule = v;
  __setDirty(true);
  NotifyControllers(null);
}


public RuleDisabling()
{
RuleDisabling obj = this;
aRule=(null);
}

public void copyTo(RuleDisabling other)
{
base.copyTo(other);
other.aRule = aRule;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl255;
bool fl256;
bool fl257;
bool fl258;
bool fl259;
bool fl260;
bool fl261;
bool fl262;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl255 = false ; 
fl256 = false ; 
fl257 = false ; 
fl258 = false ; 
fl259 = false ; 
fl260 = false ; 
fl261 = false ; 
fl262 = true ; 
while (fl262) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 257;
} else {
indicator = 263;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 261;
} else {
indicator = 263;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("ule=")){
indicator = 255;
} else {
indicator = 263;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 258;
} else {
indicator = 263;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 259;
} else {
indicator = 263;
} // If
break;
} // Case
default:
indicator = 263;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 256;
} else {
indicator = 263;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 260;
} else {
indicator = 263;
} // If
break;
} // Case
default:
indicator = 263;
break;
} // Switch
switch (indicator) {
case 255: {
// Handling attribute Rule
// Also handles alien attributes with prefix Rule
if (fl255){
ctxt.fail ("Duplicate attribute: Rule");
} // If
fl255 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRule((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 256: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl256){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl256 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 257: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl257){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl257 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 258: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl258){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl258 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 259: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl259){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl259 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 260: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl260){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl260 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 261: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl261){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl261 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 263: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl255){
ctxt.fail ("Mandatory attribute missing: Rule in RuleDisabling");
} // If
if (!fl256){
this.setImplemented( false);
} // If
if (!fl257){
this.setVerified( false);
} // If
if (!fl258){
this.setNeedsRequirement( true);
} // If
fl262 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RuleDisabling";
  endingTag = "</RuleDisabling>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RuleDisabling\"");
} // If
pw.Write('\n');
pw.Write(" Rule=\"");
acceptor.unParsePcData(pw, this.getRule());
pw.Write('"');
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class NameSpaceRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.NameSpaceRefController.alertChange(aLock, this);
}
public NameSpaceRef()
{
NameSpaceRef obj = this;
}

public void copyTo(NameSpaceRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl273;
bool fl274;
bool fl275;
bool fl276;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl273 = false ; 
fl274 = false ; 
fl275 = false ; 
fl276 = true ; 
while (fl276) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 275;
} else {
indicator = 277;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 273;
} else {
indicator = 277;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 274;
} else {
indicator = 277;
} // If
break;
} // Case
default:
indicator = 277;
break;
} // Switch
switch (indicator) {
case 273: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl273){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl273 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 274: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl274){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl274 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 275: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl275){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl275 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 277: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl276 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<NameSpaceRef";
  endingTag = "</NameSpaceRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"NameSpaceRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class NameSpace
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.NameSpaceController.alertChange(aLock, this);
}
private System.Collections.ArrayList aNameSpaces;

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
public System.Collections.ArrayList allNameSpaces()
  {
if (aNameSpaces == null){
    setAllNameSpaces( new System.Collections.ArrayList() );
} // If
    return aNameSpaces;
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
private System.Collections.ArrayList getNameSpaces()
  {
    return allNameSpaces();
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaces's current content.</param>
public void setAllNameSpaces(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaces(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="el">a NameSpace to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(System.Collections.IList)"/>
public void appendNameSpaces(NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaces(Lock aLock,NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection ofNameSpaces to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(NameSpace)"/>
public void appendNameSpaces(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaces(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This insertion function inserts a new element in the
/// collection in NameSpaces</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaces(int idx, NameSpace el)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaces(int idx, NameSpace el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaces(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaces()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaces(int idx)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaces(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaces(IXmlBBase obj)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaces(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>the number of elements in NameSpaces</returns>
public int countNameSpaces()
  {
  return allNameSpaces().Count;
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns an element from the
/// collection in NameSpaces based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpace getNameSpaces(int idx)
{
  return (NameSpace) ( allNameSpaces()[idx]);
}

private System.Collections.ArrayList aNameSpaceRefs;

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
public System.Collections.ArrayList allNameSpaceRefs()
  {
if (aNameSpaceRefs == null){
    setAllNameSpaceRefs( new System.Collections.ArrayList() );
} // If
    return aNameSpaceRefs;
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
private System.Collections.ArrayList getNameSpaceRefs()
  {
    return allNameSpaceRefs();
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaceRefs's current content.</param>
public void setAllNameSpaceRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaceRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="el">a NameSpaceRef to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(System.Collections.IList)"/>
public void appendNameSpaceRefs(NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(Lock aLock,NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection ofNameSpaceRefs to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(NameSpaceRef)"/>
public void appendNameSpaceRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaceRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This insertion function inserts a new element in the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaceRefs(int idx, NameSpaceRef el)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaceRefs(int idx, NameSpaceRef el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaceRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaceRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaceRefs(int idx)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaceRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaceRefs(IXmlBBase obj)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaceRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>the number of elements in NameSpaceRefs</returns>
public int countNameSpaceRefs()
  {
  return allNameSpaceRefs().Count;
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns an element from the
/// collection in NameSpaceRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpaceRef getNameSpaceRefs(int idx)
{
  return (NameSpaceRef) ( allNameSpaceRefs()[idx]);
}

private System.Collections.ArrayList aRanges;

/// <summary>Part of the list interface for Ranges</summary>
/// <returns>a collection of all the elements in Ranges</returns>
public System.Collections.ArrayList allRanges()
  {
if (aRanges == null){
    setAllRanges( new System.Collections.ArrayList() );
} // If
    return aRanges;
  }

/// <summary>Part of the list interface for Ranges</summary>
/// <returns>a collection of all the elements in Ranges</returns>
private System.Collections.ArrayList getRanges()
  {
    return allRanges();
  }

/// <summary>Part of the list interface for Ranges</summary>
/// <param name="coll">a collection of elements which replaces 
///        Ranges's current content.</param>
public void setAllRanges(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRanges = coll;
    NotifyControllers(null);
  }
public void setAllRanges(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRanges = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges</summary>
/// <param name="el">a Range to add to the collection in 
///           Ranges</param>
/// <seealso cref="appendRanges(System.Collections.IList)"/>
public void appendRanges(Range el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRanges().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRanges(Lock aLock,Range el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRanges().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Ranges</summary>
/// <param name="coll">a collection ofRanges to add to the collection in 
///           Ranges</param>
/// <seealso cref="appendRanges(Range)"/>
public void appendRanges(System.Collections.IList coll)
  {
  __setDirty(true);
  allRanges().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRanges(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRanges().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges
/// This insertion function inserts a new element in the
/// collection in Ranges</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRanges(int idx, Range el)
  {
  __setDirty(true);
  allRanges().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRanges(int idx, Range el,Lock aLock)
  {
  __setDirty(true);
  allRanges().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRanges(IXmlBBase el)
  {
  return ((System.Collections.IList) allRanges()).IndexOf (el);
  }

/// <summary>Part of the list interface for Ranges
/// This deletion function removes an element from the
/// collection in Ranges</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRanges(int idx)
  {
  __setDirty(true);
  allRanges().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRanges(int idx,Lock aLock)
  {
  __setDirty(true);
  allRanges().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges
/// This deletion function removes an element from the
/// collection in Ranges
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRanges(IXmlBBase obj)
  {
  int idx = indexOfRanges(obj);
  if (idx >= 0) { deleteRanges(idx);
NotifyControllers(null);
   }
  }

public void removeRanges(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRanges(obj);
  if (idx >= 0) { deleteRanges(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Ranges</summary>
/// <returns>the number of elements in Ranges</returns>
public int countRanges()
  {
  return allRanges().Count;
  }

/// <summary>Part of the list interface for Ranges
/// This function returns an element from the
/// collection in Ranges based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Range getRanges(int idx)
{
  return (Range) ( allRanges()[idx]);
}

private System.Collections.ArrayList aEnumerations;

/// <summary>Part of the list interface for Enumerations</summary>
/// <returns>a collection of all the elements in Enumerations</returns>
public System.Collections.ArrayList allEnumerations()
  {
if (aEnumerations == null){
    setAllEnumerations( new System.Collections.ArrayList() );
} // If
    return aEnumerations;
  }

/// <summary>Part of the list interface for Enumerations</summary>
/// <returns>a collection of all the elements in Enumerations</returns>
private System.Collections.ArrayList getEnumerations()
  {
    return allEnumerations();
  }

/// <summary>Part of the list interface for Enumerations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Enumerations's current content.</param>
public void setAllEnumerations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aEnumerations = coll;
    NotifyControllers(null);
  }
public void setAllEnumerations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aEnumerations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations</summary>
/// <param name="el">a Enum to add to the collection in 
///           Enumerations</param>
/// <seealso cref="appendEnumerations(System.Collections.IList)"/>
public void appendEnumerations(Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allEnumerations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendEnumerations(Lock aLock,Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allEnumerations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Enumerations</summary>
/// <param name="coll">a collection ofEnums to add to the collection in 
///           Enumerations</param>
/// <seealso cref="appendEnumerations(Enum)"/>
public void appendEnumerations(System.Collections.IList coll)
  {
  __setDirty(true);
  allEnumerations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendEnumerations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allEnumerations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations
/// This insertion function inserts a new element in the
/// collection in Enumerations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertEnumerations(int idx, Enum el)
  {
  __setDirty(true);
  allEnumerations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertEnumerations(int idx, Enum el,Lock aLock)
  {
  __setDirty(true);
  allEnumerations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfEnumerations(IXmlBBase el)
  {
  return ((System.Collections.IList) allEnumerations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Enumerations
/// This deletion function removes an element from the
/// collection in Enumerations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteEnumerations(int idx)
  {
  __setDirty(true);
  allEnumerations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteEnumerations(int idx,Lock aLock)
  {
  __setDirty(true);
  allEnumerations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations
/// This deletion function removes an element from the
/// collection in Enumerations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeEnumerations(IXmlBBase obj)
  {
  int idx = indexOfEnumerations(obj);
  if (idx >= 0) { deleteEnumerations(idx);
NotifyControllers(null);
   }
  }

public void removeEnumerations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfEnumerations(obj);
  if (idx >= 0) { deleteEnumerations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Enumerations</summary>
/// <returns>the number of elements in Enumerations</returns>
public int countEnumerations()
  {
  return allEnumerations().Count;
  }

/// <summary>Part of the list interface for Enumerations
/// This function returns an element from the
/// collection in Enumerations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Enum getEnumerations(int idx)
{
  return (Enum) ( allEnumerations()[idx]);
}

private System.Collections.ArrayList aStructures;

/// <summary>Part of the list interface for Structures</summary>
/// <returns>a collection of all the elements in Structures</returns>
public System.Collections.ArrayList allStructures()
  {
if (aStructures == null){
    setAllStructures( new System.Collections.ArrayList() );
} // If
    return aStructures;
  }

/// <summary>Part of the list interface for Structures</summary>
/// <returns>a collection of all the elements in Structures</returns>
private System.Collections.ArrayList getStructures()
  {
    return allStructures();
  }

/// <summary>Part of the list interface for Structures</summary>
/// <param name="coll">a collection of elements which replaces 
///        Structures's current content.</param>
public void setAllStructures(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStructures = coll;
    NotifyControllers(null);
  }
public void setAllStructures(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStructures = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures</summary>
/// <param name="el">a Structure to add to the collection in 
///           Structures</param>
/// <seealso cref="appendStructures(System.Collections.IList)"/>
public void appendStructures(Structure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStructures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStructures(Lock aLock,Structure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStructures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Structures</summary>
/// <param name="coll">a collection ofStructures to add to the collection in 
///           Structures</param>
/// <seealso cref="appendStructures(Structure)"/>
public void appendStructures(System.Collections.IList coll)
  {
  __setDirty(true);
  allStructures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStructures(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStructures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures
/// This insertion function inserts a new element in the
/// collection in Structures</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStructures(int idx, Structure el)
  {
  __setDirty(true);
  allStructures().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStructures(int idx, Structure el,Lock aLock)
  {
  __setDirty(true);
  allStructures().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStructures(IXmlBBase el)
  {
  return ((System.Collections.IList) allStructures()).IndexOf (el);
  }

/// <summary>Part of the list interface for Structures
/// This deletion function removes an element from the
/// collection in Structures</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStructures(int idx)
  {
  __setDirty(true);
  allStructures().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStructures(int idx,Lock aLock)
  {
  __setDirty(true);
  allStructures().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures
/// This deletion function removes an element from the
/// collection in Structures
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStructures(IXmlBBase obj)
  {
  int idx = indexOfStructures(obj);
  if (idx >= 0) { deleteStructures(idx);
NotifyControllers(null);
   }
  }

public void removeStructures(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStructures(obj);
  if (idx >= 0) { deleteStructures(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Structures</summary>
/// <returns>the number of elements in Structures</returns>
public int countStructures()
  {
  return allStructures().Count;
  }

/// <summary>Part of the list interface for Structures
/// This function returns an element from the
/// collection in Structures based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Structure getStructures(int idx)
{
  return (Structure) ( allStructures()[idx]);
}

private System.Collections.ArrayList aCollections;

/// <summary>Part of the list interface for Collections</summary>
/// <returns>a collection of all the elements in Collections</returns>
public System.Collections.ArrayList allCollections()
  {
if (aCollections == null){
    setAllCollections( new System.Collections.ArrayList() );
} // If
    return aCollections;
  }

/// <summary>Part of the list interface for Collections</summary>
/// <returns>a collection of all the elements in Collections</returns>
private System.Collections.ArrayList getCollections()
  {
    return allCollections();
  }

/// <summary>Part of the list interface for Collections</summary>
/// <param name="coll">a collection of elements which replaces 
///        Collections's current content.</param>
public void setAllCollections(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCollections = coll;
    NotifyControllers(null);
  }
public void setAllCollections(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCollections = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections</summary>
/// <param name="el">a Collection to add to the collection in 
///           Collections</param>
/// <seealso cref="appendCollections(System.Collections.IList)"/>
public void appendCollections(Collection el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCollections().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendCollections(Lock aLock,Collection el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCollections().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Collections</summary>
/// <param name="coll">a collection ofCollections to add to the collection in 
///           Collections</param>
/// <seealso cref="appendCollections(Collection)"/>
public void appendCollections(System.Collections.IList coll)
  {
  __setDirty(true);
  allCollections().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendCollections(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allCollections().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections
/// This insertion function inserts a new element in the
/// collection in Collections</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertCollections(int idx, Collection el)
  {
  __setDirty(true);
  allCollections().Insert (idx, el);
NotifyControllers(null);
  }

public void insertCollections(int idx, Collection el,Lock aLock)
  {
  __setDirty(true);
  allCollections().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfCollections(IXmlBBase el)
  {
  return ((System.Collections.IList) allCollections()).IndexOf (el);
  }

/// <summary>Part of the list interface for Collections
/// This deletion function removes an element from the
/// collection in Collections</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteCollections(int idx)
  {
  __setDirty(true);
  allCollections().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteCollections(int idx,Lock aLock)
  {
  __setDirty(true);
  allCollections().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections
/// This deletion function removes an element from the
/// collection in Collections
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeCollections(IXmlBBase obj)
  {
  int idx = indexOfCollections(obj);
  if (idx >= 0) { deleteCollections(idx);
NotifyControllers(null);
   }
  }

public void removeCollections(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfCollections(obj);
  if (idx >= 0) { deleteCollections(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Collections</summary>
/// <returns>the number of elements in Collections</returns>
public int countCollections()
  {
  return allCollections().Count;
  }

/// <summary>Part of the list interface for Collections
/// This function returns an element from the
/// collection in Collections based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Collection getCollections(int idx)
{
  return (Collection) ( allCollections()[idx]);
}

private System.Collections.ArrayList aStateMachines;

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
public System.Collections.ArrayList allStateMachines()
  {
if (aStateMachines == null){
    setAllStateMachines( new System.Collections.ArrayList() );
} // If
    return aStateMachines;
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
private System.Collections.ArrayList getStateMachines()
  {
    return allStateMachines();
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection of elements which replaces 
///        StateMachines's current content.</param>
public void setAllStateMachines(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
    NotifyControllers(null);
  }
public void setAllStateMachines(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="el">a StateMachine to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(System.Collections.IList)"/>
public void appendStateMachines(StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStateMachines(Lock aLock,StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection ofStateMachines to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(StateMachine)"/>
public void appendStateMachines(System.Collections.IList coll)
  {
  __setDirty(true);
  allStateMachines().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStateMachines(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This insertion function inserts a new element in the
/// collection in StateMachines</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStateMachines(int idx, StateMachine el)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStateMachines(int idx, StateMachine el,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStateMachines(IXmlBBase el)
  {
  return ((System.Collections.IList) allStateMachines()).IndexOf (el);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStateMachines(int idx)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStateMachines(int idx,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStateMachines(IXmlBBase obj)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(null);
   }
  }

public void removeStateMachines(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>the number of elements in StateMachines</returns>
public int countStateMachines()
  {
  return allStateMachines().Count;
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns an element from the
/// collection in StateMachines based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StateMachine getStateMachines(int idx)
{
  return (StateMachine) ( allStateMachines()[idx]);
}

private System.Collections.ArrayList aFunctions;

/// <summary>Part of the list interface for Functions</summary>
/// <returns>a collection of all the elements in Functions</returns>
public System.Collections.ArrayList allFunctions()
  {
if (aFunctions == null){
    setAllFunctions( new System.Collections.ArrayList() );
} // If
    return aFunctions;
  }

/// <summary>Part of the list interface for Functions</summary>
/// <returns>a collection of all the elements in Functions</returns>
private System.Collections.ArrayList getFunctions()
  {
    return allFunctions();
  }

/// <summary>Part of the list interface for Functions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Functions's current content.</param>
public void setAllFunctions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFunctions = coll;
    NotifyControllers(null);
  }
public void setAllFunctions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFunctions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions</summary>
/// <param name="el">a Function to add to the collection in 
///           Functions</param>
/// <seealso cref="appendFunctions(System.Collections.IList)"/>
public void appendFunctions(Function el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFunctions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFunctions(Lock aLock,Function el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFunctions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Functions</summary>
/// <param name="coll">a collection ofFunctions to add to the collection in 
///           Functions</param>
/// <seealso cref="appendFunctions(Function)"/>
public void appendFunctions(System.Collections.IList coll)
  {
  __setDirty(true);
  allFunctions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFunctions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFunctions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions
/// This insertion function inserts a new element in the
/// collection in Functions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFunctions(int idx, Function el)
  {
  __setDirty(true);
  allFunctions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFunctions(int idx, Function el,Lock aLock)
  {
  __setDirty(true);
  allFunctions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFunctions(IXmlBBase el)
  {
  return ((System.Collections.IList) allFunctions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Functions
/// This deletion function removes an element from the
/// collection in Functions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFunctions(int idx)
  {
  __setDirty(true);
  allFunctions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFunctions(int idx,Lock aLock)
  {
  __setDirty(true);
  allFunctions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions
/// This deletion function removes an element from the
/// collection in Functions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFunctions(IXmlBBase obj)
  {
  int idx = indexOfFunctions(obj);
  if (idx >= 0) { deleteFunctions(idx);
NotifyControllers(null);
   }
  }

public void removeFunctions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFunctions(obj);
  if (idx >= 0) { deleteFunctions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Functions</summary>
/// <returns>the number of elements in Functions</returns>
public int countFunctions()
  {
  return allFunctions().Count;
  }

/// <summary>Part of the list interface for Functions
/// This function returns an element from the
/// collection in Functions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Function getFunctions(int idx)
{
  return (Function) ( allFunctions()[idx]);
}

private System.Collections.ArrayList aProcedures;

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
public System.Collections.ArrayList allProcedures()
  {
if (aProcedures == null){
    setAllProcedures( new System.Collections.ArrayList() );
} // If
    return aProcedures;
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
private System.Collections.ArrayList getProcedures()
  {
    return allProcedures();
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection of elements which replaces 
///        Procedures's current content.</param>
public void setAllProcedures(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
    NotifyControllers(null);
  }
public void setAllProcedures(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="el">a Procedure to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(System.Collections.IList)"/>
public void appendProcedures(Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendProcedures(Lock aLock,Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection ofProcedures to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(Procedure)"/>
public void appendProcedures(System.Collections.IList coll)
  {
  __setDirty(true);
  allProcedures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendProcedures(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allProcedures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This insertion function inserts a new element in the
/// collection in Procedures</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertProcedures(int idx, Procedure el)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(null);
  }

public void insertProcedures(int idx, Procedure el,Lock aLock)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfProcedures(IXmlBBase el)
  {
  return ((System.Collections.IList) allProcedures()).IndexOf (el);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteProcedures(int idx)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteProcedures(int idx,Lock aLock)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeProcedures(IXmlBBase obj)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(null);
   }
  }

public void removeProcedures(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>the number of elements in Procedures</returns>
public int countProcedures()
  {
  return allProcedures().Count;
  }

/// <summary>Part of the list interface for Procedures
/// This function returns an element from the
/// collection in Procedures based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Procedure getProcedures(int idx)
{
  return (Procedure) ( allProcedures()[idx]);
}

private System.Collections.ArrayList aVariables;

/// <summary>Part of the list interface for Variables</summary>
/// <returns>a collection of all the elements in Variables</returns>
public System.Collections.ArrayList allVariables()
  {
if (aVariables == null){
    setAllVariables( new System.Collections.ArrayList() );
} // If
    return aVariables;
  }

/// <summary>Part of the list interface for Variables</summary>
/// <returns>a collection of all the elements in Variables</returns>
private System.Collections.ArrayList getVariables()
  {
    return allVariables();
  }

/// <summary>Part of the list interface for Variables</summary>
/// <param name="coll">a collection of elements which replaces 
///        Variables's current content.</param>
public void setAllVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aVariables = coll;
    NotifyControllers(null);
  }
public void setAllVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables</summary>
/// <param name="el">a Variable to add to the collection in 
///           Variables</param>
/// <seealso cref="appendVariables(System.Collections.IList)"/>
public void appendVariables(Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendVariables(Lock aLock,Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Variables</summary>
/// <param name="coll">a collection ofVariables to add to the collection in 
///           Variables</param>
/// <seealso cref="appendVariables(Variable)"/>
public void appendVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables
/// This insertion function inserts a new element in the
/// collection in Variables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertVariables(int idx, Variable el)
  {
  __setDirty(true);
  allVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertVariables(int idx, Variable el,Lock aLock)
  {
  __setDirty(true);
  allVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for Variables
/// This deletion function removes an element from the
/// collection in Variables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteVariables(int idx)
  {
  __setDirty(true);
  allVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables
/// This deletion function removes an element from the
/// collection in Variables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeVariables(IXmlBBase obj)
  {
  int idx = indexOfVariables(obj);
  if (idx >= 0) { deleteVariables(idx);
NotifyControllers(null);
   }
  }

public void removeVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfVariables(obj);
  if (idx >= 0) { deleteVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Variables</summary>
/// <returns>the number of elements in Variables</returns>
public int countVariables()
  {
  return allVariables().Count;
  }

/// <summary>Part of the list interface for Variables
/// This function returns an element from the
/// collection in Variables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Variable getVariables(int idx)
{
  return (Variable) ( allVariables()[idx]);
}

private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public NameSpace()
{
NameSpace obj = this;
aNameSpaces=(null);
aNameSpaceRefs=(null);
aRanges=(null);
aEnumerations=(null);
aStructures=(null);
aCollections=(null);
aStateMachines=(null);
aFunctions=(null);
aProcedures=(null);
aVariables=(null);
aRules=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
aComment=(null);
}

public void copyTo(NameSpace other)
{
base.copyTo(other);
other.aNameSpaces = aNameSpaces;
other.aNameSpaceRefs = aNameSpaceRefs;
other.aRanges = aRanges;
other.aEnumerations = aEnumerations;
other.aStructures = aStructures;
other.aCollections = aCollections;
other.aStateMachines = aStateMachines;
other.aFunctions = aFunctions;
other.aProcedures = aProcedures;
other.aVariables = aVariables;
other.aRules = aRules;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl282;
bool fl283;
NameSpace fl285;
NameSpaceRef fl297;
bool fl308;
Range fl310;
bool fl321;
Enum fl323;
bool fl334;
Structure fl336;
bool fl347;
Collection fl349;
bool fl360;
StateMachine fl362;
bool fl373;
Function fl375;
bool fl386;
Procedure fl388;
bool fl399;
Variable fl401;
bool fl412;
Rule fl414;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl282 = true ; 
while (fl282) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl282 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<NameSpaces")){
ctxt.skipWhiteSpace();
fl283 = true ; 
while (fl283) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl283 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl285 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpace")) {
fl285 = acceptor.lAccept_NameSpace(ctxt, "</NameSpace>");
appendNameSpaces(fl285);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl297 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpaceRef")) {
fl297 = acceptor.lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
appendNameSpaceRefs(fl297);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</NameSpaces>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Ranges")){
ctxt.skipWhiteSpace();
fl308 = true ; 
while (fl308) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl308 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl310 = null;
while(ctxt.lookAheadOpeningTag ("<Range")) {
fl310 = acceptor.lAccept_Range(ctxt, "</Range>");
appendRanges(fl310);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Ranges>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Enumerations")){
ctxt.skipWhiteSpace();
fl321 = true ; 
while (fl321) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl321 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl323 = null;
while(ctxt.lookAheadOpeningTag ("<Enum")) {
fl323 = acceptor.lAccept_Enum(ctxt, "</Enum>");
appendEnumerations(fl323);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Enumerations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Structures")){
ctxt.skipWhiteSpace();
fl334 = true ; 
while (fl334) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl334 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl336 = null;
while(ctxt.lookAheadOpeningTag ("<Structure")) {
fl336 = acceptor.lAccept_Structure(ctxt, "</Structure>");
appendStructures(fl336);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Structures>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Collections")){
ctxt.skipWhiteSpace();
fl347 = true ; 
while (fl347) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl347 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl349 = null;
while(ctxt.lookAheadOpeningTag ("<Collection")) {
fl349 = acceptor.lAccept_Collection(ctxt, "</Collection>");
appendCollections(fl349);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Collections>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<StateMachines")){
ctxt.skipWhiteSpace();
fl360 = true ; 
while (fl360) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl360 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl362 = null;
while(ctxt.lookAheadOpeningTag ("<StateMachine")) {
fl362 = acceptor.lAccept_StateMachine(ctxt, "</StateMachine>");
appendStateMachines(fl362);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</StateMachines>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Functions")){
ctxt.skipWhiteSpace();
fl373 = true ; 
while (fl373) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl373 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl375 = null;
while(ctxt.lookAheadOpeningTag ("<Function")) {
fl375 = acceptor.lAccept_Function(ctxt, "</Function>");
appendFunctions(fl375);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Functions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Procedures")){
ctxt.skipWhiteSpace();
fl386 = true ; 
while (fl386) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl386 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl388 = null;
while(ctxt.lookAheadOpeningTag ("<Procedure")) {
fl388 = acceptor.lAccept_Procedure(ctxt, "</Procedure>");
appendProcedures(fl388);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Procedures>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Variables")){
ctxt.skipWhiteSpace();
fl399 = true ; 
while (fl399) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl399 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl401 = null;
while(ctxt.lookAheadOpeningTag ("<Variable")) {
fl401 = acceptor.lAccept_Variable(ctxt, "</Variable>");
appendVariables(fl401);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Variables>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl412 = true ; 
while (fl412) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl412 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl414 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl414 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl414);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl425;
bool fl426;
bool fl427;
bool fl428;
bool fl429;
bool fl430;
bool fl431;
bool fl432;
bool fl433;
bool fl434;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl425 = false ; 
fl426 = false ; 
fl427 = false ; 
fl428 = false ; 
fl429 = false ; 
fl430 = false ; 
fl431 = false ; 
fl432 = false ; 
fl433 = false ; 
fl434 = true ; 
while (fl434) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 426;
} else {
indicator = 435;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 425;
} else {
indicator = 435;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 427;
} else {
indicator = 435;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 433;
} else {
indicator = 435;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 430;
} else {
indicator = 435;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 431;
} else {
indicator = 435;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 429;
} else {
indicator = 435;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 428;
} else {
indicator = 435;
} // If
break;
} // Case
default:
indicator = 435;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 432;
} else {
indicator = 435;
} // If
break;
} // Case
default:
indicator = 435;
break;
} // Switch
switch (indicator) {
case 425: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl425){
ctxt.fail ("Duplicate attribute: X");
} // If
fl425 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 426: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl426){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl426 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 427: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl427){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl427 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 428: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl428){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl428 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 429: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl429){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl429 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 430: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl430){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl430 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 431: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl431){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl431 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 432: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl432){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl432 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 433: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl433){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl433 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 435: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl425){
this.setX(0);
} // If
if (!fl426){
this.setY(0);
} // If
if (!fl427){
this.setWidth(0);
} // If
if (!fl428){
this.setHeight(0);
} // If
if (!fl429){
this.setHidden( false);
} // If
if (!fl430){
this.setPinned( false);
} // If
fl434 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<NameSpace";
  endingTag = "</NameSpace>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"NameSpace\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
pw.Write("<NameSpaces>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaces(), false, "<NameSpace", "</NameSpace>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaceRefs(), false, "<NameSpaceRef", "</NameSpaceRef>");
pw.Write("</NameSpaces>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: Ranges
if (countRanges() > 0){
pw.Write("<Ranges>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRanges(), false, "<Range", "</Range>");
pw.Write("</Ranges>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Ranges
// Unparsing Enclosed
// Testing for empty content: Enumerations
if (countEnumerations() > 0){
pw.Write("<Enumerations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getEnumerations(), false, "<Enum", "</Enum>");
pw.Write("</Enumerations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Enumerations
// Unparsing Enclosed
// Testing for empty content: Structures
if (countStructures() > 0){
pw.Write("<Structures>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStructures(), false, "<Structure", "</Structure>");
pw.Write("</Structures>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Structures
// Unparsing Enclosed
// Testing for empty content: Collections
if (countCollections() > 0){
pw.Write("<Collections>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getCollections(), false, "<Collection", "</Collection>");
pw.Write("</Collections>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Collections
// Unparsing Enclosed
// Testing for empty content: StateMachines
if (countStateMachines() > 0){
pw.Write("<StateMachines>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStateMachines(), false, "<StateMachine", "</StateMachine>");
pw.Write("</StateMachines>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: StateMachines
// Unparsing Enclosed
// Testing for empty content: Functions
if (countFunctions() > 0){
pw.Write("<Functions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFunctions(), false, "<Function", "</Function>");
pw.Write("</Functions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Functions
// Unparsing Enclosed
// Testing for empty content: Procedures
if (countProcedures() > 0){
pw.Write("<Procedures>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getProcedures(), false, "<Procedure", "</Procedure>");
pw.Write("</Procedures>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Procedures
// Unparsing Enclosed
// Testing for empty content: Variables
if (countVariables() > 0){
pw.Write("<Variables>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getVariables(), false, "<Variable", "</Variable>");
pw.Write("</Variables>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Variables
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countNameSpaces(); i++) {
  l.Add(getNameSpaces(i));
}
for (int i = 0; i < countNameSpaceRefs(); i++) {
  l.Add(getNameSpaceRefs(i));
}
for (int i = 0; i < countRanges(); i++) {
  l.Add(getRanges(i));
}
for (int i = 0; i < countEnumerations(); i++) {
  l.Add(getEnumerations(i));
}
for (int i = 0; i < countStructures(); i++) {
  l.Add(getStructures(i));
}
for (int i = 0; i < countCollections(); i++) {
  l.Add(getCollections(i));
}
for (int i = 0; i < countStateMachines(); i++) {
  l.Add(getStateMachines(i));
}
for (int i = 0; i < countFunctions(); i++) {
  l.Add(getFunctions(i));
}
for (int i = 0; i < countProcedures(); i++) {
  l.Add(getProcedures(i));
}
for (int i = 0; i < countVariables(); i++) {
  l.Add(getVariables(i));
}
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
}

}
public partial class ReqRef
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getId().CompareTo((String) search) == 0)return true;
if(getSpecId().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ReqRefController.alertChange(aLock, this);
}
private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aSpecId;

public   string  getSpecId() { return aSpecId;}

public  void setSpecId( string  v) {
  aSpecId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ReqRef()
{
ReqRef obj = this;
aId=(null);
aSpecId=(null);
aComment=(null);
}

public void copyTo(ReqRef other)
{
base.copyTo(other);
other.aId = aId;
other.aSpecId = aSpecId;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl447;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl447 = true ; 
while (fl447) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl447 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl448;
bool fl449;
bool fl450;
bool fl451;
bool fl452;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl448 = false ; 
fl449 = false ; 
fl450 = false ; 
fl451 = false ; 
fl452 = true ; 
while (fl452) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 451;
} else {
indicator = 453;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
if (ctxt.lookAheadString("pecId=")){
indicator = 449;
} else {
indicator = 453;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 448;
} else {
indicator = 453;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 450;
} else {
indicator = 453;
} // If
break;
} // Case
default:
indicator = 453;
break;
} // Switch
switch (indicator) {
case 448: {
// Handling attribute Id
// Also handles alien attributes with prefix Id
if (fl448){
ctxt.fail ("Duplicate attribute: Id");
} // If
fl448 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 449: {
// Handling attribute SpecId
// Also handles alien attributes with prefix SpecId
if (fl449){
ctxt.fail ("Duplicate attribute: SpecId");
} // If
fl449 = true ; 
quoteChar = ctxt.acceptQuote();
this.setSpecId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 450: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl450){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl450 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 451: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl451){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl451 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 453: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl448){
ctxt.fail ("Mandatory attribute missing: Id in ReqRef");
} // If
fl452 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ReqRef";
  endingTag = "</ReqRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ReqRef\"");
} // If
pw.Write('\n');
pw.Write(" Id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
if (this.getSpecId() != null){
pw.Write(" SpecId=\"");
acceptor.unParsePcData(pw, this.getSpecId());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public abstract partial class Type
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getDefault().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TypeController.alertChange(aLock, this);
}
private   string  aDefault;

public   string  getDefault() { return aDefault;}

public  void setDefault( string  v) {
  aDefault = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Type()
{
Type obj = this;
aDefault=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
}

public void copyTo(Type other)
{
base.copyTo(other);
other.aDefault = aDefault;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl459;
bool fl460;
bool fl461;
bool fl462;
bool fl463;
bool fl464;
bool fl465;
bool fl466;
bool fl467;
bool fl468;
bool fl469;
bool fl470;
bool fl471;
bool fl472;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl459 = false ; 
fl460 = false ; 
fl461 = false ; 
fl462 = false ; 
fl463 = false ; 
fl464 = false ; 
fl465 = false ; 
fl466 = false ; 
fl467 = false ; 
fl468 = false ; 
fl469 = false ; 
fl470 = false ; 
fl471 = false ; 
fl472 = true ; 
while (fl472) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 461;
} else {
indicator = 473;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 460;
} else {
indicator = 473;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 462;
} else {
indicator = 473;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 467;
} else {
indicator = 473;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 471;
} else {
indicator = 473;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 465;
} else {
indicator = 473;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 468;
} else {
indicator = 473;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 469;
} else {
indicator = 473;
} // If
break;
} // Case
default:
indicator = 473;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 466;
} else {
indicator = 473;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 464;
} else {
indicator = 473;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 463;
} else {
indicator = 473;
} // If
break;
} // Case
default:
indicator = 473;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 470;
} else {
indicator = 473;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 459;
} else {
indicator = 473;
} // If
break;
} // Case
default:
indicator = 473;
break;
} // Switch
switch (indicator) {
case 459: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl459){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl459 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 460: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl460){
ctxt.fail ("Duplicate attribute: X");
} // If
fl460 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 461: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl461){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl461 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 462: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl462){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl462 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 463: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl463){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl463 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 464: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl464){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl464 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 465: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl465){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl465 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 466: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl466){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl466 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 467: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl467){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl467 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 468: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl468){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl468 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 469: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl469){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl469 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 470: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl470){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl470 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 471: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl471){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl471 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 473: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl460){
this.setX(0);
} // If
if (!fl461){
this.setY(0);
} // If
if (!fl462){
this.setWidth(0);
} // If
if (!fl463){
this.setHeight(0);
} // If
if (!fl464){
this.setHidden( false);
} // If
if (!fl465){
this.setPinned( false);
} // If
if (!fl466){
this.setImplemented( false);
} // If
if (!fl467){
this.setVerified( false);
} // If
if (!fl468){
this.setNeedsRequirement( true);
} // If
fl472 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Type";
  endingTag = "</Type>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Type\"");
} // If
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Enum
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.EnumController.alertChange(aLock, this);
}
private System.Collections.ArrayList aValues;

/// <summary>Part of the list interface for Values</summary>
/// <returns>a collection of all the elements in Values</returns>
public System.Collections.ArrayList allValues()
  {
if (aValues == null){
    setAllValues( new System.Collections.ArrayList() );
} // If
    return aValues;
  }

/// <summary>Part of the list interface for Values</summary>
/// <returns>a collection of all the elements in Values</returns>
private System.Collections.ArrayList getValues()
  {
    return allValues();
  }

/// <summary>Part of the list interface for Values</summary>
/// <param name="coll">a collection of elements which replaces 
///        Values's current content.</param>
public void setAllValues(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aValues = coll;
    NotifyControllers(null);
  }
public void setAllValues(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aValues = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values</summary>
/// <param name="el">a EnumValue to add to the collection in 
///           Values</param>
/// <seealso cref="appendValues(System.Collections.IList)"/>
public void appendValues(EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendValues(Lock aLock,EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Values</summary>
/// <param name="coll">a collection ofEnumValues to add to the collection in 
///           Values</param>
/// <seealso cref="appendValues(EnumValue)"/>
public void appendValues(System.Collections.IList coll)
  {
  __setDirty(true);
  allValues().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendValues(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allValues().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values
/// This insertion function inserts a new element in the
/// collection in Values</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertValues(int idx, EnumValue el)
  {
  __setDirty(true);
  allValues().Insert (idx, el);
NotifyControllers(null);
  }

public void insertValues(int idx, EnumValue el,Lock aLock)
  {
  __setDirty(true);
  allValues().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfValues(IXmlBBase el)
  {
  return ((System.Collections.IList) allValues()).IndexOf (el);
  }

/// <summary>Part of the list interface for Values
/// This deletion function removes an element from the
/// collection in Values</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteValues(int idx)
  {
  __setDirty(true);
  allValues().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteValues(int idx,Lock aLock)
  {
  __setDirty(true);
  allValues().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values
/// This deletion function removes an element from the
/// collection in Values
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeValues(IXmlBBase obj)
  {
  int idx = indexOfValues(obj);
  if (idx >= 0) { deleteValues(idx);
NotifyControllers(null);
   }
  }

public void removeValues(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfValues(obj);
  if (idx >= 0) { deleteValues(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Values</summary>
/// <returns>the number of elements in Values</returns>
public int countValues()
  {
  return allValues().Count;
  }

/// <summary>Part of the list interface for Values
/// This function returns an element from the
/// collection in Values based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public EnumValue getValues(int idx)
{
  return (EnumValue) ( allValues()[idx]);
}

private System.Collections.ArrayList aSubEnums;

/// <summary>Part of the list interface for SubEnums</summary>
/// <returns>a collection of all the elements in SubEnums</returns>
public System.Collections.ArrayList allSubEnums()
  {
if (aSubEnums == null){
    setAllSubEnums( new System.Collections.ArrayList() );
} // If
    return aSubEnums;
  }

/// <summary>Part of the list interface for SubEnums</summary>
/// <returns>a collection of all the elements in SubEnums</returns>
private System.Collections.ArrayList getSubEnums()
  {
    return allSubEnums();
  }

/// <summary>Part of the list interface for SubEnums</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubEnums's current content.</param>
public void setAllSubEnums(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubEnums = coll;
    NotifyControllers(null);
  }
public void setAllSubEnums(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubEnums = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums</summary>
/// <param name="el">a Enum to add to the collection in 
///           SubEnums</param>
/// <seealso cref="appendSubEnums(System.Collections.IList)"/>
public void appendSubEnums(Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubEnums().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubEnums(Lock aLock,Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubEnums().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubEnums</summary>
/// <param name="coll">a collection ofEnums to add to the collection in 
///           SubEnums</param>
/// <seealso cref="appendSubEnums(Enum)"/>
public void appendSubEnums(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubEnums().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubEnums(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubEnums().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums
/// This insertion function inserts a new element in the
/// collection in SubEnums</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubEnums(int idx, Enum el)
  {
  __setDirty(true);
  allSubEnums().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubEnums(int idx, Enum el,Lock aLock)
  {
  __setDirty(true);
  allSubEnums().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubEnums(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubEnums()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubEnums
/// This deletion function removes an element from the
/// collection in SubEnums</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubEnums(int idx)
  {
  __setDirty(true);
  allSubEnums().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubEnums(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubEnums().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums
/// This deletion function removes an element from the
/// collection in SubEnums
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubEnums(IXmlBBase obj)
  {
  int idx = indexOfSubEnums(obj);
  if (idx >= 0) { deleteSubEnums(idx);
NotifyControllers(null);
   }
  }

public void removeSubEnums(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubEnums(obj);
  if (idx >= 0) { deleteSubEnums(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubEnums</summary>
/// <returns>the number of elements in SubEnums</returns>
public int countSubEnums()
  {
  return allSubEnums().Count;
  }

/// <summary>Part of the list interface for SubEnums
/// This function returns an element from the
/// collection in SubEnums based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Enum getSubEnums(int idx)
{
  return (Enum) ( allSubEnums()[idx]);
}

public Enum()
{
Enum obj = this;
aValues=(null);
aSubEnums=(null);
}

public void copyTo(Enum other)
{
base.copyTo(other);
other.aValues = aValues;
other.aSubEnums = aSubEnums;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl490;
EnumValue fl492;
bool fl503;
Enum fl505;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Values")){
ctxt.skipWhiteSpace();
fl490 = true ; 
while (fl490) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl490 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl492 = null;
while(ctxt.lookAheadOpeningTag ("<EnumValue")) {
fl492 = acceptor.lAccept_EnumValue(ctxt, "</EnumValue>");
appendValues(fl492);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Values>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubEnums")){
ctxt.skipWhiteSpace();
fl503 = true ; 
while (fl503) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl503 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl505 = null;
while(ctxt.lookAheadOpeningTag ("<Enum")) {
fl505 = acceptor.lAccept_Enum(ctxt, "</Enum>");
appendSubEnums(fl505);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubEnums>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl516;
bool fl517;
bool fl518;
bool fl519;
bool fl520;
bool fl521;
bool fl522;
bool fl523;
bool fl524;
bool fl525;
bool fl526;
bool fl527;
bool fl528;
bool fl529;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl516 = false ; 
fl517 = false ; 
fl518 = false ; 
fl519 = false ; 
fl520 = false ; 
fl521 = false ; 
fl522 = false ; 
fl523 = false ; 
fl524 = false ; 
fl525 = false ; 
fl526 = false ; 
fl527 = false ; 
fl528 = false ; 
fl529 = true ; 
while (fl529) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 518;
} else {
indicator = 530;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 517;
} else {
indicator = 530;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 519;
} else {
indicator = 530;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 524;
} else {
indicator = 530;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 528;
} else {
indicator = 530;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 522;
} else {
indicator = 530;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 525;
} else {
indicator = 530;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 526;
} else {
indicator = 530;
} // If
break;
} // Case
default:
indicator = 530;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 523;
} else {
indicator = 530;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 521;
} else {
indicator = 530;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 520;
} else {
indicator = 530;
} // If
break;
} // Case
default:
indicator = 530;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 527;
} else {
indicator = 530;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 516;
} else {
indicator = 530;
} // If
break;
} // Case
default:
indicator = 530;
break;
} // Switch
switch (indicator) {
case 516: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl516){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl516 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 517: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl517){
ctxt.fail ("Duplicate attribute: X");
} // If
fl517 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 518: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl518){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl518 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 519: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl519){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl519 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 520: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl520){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl520 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 521: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl521){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl521 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 522: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl522){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl522 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 523: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl523){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl523 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 524: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl524){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl524 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 525: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl525){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl525 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 526: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl526){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl526 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 527: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl527){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl527 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 528: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl528){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl528 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 530: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl517){
this.setX(0);
} // If
if (!fl518){
this.setY(0);
} // If
if (!fl519){
this.setWidth(0);
} // If
if (!fl520){
this.setHeight(0);
} // If
if (!fl521){
this.setHidden( false);
} // If
if (!fl522){
this.setPinned( false);
} // If
if (!fl523){
this.setImplemented( false);
} // If
if (!fl524){
this.setVerified( false);
} // If
if (!fl525){
this.setNeedsRequirement( true);
} // If
fl529 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Enum";
  endingTag = "</Enum>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Enum\"");
} // If
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Values
if (countValues() > 0){
pw.Write("<Values>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getValues(), false, "<EnumValue", "</EnumValue>");
pw.Write("</Values>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Values
// Unparsing Enclosed
// Testing for empty content: SubEnums
if (countSubEnums() > 0){
pw.Write("<SubEnums>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubEnums(), false, "<Enum", "</Enum>");
pw.Write("</SubEnums>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubEnums
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countValues(); i++) {
  l.Add(getValues(i));
}
for (int i = 0; i < countSubEnums(); i++) {
  l.Add(getSubEnums(i));
}
}

}
public partial class EnumValue
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.EnumValueController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aForbidArithmeticOperation;

public  bool getForbidArithmeticOperation() { return aForbidArithmeticOperation;}

public  void setForbidArithmeticOperation(bool v) {
  aForbidArithmeticOperation = v;
  __setDirty(true);
  NotifyControllers(null);
}


public EnumValue()
{
EnumValue obj = this;
aValue=(null);
aForbidArithmeticOperation=(false);
}

public void copyTo(EnumValue other)
{
base.copyTo(other);
other.aValue = aValue;
other.aForbidArithmeticOperation = aForbidArithmeticOperation;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl547;
bool fl548;
bool fl549;
bool fl550;
bool fl551;
bool fl552;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl547 = false ; 
fl548 = false ; 
fl549 = false ; 
fl550 = false ; 
fl551 = false ; 
fl552 = true ; 
while (fl552) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue=")){
indicator = 547;
} else {
indicator = 553;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 551;
} else {
indicator = 553;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 549;
} else {
indicator = 553;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 550;
} else {
indicator = 553;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("orbidArithmeticOperation=")){
indicator = 548;
} else {
indicator = 553;
} // If
break;
} // Case
default:
indicator = 553;
break;
} // Switch
switch (indicator) {
case 547: {
// Handling attribute Value
// Also handles alien attributes with prefix Value
if (fl547){
ctxt.fail ("Duplicate attribute: Value");
} // If
fl547 = true ; 
quoteChar = ctxt.acceptQuote();
this.setValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 548: {
// Handling attribute ForbidArithmeticOperation
// Also handles alien attributes with prefix ForbidArithmeticOperation
if (fl548){
ctxt.fail ("Duplicate attribute: ForbidArithmeticOperation");
} // If
fl548 = true ; 
quoteChar = ctxt.acceptQuote();
this.setForbidArithmeticOperation(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 549: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl549){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl549 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 550: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl550){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl550 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 551: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl551){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl551 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 553: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl547){
this.setValue("0");
} // If
if (!fl548){
this.setForbidArithmeticOperation( false);
} // If
fl552 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<EnumValue";
  endingTag = "</EnumValue>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"EnumValue\"");
} // If
pw.Write('\n');
if (this.getValue() != null){
pw.Write(" Value=\"");
acceptor.unParsePcData(pw, this.getValue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getForbidArithmeticOperation()){
pw.Write(" ForbidArithmeticOperation=\"");
acceptor.unParsePcData(pw, this.getForbidArithmeticOperation());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Range
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getMinValue().CompareTo((String) search) == 0)return true;
if(getMaxValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RangeController.alertChange(aLock, this);
}
private   string  aMinValue;

public   string  getMinValue() { return aMinValue;}

public  void setMinValue( string  v) {
  aMinValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMaxValue;

public   string  getMaxValue() { return aMaxValue;}

public  void setMaxValue( string  v) {
  aMaxValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSpecialValues;

/// <summary>Part of the list interface for SpecialValues</summary>
/// <returns>a collection of all the elements in SpecialValues</returns>
public System.Collections.ArrayList allSpecialValues()
  {
if (aSpecialValues == null){
    setAllSpecialValues( new System.Collections.ArrayList() );
} // If
    return aSpecialValues;
  }

/// <summary>Part of the list interface for SpecialValues</summary>
/// <returns>a collection of all the elements in SpecialValues</returns>
private System.Collections.ArrayList getSpecialValues()
  {
    return allSpecialValues();
  }

/// <summary>Part of the list interface for SpecialValues</summary>
/// <param name="coll">a collection of elements which replaces 
///        SpecialValues's current content.</param>
public void setAllSpecialValues(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecialValues = coll;
    NotifyControllers(null);
  }
public void setAllSpecialValues(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecialValues = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues</summary>
/// <param name="el">a EnumValue to add to the collection in 
///           SpecialValues</param>
/// <seealso cref="appendSpecialValues(System.Collections.IList)"/>
public void appendSpecialValues(EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecialValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSpecialValues(Lock aLock,EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecialValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SpecialValues</summary>
/// <param name="coll">a collection ofEnumValues to add to the collection in 
///           SpecialValues</param>
/// <seealso cref="appendSpecialValues(EnumValue)"/>
public void appendSpecialValues(System.Collections.IList coll)
  {
  __setDirty(true);
  allSpecialValues().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSpecialValues(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSpecialValues().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues
/// This insertion function inserts a new element in the
/// collection in SpecialValues</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSpecialValues(int idx, EnumValue el)
  {
  __setDirty(true);
  allSpecialValues().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSpecialValues(int idx, EnumValue el,Lock aLock)
  {
  __setDirty(true);
  allSpecialValues().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSpecialValues(IXmlBBase el)
  {
  return ((System.Collections.IList) allSpecialValues()).IndexOf (el);
  }

/// <summary>Part of the list interface for SpecialValues
/// This deletion function removes an element from the
/// collection in SpecialValues</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSpecialValues(int idx)
  {
  __setDirty(true);
  allSpecialValues().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSpecialValues(int idx,Lock aLock)
  {
  __setDirty(true);
  allSpecialValues().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues
/// This deletion function removes an element from the
/// collection in SpecialValues
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSpecialValues(IXmlBBase obj)
  {
  int idx = indexOfSpecialValues(obj);
  if (idx >= 0) { deleteSpecialValues(idx);
NotifyControllers(null);
   }
  }

public void removeSpecialValues(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSpecialValues(obj);
  if (idx >= 0) { deleteSpecialValues(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SpecialValues</summary>
/// <returns>the number of elements in SpecialValues</returns>
public int countSpecialValues()
  {
  return allSpecialValues().Count;
  }

/// <summary>Part of the list interface for SpecialValues
/// This function returns an element from the
/// collection in SpecialValues based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public EnumValue getSpecialValues(int idx)
{
  return (EnumValue) ( allSpecialValues()[idx]);
}

private  acceptor.PrecisionEnum aPrecision;

public  acceptor.PrecisionEnum getPrecision() { return aPrecision;}

public  void setPrecision(acceptor.PrecisionEnum v) {
  aPrecision = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getPrecision_AsString()
{
  return acceptor.Enum_PrecisionEnum_ToString (aPrecision);
}

public  bool setPrecision_AsString( string  v)
{
 acceptor.PrecisionEnum  temp = acceptor.StringTo_Enum_PrecisionEnum(v);
if (temp >= 0){
  aPrecision = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public Range()
{
Range obj = this;
aMinValue=(null);
aMaxValue=(null);
aSpecialValues=(null);
aPrecision=(0);
}

public void copyTo(Range other)
{
base.copyTo(other);
other.aMinValue = aMinValue;
other.aMaxValue = aMaxValue;
other.aSpecialValues = aSpecialValues;
other.aPrecision = aPrecision;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl560;
EnumValue fl562;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SpecialValues")){
ctxt.skipWhiteSpace();
fl560 = true ; 
while (fl560) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl560 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl562 = null;
while(ctxt.lookAheadOpeningTag ("<EnumValue")) {
fl562 = acceptor.lAccept_EnumValue(ctxt, "</EnumValue>");
appendSpecialValues(fl562);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SpecialValues>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl573;
bool fl574;
bool fl575;
bool fl576;
bool fl577;
bool fl578;
bool fl579;
bool fl580;
bool fl581;
bool fl582;
bool fl583;
bool fl584;
bool fl585;
bool fl586;
bool fl587;
bool fl588;
bool fl589;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl573 = false ; 
fl574 = false ; 
fl575 = false ; 
fl576 = false ; 
fl577 = false ; 
fl578 = false ; 
fl579 = false ; 
fl580 = false ; 
fl581 = false ; 
fl582 = false ; 
fl583 = false ; 
fl584 = false ; 
fl585 = false ; 
fl586 = false ; 
fl587 = false ; 
fl588 = false ; 
fl589 = true ; 
while (fl589) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 578;
} else {
indicator = 590;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 577;
} else {
indicator = 590;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 579;
} else {
indicator = 590;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 584;
} else {
indicator = 590;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 588;
} else {
indicator = 590;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ecision=")){
indicator = 575;
} else {
indicator = 590;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nned=")){
indicator = 582;
} else {
indicator = 590;
} // If
break;
} // Case
default:
indicator = 590;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 585;
} else {
indicator = 590;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 586;
} else {
indicator = 590;
} // If
break;
} // Case
default:
indicator = 590;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nValue=")){
indicator = 573;
} else {
indicator = 590;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("xValue=")){
indicator = 574;
} else {
indicator = 590;
} // If
break;
} // Case
default:
indicator = 590;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 583;
} else {
indicator = 590;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 581;
} else {
indicator = 590;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 580;
} else {
indicator = 590;
} // If
break;
} // Case
default:
indicator = 590;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 587;
} else {
indicator = 590;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 576;
} else {
indicator = 590;
} // If
break;
} // Case
default:
indicator = 590;
break;
} // Switch
switch (indicator) {
case 573: {
// Handling attribute MinValue
// Also handles alien attributes with prefix MinValue
if (fl573){
ctxt.fail ("Duplicate attribute: MinValue");
} // If
fl573 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMinValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 574: {
// Handling attribute MaxValue
// Also handles alien attributes with prefix MaxValue
if (fl574){
ctxt.fail ("Duplicate attribute: MaxValue");
} // If
fl574 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMaxValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 575: {
// Handling attribute Precision
// Also handles alien attributes with prefix Precision
if (fl575){
ctxt.fail ("Duplicate attribute: Precision");
} // If
fl575 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPrecision(acceptor.lAcceptEnum_PrecisionEnum(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 576: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl576){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl576 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 577: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl577){
ctxt.fail ("Duplicate attribute: X");
} // If
fl577 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 578: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl578){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl578 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 579: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl579){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl579 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 580: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl580){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl580 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 581: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl581){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl581 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 582: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl582){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl582 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 583: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl583){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl583 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 584: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl584){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl584 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 585: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl585){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl585 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 586: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl586){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl586 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 587: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl587){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl587 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 588: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl588){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl588 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 590: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl573){
ctxt.fail ("Mandatory attribute missing: MinValue in Range");
} // If
if (!fl574){
ctxt.fail ("Mandatory attribute missing: MaxValue in Range");
} // If
if (!fl575){
this.setPrecision(acceptor.PrecisionEnum.aIntegerPrecision);
} // If
if (!fl577){
this.setX(0);
} // If
if (!fl578){
this.setY(0);
} // If
if (!fl579){
this.setWidth(0);
} // If
if (!fl580){
this.setHeight(0);
} // If
if (!fl581){
this.setHidden( false);
} // If
if (!fl582){
this.setPinned( false);
} // If
if (!fl583){
this.setImplemented( false);
} // If
if (!fl584){
this.setVerified( false);
} // If
if (!fl585){
this.setNeedsRequirement( true);
} // If
fl589 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Range";
  endingTag = "</Range>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Range\"");
} // If
pw.Write('\n');
pw.Write(" MinValue=\"");
acceptor.unParsePcData(pw, this.getMinValue());
pw.Write('"');
pw.Write('\n');
pw.Write(" MaxValue=\"");
acceptor.unParsePcData(pw, this.getMaxValue());
pw.Write('"');
pw.Write('\n');
if (this.getPrecision() != 0){
pw.Write(" Precision=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_PrecisionEnum_ToString(this.getPrecision()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: SpecialValues
if (countSpecialValues() > 0){
pw.Write("<SpecialValues>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSpecialValues(), false, "<EnumValue", "</EnumValue>");
pw.Write("</SpecialValues>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SpecialValues
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSpecialValues(); i++) {
  l.Add(getSpecialValues(i));
}
}

}
public partial class Structure
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StructureController.alertChange(aLock, this);
}
private System.Collections.ArrayList aElements;

/// <summary>Part of the list interface for Elements</summary>
/// <returns>a collection of all the elements in Elements</returns>
public System.Collections.ArrayList allElements()
  {
if (aElements == null){
    setAllElements( new System.Collections.ArrayList() );
} // If
    return aElements;
  }

/// <summary>Part of the list interface for Elements</summary>
/// <returns>a collection of all the elements in Elements</returns>
private System.Collections.ArrayList getElements()
  {
    return allElements();
  }

/// <summary>Part of the list interface for Elements</summary>
/// <param name="coll">a collection of elements which replaces 
///        Elements's current content.</param>
public void setAllElements(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aElements = coll;
    NotifyControllers(null);
  }
public void setAllElements(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aElements = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements</summary>
/// <param name="el">a StructureElement to add to the collection in 
///           Elements</param>
/// <seealso cref="appendElements(System.Collections.IList)"/>
public void appendElements(StructureElement el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allElements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendElements(Lock aLock,StructureElement el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allElements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Elements</summary>
/// <param name="coll">a collection ofStructureElements to add to the collection in 
///           Elements</param>
/// <seealso cref="appendElements(StructureElement)"/>
public void appendElements(System.Collections.IList coll)
  {
  __setDirty(true);
  allElements().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendElements(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allElements().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements
/// This insertion function inserts a new element in the
/// collection in Elements</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertElements(int idx, StructureElement el)
  {
  __setDirty(true);
  allElements().Insert (idx, el);
NotifyControllers(null);
  }

public void insertElements(int idx, StructureElement el,Lock aLock)
  {
  __setDirty(true);
  allElements().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfElements(IXmlBBase el)
  {
  return ((System.Collections.IList) allElements()).IndexOf (el);
  }

/// <summary>Part of the list interface for Elements
/// This deletion function removes an element from the
/// collection in Elements</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteElements(int idx)
  {
  __setDirty(true);
  allElements().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteElements(int idx,Lock aLock)
  {
  __setDirty(true);
  allElements().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements
/// This deletion function removes an element from the
/// collection in Elements
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeElements(IXmlBBase obj)
  {
  int idx = indexOfElements(obj);
  if (idx >= 0) { deleteElements(idx);
NotifyControllers(null);
   }
  }

public void removeElements(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfElements(obj);
  if (idx >= 0) { deleteElements(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Elements</summary>
/// <returns>the number of elements in Elements</returns>
public int countElements()
  {
  return allElements().Count;
  }

/// <summary>Part of the list interface for Elements
/// This function returns an element from the
/// collection in Elements based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StructureElement getElements(int idx)
{
  return (StructureElement) ( allElements()[idx]);
}

private System.Collections.ArrayList aProcedures;

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
public System.Collections.ArrayList allProcedures()
  {
if (aProcedures == null){
    setAllProcedures( new System.Collections.ArrayList() );
} // If
    return aProcedures;
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
private System.Collections.ArrayList getProcedures()
  {
    return allProcedures();
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection of elements which replaces 
///        Procedures's current content.</param>
public void setAllProcedures(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
    NotifyControllers(null);
  }
public void setAllProcedures(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="el">a Procedure to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(System.Collections.IList)"/>
public void appendProcedures(Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendProcedures(Lock aLock,Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection ofProcedures to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(Procedure)"/>
public void appendProcedures(System.Collections.IList coll)
  {
  __setDirty(true);
  allProcedures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendProcedures(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allProcedures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This insertion function inserts a new element in the
/// collection in Procedures</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertProcedures(int idx, Procedure el)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(null);
  }

public void insertProcedures(int idx, Procedure el,Lock aLock)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfProcedures(IXmlBBase el)
  {
  return ((System.Collections.IList) allProcedures()).IndexOf (el);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteProcedures(int idx)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteProcedures(int idx,Lock aLock)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeProcedures(IXmlBBase obj)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(null);
   }
  }

public void removeProcedures(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>the number of elements in Procedures</returns>
public int countProcedures()
  {
  return allProcedures().Count;
  }

/// <summary>Part of the list interface for Procedures
/// This function returns an element from the
/// collection in Procedures based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Procedure getProcedures(int idx)
{
  return (Procedure) ( allProcedures()[idx]);
}

private System.Collections.ArrayList aStateMachines;

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
public System.Collections.ArrayList allStateMachines()
  {
if (aStateMachines == null){
    setAllStateMachines( new System.Collections.ArrayList() );
} // If
    return aStateMachines;
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
private System.Collections.ArrayList getStateMachines()
  {
    return allStateMachines();
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection of elements which replaces 
///        StateMachines's current content.</param>
public void setAllStateMachines(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
    NotifyControllers(null);
  }
public void setAllStateMachines(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="el">a StateMachine to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(System.Collections.IList)"/>
public void appendStateMachines(StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStateMachines(Lock aLock,StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection ofStateMachines to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(StateMachine)"/>
public void appendStateMachines(System.Collections.IList coll)
  {
  __setDirty(true);
  allStateMachines().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStateMachines(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This insertion function inserts a new element in the
/// collection in StateMachines</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStateMachines(int idx, StateMachine el)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStateMachines(int idx, StateMachine el,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStateMachines(IXmlBBase el)
  {
  return ((System.Collections.IList) allStateMachines()).IndexOf (el);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStateMachines(int idx)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStateMachines(int idx,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStateMachines(IXmlBBase obj)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(null);
   }
  }

public void removeStateMachines(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>the number of elements in StateMachines</returns>
public int countStateMachines()
  {
  return allStateMachines().Count;
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns an element from the
/// collection in StateMachines based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StateMachine getStateMachines(int idx)
{
  return (StateMachine) ( allStateMachines()[idx]);
}

private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

private System.Collections.ArrayList aInterfaces;

/// <summary>Part of the list interface for Interfaces</summary>
/// <returns>a collection of all the elements in Interfaces</returns>
public System.Collections.ArrayList allInterfaces()
  {
if (aInterfaces == null){
    setAllInterfaces( new System.Collections.ArrayList() );
} // If
    return aInterfaces;
  }

/// <summary>Part of the list interface for Interfaces</summary>
/// <returns>a collection of all the elements in Interfaces</returns>
private System.Collections.ArrayList getInterfaces()
  {
    return allInterfaces();
  }

/// <summary>Part of the list interface for Interfaces</summary>
/// <param name="coll">a collection of elements which replaces 
///        Interfaces's current content.</param>
public void setAllInterfaces(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aInterfaces = coll;
    NotifyControllers(null);
  }
public void setAllInterfaces(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aInterfaces = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Interfaces</summary>
/// <param name="el">a StructureRef to add to the collection in 
///           Interfaces</param>
/// <seealso cref="appendInterfaces(System.Collections.IList)"/>
public void appendInterfaces(StructureRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allInterfaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendInterfaces(Lock aLock,StructureRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allInterfaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Interfaces</summary>
/// <param name="coll">a collection ofStructureRefs to add to the collection in 
///           Interfaces</param>
/// <seealso cref="appendInterfaces(StructureRef)"/>
public void appendInterfaces(System.Collections.IList coll)
  {
  __setDirty(true);
  allInterfaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendInterfaces(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allInterfaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Interfaces
/// This insertion function inserts a new element in the
/// collection in Interfaces</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertInterfaces(int idx, StructureRef el)
  {
  __setDirty(true);
  allInterfaces().Insert (idx, el);
NotifyControllers(null);
  }

public void insertInterfaces(int idx, StructureRef el,Lock aLock)
  {
  __setDirty(true);
  allInterfaces().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Interfaces
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfInterfaces(IXmlBBase el)
  {
  return ((System.Collections.IList) allInterfaces()).IndexOf (el);
  }

/// <summary>Part of the list interface for Interfaces
/// This deletion function removes an element from the
/// collection in Interfaces</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteInterfaces(int idx)
  {
  __setDirty(true);
  allInterfaces().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteInterfaces(int idx,Lock aLock)
  {
  __setDirty(true);
  allInterfaces().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Interfaces
/// This deletion function removes an element from the
/// collection in Interfaces
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeInterfaces(IXmlBBase obj)
  {
  int idx = indexOfInterfaces(obj);
  if (idx >= 0) { deleteInterfaces(idx);
NotifyControllers(null);
   }
  }

public void removeInterfaces(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfInterfaces(obj);
  if (idx >= 0) { deleteInterfaces(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Interfaces</summary>
/// <returns>the number of elements in Interfaces</returns>
public int countInterfaces()
  {
  return allInterfaces().Count;
  }

/// <summary>Part of the list interface for Interfaces
/// This function returns an element from the
/// collection in Interfaces based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StructureRef getInterfaces(int idx)
{
  return (StructureRef) ( allInterfaces()[idx]);
}

private  bool aIsAbstract;

public  bool getIsAbstract() { return aIsAbstract;}

public  void setIsAbstract(bool v) {
  aIsAbstract = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Structure()
{
Structure obj = this;
aElements=(null);
aProcedures=(null);
aStateMachines=(null);
aRules=(null);
aInterfaces=(null);
aIsAbstract=(false);
}

public void copyTo(Structure other)
{
base.copyTo(other);
other.aElements = aElements;
other.aProcedures = aProcedures;
other.aStateMachines = aStateMachines;
other.aRules = aRules;
other.aInterfaces = aInterfaces;
other.aIsAbstract = aIsAbstract;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl612;
Rule fl614;
bool fl625;
Procedure fl627;
StructureElement fl639;
bool fl650;
StateMachine fl652;
bool fl663;
StructureRef fl665;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl612 = true ; 
while (fl612) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl612 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl614 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl614 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl614);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Procedures")){
ctxt.skipWhiteSpace();
fl625 = true ; 
while (fl625) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl625 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl627 = null;
while(ctxt.lookAheadOpeningTag ("<Procedure")) {
fl627 = acceptor.lAccept_Procedure(ctxt, "</Procedure>");
appendProcedures(fl627);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Procedures>");
} // If
} // If
// End enclosed
// Repeat
ctxt.skipWhiteSpace();
fl639 = null;
while(ctxt.lookAheadOpeningTag ("<StructureElement")) {
fl639 = acceptor.lAccept_StructureElement(ctxt, "</StructureElement>");
appendElements(fl639);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<StateMachines")){
ctxt.skipWhiteSpace();
fl650 = true ; 
while (fl650) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl650 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl652 = null;
while(ctxt.lookAheadOpeningTag ("<StateMachine")) {
fl652 = acceptor.lAccept_StateMachine(ctxt, "</StateMachine>");
appendStateMachines(fl652);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</StateMachines>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Interfaces")){
ctxt.skipWhiteSpace();
fl663 = true ; 
while (fl663) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl663 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl665 = null;
while(ctxt.lookAheadOpeningTag ("<StructureRef")) {
fl665 = acceptor.lAccept_StructureRef(ctxt, "</StructureRef>");
appendInterfaces(fl665);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Interfaces>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl676;
bool fl677;
bool fl678;
bool fl679;
bool fl680;
bool fl681;
bool fl682;
bool fl683;
bool fl684;
bool fl685;
bool fl686;
bool fl687;
bool fl688;
bool fl689;
bool fl690;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl676 = false ; 
fl677 = false ; 
fl678 = false ; 
fl679 = false ; 
fl680 = false ; 
fl681 = false ; 
fl682 = false ; 
fl683 = false ; 
fl684 = false ; 
fl685 = false ; 
fl686 = false ; 
fl687 = false ; 
fl688 = false ; 
fl689 = false ; 
fl690 = true ; 
while (fl690) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 679;
} else {
indicator = 691;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 678;
} else {
indicator = 691;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 680;
} else {
indicator = 691;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 685;
} else {
indicator = 691;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 689;
} else {
indicator = 691;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 683;
} else {
indicator = 691;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 686;
} else {
indicator = 691;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 687;
} else {
indicator = 691;
} // If
break;
} // Case
default:
indicator = 691;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
if (ctxt.lookAheadString("Abstract=")){
indicator = 676;
} else {
indicator = 691;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("plemented=")){
indicator = 684;
} else {
indicator = 691;
} // If
break;
} // Case
default:
indicator = 691;
break;
} // Switch
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 682;
} else {
indicator = 691;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 681;
} else {
indicator = 691;
} // If
break;
} // Case
default:
indicator = 691;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 688;
} else {
indicator = 691;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 677;
} else {
indicator = 691;
} // If
break;
} // Case
default:
indicator = 691;
break;
} // Switch
switch (indicator) {
case 676: {
// Handling attribute IsAbstract
// Also handles alien attributes with prefix IsAbstract
if (fl676){
ctxt.fail ("Duplicate attribute: IsAbstract");
} // If
fl676 = true ; 
quoteChar = ctxt.acceptQuote();
this.setIsAbstract(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 677: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl677){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl677 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 678: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl678){
ctxt.fail ("Duplicate attribute: X");
} // If
fl678 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 679: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl679){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl679 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 680: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl680){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl680 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 681: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl681){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl681 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 682: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl682){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl682 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 683: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl683){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl683 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 684: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl684){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl684 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 685: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl685){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl685 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 686: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl686){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl686 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 687: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl687){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl687 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 688: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl688){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl688 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 689: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl689){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl689 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 691: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl676){
this.setIsAbstract( false);
} // If
if (!fl678){
this.setX(0);
} // If
if (!fl679){
this.setY(0);
} // If
if (!fl680){
this.setWidth(0);
} // If
if (!fl681){
this.setHeight(0);
} // If
if (!fl682){
this.setHidden( false);
} // If
if (!fl683){
this.setPinned( false);
} // If
if (!fl684){
this.setImplemented( false);
} // If
if (!fl685){
this.setVerified( false);
} // If
if (!fl686){
this.setNeedsRequirement( true);
} // If
fl690 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Structure";
  endingTag = "</Structure>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Structure\"");
} // If
pw.Write('\n');
if (this.getIsAbstract()){
pw.Write(" IsAbstract=\"");
acceptor.unParsePcData(pw, this.getIsAbstract());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
// Unparsing Enclosed
// Testing for empty content: Procedures
if (countProcedures() > 0){
pw.Write("<Procedures>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getProcedures(), false, "<Procedure", "</Procedure>");
pw.Write("</Procedures>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Procedures
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getElements(), false, "<StructureElement", "</StructureElement>");
// Unparsing Enclosed
// Testing for empty content: StateMachines
if (countStateMachines() > 0){
pw.Write("<StateMachines>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStateMachines(), false, "<StateMachine", "</StateMachine>");
pw.Write("</StateMachines>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: StateMachines
// Unparsing Enclosed
// Testing for empty content: Interfaces
if (countInterfaces() > 0){
pw.Write("<Interfaces>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getInterfaces(), false, "<StructureRef", "</StructureRef>");
pw.Write("</Interfaces>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Interfaces
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countElements(); i++) {
  l.Add(getElements(i));
}
for (int i = 0; i < countProcedures(); i++) {
  l.Add(getProcedures(i));
}
for (int i = 0; i < countStateMachines(); i++) {
  l.Add(getStateMachines(i));
}
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
for (int i = 0; i < countInterfaces(); i++) {
  l.Add(getInterfaces(i));
}
}

}
public partial class StructureRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StructureRefController.alertChange(aLock, this);
}
public StructureRef()
{
StructureRef obj = this;
}

public void copyTo(StructureRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl710;
bool fl711;
bool fl712;
bool fl713;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl710 = false ; 
fl711 = false ; 
fl712 = false ; 
fl713 = true ; 
while (fl713) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 712;
} else {
indicator = 714;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 710;
} else {
indicator = 714;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 711;
} else {
indicator = 714;
} // If
break;
} // Case
default:
indicator = 714;
break;
} // Switch
switch (indicator) {
case 710: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl710){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl710 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 711: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl711){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl711 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 712: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl712){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl712 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 714: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl713 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<StructureRef";
  endingTag = "</StructureRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"StructureRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class StructureElement
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
if(getDefault().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StructureElementController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDefault;

public   string  getDefault() { return aDefault;}

public  void setDefault( string  v) {
  aDefault = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.VariableModeEnumType aMode;

public  acceptor.VariableModeEnumType getMode() { return aMode;}

public  void setMode(acceptor.VariableModeEnumType v) {
  aMode = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMode_AsString()
{
  return acceptor.Enum_VariableModeEnumType_ToString (aMode);
}

public  bool setMode_AsString( string  v)
{
 acceptor.VariableModeEnumType  temp = acceptor.StringTo_Enum_VariableModeEnumType(v);
if (temp >= 0){
  aMode = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public StructureElement()
{
StructureElement obj = this;
aTypeName=(null);
aDefault=(null);
aMode=(0);
}

public void copyTo(StructureElement other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
other.aDefault = aDefault;
other.aMode = aMode;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl719;
bool fl720;
bool fl721;
bool fl722;
bool fl723;
bool fl724;
bool fl725;
bool fl726;
bool fl727;
bool fl728;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl719 = false ; 
fl720 = false ; 
fl721 = false ; 
fl722 = false ; 
fl723 = false ; 
fl724 = false ; 
fl725 = false ; 
fl726 = false ; 
fl727 = false ; 
fl728 = true ; 
while (fl728) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 723;
} else {
indicator = 729;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 727;
} else {
indicator = 729;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ypeName=")){
indicator = 719;
} else {
indicator = 729;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 724;
} else {
indicator = 729;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 725;
} else {
indicator = 729;
} // If
break;
} // Case
default:
indicator = 729;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("ode=")){
indicator = 721;
} else {
indicator = 729;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 722;
} else {
indicator = 729;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 726;
} else {
indicator = 729;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 720;
} else {
indicator = 729;
} // If
break;
} // Case
default:
indicator = 729;
break;
} // Switch
switch (indicator) {
case 719: {
// Handling attribute TypeName
// Also handles alien attributes with prefix TypeName
if (fl719){
ctxt.fail ("Duplicate attribute: TypeName");
} // If
fl719 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 720: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl720){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl720 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 721: {
// Handling attribute Mode
// Also handles alien attributes with prefix Mode
if (fl721){
ctxt.fail ("Duplicate attribute: Mode");
} // If
fl721 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMode(acceptor.lAcceptEnum_VariableModeEnumType(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 722: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl722){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl722 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 723: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl723){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl723 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 724: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl724){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl724 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 725: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl725){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl725 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 726: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl726){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl726 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 727: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl727){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl727 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 729: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl719){
ctxt.fail ("Mandatory attribute missing: TypeName in StructureElement");
} // If
if (!fl720){
this.setDefault("");
} // If
if (!fl721){
this.setMode(acceptor.VariableModeEnumType.aInternal);
} // If
if (!fl722){
this.setImplemented( false);
} // If
if (!fl723){
this.setVerified( false);
} // If
if (!fl724){
this.setNeedsRequirement( true);
} // If
fl728 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<StructureElement";
  endingTag = "</StructureElement>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"StructureElement\"");
} // If
pw.Write('\n');
pw.Write(" TypeName=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMode() != 0){
pw.Write(" Mode=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_VariableModeEnumType_ToString(this.getMode()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Collection
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.CollectionController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aMaxSize;

public  int getMaxSize() { return aMaxSize;}

public  void setMaxSize(int v) {
  aMaxSize = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Collection()
{
Collection obj = this;
aTypeName=(null);
aMaxSize=(0);
}

public void copyTo(Collection other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
other.aMaxSize = aMaxSize;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl741;
bool fl742;
bool fl743;
bool fl744;
bool fl745;
bool fl746;
bool fl747;
bool fl748;
bool fl749;
bool fl750;
bool fl751;
bool fl752;
bool fl753;
bool fl754;
bool fl755;
bool fl756;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl741 = false ; 
fl742 = false ; 
fl743 = false ; 
fl744 = false ; 
fl745 = false ; 
fl746 = false ; 
fl747 = false ; 
fl748 = false ; 
fl749 = false ; 
fl750 = false ; 
fl751 = false ; 
fl752 = false ; 
fl753 = false ; 
fl754 = false ; 
fl755 = false ; 
fl756 = true ; 
while (fl756) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 745;
} else {
indicator = 757;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 744;
} else {
indicator = 757;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 746;
} else {
indicator = 757;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 751;
} else {
indicator = 757;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 755;
} else {
indicator = 757;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ypeName=")){
indicator = 741;
} else {
indicator = 757;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 749;
} else {
indicator = 757;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 752;
} else {
indicator = 757;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 753;
} else {
indicator = 757;
} // If
break;
} // Case
default:
indicator = 757;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("axSize=")){
indicator = 742;
} else {
indicator = 757;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 750;
} else {
indicator = 757;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 748;
} else {
indicator = 757;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 747;
} else {
indicator = 757;
} // If
break;
} // Case
default:
indicator = 757;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 754;
} else {
indicator = 757;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 743;
} else {
indicator = 757;
} // If
break;
} // Case
default:
indicator = 757;
break;
} // Switch
switch (indicator) {
case 741: {
// Handling attribute TypeName
// Also handles alien attributes with prefix TypeName
if (fl741){
ctxt.fail ("Duplicate attribute: TypeName");
} // If
fl741 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 742: {
// Handling attribute MaxSize
// Also handles alien attributes with prefix MaxSize
if (fl742){
ctxt.fail ("Duplicate attribute: MaxSize");
} // If
fl742 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMaxSize(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 743: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl743){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl743 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 744: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl744){
ctxt.fail ("Duplicate attribute: X");
} // If
fl744 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 745: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl745){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl745 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 746: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl746){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl746 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 747: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl747){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl747 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 748: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl748){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl748 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 749: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl749){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl749 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 750: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl750){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl750 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 751: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl751){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl751 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 752: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl752){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl752 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 753: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl753){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl753 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 754: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl754){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl754 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 755: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl755){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl755 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 757: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl741){
ctxt.fail ("Mandatory attribute missing: TypeName in Collection");
} // If
if (!fl742){
this.setMaxSize(10);
} // If
if (!fl744){
this.setX(0);
} // If
if (!fl745){
this.setY(0);
} // If
if (!fl746){
this.setWidth(0);
} // If
if (!fl747){
this.setHeight(0);
} // If
if (!fl748){
this.setHidden( false);
} // If
if (!fl749){
this.setPinned( false);
} // If
if (!fl750){
this.setImplemented( false);
} // If
if (!fl751){
this.setVerified( false);
} // If
if (!fl752){
this.setNeedsRequirement( true);
} // If
fl756 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Collection";
  endingTag = "</Collection>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Collection\"");
} // If
pw.Write('\n');
pw.Write(" TypeName=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
if (this.getMaxSize() != 10){
pw.Write(" MaxSize=\"");
acceptor.unParsePcData(pw, this.getMaxSize());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Function
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FunctionController.alertChange(aLock, this);
}
private System.Collections.ArrayList aParameters;

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
public System.Collections.ArrayList allParameters()
  {
if (aParameters == null){
    setAllParameters( new System.Collections.ArrayList() );
} // If
    return aParameters;
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
private System.Collections.ArrayList getParameters()
  {
    return allParameters();
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection of elements which replaces 
///        Parameters's current content.</param>
public void setAllParameters(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
    NotifyControllers(null);
  }
public void setAllParameters(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="el">a Parameter to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(System.Collections.IList)"/>
public void appendParameters(Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParameters(Lock aLock,Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection ofParameters to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(Parameter)"/>
public void appendParameters(System.Collections.IList coll)
  {
  __setDirty(true);
  allParameters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParameters(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParameters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This insertion function inserts a new element in the
/// collection in Parameters</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParameters(int idx, Parameter el)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParameters(int idx, Parameter el,Lock aLock)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParameters(IXmlBBase el)
  {
  return ((System.Collections.IList) allParameters()).IndexOf (el);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParameters(int idx)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParameters(int idx,Lock aLock)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParameters(IXmlBBase obj)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(null);
   }
  }

public void removeParameters(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>the number of elements in Parameters</returns>
public int countParameters()
  {
  return allParameters().Count;
  }

/// <summary>Part of the list interface for Parameters
/// This function returns an element from the
/// collection in Parameters based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Parameter getParameters(int idx)
{
  return (Parameter) ( allParameters()[idx]);
}

private System.Collections.ArrayList aCases;

/// <summary>Part of the list interface for Cases</summary>
/// <returns>a collection of all the elements in Cases</returns>
public System.Collections.ArrayList allCases()
  {
if (aCases == null){
    setAllCases( new System.Collections.ArrayList() );
} // If
    return aCases;
  }

/// <summary>Part of the list interface for Cases</summary>
/// <returns>a collection of all the elements in Cases</returns>
private System.Collections.ArrayList getCases()
  {
    return allCases();
  }

/// <summary>Part of the list interface for Cases</summary>
/// <param name="coll">a collection of elements which replaces 
///        Cases's current content.</param>
public void setAllCases(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCases = coll;
    NotifyControllers(null);
  }
public void setAllCases(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCases = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases</summary>
/// <param name="el">a Case to add to the collection in 
///           Cases</param>
/// <seealso cref="appendCases(System.Collections.IList)"/>
public void appendCases(Case el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendCases(Lock aLock,Case el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Cases</summary>
/// <param name="coll">a collection ofCases to add to the collection in 
///           Cases</param>
/// <seealso cref="appendCases(Case)"/>
public void appendCases(System.Collections.IList coll)
  {
  __setDirty(true);
  allCases().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendCases(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allCases().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases
/// This insertion function inserts a new element in the
/// collection in Cases</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertCases(int idx, Case el)
  {
  __setDirty(true);
  allCases().Insert (idx, el);
NotifyControllers(null);
  }

public void insertCases(int idx, Case el,Lock aLock)
  {
  __setDirty(true);
  allCases().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfCases(IXmlBBase el)
  {
  return ((System.Collections.IList) allCases()).IndexOf (el);
  }

/// <summary>Part of the list interface for Cases
/// This deletion function removes an element from the
/// collection in Cases</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteCases(int idx)
  {
  __setDirty(true);
  allCases().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteCases(int idx,Lock aLock)
  {
  __setDirty(true);
  allCases().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases
/// This deletion function removes an element from the
/// collection in Cases
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeCases(IXmlBBase obj)
  {
  int idx = indexOfCases(obj);
  if (idx >= 0) { deleteCases(idx);
NotifyControllers(null);
   }
  }

public void removeCases(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfCases(obj);
  if (idx >= 0) { deleteCases(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Cases</summary>
/// <returns>the number of elements in Cases</returns>
public int countCases()
  {
  return allCases().Count;
  }

/// <summary>Part of the list interface for Cases
/// This function returns an element from the
/// collection in Cases based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Case getCases(int idx)
{
  return (Case) ( allCases()[idx]);
}

private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aCacheable;

public  bool getCacheable() { return aCacheable;}

public  void setCacheable(bool v) {
  aCacheable = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Function()
{
Function obj = this;
aParameters=(null);
aCases=(null);
aTypeName=(null);
aCacheable=(false);
}

public void copyTo(Function other)
{
base.copyTo(other);
other.aParameters = aParameters;
other.aCases = aCases;
other.aTypeName = aTypeName;
other.aCacheable = aCacheable;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl776;
Parameter fl778;
bool fl789;
Case fl791;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Parameters")){
ctxt.skipWhiteSpace();
fl776 = true ; 
while (fl776) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl776 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl778 = null;
while(ctxt.lookAheadOpeningTag ("<Parameter")) {
fl778 = acceptor.lAccept_Parameter(ctxt, "</Parameter>");
appendParameters(fl778);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Parameters>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<Cases");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl789 = true ; 
while (fl789) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl789 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl791 = null;
while(ctxt.lookAheadOpeningTag ("<Case")) {
fl791 = acceptor.lAccept_Case(ctxt, "</Case>");
appendCases(fl791);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Cases>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl802;
bool fl803;
bool fl804;
bool fl805;
bool fl806;
bool fl807;
bool fl808;
bool fl809;
bool fl810;
bool fl811;
bool fl812;
bool fl813;
bool fl814;
bool fl815;
bool fl816;
bool fl817;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl802 = false ; 
fl803 = false ; 
fl804 = false ; 
fl805 = false ; 
fl806 = false ; 
fl807 = false ; 
fl808 = false ; 
fl809 = false ; 
fl810 = false ; 
fl811 = false ; 
fl812 = false ; 
fl813 = false ; 
fl814 = false ; 
fl815 = false ; 
fl816 = false ; 
fl817 = true ; 
while (fl817) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 806;
} else {
indicator = 818;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 805;
} else {
indicator = 818;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 807;
} else {
indicator = 818;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 812;
} else {
indicator = 818;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 816;
} else {
indicator = 818;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 802;
} else {
indicator = 818;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 810;
} else {
indicator = 818;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 813;
} else {
indicator = 818;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 814;
} else {
indicator = 818;
} // If
break;
} // Case
default:
indicator = 818;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 811;
} else {
indicator = 818;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 809;
} else {
indicator = 818;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 808;
} else {
indicator = 818;
} // If
break;
} // Case
default:
indicator = 818;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 815;
} else {
indicator = 818;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 804;
} else {
indicator = 818;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("acheable=")){
indicator = 803;
} else {
indicator = 818;
} // If
break;
} // Case
default:
indicator = 818;
break;
} // Switch
switch (indicator) {
case 802: {
// Handling attribute Type
// Also handles alien attributes with prefix Type
if (fl802){
ctxt.fail ("Duplicate attribute: Type");
} // If
fl802 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 803: {
// Handling attribute Cacheable
// Also handles alien attributes with prefix Cacheable
if (fl803){
ctxt.fail ("Duplicate attribute: Cacheable");
} // If
fl803 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCacheable(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 804: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl804){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl804 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 805: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl805){
ctxt.fail ("Duplicate attribute: X");
} // If
fl805 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 806: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl806){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl806 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 807: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl807){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl807 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 808: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl808){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl808 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 809: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl809){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl809 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 810: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl810){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl810 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 811: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl811){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl811 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 812: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl812){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl812 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 813: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl813){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl813 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 814: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl814){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl814 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 815: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl815){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl815 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 816: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl816){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl816 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 818: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl803){
this.setCacheable( false);
} // If
if (!fl805){
this.setX(0);
} // If
if (!fl806){
this.setY(0);
} // If
if (!fl807){
this.setWidth(0);
} // If
if (!fl808){
this.setHeight(0);
} // If
if (!fl809){
this.setHidden( false);
} // If
if (!fl810){
this.setPinned( false);
} // If
if (!fl811){
this.setImplemented( false);
} // If
if (!fl812){
this.setVerified( false);
} // If
if (!fl813){
this.setNeedsRequirement( true);
} // If
fl817 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Function";
  endingTag = "</Function>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Function\"");
} // If
pw.Write('\n');
if (this.getTypeName() != null){
pw.Write(" Type=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getCacheable()){
pw.Write(" Cacheable=\"");
acceptor.unParsePcData(pw, this.getCacheable());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Parameters
if (countParameters() > 0){
pw.Write("<Parameters>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParameters(), false, "<Parameter", "</Parameter>");
pw.Write("</Parameters>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Parameters
// Unparsing Enclosed
pw.Write("<Cases>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getCases(), false, "<Case", "</Case>");
pw.Write("</Cases>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countParameters(); i++) {
  l.Add(getParameters(i));
}
for (int i = 0; i < countCases(); i++) {
  l.Add(getCases(i));
}
}

}
public partial class Parameter
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ParameterController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Parameter()
{
Parameter obj = this;
aTypeName=(null);
}

public void copyTo(Parameter other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl837;
bool fl838;
bool fl839;
bool fl840;
bool fl841;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl837 = false ; 
fl838 = false ; 
fl839 = false ; 
fl840 = false ; 
fl841 = true ; 
while (fl841) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 840;
} else {
indicator = 842;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 837;
} else {
indicator = 842;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 838;
} else {
indicator = 842;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 839;
} else {
indicator = 842;
} // If
break;
} // Case
default:
indicator = 842;
break;
} // Switch
switch (indicator) {
case 837: {
// Handling attribute Type
// Also handles alien attributes with prefix Type
if (fl837){
ctxt.fail ("Duplicate attribute: Type");
} // If
fl837 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 838: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl838){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl838 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 839: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl839){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl839 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 840: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl840){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl840 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 842: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl837){
ctxt.fail ("Mandatory attribute missing: Type in Parameter");
} // If
fl841 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Parameter";
  endingTag = "</Parameter>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Parameter\"");
} // If
pw.Write('\n');
pw.Write(" Type=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Case
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getExpression().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.CaseController.alertChange(aLock, this);
}
private System.Collections.ArrayList aPreConditions;

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
public System.Collections.ArrayList allPreConditions()
  {
if (aPreConditions == null){
    setAllPreConditions( new System.Collections.ArrayList() );
} // If
    return aPreConditions;
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
private System.Collections.ArrayList getPreConditions()
  {
    return allPreConditions();
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection of elements which replaces 
///        PreConditions's current content.</param>
public void setAllPreConditions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
    NotifyControllers(null);
  }
public void setAllPreConditions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="el">a PreCondition to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(System.Collections.IList)"/>
public void appendPreConditions(PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendPreConditions(Lock aLock,PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection ofPreConditions to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(PreCondition)"/>
public void appendPreConditions(System.Collections.IList coll)
  {
  __setDirty(true);
  allPreConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendPreConditions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This insertion function inserts a new element in the
/// collection in PreConditions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertPreConditions(int idx, PreCondition el)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertPreConditions(int idx, PreCondition el,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfPreConditions(IXmlBBase el)
  {
  return ((System.Collections.IList) allPreConditions()).IndexOf (el);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deletePreConditions(int idx)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deletePreConditions(int idx,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removePreConditions(IXmlBBase obj)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(null);
   }
  }

public void removePreConditions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>the number of elements in PreConditions</returns>
public int countPreConditions()
  {
  return allPreConditions().Count;
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns an element from the
/// collection in PreConditions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public PreCondition getPreConditions(int idx)
{
  return (PreCondition) ( allPreConditions()[idx]);
}

private   string  aExpression;

public   string  getExpression() { return aExpression;}

public  void setExpression( string  v) {
  aExpression = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Case()
{
Case obj = this;
aPreConditions=(null);
aExpression=(null);
aComment=(null);
}

public void copyTo(Case other)
{
base.copyTo(other);
other.aPreConditions = aPreConditions;
other.aExpression = aExpression;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl848;
bool fl849;
PreCondition fl851;
bool fl862;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl848 = true ; 
while (fl848) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl848 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<PreConditions")){
ctxt.skipWhiteSpace();
fl849 = true ; 
while (fl849) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl849 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl851 = null;
while(ctxt.lookAheadOpeningTag ("<PreCondition")) {
fl851 = acceptor.lAccept_PreCondition(ctxt, "</PreCondition>");
appendPreConditions(fl851);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</PreConditions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<Expression");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl862 = true ; 
while (fl862) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl862 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setExpression(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Expression>");
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl863;
bool fl864;
bool fl865;
bool fl866;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl863 = false ; 
fl864 = false ; 
fl865 = false ; 
fl866 = true ; 
while (fl866) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 865;
} else {
indicator = 867;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 863;
} else {
indicator = 867;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 864;
} else {
indicator = 867;
} // If
break;
} // Case
default:
indicator = 867;
break;
} // Switch
switch (indicator) {
case 863: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl863){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl863 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 864: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl864){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl864 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 865: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl865){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl865 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 867: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl866 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Case";
  endingTag = "</Case>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Case\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: PreConditions
if (countPreConditions() > 0){
pw.Write("<PreConditions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getPreConditions(), false, "<PreCondition", "</PreCondition>");
pw.Write("</PreConditions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: PreConditions
// Unparsing Enclosed
pw.Write("<Expression>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getExpression());
pw.Write("</Expression>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countPreConditions(); i++) {
  l.Add(getPreConditions(i));
}
}

}
public partial class Procedure
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ProcedureController.alertChange(aLock, this);
}
private  StateMachine aStateMachine;

public  StateMachine getStateMachine() { return aStateMachine;}

public  void setStateMachine(StateMachine v) {
  aStateMachine = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

private System.Collections.ArrayList aParameters;

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
public System.Collections.ArrayList allParameters()
  {
if (aParameters == null){
    setAllParameters( new System.Collections.ArrayList() );
} // If
    return aParameters;
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
private System.Collections.ArrayList getParameters()
  {
    return allParameters();
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection of elements which replaces 
///        Parameters's current content.</param>
public void setAllParameters(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
    NotifyControllers(null);
  }
public void setAllParameters(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="el">a Parameter to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(System.Collections.IList)"/>
public void appendParameters(Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParameters(Lock aLock,Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection ofParameters to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(Parameter)"/>
public void appendParameters(System.Collections.IList coll)
  {
  __setDirty(true);
  allParameters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParameters(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParameters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This insertion function inserts a new element in the
/// collection in Parameters</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParameters(int idx, Parameter el)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParameters(int idx, Parameter el,Lock aLock)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParameters(IXmlBBase el)
  {
  return ((System.Collections.IList) allParameters()).IndexOf (el);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParameters(int idx)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParameters(int idx,Lock aLock)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParameters(IXmlBBase obj)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(null);
   }
  }

public void removeParameters(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>the number of elements in Parameters</returns>
public int countParameters()
  {
  return allParameters().Count;
  }

/// <summary>Part of the list interface for Parameters
/// This function returns an element from the
/// collection in Parameters based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Parameter getParameters(int idx)
{
  return (Parameter) ( allParameters()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Procedure()
{
Procedure obj = this;
aStateMachine=(null);
aRules=(null);
aParameters=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
}

public void copyTo(Procedure other)
{
base.copyTo(other);
other.aStateMachine = aStateMachine;
other.aRules = aRules;
other.aParameters = aParameters;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl872;
Parameter fl874;
bool fl885;
Rule fl887;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Parameters")){
ctxt.skipWhiteSpace();
fl872 = true ; 
while (fl872) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl872 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl874 = null;
while(ctxt.lookAheadOpeningTag ("<Parameter")) {
fl874 = acceptor.lAccept_Parameter(ctxt, "</Parameter>");
appendParameters(fl874);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Parameters>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl885 = true ; 
while (fl885) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl885 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl887 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl887 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl887);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
// Element Ref : StateMachine
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<StateMachine")){
// Parsing sub element
this.setStateMachine(acceptor.lAccept_StateMachine(ctxt,"</StateMachine>"));
setSon(this.getStateMachine());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl898;
bool fl899;
bool fl900;
bool fl901;
bool fl902;
bool fl903;
bool fl904;
bool fl905;
bool fl906;
bool fl907;
bool fl908;
bool fl909;
bool fl910;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl898 = false ; 
fl899 = false ; 
fl900 = false ; 
fl901 = false ; 
fl902 = false ; 
fl903 = false ; 
fl904 = false ; 
fl905 = false ; 
fl906 = false ; 
fl907 = false ; 
fl908 = false ; 
fl909 = false ; 
fl910 = true ; 
while (fl910) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 899;
} else {
indicator = 911;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 898;
} else {
indicator = 911;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 900;
} else {
indicator = 911;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 905;
} else {
indicator = 911;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 909;
} else {
indicator = 911;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 903;
} else {
indicator = 911;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 906;
} else {
indicator = 911;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 907;
} else {
indicator = 911;
} // If
break;
} // Case
default:
indicator = 911;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 904;
} else {
indicator = 911;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 902;
} else {
indicator = 911;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 901;
} else {
indicator = 911;
} // If
break;
} // Case
default:
indicator = 911;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 908;
} else {
indicator = 911;
} // If
break;
} // Case
default:
indicator = 911;
break;
} // Switch
switch (indicator) {
case 898: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl898){
ctxt.fail ("Duplicate attribute: X");
} // If
fl898 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 899: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl899){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl899 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 900: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl900){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl900 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 901: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl901){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl901 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 902: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl902){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl902 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 903: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl903){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl903 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 904: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl904){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl904 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 905: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl905){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl905 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 906: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl906){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl906 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 907: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl907){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl907 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 908: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl908){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl908 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 909: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl909){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl909 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 911: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl898){
this.setX(0);
} // If
if (!fl899){
this.setY(0);
} // If
if (!fl900){
this.setWidth(0);
} // If
if (!fl901){
this.setHeight(0);
} // If
if (!fl902){
this.setHidden( false);
} // If
if (!fl903){
this.setPinned( false);
} // If
if (!fl904){
this.setImplemented( false);
} // If
if (!fl905){
this.setVerified( false);
} // If
if (!fl906){
this.setNeedsRequirement( true);
} // If
fl910 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Procedure";
  endingTag = "</Procedure>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Procedure\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Parameters
if (countParameters() > 0){
pw.Write("<Parameters>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParameters(), false, "<Parameter", "</Parameter>");
pw.Write("</Parameters>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Parameters
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
// Unparsing ElementRef
if (this.getStateMachine() != null){
unParse(pw, this.getStateMachine(),false,"<StateMachine","</StateMachine>");
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
l.Add(this.getStateMachine());
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
for (int i = 0; i < countParameters(); i++) {
  l.Add(getParameters(i));
}
}

}
public partial class StateMachine
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getInitialState().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StateMachineController.alertChange(aLock, this);
}
private   string  aInitialState;

public   string  getInitialState() { return aInitialState;}

public  void setInitialState( string  v) {
  aInitialState = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aStates;

/// <summary>Part of the list interface for States</summary>
/// <returns>a collection of all the elements in States</returns>
public System.Collections.ArrayList allStates()
  {
if (aStates == null){
    setAllStates( new System.Collections.ArrayList() );
} // If
    return aStates;
  }

/// <summary>Part of the list interface for States</summary>
/// <returns>a collection of all the elements in States</returns>
private System.Collections.ArrayList getStates()
  {
    return allStates();
  }

/// <summary>Part of the list interface for States</summary>
/// <param name="coll">a collection of elements which replaces 
///        States's current content.</param>
public void setAllStates(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStates = coll;
    NotifyControllers(null);
  }
public void setAllStates(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStates = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States</summary>
/// <param name="el">a State to add to the collection in 
///           States</param>
/// <seealso cref="appendStates(System.Collections.IList)"/>
public void appendStates(State el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStates().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStates(Lock aLock,State el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStates().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for States</summary>
/// <param name="coll">a collection ofStates to add to the collection in 
///           States</param>
/// <seealso cref="appendStates(State)"/>
public void appendStates(System.Collections.IList coll)
  {
  __setDirty(true);
  allStates().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStates(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStates().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States
/// This insertion function inserts a new element in the
/// collection in States</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStates(int idx, State el)
  {
  __setDirty(true);
  allStates().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStates(int idx, State el,Lock aLock)
  {
  __setDirty(true);
  allStates().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStates(IXmlBBase el)
  {
  return ((System.Collections.IList) allStates()).IndexOf (el);
  }

/// <summary>Part of the list interface for States
/// This deletion function removes an element from the
/// collection in States</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStates(int idx)
  {
  __setDirty(true);
  allStates().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStates(int idx,Lock aLock)
  {
  __setDirty(true);
  allStates().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States
/// This deletion function removes an element from the
/// collection in States
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStates(IXmlBBase obj)
  {
  int idx = indexOfStates(obj);
  if (idx >= 0) { deleteStates(idx);
NotifyControllers(null);
   }
  }

public void removeStates(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStates(obj);
  if (idx >= 0) { deleteStates(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for States</summary>
/// <returns>the number of elements in States</returns>
public int countStates()
  {
  return allStates().Count;
  }

/// <summary>Part of the list interface for States
/// This function returns an element from the
/// collection in States based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public State getStates(int idx)
{
  return (State) ( allStates()[idx]);
}

private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

public StateMachine()
{
StateMachine obj = this;
aInitialState=(null);
aStates=(null);
aRules=(null);
}

public void copyTo(StateMachine other)
{
base.copyTo(other);
other.aInitialState = aInitialState;
other.aStates = aStates;
other.aRules = aRules;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl927;
State fl929;
bool fl940;
Rule fl942;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<States")){
ctxt.skipWhiteSpace();
fl927 = true ; 
while (fl927) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl927 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl929 = null;
while(ctxt.lookAheadOpeningTag ("<State")) {
fl929 = acceptor.lAccept_State(ctxt, "</State>");
appendStates(fl929);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</States>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl940 = true ; 
while (fl940) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl940 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl942 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl942 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl942);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl953;
bool fl954;
bool fl955;
bool fl956;
bool fl957;
bool fl958;
bool fl959;
bool fl960;
bool fl961;
bool fl962;
bool fl963;
bool fl964;
bool fl965;
bool fl966;
bool fl967;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl953 = false ; 
fl954 = false ; 
fl955 = false ; 
fl956 = false ; 
fl957 = false ; 
fl958 = false ; 
fl959 = false ; 
fl960 = false ; 
fl961 = false ; 
fl962 = false ; 
fl963 = false ; 
fl964 = false ; 
fl965 = false ; 
fl966 = false ; 
fl967 = true ; 
while (fl967) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 956;
} else {
indicator = 968;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 955;
} else {
indicator = 968;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 957;
} else {
indicator = 968;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 962;
} else {
indicator = 968;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 966;
} else {
indicator = 968;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 960;
} else {
indicator = 968;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 963;
} else {
indicator = 968;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 964;
} else {
indicator = 968;
} // If
break;
} // Case
default:
indicator = 968;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("itialState=")){
indicator = 953;
} else {
indicator = 968;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("plemented=")){
indicator = 961;
} else {
indicator = 968;
} // If
break;
} // Case
default:
indicator = 968;
break;
} // Switch
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 959;
} else {
indicator = 968;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 958;
} else {
indicator = 968;
} // If
break;
} // Case
default:
indicator = 968;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 965;
} else {
indicator = 968;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 954;
} else {
indicator = 968;
} // If
break;
} // Case
default:
indicator = 968;
break;
} // Switch
switch (indicator) {
case 953: {
// Handling attribute InitialState
// Also handles alien attributes with prefix InitialState
if (fl953){
ctxt.fail ("Duplicate attribute: InitialState");
} // If
fl953 = true ; 
quoteChar = ctxt.acceptQuote();
this.setInitialState((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 954: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl954){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl954 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 955: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl955){
ctxt.fail ("Duplicate attribute: X");
} // If
fl955 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 956: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl956){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl956 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 957: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl957){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl957 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 958: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl958){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl958 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 959: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl959){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl959 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 960: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl960){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl960 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 961: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl961){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl961 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 962: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl962){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl962 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 963: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl963){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl963 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 964: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl964){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl964 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 965: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl965){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl965 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 966: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl966){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl966 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 968: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl955){
this.setX(0);
} // If
if (!fl956){
this.setY(0);
} // If
if (!fl957){
this.setWidth(0);
} // If
if (!fl958){
this.setHeight(0);
} // If
if (!fl959){
this.setHidden( false);
} // If
if (!fl960){
this.setPinned( false);
} // If
if (!fl961){
this.setImplemented( false);
} // If
if (!fl962){
this.setVerified( false);
} // If
if (!fl963){
this.setNeedsRequirement( true);
} // If
fl967 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<StateMachine";
  endingTag = "</StateMachine>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"StateMachine\"");
} // If
pw.Write('\n');
if (this.getInitialState() != null){
pw.Write(" InitialState=\"");
acceptor.unParsePcData(pw, this.getInitialState());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: States
if (countStates() > 0){
pw.Write("<States>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStates(), false, "<State", "</State>");
pw.Write("</States>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: States
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countStates(); i++) {
  l.Add(getStates(i));
}
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
}

}
public partial class State
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StateController.alertChange(aLock, this);
}
private  StateMachine aStateMachine;

public  StateMachine getStateMachine() { return aStateMachine;}

public  void setStateMachine(StateMachine v) {
  aStateMachine = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  Rule aEnterAction;

public  Rule getEnterAction() { return aEnterAction;}

public  void setEnterAction(Rule v) {
  aEnterAction = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  Rule aLeaveAction;

public  Rule getLeaveAction() { return aLeaveAction;}

public  void setLeaveAction(Rule v) {
  aLeaveAction = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


public State()
{
State obj = this;
aStateMachine=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aPinned=(false);
aEnterAction=(null);
aLeaveAction=(null);
}

public void copyTo(State other)
{
base.copyTo(other);
other.aStateMachine = aStateMachine;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aPinned = aPinned;
other.aEnterAction = aEnterAction;
other.aLeaveAction = aLeaveAction;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl987;
bool fl988;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Element Ref : StateMachine
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<StateMachine")){
// Parsing sub element
this.setStateMachine(acceptor.lAccept_StateMachine(ctxt,"</StateMachine>"));
setSon(this.getStateMachine());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<EnterAction")){
ctxt.skipWhiteSpace();
fl987 = true ; 
while (fl987) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl987 = false ; 
} // If
} // While
ctxt.accept('>');
// Element Ref : Rule
ctxt.skipWhiteSpace();
ctxt.acceptString ("<Rule");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
// Parsing sub element
this.setEnterAction(acceptor.lAccept_Rule(ctxt,"</Rule>"));
setSon(this.getEnterAction());
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
ctxt.acceptString ("</EnterAction>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<LeaveAction")){
ctxt.skipWhiteSpace();
fl988 = true ; 
while (fl988) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl988 = false ; 
} // If
} // While
ctxt.accept('>');
// Element Ref : Rule
ctxt.skipWhiteSpace();
ctxt.acceptString ("<Rule");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
// Parsing sub element
this.setLeaveAction(acceptor.lAccept_Rule(ctxt,"</Rule>"));
setSon(this.getLeaveAction());
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
ctxt.acceptString ("</LeaveAction>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl989;
bool fl990;
bool fl991;
bool fl992;
bool fl993;
bool fl994;
bool fl995;
bool fl996;
bool fl997;
bool fl998;
bool fl999;
bool fl1000;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl989 = false ; 
fl990 = false ; 
fl991 = false ; 
fl992 = false ; 
fl993 = false ; 
fl994 = false ; 
fl995 = false ; 
fl996 = false ; 
fl997 = false ; 
fl998 = false ; 
fl999 = false ; 
fl1000 = true ; 
while (fl1000) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 990;
} else {
indicator = 1001;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 989;
} else {
indicator = 1001;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 991;
} else {
indicator = 1001;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 995;
} else {
indicator = 1001;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 999;
} else {
indicator = 1001;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 993;
} else {
indicator = 1001;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 996;
} else {
indicator = 1001;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 997;
} else {
indicator = 1001;
} // If
break;
} // Case
default:
indicator = 1001;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 994;
} else {
indicator = 1001;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
if (ctxt.lookAheadString("eight=")){
indicator = 992;
} else {
indicator = 1001;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 998;
} else {
indicator = 1001;
} // If
break;
} // Case
default:
indicator = 1001;
break;
} // Switch
switch (indicator) {
case 989: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl989){
ctxt.fail ("Duplicate attribute: X");
} // If
fl989 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 990: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl990){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl990 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 991: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl991){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl991 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 992: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl992){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl992 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 993: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl993){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl993 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 994: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl994){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl994 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 995: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl995){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl995 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 996: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl996){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl996 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 997: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl997){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl997 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 998: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl998){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl998 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 999: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl999){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl999 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1001: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl989){
this.setX(0);
} // If
if (!fl990){
this.setY(0);
} // If
if (!fl991){
this.setWidth(0);
} // If
if (!fl992){
this.setHeight(0);
} // If
if (!fl993){
this.setPinned( false);
} // If
if (!fl994){
this.setImplemented( false);
} // If
if (!fl995){
this.setVerified( false);
} // If
if (!fl996){
this.setNeedsRequirement( true);
} // If
fl1000 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<State";
  endingTag = "</State>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"State\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing ElementRef
if (this.getStateMachine() != null){
unParse(pw, this.getStateMachine(),false,"<StateMachine","</StateMachine>");
} // If
// Unparsing Enclosed
// Testing for empty content: EnterAction
if (this.getEnterAction() != null){
pw.Write("<EnterAction>");
pw.Write('\n');
// Unparsing ElementRef
unParse(pw, this.getEnterAction(),false,"<Rule","</Rule>");
pw.Write("</EnterAction>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: EnterAction
// Unparsing Enclosed
// Testing for empty content: LeaveAction
if (this.getLeaveAction() != null){
pw.Write("<LeaveAction>");
pw.Write('\n');
// Unparsing ElementRef
unParse(pw, this.getLeaveAction(),false,"<Rule","</Rule>");
pw.Write("</LeaveAction>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: LeaveAction
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
l.Add(this.getStateMachine());
l.Add(this.getEnterAction());
l.Add(this.getLeaveAction());
}

}
public partial class Variable
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
if(getDefaultValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.VariableController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDefaultValue;

public   string  getDefaultValue() { return aDefaultValue;}

public  void setDefaultValue( string  v) {
  aDefaultValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.VariableModeEnumType aVariableMode;

public  acceptor.VariableModeEnumType getVariableMode() { return aVariableMode;}

public  void setVariableMode(acceptor.VariableModeEnumType v) {
  aVariableMode = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getVariableMode_AsString()
{
  return acceptor.Enum_VariableModeEnumType_ToString (aVariableMode);
}

public  bool setVariableMode_AsString( string  v)
{
 acceptor.VariableModeEnumType  temp = acceptor.StringTo_Enum_VariableModeEnumType(v);
if (temp >= 0){
  aVariableMode = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aSubVariables;

/// <summary>Part of the list interface for SubVariables</summary>
/// <returns>a collection of all the elements in SubVariables</returns>
public System.Collections.ArrayList allSubVariables()
  {
if (aSubVariables == null){
    setAllSubVariables( new System.Collections.ArrayList() );
} // If
    return aSubVariables;
  }

/// <summary>Part of the list interface for SubVariables</summary>
/// <returns>a collection of all the elements in SubVariables</returns>
private System.Collections.ArrayList getSubVariables()
  {
    return allSubVariables();
  }

/// <summary>Part of the list interface for SubVariables</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubVariables's current content.</param>
public void setAllSubVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubVariables = coll;
    NotifyControllers(null);
  }
public void setAllSubVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables</summary>
/// <param name="el">a Variable to add to the collection in 
///           SubVariables</param>
/// <seealso cref="appendSubVariables(System.Collections.IList)"/>
public void appendSubVariables(Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubVariables(Lock aLock,Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubVariables</summary>
/// <param name="coll">a collection ofVariables to add to the collection in 
///           SubVariables</param>
/// <seealso cref="appendSubVariables(Variable)"/>
public void appendSubVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables
/// This insertion function inserts a new element in the
/// collection in SubVariables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubVariables(int idx, Variable el)
  {
  __setDirty(true);
  allSubVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubVariables(int idx, Variable el,Lock aLock)
  {
  __setDirty(true);
  allSubVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubVariables
/// This deletion function removes an element from the
/// collection in SubVariables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubVariables(int idx)
  {
  __setDirty(true);
  allSubVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables
/// This deletion function removes an element from the
/// collection in SubVariables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubVariables(IXmlBBase obj)
  {
  int idx = indexOfSubVariables(obj);
  if (idx >= 0) { deleteSubVariables(idx);
NotifyControllers(null);
   }
  }

public void removeSubVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubVariables(obj);
  if (idx >= 0) { deleteSubVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubVariables</summary>
/// <returns>the number of elements in SubVariables</returns>
public int countSubVariables()
  {
  return allSubVariables().Count;
  }

/// <summary>Part of the list interface for SubVariables
/// This function returns an element from the
/// collection in SubVariables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Variable getSubVariables(int idx)
{
  return (Variable) ( allSubVariables()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Variable()
{
Variable obj = this;
aTypeName=(null);
aDefaultValue=(null);
aVariableMode=(0);
aSubVariables=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
}

public void copyTo(Variable other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
other.aDefaultValue = aDefaultValue;
other.aVariableMode = aVariableMode;
other.aSubVariables = aSubVariables;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1015;
Variable fl1017;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubVariables")){
ctxt.skipWhiteSpace();
fl1015 = true ; 
while (fl1015) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1015 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1017 = null;
while(ctxt.lookAheadOpeningTag ("<Variable")) {
fl1017 = acceptor.lAccept_Variable(ctxt, "</Variable>");
appendSubVariables(fl1017);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubVariables>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1028;
bool fl1029;
bool fl1030;
bool fl1031;
bool fl1032;
bool fl1033;
bool fl1034;
bool fl1035;
bool fl1036;
bool fl1037;
bool fl1038;
bool fl1039;
bool fl1040;
bool fl1041;
bool fl1042;
bool fl1043;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1028 = false ; 
fl1029 = false ; 
fl1030 = false ; 
fl1031 = false ; 
fl1032 = false ; 
fl1033 = false ; 
fl1034 = false ; 
fl1035 = false ; 
fl1036 = false ; 
fl1037 = false ; 
fl1038 = false ; 
fl1039 = false ; 
fl1040 = false ; 
fl1041 = false ; 
fl1042 = false ; 
fl1043 = true ; 
while (fl1043) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1032;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1031;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 1033;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("rified=")){
indicator = 1038;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("riableMode=")){
indicator = 1030;
} else {
indicator = 1044;
} // If
break;
} // Case
default:
indicator = 1044;
break;
} // Switch
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1042;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 1028;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 1036;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 1039;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1040;
} else {
indicator = 1044;
} // If
break;
} // Case
default:
indicator = 1044;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1037;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 1035;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 1034;
} else {
indicator = 1044;
} // If
break;
} // Case
default:
indicator = 1044;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1041;
} else {
indicator = 1044;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efaultValue=")){
indicator = 1029;
} else {
indicator = 1044;
} // If
break;
} // Case
default:
indicator = 1044;
break;
} // Switch
switch (indicator) {
case 1028: {
// Handling attribute Type
// Also handles alien attributes with prefix Type
if (fl1028){
ctxt.fail ("Duplicate attribute: Type");
} // If
fl1028 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1029: {
// Handling attribute DefaultValue
// Also handles alien attributes with prefix DefaultValue
if (fl1029){
ctxt.fail ("Duplicate attribute: DefaultValue");
} // If
fl1029 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefaultValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1030: {
// Handling attribute VariableMode
// Also handles alien attributes with prefix VariableMode
if (fl1030){
ctxt.fail ("Duplicate attribute: VariableMode");
} // If
fl1030 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVariableMode(acceptor.lAcceptEnum_VariableModeEnumType(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1031: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl1031){
ctxt.fail ("Duplicate attribute: X");
} // If
fl1031 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1032: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl1032){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl1032 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1033: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl1033){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl1033 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1034: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl1034){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl1034 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1035: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl1035){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl1035 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1036: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl1036){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl1036 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1037: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1037){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1037 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1038: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl1038){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl1038 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1039: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl1039){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl1039 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1040: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1040){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1040 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1041: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1041){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1041 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1042: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1042){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1042 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1044: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1030){
this.setVariableMode(acceptor.VariableModeEnumType.aInternal);
} // If
if (!fl1031){
this.setX(0);
} // If
if (!fl1032){
this.setY(0);
} // If
if (!fl1033){
this.setWidth(0);
} // If
if (!fl1034){
this.setHeight(0);
} // If
if (!fl1035){
this.setHidden( false);
} // If
if (!fl1036){
this.setPinned( false);
} // If
if (!fl1037){
this.setImplemented( false);
} // If
if (!fl1038){
this.setVerified( false);
} // If
if (!fl1039){
this.setNeedsRequirement( true);
} // If
fl1043 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Variable";
  endingTag = "</Variable>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Variable\"");
} // If
pw.Write('\n');
if (this.getTypeName() != null){
pw.Write(" Type=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefaultValue() != null){
pw.Write(" DefaultValue=\"");
acceptor.unParsePcData(pw, this.getDefaultValue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVariableMode() != 0){
pw.Write(" VariableMode=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_VariableModeEnumType_ToString(this.getVariableMode()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: SubVariables
if (countSubVariables() > 0){
pw.Write("<SubVariables>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubVariables(), false, "<Variable", "</Variable>");
pw.Write("</SubVariables>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubVariables
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSubVariables(); i++) {
  l.Add(getSubVariables(i));
}
}

}
public partial class Rule
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RuleController.alertChange(aLock, this);
}
private  acceptor.RulePriority aPriority;

public  acceptor.RulePriority getPriority() { return aPriority;}

public  void setPriority(acceptor.RulePriority v) {
  aPriority = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getPriority_AsString()
{
  return acceptor.Enum_RulePriority_ToString (aPriority);
}

public  bool setPriority_AsString( string  v)
{
 acceptor.RulePriority  temp = acceptor.StringTo_Enum_RulePriority(v);
if (temp >= 0){
  aPriority = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aConditions;

/// <summary>Part of the list interface for Conditions</summary>
/// <returns>a collection of all the elements in Conditions</returns>
public System.Collections.ArrayList allConditions()
  {
if (aConditions == null){
    setAllConditions( new System.Collections.ArrayList() );
} // If
    return aConditions;
  }

/// <summary>Part of the list interface for Conditions</summary>
/// <returns>a collection of all the elements in Conditions</returns>
private System.Collections.ArrayList getConditions()
  {
    return allConditions();
  }

/// <summary>Part of the list interface for Conditions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Conditions's current content.</param>
public void setAllConditions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aConditions = coll;
    NotifyControllers(null);
  }
public void setAllConditions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aConditions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions</summary>
/// <param name="el">a RuleCondition to add to the collection in 
///           Conditions</param>
/// <seealso cref="appendConditions(System.Collections.IList)"/>
public void appendConditions(RuleCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendConditions(Lock aLock,RuleCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Conditions</summary>
/// <param name="coll">a collection ofRuleConditions to add to the collection in 
///           Conditions</param>
/// <seealso cref="appendConditions(RuleCondition)"/>
public void appendConditions(System.Collections.IList coll)
  {
  __setDirty(true);
  allConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendConditions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions
/// This insertion function inserts a new element in the
/// collection in Conditions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertConditions(int idx, RuleCondition el)
  {
  __setDirty(true);
  allConditions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertConditions(int idx, RuleCondition el,Lock aLock)
  {
  __setDirty(true);
  allConditions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfConditions(IXmlBBase el)
  {
  return ((System.Collections.IList) allConditions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Conditions
/// This deletion function removes an element from the
/// collection in Conditions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteConditions(int idx)
  {
  __setDirty(true);
  allConditions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteConditions(int idx,Lock aLock)
  {
  __setDirty(true);
  allConditions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions
/// This deletion function removes an element from the
/// collection in Conditions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeConditions(IXmlBBase obj)
  {
  int idx = indexOfConditions(obj);
  if (idx >= 0) { deleteConditions(idx);
NotifyControllers(null);
   }
  }

public void removeConditions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfConditions(obj);
  if (idx >= 0) { deleteConditions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Conditions</summary>
/// <returns>the number of elements in Conditions</returns>
public int countConditions()
  {
  return allConditions().Count;
  }

/// <summary>Part of the list interface for Conditions
/// This function returns an element from the
/// collection in Conditions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RuleCondition getConditions(int idx)
{
  return (RuleCondition) ( allConditions()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Rule()
{
Rule obj = this;
aPriority=(0);
aConditions=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
}

public void copyTo(Rule other)
{
base.copyTo(other);
other.aPriority = aPriority;
other.aConditions = aConditions;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1064;
bool fl1065;
RuleCondition fl1067;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubRules")){
ctxt.skipWhiteSpace();
fl1064 = true ; 
while (fl1064) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1064 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
acceptor.lAcceptPcData(ctxt, 0, '<', XmlBContext.WS_PRESERVE);
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubRules>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Conditions")){
ctxt.skipWhiteSpace();
fl1065 = true ; 
while (fl1065) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1065 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1067 = null;
while(ctxt.lookAheadOpeningTag ("<RuleCondition")) {
fl1067 = acceptor.lAccept_RuleCondition(ctxt, "</RuleCondition>");
appendConditions(fl1067);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Conditions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1078;
bool fl1079;
bool fl1080;
bool fl1081;
bool fl1082;
bool fl1083;
bool fl1084;
bool fl1085;
bool fl1086;
bool fl1087;
bool fl1088;
bool fl1089;
bool fl1090;
bool fl1091;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1078 = false ; 
fl1079 = false ; 
fl1080 = false ; 
fl1081 = false ; 
fl1082 = false ; 
fl1083 = false ; 
fl1084 = false ; 
fl1085 = false ; 
fl1086 = false ; 
fl1087 = false ; 
fl1088 = false ; 
fl1089 = false ; 
fl1090 = false ; 
fl1091 = true ; 
while (fl1091) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1080;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1079;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 1081;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 1086;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1090;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("iority=")){
indicator = 1078;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nned=")){
indicator = 1084;
} else {
indicator = 1092;
} // If
break;
} // Case
default:
indicator = 1092;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 1087;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1088;
} else {
indicator = 1092;
} // If
break;
} // Case
default:
indicator = 1092;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1085;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 1083;
} else {
indicator = 1092;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 1082;
} else {
indicator = 1092;
} // If
break;
} // Case
default:
indicator = 1092;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1089;
} else {
indicator = 1092;
} // If
break;
} // Case
default:
indicator = 1092;
break;
} // Switch
switch (indicator) {
case 1078: {
// Handling attribute Priority
// Also handles alien attributes with prefix Priority
if (fl1078){
ctxt.fail ("Duplicate attribute: Priority");
} // If
fl1078 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPriority(acceptor.lAcceptEnum_RulePriority(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1079: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl1079){
ctxt.fail ("Duplicate attribute: X");
} // If
fl1079 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1080: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl1080){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl1080 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1081: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl1081){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl1081 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1082: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl1082){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl1082 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1083: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl1083){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl1083 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1084: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl1084){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl1084 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1085: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1085){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1085 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1086: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl1086){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl1086 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1087: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl1087){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl1087 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1088: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1088){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1088 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1089: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1089){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1089 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1090: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1090){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1090 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1092: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1079){
this.setX(0);
} // If
if (!fl1080){
this.setY(0);
} // If
if (!fl1081){
this.setWidth(0);
} // If
if (!fl1082){
this.setHeight(0);
} // If
if (!fl1083){
this.setHidden( false);
} // If
if (!fl1084){
this.setPinned( false);
} // If
if (!fl1085){
this.setImplemented( false);
} // If
if (!fl1086){
this.setVerified( false);
} // If
if (!fl1087){
this.setNeedsRequirement( true);
} // If
fl1091 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Rule";
  endingTag = "</Rule>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Rule\"");
} // If
pw.Write('\n');
if (this.getPriority() != 0){
pw.Write(" Priority=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_RulePriority_ToString(this.getPriority()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
pw.Write("<SubRules>");
// Unparsing PcData
pw.Write("</SubRules>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: Conditions
if (countConditions() > 0){
pw.Write("<Conditions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getConditions(), false, "<RuleCondition", "</RuleCondition>");
pw.Write("</Conditions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Conditions
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countConditions(); i++) {
  l.Add(getConditions(i));
}
}

}
public partial class RuleCondition
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RuleConditionController.alertChange(aLock, this);
}
private System.Collections.ArrayList aPreConditions;

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
public System.Collections.ArrayList allPreConditions()
  {
if (aPreConditions == null){
    setAllPreConditions( new System.Collections.ArrayList() );
} // If
    return aPreConditions;
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
private System.Collections.ArrayList getPreConditions()
  {
    return allPreConditions();
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection of elements which replaces 
///        PreConditions's current content.</param>
public void setAllPreConditions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
    NotifyControllers(null);
  }
public void setAllPreConditions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="el">a PreCondition to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(System.Collections.IList)"/>
public void appendPreConditions(PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendPreConditions(Lock aLock,PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection ofPreConditions to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(PreCondition)"/>
public void appendPreConditions(System.Collections.IList coll)
  {
  __setDirty(true);
  allPreConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendPreConditions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This insertion function inserts a new element in the
/// collection in PreConditions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertPreConditions(int idx, PreCondition el)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertPreConditions(int idx, PreCondition el,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfPreConditions(IXmlBBase el)
  {
  return ((System.Collections.IList) allPreConditions()).IndexOf (el);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deletePreConditions(int idx)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deletePreConditions(int idx,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removePreConditions(IXmlBBase obj)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(null);
   }
  }

public void removePreConditions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>the number of elements in PreConditions</returns>
public int countPreConditions()
  {
  return allPreConditions().Count;
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns an element from the
/// collection in PreConditions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public PreCondition getPreConditions(int idx)
{
  return (PreCondition) ( allPreConditions()[idx]);
}

private System.Collections.ArrayList aActions;

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
public System.Collections.ArrayList allActions()
  {
if (aActions == null){
    setAllActions( new System.Collections.ArrayList() );
} // If
    return aActions;
  }

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
private System.Collections.ArrayList getActions()
  {
    return allActions();
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Actions's current content.</param>
public void setAllActions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
    NotifyControllers(null);
  }
public void setAllActions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="el">a Action to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(System.Collections.IList)"/>
public void appendActions(Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendActions(Lock aLock,Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection ofActions to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(Action)"/>
public void appendActions(System.Collections.IList coll)
  {
  __setDirty(true);
  allActions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendActions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allActions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This insertion function inserts a new element in the
/// collection in Actions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertActions(int idx, Action el)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertActions(int idx, Action el,Lock aLock)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfActions(IXmlBBase el)
  {
  return ((System.Collections.IList) allActions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteActions(int idx)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteActions(int idx,Lock aLock)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeActions(IXmlBBase obj)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(null);
   }
  }

public void removeActions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Actions</summary>
/// <returns>the number of elements in Actions</returns>
public int countActions()
  {
  return allActions().Count;
  }

/// <summary>Part of the list interface for Actions
/// This function returns an element from the
/// collection in Actions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Action getActions(int idx)
{
  return (Action) ( allActions()[idx]);
}

private System.Collections.ArrayList aSubRules;

/// <summary>Part of the list interface for SubRules</summary>
/// <returns>a collection of all the elements in SubRules</returns>
public System.Collections.ArrayList allSubRules()
  {
if (aSubRules == null){
    setAllSubRules( new System.Collections.ArrayList() );
} // If
    return aSubRules;
  }

/// <summary>Part of the list interface for SubRules</summary>
/// <returns>a collection of all the elements in SubRules</returns>
private System.Collections.ArrayList getSubRules()
  {
    return allSubRules();
  }

/// <summary>Part of the list interface for SubRules</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubRules's current content.</param>
public void setAllSubRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubRules = coll;
    NotifyControllers(null);
  }
public void setAllSubRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules</summary>
/// <param name="el">a Rule to add to the collection in 
///           SubRules</param>
/// <seealso cref="appendSubRules(System.Collections.IList)"/>
public void appendSubRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubRules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           SubRules</param>
/// <seealso cref="appendSubRules(Rule)"/>
public void appendSubRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules
/// This insertion function inserts a new element in the
/// collection in SubRules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubRules(int idx, Rule el)
  {
  __setDirty(true);
  allSubRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allSubRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubRules
/// This deletion function removes an element from the
/// collection in SubRules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubRules(int idx)
  {
  __setDirty(true);
  allSubRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules
/// This deletion function removes an element from the
/// collection in SubRules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubRules(IXmlBBase obj)
  {
  int idx = indexOfSubRules(obj);
  if (idx >= 0) { deleteSubRules(idx);
NotifyControllers(null);
   }
  }

public void removeSubRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubRules(obj);
  if (idx >= 0) { deleteSubRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubRules</summary>
/// <returns>the number of elements in SubRules</returns>
public int countSubRules()
  {
  return allSubRules().Count;
  }

/// <summary>Part of the list interface for SubRules
/// This function returns an element from the
/// collection in SubRules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getSubRules(int idx)
{
  return (Rule) ( allSubRules()[idx]);
}

public RuleCondition()
{
RuleCondition obj = this;
aPreConditions=(null);
aActions=(null);
aSubRules=(null);
}

public void copyTo(RuleCondition other)
{
base.copyTo(other);
other.aPreConditions = aPreConditions;
other.aActions = aActions;
other.aSubRules = aSubRules;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1110;
PreCondition fl1112;
bool fl1123;
Action fl1125;
bool fl1136;
Rule fl1138;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<PreConditions")){
ctxt.skipWhiteSpace();
fl1110 = true ; 
while (fl1110) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1110 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1112 = null;
while(ctxt.lookAheadOpeningTag ("<PreCondition")) {
fl1112 = acceptor.lAccept_PreCondition(ctxt, "</PreCondition>");
appendPreConditions(fl1112);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</PreConditions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Actions")){
ctxt.skipWhiteSpace();
fl1123 = true ; 
while (fl1123) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1123 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1125 = null;
while(ctxt.lookAheadOpeningTag ("<Action")) {
fl1125 = acceptor.lAccept_Action(ctxt, "</Action>");
appendActions(fl1125);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Actions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubRules")){
ctxt.skipWhiteSpace();
fl1136 = true ; 
while (fl1136) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1136 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1138 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl1138 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendSubRules(fl1138);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubRules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1149;
bool fl1150;
bool fl1151;
bool fl1152;
bool fl1153;
bool fl1154;
bool fl1155;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1149 = false ; 
fl1150 = false ; 
fl1151 = false ; 
fl1152 = false ; 
fl1153 = false ; 
fl1154 = false ; 
fl1155 = true ; 
while (fl1155) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 1150;
} else {
indicator = 1156;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1154;
} else {
indicator = 1156;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 1151;
} else {
indicator = 1156;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1152;
} else {
indicator = 1156;
} // If
break;
} // Case
default:
indicator = 1156;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1149;
} else {
indicator = 1156;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1153;
} else {
indicator = 1156;
} // If
break;
} // Case
default:
indicator = 1156;
break;
} // Switch
switch (indicator) {
case 1149: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1149){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1149 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1150: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl1150){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl1150 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1151: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl1151){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl1151 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1152: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1152){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1152 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1153: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1153){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1153 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1154: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1154){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1154 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1156: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1149){
this.setImplemented( false);
} // If
if (!fl1150){
this.setVerified( false);
} // If
if (!fl1151){
this.setNeedsRequirement( true);
} // If
fl1155 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RuleCondition";
  endingTag = "</RuleCondition>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RuleCondition\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
pw.Write("<PreConditions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getPreConditions(), false, "<PreCondition", "</PreCondition>");
pw.Write("</PreConditions>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<Actions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getActions(), false, "<Action", "</Action>");
pw.Write("</Actions>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: SubRules
if (countSubRules() > 0){
pw.Write("<SubRules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubRules(), false, "<Rule", "</Rule>");
pw.Write("</SubRules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubRules
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countPreConditions(); i++) {
  l.Add(getPreConditions(i));
}
for (int i = 0; i < countActions(); i++) {
  l.Add(getActions(i));
}
for (int i = 0; i < countSubRules(); i++) {
  l.Add(getSubRules(i));
}
}

}
public partial class PreCondition
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getCondition().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.PreConditionController.alertChange(aLock, this);
}
private   string  aCondition;

public   string  getCondition() { return aCondition;}

public  void setCondition( string  v) {
  aCondition = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public PreCondition()
{
PreCondition obj = this;
aCondition=(null);
aComment=(null);
}

public void copyTo(PreCondition other)
{
base.copyTo(other);
other.aCondition = aCondition;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1165;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1165 = true ; 
while (fl1165) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1165 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
// Indicator
// Parse PC data
this.setCondition(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1166;
bool fl1167;
bool fl1168;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1166 = false ; 
fl1167 = false ; 
fl1168 = true ; 
while (fl1168) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1167;
} else {
indicator = 1169;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1166;
} else {
indicator = 1169;
} // If
break;
} // Case
default:
indicator = 1169;
break;
} // Switch
switch (indicator) {
case 1166: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1166){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1166 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1167: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1167){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1167 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1169: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1168 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<PreCondition";
  endingTag = "</PreCondition>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"PreCondition\"");
} // If
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing PcData
acceptor.unParsePcData(pw, this.getCondition());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Action
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getExpression().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ActionController.alertChange(aLock, this);
}
private   string  aExpression;

public   string  getExpression() { return aExpression;}

public  void setExpression( string  v) {
  aExpression = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Action()
{
Action obj = this;
aExpression=(null);
aComment=(null);
}

public void copyTo(Action other)
{
base.copyTo(other);
other.aExpression = aExpression;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1173;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1173 = true ; 
while (fl1173) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1173 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
// Indicator
// Parse PC data
this.setExpression(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1174;
bool fl1175;
bool fl1176;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1174 = false ; 
fl1175 = false ; 
fl1176 = true ; 
while (fl1176) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1175;
} else {
indicator = 1177;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1174;
} else {
indicator = 1177;
} // If
break;
} // Case
default:
indicator = 1177;
break;
} // Switch
switch (indicator) {
case 1174: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1174){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1174 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1175: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1175){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1175 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1177: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1176 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Action";
  endingTag = "</Action>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Action\"");
} // If
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing PcData
acceptor.unParsePcData(pw, this.getExpression());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class FrameRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FrameRefController.alertChange(aLock, this);
}
public FrameRef()
{
FrameRef obj = this;
}

public void copyTo(FrameRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1181;
bool fl1182;
bool fl1183;
bool fl1184;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1181 = false ; 
fl1182 = false ; 
fl1183 = false ; 
fl1184 = true ; 
while (fl1184) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1183;
} else {
indicator = 1185;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1181;
} else {
indicator = 1185;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1182;
} else {
indicator = 1185;
} // If
break;
} // Case
default:
indicator = 1185;
break;
} // Switch
switch (indicator) {
case 1181: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1181){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1181 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1182: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1182){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1182 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1183: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1183){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1183 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1185: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1184 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<FrameRef";
  endingTag = "</FrameRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"FrameRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Frame
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getCycleDuration().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FrameController.alertChange(aLock, this);
}
private   string  aCycleDuration;

public   string  getCycleDuration() { return aCycleDuration;}

public  void setCycleDuration( string  v) {
  aCycleDuration = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSubSequences;

/// <summary>Part of the list interface for SubSequences</summary>
/// <returns>a collection of all the elements in SubSequences</returns>
public System.Collections.ArrayList allSubSequences()
  {
if (aSubSequences == null){
    setAllSubSequences( new System.Collections.ArrayList() );
} // If
    return aSubSequences;
  }

/// <summary>Part of the list interface for SubSequences</summary>
/// <returns>a collection of all the elements in SubSequences</returns>
private System.Collections.ArrayList getSubSequences()
  {
    return allSubSequences();
  }

/// <summary>Part of the list interface for SubSequences</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSequences's current content.</param>
public void setAllSubSequences(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSequences = coll;
    NotifyControllers(null);
  }
public void setAllSubSequences(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSequences = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences</summary>
/// <param name="el">a SubSequence to add to the collection in 
///           SubSequences</param>
/// <seealso cref="appendSubSequences(System.Collections.IList)"/>
public void appendSubSequences(SubSequence el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSequences().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSequences(Lock aLock,SubSequence el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSequences().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSequences</summary>
/// <param name="coll">a collection ofSubSequences to add to the collection in 
///           SubSequences</param>
/// <seealso cref="appendSubSequences(SubSequence)"/>
public void appendSubSequences(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSequences().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSequences(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSequences().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences
/// This insertion function inserts a new element in the
/// collection in SubSequences</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSequences(int idx, SubSequence el)
  {
  __setDirty(true);
  allSubSequences().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSequences(int idx, SubSequence el,Lock aLock)
  {
  __setDirty(true);
  allSubSequences().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSequences(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSequences()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSequences
/// This deletion function removes an element from the
/// collection in SubSequences</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSequences(int idx)
  {
  __setDirty(true);
  allSubSequences().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSequences(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSequences().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences
/// This deletion function removes an element from the
/// collection in SubSequences
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSequences(IXmlBBase obj)
  {
  int idx = indexOfSubSequences(obj);
  if (idx >= 0) { deleteSubSequences(idx);
NotifyControllers(null);
   }
  }

public void removeSubSequences(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSequences(obj);
  if (idx >= 0) { deleteSubSequences(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSequences</summary>
/// <returns>the number of elements in SubSequences</returns>
public int countSubSequences()
  {
  return allSubSequences().Count;
  }

/// <summary>Part of the list interface for SubSequences
/// This function returns an element from the
/// collection in SubSequences based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SubSequence getSubSequences(int idx)
{
  return (SubSequence) ( allSubSequences()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Frame()
{
Frame obj = this;
aCycleDuration=(null);
aSubSequences=(null);
aComment=(null);
}

public void copyTo(Frame other)
{
base.copyTo(other);
other.aCycleDuration = aCycleDuration;
other.aSubSequences = aSubSequences;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1190;
bool fl1191;
SubSequence fl1193;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1190 = true ; 
while (fl1190) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1190 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubSequences")){
ctxt.skipWhiteSpace();
fl1191 = true ; 
while (fl1191) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1191 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1193 = null;
while(ctxt.lookAheadOpeningTag ("<SubSequence")) {
fl1193 = acceptor.lAccept_SubSequence(ctxt, "</SubSequence>");
appendSubSequences(fl1193);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSequences>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1204;
bool fl1205;
bool fl1206;
bool fl1207;
bool fl1208;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1204 = false ; 
fl1205 = false ; 
fl1206 = false ; 
fl1207 = false ; 
fl1208 = true ; 
while (fl1208) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1207;
} else {
indicator = 1209;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1205;
} else {
indicator = 1209;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1206;
} else {
indicator = 1209;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ycleDuration=")){
indicator = 1204;
} else {
indicator = 1209;
} // If
break;
} // Case
default:
indicator = 1209;
break;
} // Switch
switch (indicator) {
case 1204: {
// Handling attribute CycleDuration
// Also handles alien attributes with prefix CycleDuration
if (fl1204){
ctxt.fail ("Duplicate attribute: CycleDuration");
} // If
fl1204 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCycleDuration((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1205: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1205){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1205 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1206: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1206){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1206 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1207: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1207){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1207 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1209: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1204){
this.setCycleDuration("0.1");
} // If
fl1208 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Frame";
  endingTag = "</Frame>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Frame\"");
} // If
pw.Write('\n');
if (this.getCycleDuration() != null){
pw.Write(" CycleDuration=\"");
acceptor.unParsePcData(pw, this.getCycleDuration());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: SubSequences
if (countSubSequences() > 0){
pw.Write("<SubSequences>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSequences(), false, "<SubSequence", "</SubSequence>");
pw.Write("</SubSequences>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubSequences
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSubSequences(); i++) {
  l.Add(getSubSequences(i));
}
}

}
public partial class SubSequence
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getD_LRBG().CompareTo((String) search) == 0)return true;
if(getLevel().CompareTo((String) search) == 0)return true;
if(getMode().CompareTo((String) search) == 0)return true;
if(getNID_LRBG().CompareTo((String) search) == 0)return true;
if(getQ_DIRLRBG().CompareTo((String) search) == 0)return true;
if(getQ_DIRTRAIN().CompareTo((String) search) == 0)return true;
if(getQ_DLRBG().CompareTo((String) search) == 0)return true;
if(getRBC_ID().CompareTo((String) search) == 0)return true;
if(getRBCPhone().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SubSequenceController.alertChange(aLock, this);
}
private   string  aD_LRBG;

public   string  getD_LRBG() { return aD_LRBG;}

public  void setD_LRBG( string  v) {
  aD_LRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aLevel;

public   string  getLevel() { return aLevel;}

public  void setLevel( string  v) {
  aLevel = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMode;

public   string  getMode() { return aMode;}

public  void setMode( string  v) {
  aMode = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aNID_LRBG;

public   string  getNID_LRBG() { return aNID_LRBG;}

public  void setNID_LRBG( string  v) {
  aNID_LRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aQ_DIRLRBG;

public   string  getQ_DIRLRBG() { return aQ_DIRLRBG;}

public  void setQ_DIRLRBG( string  v) {
  aQ_DIRLRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aQ_DIRTRAIN;

public   string  getQ_DIRTRAIN() { return aQ_DIRTRAIN;}

public  void setQ_DIRTRAIN( string  v) {
  aQ_DIRTRAIN = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aQ_DLRBG;

public   string  getQ_DLRBG() { return aQ_DLRBG;}

public  void setQ_DLRBG( string  v) {
  aQ_DLRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aRBC_ID;

public   string  getRBC_ID() { return aRBC_ID;}

public  void setRBC_ID( string  v) {
  aRBC_ID = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aRBCPhone;

public   string  getRBCPhone() { return aRBCPhone;}

public  void setRBCPhone( string  v) {
  aRBCPhone = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aTestCases;

/// <summary>Part of the list interface for TestCases</summary>
/// <returns>a collection of all the elements in TestCases</returns>
public System.Collections.ArrayList allTestCases()
  {
if (aTestCases == null){
    setAllTestCases( new System.Collections.ArrayList() );
} // If
    return aTestCases;
  }

/// <summary>Part of the list interface for TestCases</summary>
/// <returns>a collection of all the elements in TestCases</returns>
private System.Collections.ArrayList getTestCases()
  {
    return allTestCases();
  }

/// <summary>Part of the list interface for TestCases</summary>
/// <param name="coll">a collection of elements which replaces 
///        TestCases's current content.</param>
public void setAllTestCases(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestCases = coll;
    NotifyControllers(null);
  }
public void setAllTestCases(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestCases = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases</summary>
/// <param name="el">a TestCase to add to the collection in 
///           TestCases</param>
/// <seealso cref="appendTestCases(System.Collections.IList)"/>
public void appendTestCases(TestCase el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTestCases(Lock aLock,TestCase el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TestCases</summary>
/// <param name="coll">a collection ofTestCases to add to the collection in 
///           TestCases</param>
/// <seealso cref="appendTestCases(TestCase)"/>
public void appendTestCases(System.Collections.IList coll)
  {
  __setDirty(true);
  allTestCases().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTestCases(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTestCases().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases
/// This insertion function inserts a new element in the
/// collection in TestCases</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTestCases(int idx, TestCase el)
  {
  __setDirty(true);
  allTestCases().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTestCases(int idx, TestCase el,Lock aLock)
  {
  __setDirty(true);
  allTestCases().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTestCases(IXmlBBase el)
  {
  return ((System.Collections.IList) allTestCases()).IndexOf (el);
  }

/// <summary>Part of the list interface for TestCases
/// This deletion function removes an element from the
/// collection in TestCases</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTestCases(int idx)
  {
  __setDirty(true);
  allTestCases().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTestCases(int idx,Lock aLock)
  {
  __setDirty(true);
  allTestCases().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases
/// This deletion function removes an element from the
/// collection in TestCases
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTestCases(IXmlBBase obj)
  {
  int idx = indexOfTestCases(obj);
  if (idx >= 0) { deleteTestCases(idx);
NotifyControllers(null);
   }
  }

public void removeTestCases(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTestCases(obj);
  if (idx >= 0) { deleteTestCases(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TestCases</summary>
/// <returns>the number of elements in TestCases</returns>
public int countTestCases()
  {
  return allTestCases().Count;
  }

/// <summary>Part of the list interface for TestCases
/// This function returns an element from the
/// collection in TestCases based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public TestCase getTestCases(int idx)
{
  return (TestCase) ( allTestCases()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aCompleted;

public  bool getCompleted() { return aCompleted;}

public  void setCompleted(bool v) {
  aCompleted = v;
  __setDirty(true);
  NotifyControllers(null);
}


public SubSequence()
{
SubSequence obj = this;
aD_LRBG=(null);
aLevel=(null);
aMode=(null);
aNID_LRBG=(null);
aQ_DIRLRBG=(null);
aQ_DIRTRAIN=(null);
aQ_DLRBG=(null);
aRBC_ID=(null);
aRBCPhone=(null);
aTestCases=(null);
aComment=(null);
aCompleted=(false);
}

public void copyTo(SubSequence other)
{
base.copyTo(other);
other.aD_LRBG = aD_LRBG;
other.aLevel = aLevel;
other.aMode = aMode;
other.aNID_LRBG = aNID_LRBG;
other.aQ_DIRLRBG = aQ_DIRLRBG;
other.aQ_DIRTRAIN = aQ_DIRTRAIN;
other.aQ_DLRBG = aQ_DLRBG;
other.aRBC_ID = aRBC_ID;
other.aRBCPhone = aRBCPhone;
other.aTestCases = aTestCases;
other.aComment = aComment;
other.aCompleted = aCompleted;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1215;
bool fl1216;
TestCase fl1218;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1215 = true ; 
while (fl1215) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1215 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<TestCases")){
ctxt.skipWhiteSpace();
fl1216 = true ; 
while (fl1216) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1216 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1218 = null;
while(ctxt.lookAheadOpeningTag ("<TestCase")) {
fl1218 = acceptor.lAccept_TestCase(ctxt, "</TestCase>");
appendTestCases(fl1218);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</TestCases>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1229;
bool fl1230;
bool fl1231;
bool fl1232;
bool fl1233;
bool fl1234;
bool fl1235;
bool fl1236;
bool fl1237;
bool fl1238;
bool fl1239;
bool fl1240;
bool fl1241;
bool fl1242;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1229 = false ; 
fl1230 = false ; 
fl1231 = false ; 
fl1232 = false ; 
fl1233 = false ; 
fl1234 = false ; 
fl1235 = false ; 
fl1236 = false ; 
fl1237 = false ; 
fl1238 = false ; 
fl1239 = false ; 
fl1240 = false ; 
fl1241 = false ; 
fl1242 = true ; 
while (fl1242) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1241;
} else {
indicator = 1243;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('B','C')){
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
if (ctxt.lookAhead3('I','D','=')){
indicator = 1236;
} else {
indicator = 1243;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("hone=")){
indicator = 1237;
} else {
indicator = 1243;
} // If
break;
} // Case
default:
indicator = 1243;
break;
} // Switch
} else {
indicator = 1243;
} // If
break;
} // Case
case 'Q':
{
ctxt.advance();
if (ctxt.lookAhead2('_','D')){
switch (ctxt.current()) {
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("RBG=")){
indicator = 1235;
} else {
indicator = 1243;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('R')){
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("RAIN=")){
indicator = 1234;
} else {
indicator = 1243;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("RBG=")){
indicator = 1233;
} else {
indicator = 1243;
} // If
break;
} // Case
default:
indicator = 1243;
break;
} // Switch
} else {
indicator = 1243;
} // If
break;
} // Case
default:
indicator = 1243;
break;
} // Switch
} else {
indicator = 1243;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1239;
} else {
indicator = 1243;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("D_LRBG=")){
indicator = 1232;
} else {
indicator = 1243;
} // If
break;
} // Case
default:
indicator = 1243;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("ode=")){
indicator = 1231;
} else {
indicator = 1243;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("evel=")){
indicator = 1230;
} else {
indicator = 1243;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1240;
} else {
indicator = 1243;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("_LRBG=")){
indicator = 1229;
} else {
indicator = 1243;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ompleted=")){
indicator = 1238;
} else {
indicator = 1243;
} // If
break;
} // Case
default:
indicator = 1243;
break;
} // Switch
switch (indicator) {
case 1229: {
// Handling attribute D_LRBG
// Also handles alien attributes with prefix D_LRBG
if (fl1229){
ctxt.fail ("Duplicate attribute: D_LRBG");
} // If
fl1229 = true ; 
quoteChar = ctxt.acceptQuote();
this.setD_LRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1230: {
// Handling attribute Level
// Also handles alien attributes with prefix Level
if (fl1230){
ctxt.fail ("Duplicate attribute: Level");
} // If
fl1230 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLevel((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1231: {
// Handling attribute Mode
// Also handles alien attributes with prefix Mode
if (fl1231){
ctxt.fail ("Duplicate attribute: Mode");
} // If
fl1231 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMode((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1232: {
// Handling attribute NID_LRBG
// Also handles alien attributes with prefix NID_LRBG
if (fl1232){
ctxt.fail ("Duplicate attribute: NID_LRBG");
} // If
fl1232 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNID_LRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1233: {
// Handling attribute Q_DIRLRBG
// Also handles alien attributes with prefix Q_DIRLRBG
if (fl1233){
ctxt.fail ("Duplicate attribute: Q_DIRLRBG");
} // If
fl1233 = true ; 
quoteChar = ctxt.acceptQuote();
this.setQ_DIRLRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1234: {
// Handling attribute Q_DIRTRAIN
// Also handles alien attributes with prefix Q_DIRTRAIN
if (fl1234){
ctxt.fail ("Duplicate attribute: Q_DIRTRAIN");
} // If
fl1234 = true ; 
quoteChar = ctxt.acceptQuote();
this.setQ_DIRTRAIN((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1235: {
// Handling attribute Q_DLRBG
// Also handles alien attributes with prefix Q_DLRBG
if (fl1235){
ctxt.fail ("Duplicate attribute: Q_DLRBG");
} // If
fl1235 = true ; 
quoteChar = ctxt.acceptQuote();
this.setQ_DLRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1236: {
// Handling attribute RBC_ID
// Also handles alien attributes with prefix RBC_ID
if (fl1236){
ctxt.fail ("Duplicate attribute: RBC_ID");
} // If
fl1236 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRBC_ID((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1237: {
// Handling attribute RBCPhone
// Also handles alien attributes with prefix RBCPhone
if (fl1237){
ctxt.fail ("Duplicate attribute: RBCPhone");
} // If
fl1237 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRBCPhone((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1238: {
// Handling attribute Completed
// Also handles alien attributes with prefix Completed
if (fl1238){
ctxt.fail ("Duplicate attribute: Completed");
} // If
fl1238 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCompleted(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1239: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1239){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1239 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1240: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1240){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1240 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1241: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1241){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1241 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1243: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1229){
this.setD_LRBG("");
} // If
if (!fl1230){
this.setLevel("");
} // If
if (!fl1231){
this.setMode("");
} // If
if (!fl1232){
this.setNID_LRBG("");
} // If
if (!fl1233){
this.setQ_DIRLRBG("");
} // If
if (!fl1234){
this.setQ_DIRTRAIN("");
} // If
if (!fl1235){
this.setQ_DLRBG("");
} // If
if (!fl1236){
this.setRBC_ID("");
} // If
if (!fl1237){
this.setRBCPhone("");
} // If
if (!fl1238){
this.setCompleted( true);
} // If
fl1242 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SubSequence";
  endingTag = "</SubSequence>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SubSequence\"");
} // If
pw.Write('\n');
if (this.getD_LRBG() != null){
pw.Write(" D_LRBG=\"");
acceptor.unParsePcData(pw, this.getD_LRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getLevel() != null){
pw.Write(" Level=\"");
acceptor.unParsePcData(pw, this.getLevel());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMode() != null){
pw.Write(" Mode=\"");
acceptor.unParsePcData(pw, this.getMode());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getNID_LRBG() != null){
pw.Write(" NID_LRBG=\"");
acceptor.unParsePcData(pw, this.getNID_LRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getQ_DIRLRBG() != null){
pw.Write(" Q_DIRLRBG=\"");
acceptor.unParsePcData(pw, this.getQ_DIRLRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getQ_DIRTRAIN() != null){
pw.Write(" Q_DIRTRAIN=\"");
acceptor.unParsePcData(pw, this.getQ_DIRTRAIN());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getQ_DLRBG() != null){
pw.Write(" Q_DLRBG=\"");
acceptor.unParsePcData(pw, this.getQ_DLRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getRBC_ID() != null){
pw.Write(" RBC_ID=\"");
acceptor.unParsePcData(pw, this.getRBC_ID());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getRBCPhone() != null){
pw.Write(" RBCPhone=\"");
acceptor.unParsePcData(pw, this.getRBCPhone());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getCompleted()){
pw.Write(" Completed=\"");
acceptor.unParsePcData(pw, this.getCompleted());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: TestCases
if (countTestCases() > 0){
pw.Write("<TestCases>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTestCases(), false, "<TestCase", "</TestCase>");
pw.Write("</TestCases>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: TestCases
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countTestCases(); i++) {
  l.Add(getTestCases(i));
}
}

}
public partial class TestCase
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getObsoleteComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TestCaseController.alertChange(aLock, this);
}
private  int aFeature;

public  int getFeature() { return aFeature;}

public  void setFeature(int v) {
  aFeature = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aCase;

public  int getCase() { return aCase;}

public  void setCase(int v) {
  aCase = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSteps;

/// <summary>Part of the list interface for Steps</summary>
/// <returns>a collection of all the elements in Steps</returns>
public System.Collections.ArrayList allSteps()
  {
if (aSteps == null){
    setAllSteps( new System.Collections.ArrayList() );
} // If
    return aSteps;
  }

/// <summary>Part of the list interface for Steps</summary>
/// <returns>a collection of all the elements in Steps</returns>
private System.Collections.ArrayList getSteps()
  {
    return allSteps();
  }

/// <summary>Part of the list interface for Steps</summary>
/// <param name="coll">a collection of elements which replaces 
///        Steps's current content.</param>
public void setAllSteps(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSteps = coll;
    NotifyControllers(null);
  }
public void setAllSteps(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSteps = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps</summary>
/// <param name="el">a Step to add to the collection in 
///           Steps</param>
/// <seealso cref="appendSteps(System.Collections.IList)"/>
public void appendSteps(Step el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSteps(Lock aLock,Step el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Steps</summary>
/// <param name="coll">a collection ofSteps to add to the collection in 
///           Steps</param>
/// <seealso cref="appendSteps(Step)"/>
public void appendSteps(System.Collections.IList coll)
  {
  __setDirty(true);
  allSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSteps(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps
/// This insertion function inserts a new element in the
/// collection in Steps</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSteps(int idx, Step el)
  {
  __setDirty(true);
  allSteps().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSteps(int idx, Step el,Lock aLock)
  {
  __setDirty(true);
  allSteps().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSteps(IXmlBBase el)
  {
  return ((System.Collections.IList) allSteps()).IndexOf (el);
  }

/// <summary>Part of the list interface for Steps
/// This deletion function removes an element from the
/// collection in Steps</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSteps(int idx)
  {
  __setDirty(true);
  allSteps().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSteps(int idx,Lock aLock)
  {
  __setDirty(true);
  allSteps().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps
/// This deletion function removes an element from the
/// collection in Steps
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSteps(IXmlBBase obj)
  {
  int idx = indexOfSteps(obj);
  if (idx >= 0) { deleteSteps(idx);
NotifyControllers(null);
   }
  }

public void removeSteps(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSteps(obj);
  if (idx >= 0) { deleteSteps(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Steps</summary>
/// <returns>the number of elements in Steps</returns>
public int countSteps()
  {
  return allSteps().Count;
  }

/// <summary>Part of the list interface for Steps
/// This function returns an element from the
/// collection in Steps based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Step getSteps(int idx)
{
  return (Step) ( allSteps()[idx]);
}

private   string  aObsoleteComment;

public   string  getObsoleteComment() { return aObsoleteComment;}

public  void setObsoleteComment( string  v) {
  aObsoleteComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public TestCase()
{
TestCase obj = this;
aFeature=(0);
aCase=(0);
aSteps=(null);
aObsoleteComment=(null);
}

public void copyTo(TestCase other)
{
base.copyTo(other);
other.aFeature = aFeature;
other.aCase = aCase;
other.aSteps = aSteps;
other.aObsoleteComment = aObsoleteComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1262;
bool fl1263;
Step fl1265;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1262 = true ; 
while (fl1262) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1262 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setObsoleteComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Steps")){
ctxt.skipWhiteSpace();
fl1263 = true ; 
while (fl1263) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1263 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1265 = null;
while(ctxt.lookAheadOpeningTag ("<Step")) {
fl1265 = acceptor.lAccept_Step(ctxt, "</Step>");
appendSteps(fl1265);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Steps>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1276;
bool fl1277;
bool fl1278;
bool fl1279;
bool fl1280;
bool fl1281;
bool fl1282;
bool fl1283;
bool fl1284;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1276 = false ; 
fl1277 = false ; 
fl1278 = false ; 
fl1279 = false ; 
fl1280 = false ; 
fl1281 = false ; 
fl1282 = false ; 
fl1283 = false ; 
fl1284 = true ; 
while (fl1284) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 1279;
} else {
indicator = 1285;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1283;
} else {
indicator = 1285;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 1280;
} else {
indicator = 1285;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1281;
} else {
indicator = 1285;
} // If
break;
} // Case
default:
indicator = 1285;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1278;
} else {
indicator = 1285;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1282;
} else {
indicator = 1285;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("eature=")){
indicator = 1276;
} else {
indicator = 1285;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ase=")){
indicator = 1277;
} else {
indicator = 1285;
} // If
break;
} // Case
default:
indicator = 1285;
break;
} // Switch
switch (indicator) {
case 1276: {
// Handling attribute Feature
// Also handles alien attributes with prefix Feature
if (fl1276){
ctxt.fail ("Duplicate attribute: Feature");
} // If
fl1276 = true ; 
quoteChar = ctxt.acceptQuote();
this.setFeature(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1277: {
// Handling attribute Case
// Also handles alien attributes with prefix Case
if (fl1277){
ctxt.fail ("Duplicate attribute: Case");
} // If
fl1277 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCase(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1278: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1278){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1278 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1279: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl1279){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl1279 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1280: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl1280){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl1280 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1281: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1281){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1281 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1282: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1282){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1282 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1283: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1283){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1283 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1285: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1276){
this.setFeature(9999);
} // If
if (!fl1277){
this.setCase(9999);
} // If
if (!fl1278){
this.setImplemented( false);
} // If
if (!fl1279){
this.setVerified( false);
} // If
if (!fl1280){
this.setNeedsRequirement( true);
} // If
fl1284 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<TestCase";
  endingTag = "</TestCase>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"TestCase\"");
} // If
pw.Write('\n');
if (this.getFeature() != 9999){
pw.Write(" Feature=\"");
acceptor.unParsePcData(pw, this.getFeature());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getCase() != 9999){
pw.Write(" Case=\"");
acceptor.unParsePcData(pw, this.getCase());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: ObsoleteComment
if (this.getObsoleteComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getObsoleteComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: ObsoleteComment
// Unparsing Enclosed
// Testing for empty content: Steps
if (countSteps() > 0){
pw.Write("<Steps>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSteps(), false, "<Step", "</Step>");
pw.Write("</Steps>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Steps
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSteps(); i++) {
  l.Add(getSteps(i));
}
}

}
public partial class Step
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
if(getDescription().CompareTo((String) search) == 0)return true;
if(getObsoleteComment().CompareTo((String) search) == 0)return true;
if(getUserComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StepController.alertChange(aLock, this);
}
private  int aTCS_Order;

public  int getTCS_Order() { return aTCS_Order;}

public  void setTCS_Order(int v) {
  aTCS_Order = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aDistance;

public  int getDistance() { return aDistance;}

public  void setDistance(int v) {
  aDistance = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDescription;

public   string  getDescription() { return aDescription;}

public  void setDescription( string  v) {
  aDescription = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aObsoleteComment;

public   string  getObsoleteComment() { return aObsoleteComment;}

public  void setObsoleteComment( string  v) {
  aObsoleteComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aUserComment;

public   string  getUserComment() { return aUserComment;}

public  void setUserComment( string  v) {
  aUserComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.ST_IO aIO;

public  acceptor.ST_IO getIO() { return aIO;}

public  void setIO(acceptor.ST_IO v) {
  aIO = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getIO_AsString()
{
  return acceptor.Enum_ST_IO_ToString (aIO);
}

public  bool setIO_AsString( string  v)
{
 acceptor.ST_IO  temp = acceptor.StringTo_Enum_ST_IO(v);
if (temp >= 0){
  aIO = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_INTERFACE aInterface;

public  acceptor.ST_INTERFACE getInterface() { return aInterface;}

public  void setInterface(acceptor.ST_INTERFACE v) {
  aInterface = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getInterface_AsString()
{
  return acceptor.Enum_ST_INTERFACE_ToString (aInterface);
}

public  bool setInterface_AsString( string  v)
{
 acceptor.ST_INTERFACE  temp = acceptor.StringTo_Enum_ST_INTERFACE(v);
if (temp >= 0){
  aInterface = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_LEVEL aLevelIN;

public  acceptor.ST_LEVEL getLevelIN() { return aLevelIN;}

public  void setLevelIN(acceptor.ST_LEVEL v) {
  aLevelIN = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getLevelIN_AsString()
{
  return acceptor.Enum_ST_LEVEL_ToString (aLevelIN);
}

public  bool setLevelIN_AsString( string  v)
{
 acceptor.ST_LEVEL  temp = acceptor.StringTo_Enum_ST_LEVEL(v);
if (temp >= 0){
  aLevelIN = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_LEVEL aLevelOUT;

public  acceptor.ST_LEVEL getLevelOUT() { return aLevelOUT;}

public  void setLevelOUT(acceptor.ST_LEVEL v) {
  aLevelOUT = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getLevelOUT_AsString()
{
  return acceptor.Enum_ST_LEVEL_ToString (aLevelOUT);
}

public  bool setLevelOUT_AsString( string  v)
{
 acceptor.ST_LEVEL  temp = acceptor.StringTo_Enum_ST_LEVEL(v);
if (temp >= 0){
  aLevelOUT = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_MODE aModeIN;

public  acceptor.ST_MODE getModeIN() { return aModeIN;}

public  void setModeIN(acceptor.ST_MODE v) {
  aModeIN = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getModeIN_AsString()
{
  return acceptor.Enum_ST_MODE_ToString (aModeIN);
}

public  bool setModeIN_AsString( string  v)
{
 acceptor.ST_MODE  temp = acceptor.StringTo_Enum_ST_MODE(v);
if (temp >= 0){
  aModeIN = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_MODE aModeOUT;

public  acceptor.ST_MODE getModeOUT() { return aModeOUT;}

public  void setModeOUT(acceptor.ST_MODE v) {
  aModeOUT = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getModeOUT_AsString()
{
  return acceptor.Enum_ST_MODE_ToString (aModeOUT);
}

public  bool setModeOUT_AsString( string  v)
{
 acceptor.ST_MODE  temp = acceptor.StringTo_Enum_ST_MODE(v);
if (temp >= 0){
  aModeOUT = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  bool aTranslationRequired;

public  bool getTranslationRequired() { return aTranslationRequired;}

public  void setTranslationRequired(bool v) {
  aTranslationRequired = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aTranslated;

public  bool getTranslated() { return aTranslated;}

public  void setTranslated(bool v) {
  aTranslated = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSubSteps;

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
public System.Collections.ArrayList allSubSteps()
  {
if (aSubSteps == null){
    setAllSubSteps( new System.Collections.ArrayList() );
} // If
    return aSubSteps;
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
private System.Collections.ArrayList getSubSteps()
  {
    return allSubSteps();
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSteps's current content.</param>
public void setAllSubSteps(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
    NotifyControllers(null);
  }
public void setAllSubSteps(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="el">a SubStep to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(System.Collections.IList)"/>
public void appendSubSteps(SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSteps(Lock aLock,SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection ofSubSteps to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(SubStep)"/>
public void appendSubSteps(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSteps(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This insertion function inserts a new element in the
/// collection in SubSteps</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSteps(int idx, SubStep el)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSteps(int idx, SubStep el,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSteps(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSteps()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSteps(int idx)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSteps(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSteps(IXmlBBase obj)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(null);
   }
  }

public void removeSubSteps(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>the number of elements in SubSteps</returns>
public int countSubSteps()
  {
  return allSubSteps().Count;
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns an element from the
/// collection in SubSteps based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SubStep getSubSteps(int idx)
{
  return (SubStep) ( allSubSteps()[idx]);
}

private System.Collections.ArrayList aMessages;

/// <summary>Part of the list interface for Messages</summary>
/// <returns>a collection of all the elements in Messages</returns>
public System.Collections.ArrayList allMessages()
  {
if (aMessages == null){
    setAllMessages( new System.Collections.ArrayList() );
} // If
    return aMessages;
  }

/// <summary>Part of the list interface for Messages</summary>
/// <returns>a collection of all the elements in Messages</returns>
private System.Collections.ArrayList getMessages()
  {
    return allMessages();
  }

/// <summary>Part of the list interface for Messages</summary>
/// <param name="coll">a collection of elements which replaces 
///        Messages's current content.</param>
public void setAllMessages(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMessages = coll;
    NotifyControllers(null);
  }
public void setAllMessages(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMessages = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages</summary>
/// <param name="el">a DBMessage to add to the collection in 
///           Messages</param>
/// <seealso cref="appendMessages(System.Collections.IList)"/>
public void appendMessages(DBMessage el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMessages().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendMessages(Lock aLock,DBMessage el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMessages().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Messages</summary>
/// <param name="coll">a collection ofDBMessages to add to the collection in 
///           Messages</param>
/// <seealso cref="appendMessages(DBMessage)"/>
public void appendMessages(System.Collections.IList coll)
  {
  __setDirty(true);
  allMessages().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendMessages(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allMessages().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages
/// This insertion function inserts a new element in the
/// collection in Messages</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertMessages(int idx, DBMessage el)
  {
  __setDirty(true);
  allMessages().Insert (idx, el);
NotifyControllers(null);
  }

public void insertMessages(int idx, DBMessage el,Lock aLock)
  {
  __setDirty(true);
  allMessages().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfMessages(IXmlBBase el)
  {
  return ((System.Collections.IList) allMessages()).IndexOf (el);
  }

/// <summary>Part of the list interface for Messages
/// This deletion function removes an element from the
/// collection in Messages</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteMessages(int idx)
  {
  __setDirty(true);
  allMessages().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteMessages(int idx,Lock aLock)
  {
  __setDirty(true);
  allMessages().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages
/// This deletion function removes an element from the
/// collection in Messages
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeMessages(IXmlBBase obj)
  {
  int idx = indexOfMessages(obj);
  if (idx >= 0) { deleteMessages(idx);
NotifyControllers(null);
   }
  }

public void removeMessages(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfMessages(obj);
  if (idx >= 0) { deleteMessages(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Messages</summary>
/// <returns>the number of elements in Messages</returns>
public int countMessages()
  {
  return allMessages().Count;
  }

/// <summary>Part of the list interface for Messages
/// This function returns an element from the
/// collection in Messages based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBMessage getMessages(int idx)
{
  return (DBMessage) ( allMessages()[idx]);
}

public Step()
{
Step obj = this;
aTCS_Order=(0);
aDistance=(0);
aDescription=(null);
aObsoleteComment=(null);
aUserComment=(null);
aIO=(0);
aInterface=(0);
aLevelIN=(0);
aLevelOUT=(0);
aModeIN=(0);
aModeOUT=(0);
aTranslationRequired=(false);
aTranslated=(false);
aSubSteps=(null);
aMessages=(null);
}

public void copyTo(Step other)
{
base.copyTo(other);
other.aTCS_Order = aTCS_Order;
other.aDistance = aDistance;
other.aDescription = aDescription;
other.aObsoleteComment = aObsoleteComment;
other.aUserComment = aUserComment;
other.aIO = aIO;
other.aInterface = aInterface;
other.aLevelIN = aLevelIN;
other.aLevelOUT = aLevelOUT;
other.aModeIN = aModeIN;
other.aModeOUT = aModeOUT;
other.aTranslationRequired = aTranslationRequired;
other.aTranslated = aTranslated;
other.aSubSteps = aSubSteps;
other.aMessages = aMessages;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1296;
bool fl1297;
bool fl1298;
bool fl1299;
SubStep fl1301;
bool fl1312;
DBMessage fl1314;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Description")){
ctxt.skipWhiteSpace();
fl1296 = true ; 
while (fl1296) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1296 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setDescription(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Description>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1297 = true ; 
while (fl1297) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1297 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setObsoleteComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<UserComment")){
ctxt.skipWhiteSpace();
fl1298 = true ; 
while (fl1298) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1298 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setUserComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</UserComment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubSteps")){
ctxt.skipWhiteSpace();
fl1299 = true ; 
while (fl1299) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1299 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1301 = null;
while(ctxt.lookAheadOpeningTag ("<SubStep")) {
fl1301 = acceptor.lAccept_SubStep(ctxt, "</SubStep>");
appendSubSteps(fl1301);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSteps>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Messsages")){
ctxt.skipWhiteSpace();
fl1312 = true ; 
while (fl1312) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1312 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1314 = null;
while(ctxt.lookAheadOpeningTag ("<DBMessage")) {
fl1314 = acceptor.lAccept_DBMessage(ctxt, "</DBMessage>");
appendMessages(fl1314);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Messsages>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1325;
bool fl1326;
bool fl1327;
bool fl1328;
bool fl1329;
bool fl1330;
bool fl1331;
bool fl1332;
bool fl1333;
bool fl1334;
bool fl1335;
bool fl1336;
bool fl1337;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1325 = false ; 
fl1326 = false ; 
fl1327 = false ; 
fl1328 = false ; 
fl1329 = false ; 
fl1330 = false ; 
fl1331 = false ; 
fl1332 = false ; 
fl1333 = false ; 
fl1334 = false ; 
fl1335 = false ; 
fl1336 = false ; 
fl1337 = true ; 
while (fl1337) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1336;
} else {
indicator = 1338;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslat")){
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("onRequired=")){
indicator = 1332;
} else {
indicator = 1338;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 1333;
} else {
indicator = 1338;
} // If
break;
} // Case
default:
indicator = 1338;
break;
} // Switch
} else {
indicator = 1338;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("S_Order=")){
indicator = 1325;
} else {
indicator = 1338;
} // If
break;
} // Case
default:
indicator = 1338;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1334;
} else {
indicator = 1338;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAhead3('o','d','e')){
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead3('U','T','=')){
indicator = 1331;
} else {
indicator = 1338;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('N','=')){
indicator = 1330;
} else {
indicator = 1338;
} // If
break;
} // Case
default:
indicator = 1338;
break;
} // Switch
} else {
indicator = 1338;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("evel")){
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead3('U','T','=')){
indicator = 1329;
} else {
indicator = 1338;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('N','=')){
indicator = 1328;
} else {
indicator = 1338;
} // If
break;
} // Case
default:
indicator = 1338;
break;
} // Switch
} else {
indicator = 1338;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('O','=')){
indicator = 1327;
} else {
indicator = 1338;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1335;
} else {
indicator = 1338;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("istance=")){
indicator = 1326;
} else {
indicator = 1338;
} // If
break;
} // Case
default:
indicator = 1338;
break;
} // Switch
switch (indicator) {
case 1325: {
// Handling attribute TCS_Order
// Also handles alien attributes with prefix TCS_Order
if (fl1325){
ctxt.fail ("Duplicate attribute: TCS_Order");
} // If
fl1325 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTCS_Order(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1326: {
// Handling attribute Distance
// Also handles alien attributes with prefix Distance
if (fl1326){
ctxt.fail ("Duplicate attribute: Distance");
} // If
fl1326 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDistance(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1327: {
// Handling attribute IO
// Also handles alien attributes with prefix IO
if (fl1327){
ctxt.fail ("Duplicate attribute: IO");
} // If
fl1327 = true ; 
quoteChar = ctxt.acceptQuote();
this.setIO(acceptor.lAcceptEnum_ST_IO(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1328: {
// Handling attribute LevelIN
// Also handles alien attributes with prefix LevelIN
if (fl1328){
ctxt.fail ("Duplicate attribute: LevelIN");
} // If
fl1328 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLevelIN(acceptor.lAcceptEnum_ST_LEVEL(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1329: {
// Handling attribute LevelOUT
// Also handles alien attributes with prefix LevelOUT
if (fl1329){
ctxt.fail ("Duplicate attribute: LevelOUT");
} // If
fl1329 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLevelOUT(acceptor.lAcceptEnum_ST_LEVEL(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1330: {
// Handling attribute ModeIN
// Also handles alien attributes with prefix ModeIN
if (fl1330){
ctxt.fail ("Duplicate attribute: ModeIN");
} // If
fl1330 = true ; 
quoteChar = ctxt.acceptQuote();
this.setModeIN(acceptor.lAcceptEnum_ST_MODE(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1331: {
// Handling attribute ModeOUT
// Also handles alien attributes with prefix ModeOUT
if (fl1331){
ctxt.fail ("Duplicate attribute: ModeOUT");
} // If
fl1331 = true ; 
quoteChar = ctxt.acceptQuote();
this.setModeOUT(acceptor.lAcceptEnum_ST_MODE(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1332: {
// Handling attribute TranslationRequired
// Also handles alien attributes with prefix TranslationRequired
if (fl1332){
ctxt.fail ("Duplicate attribute: TranslationRequired");
} // If
fl1332 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTranslationRequired(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1333: {
// Handling attribute Translated
// Also handles alien attributes with prefix Translated
if (fl1333){
ctxt.fail ("Duplicate attribute: Translated");
} // If
fl1333 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTranslated(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1334: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1334){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1334 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1335: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1335){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1335 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1336: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1336){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1336 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1338: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1325){
this.setTCS_Order(0);
} // If
if (!fl1326){
this.setDistance(0);
} // If
if (!fl1327){
this.setIO(acceptor.ST_IO.StIO_NA);
} // If
if (!fl1328){
this.setLevelIN(acceptor.ST_LEVEL.StLevel_NA);
} // If
if (!fl1329){
this.setLevelOUT(acceptor.ST_LEVEL.StLevel_NA);
} // If
if (!fl1330){
this.setModeIN(acceptor.ST_MODE.Mode_NA);
} // If
if (!fl1331){
this.setModeOUT(acceptor.ST_MODE.Mode_NA);
} // If
if (!fl1332){
this.setTranslationRequired( true);
} // If
if (!fl1333){
this.setTranslated( false);
} // If
fl1337 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Step";
  endingTag = "</Step>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Step\"");
} // If
pw.Write('\n');
if (this.getTCS_Order() != 0){
pw.Write(" TCS_Order=\"");
acceptor.unParsePcData(pw, this.getTCS_Order());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDistance() != 0){
pw.Write(" Distance=\"");
acceptor.unParsePcData(pw, this.getDistance());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getIO() != 0){
pw.Write(" IO=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_IO_ToString(this.getIO()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getLevelIN() != 0){
pw.Write(" LevelIN=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_LEVEL_ToString(this.getLevelIN()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getLevelOUT() != 0){
pw.Write(" LevelOUT=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_LEVEL_ToString(this.getLevelOUT()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getModeIN() != 0){
pw.Write(" ModeIN=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_MODE_ToString(this.getModeIN()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getModeOUT() != 0){
pw.Write(" ModeOUT=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_MODE_ToString(this.getModeOUT()));
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getTranslationRequired()){
pw.Write(" TranslationRequired=\"");
acceptor.unParsePcData(pw, this.getTranslationRequired());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getTranslated()){
pw.Write(" Translated=\"");
acceptor.unParsePcData(pw, this.getTranslated());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Description
if (this.getDescription() != null){
pw.Write("<Description>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getDescription());
pw.Write("</Description>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Description
// Unparsing Enclosed
// Testing for empty content: ObsoleteComment
if (this.getObsoleteComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getObsoleteComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: ObsoleteComment
// Unparsing Enclosed
// Testing for empty content: UserComment
if (this.getUserComment() != null){
pw.Write("<UserComment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getUserComment());
pw.Write("</UserComment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: UserComment
// Unparsing Enclosed
// Testing for empty content: SubSteps
if (countSubSteps() > 0){
pw.Write("<SubSteps>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSteps(), false, "<SubStep", "</SubStep>");
pw.Write("</SubSteps>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubSteps
// Unparsing Enclosed
// Testing for empty content: Messages
if (countMessages() > 0){
pw.Write("<Messsages>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getMessages(), false, "<DBMessage", "</DBMessage>");
pw.Write("</Messsages>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Messages
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSubSteps(); i++) {
  l.Add(getSubSteps(i));
}
for (int i = 0; i < countMessages(); i++) {
  l.Add(getMessages(i));
}
}

}
public partial class SubStep
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SubStepController.alertChange(aLock, this);
}
private System.Collections.ArrayList aActions;

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
public System.Collections.ArrayList allActions()
  {
if (aActions == null){
    setAllActions( new System.Collections.ArrayList() );
} // If
    return aActions;
  }

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
private System.Collections.ArrayList getActions()
  {
    return allActions();
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Actions's current content.</param>
public void setAllActions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
    NotifyControllers(null);
  }
public void setAllActions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="el">a Action to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(System.Collections.IList)"/>
public void appendActions(Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendActions(Lock aLock,Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection ofActions to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(Action)"/>
public void appendActions(System.Collections.IList coll)
  {
  __setDirty(true);
  allActions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendActions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allActions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This insertion function inserts a new element in the
/// collection in Actions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertActions(int idx, Action el)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertActions(int idx, Action el,Lock aLock)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfActions(IXmlBBase el)
  {
  return ((System.Collections.IList) allActions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteActions(int idx)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteActions(int idx,Lock aLock)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeActions(IXmlBBase obj)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(null);
   }
  }

public void removeActions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Actions</summary>
/// <returns>the number of elements in Actions</returns>
public int countActions()
  {
  return allActions().Count;
  }

/// <summary>Part of the list interface for Actions
/// This function returns an element from the
/// collection in Actions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Action getActions(int idx)
{
  return (Action) ( allActions()[idx]);
}

private System.Collections.ArrayList aExpectations;

/// <summary>Part of the list interface for Expectations</summary>
/// <returns>a collection of all the elements in Expectations</returns>
public System.Collections.ArrayList allExpectations()
  {
if (aExpectations == null){
    setAllExpectations( new System.Collections.ArrayList() );
} // If
    return aExpectations;
  }

/// <summary>Part of the list interface for Expectations</summary>
/// <returns>a collection of all the elements in Expectations</returns>
private System.Collections.ArrayList getExpectations()
  {
    return allExpectations();
  }

/// <summary>Part of the list interface for Expectations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Expectations's current content.</param>
public void setAllExpectations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aExpectations = coll;
    NotifyControllers(null);
  }
public void setAllExpectations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aExpectations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations</summary>
/// <param name="el">a Expectation to add to the collection in 
///           Expectations</param>
/// <seealso cref="appendExpectations(System.Collections.IList)"/>
public void appendExpectations(Expectation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allExpectations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendExpectations(Lock aLock,Expectation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allExpectations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Expectations</summary>
/// <param name="coll">a collection ofExpectations to add to the collection in 
///           Expectations</param>
/// <seealso cref="appendExpectations(Expectation)"/>
public void appendExpectations(System.Collections.IList coll)
  {
  __setDirty(true);
  allExpectations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendExpectations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allExpectations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations
/// This insertion function inserts a new element in the
/// collection in Expectations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertExpectations(int idx, Expectation el)
  {
  __setDirty(true);
  allExpectations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertExpectations(int idx, Expectation el,Lock aLock)
  {
  __setDirty(true);
  allExpectations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfExpectations(IXmlBBase el)
  {
  return ((System.Collections.IList) allExpectations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Expectations
/// This deletion function removes an element from the
/// collection in Expectations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteExpectations(int idx)
  {
  __setDirty(true);
  allExpectations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteExpectations(int idx,Lock aLock)
  {
  __setDirty(true);
  allExpectations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations
/// This deletion function removes an element from the
/// collection in Expectations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeExpectations(IXmlBBase obj)
  {
  int idx = indexOfExpectations(obj);
  if (idx >= 0) { deleteExpectations(idx);
NotifyControllers(null);
   }
  }

public void removeExpectations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfExpectations(obj);
  if (idx >= 0) { deleteExpectations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Expectations</summary>
/// <returns>the number of elements in Expectations</returns>
public int countExpectations()
  {
  return allExpectations().Count;
  }

/// <summary>Part of the list interface for Expectations
/// This function returns an element from the
/// collection in Expectations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Expectation getExpectations(int idx)
{
  return (Expectation) ( allExpectations()[idx]);
}

private  bool aSkipEngine;

public  bool getSkipEngine() { return aSkipEngine;}

public  void setSkipEngine(bool v) {
  aSkipEngine = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public SubStep()
{
SubStep obj = this;
aActions=(null);
aExpectations=(null);
aSkipEngine=(false);
aComment=(null);
}

public void copyTo(SubStep other)
{
base.copyTo(other);
other.aActions = aActions;
other.aExpectations = aExpectations;
other.aSkipEngine = aSkipEngine;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1356;
bool fl1357;
Action fl1359;
bool fl1370;
Expectation fl1372;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1356 = true ; 
while (fl1356) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1356 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Actions")){
ctxt.skipWhiteSpace();
fl1357 = true ; 
while (fl1357) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1357 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1359 = null;
while(ctxt.lookAheadOpeningTag ("<Action")) {
fl1359 = acceptor.lAccept_Action(ctxt, "</Action>");
appendActions(fl1359);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Actions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Expectations")){
ctxt.skipWhiteSpace();
fl1370 = true ; 
while (fl1370) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1370 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1372 = null;
while(ctxt.lookAheadOpeningTag ("<Expectation")) {
fl1372 = acceptor.lAccept_Expectation(ctxt, "</Expectation>");
appendExpectations(fl1372);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Expectations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1383;
bool fl1384;
bool fl1385;
bool fl1386;
bool fl1387;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1383 = false ; 
fl1384 = false ; 
fl1385 = false ; 
fl1386 = false ; 
fl1387 = true ; 
while (fl1387) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1386;
} else {
indicator = 1388;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
if (ctxt.lookAheadString("kipEngine=")){
indicator = 1383;
} else {
indicator = 1388;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1384;
} else {
indicator = 1388;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1385;
} else {
indicator = 1388;
} // If
break;
} // Case
default:
indicator = 1388;
break;
} // Switch
switch (indicator) {
case 1383: {
// Handling attribute SkipEngine
// Also handles alien attributes with prefix SkipEngine
if (fl1383){
ctxt.fail ("Duplicate attribute: SkipEngine");
} // If
fl1383 = true ; 
quoteChar = ctxt.acceptQuote();
this.setSkipEngine(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1384: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1384){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1384 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1385: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1385){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1385 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1386: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1386){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1386 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1388: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1383){
this.setSkipEngine( false);
} // If
fl1387 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SubStep";
  endingTag = "</SubStep>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SubStep\"");
} // If
pw.Write('\n');
if (this.getSkipEngine()){
pw.Write(" SkipEngine=\"");
acceptor.unParsePcData(pw, this.getSkipEngine());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: Actions
if (countActions() > 0){
pw.Write("<Actions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getActions(), false, "<Action", "</Action>");
pw.Write("</Actions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Actions
// Unparsing Enclosed
// Testing for empty content: Expectations
if (countExpectations() > 0){
pw.Write("<Expectations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getExpectations(), false, "<Expectation", "</Expectation>");
pw.Write("</Expectations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Expectations
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countActions(); i++) {
  l.Add(getActions(i));
}
for (int i = 0; i < countExpectations(); i++) {
  l.Add(getExpectations(i));
}
}

}
public partial class Expectation
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
if(getCondition().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ExpectationController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aBlocking;

public  bool getBlocking() { return aBlocking;}

public  void setBlocking(bool v) {
  aBlocking = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.ExpectationKind aKind;

public  acceptor.ExpectationKind getKind() { return aKind;}

public  void setKind(acceptor.ExpectationKind v) {
  aKind = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getKind_AsString()
{
  return acceptor.Enum_ExpectationKind_ToString (aKind);
}

public  bool setKind_AsString( string  v)
{
 acceptor.ExpectationKind  temp = acceptor.StringTo_Enum_ExpectationKind(v);
if (temp >= 0){
  aKind = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  double aDeadLine;

public  double getDeadLine() { return aDeadLine;}

public  void setDeadLine(double v) {
  aDeadLine = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aCondition;

public   string  getCondition() { return aCondition;}

public  void setCondition( string  v) {
  aCondition = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.RulePriority aCyclePhase;

public  acceptor.RulePriority getCyclePhase() { return aCyclePhase;}

public  void setCyclePhase(acceptor.RulePriority v) {
  aCyclePhase = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getCyclePhase_AsString()
{
  return acceptor.Enum_RulePriority_ToString (aCyclePhase);
}

public  bool setCyclePhase_AsString( string  v)
{
 acceptor.RulePriority  temp = acceptor.StringTo_Enum_RulePriority(v);
if (temp >= 0){
  aCyclePhase = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public Expectation()
{
Expectation obj = this;
aValue=(null);
aBlocking=(false);
aKind=(0);
aDeadLine=(0.0);
aCondition=(null);
aComment=(null);
aCyclePhase=(0);
}

public void copyTo(Expectation other)
{
base.copyTo(other);
other.aValue = aValue;
other.aBlocking = aBlocking;
other.aKind = aKind;
other.aDeadLine = aDeadLine;
other.aCondition = aCondition;
other.aComment = aComment;
other.aCyclePhase = aCyclePhase;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1394;
bool fl1395;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1394 = true ; 
while (fl1394) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1394 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Condition")){
ctxt.skipWhiteSpace();
fl1395 = true ; 
while (fl1395) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1395 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setCondition(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Condition>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1396;
bool fl1397;
bool fl1398;
bool fl1399;
bool fl1400;
bool fl1401;
bool fl1402;
bool fl1403;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1396 = false ; 
fl1397 = false ; 
fl1398 = false ; 
fl1399 = false ; 
fl1400 = false ; 
fl1401 = false ; 
fl1402 = false ; 
fl1403 = true ; 
while (fl1403) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1402;
} else {
indicator = 1404;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1400;
} else {
indicator = 1404;
} // If
break;
} // Case
case 'K':
{
ctxt.advance();
if (ctxt.lookAheadString("ind=")){
indicator = 1396;
} else {
indicator = 1404;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1401;
} else {
indicator = 1404;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("eadLine=")){
indicator = 1398;
} else {
indicator = 1404;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("yclePhase=")){
indicator = 1399;
} else {
indicator = 1404;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
if (ctxt.lookAheadString("locking=")){
indicator = 1397;
} else {
indicator = 1404;
} // If
break;
} // Case
default:
indicator = 1404;
break;
} // Switch
switch (indicator) {
case 1396: {
// Handling attribute Kind
// Also handles alien attributes with prefix Kind
if (fl1396){
ctxt.fail ("Duplicate attribute: Kind");
} // If
fl1396 = true ; 
quoteChar = ctxt.acceptQuote();
this.setKind(acceptor.lAcceptEnum_ExpectationKind(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1397: {
// Handling attribute Blocking
// Also handles alien attributes with prefix Blocking
if (fl1397){
ctxt.fail ("Duplicate attribute: Blocking");
} // If
fl1397 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBlocking(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1398: {
// Handling attribute DeadLine
// Also handles alien attributes with prefix DeadLine
if (fl1398){
ctxt.fail ("Duplicate attribute: DeadLine");
} // If
fl1398 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDeadLine(ctxt.fetchDouble());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1399: {
// Handling attribute CyclePhase
// Also handles alien attributes with prefix CyclePhase
if (fl1399){
ctxt.fail ("Duplicate attribute: CyclePhase");
} // If
fl1399 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCyclePhase(acceptor.lAcceptEnum_RulePriority(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1400: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1400){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1400 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1401: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1401){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1401 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1402: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1402){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1402 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1404: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1396){
this.setKind(acceptor.ExpectationKind.aInstantaneous);
} // If
if (!fl1397){
this.setBlocking( true);
} // If
if (!fl1398){
this.setDeadLine(0.0);
} // If
fl1403 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Expectation";
  endingTag = "</Expectation>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Expectation\"");
} // If
pw.Write('\n');
if (this.getKind() != 0){
pw.Write(" Kind=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ExpectationKind_ToString(this.getKind()));
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getBlocking()){
pw.Write(" Blocking=\"");
acceptor.unParsePcData(pw, this.getBlocking());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDeadLine() != 0){
pw.Write(" DeadLine=\"");
acceptor.unParsePcData(pw, this.getDeadLine());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getCyclePhase() != 0){
pw.Write(" CyclePhase=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_RulePriority_ToString(this.getCyclePhase()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
// Unparsing Enclosed
// Testing for empty content: Condition
if (this.getCondition() != null){
pw.Write("<Condition>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getCondition());
pw.Write("</Condition>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Condition
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class DBMessage
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DBMessageController.alertChange(aLock, this);
}
private  int aMessageOrder;

public  int getMessageOrder() { return aMessageOrder;}

public  void setMessageOrder(int v) {
  aMessageOrder = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.DBMessageType aMessageType;

public  acceptor.DBMessageType getMessageType() { return aMessageType;}

public  void setMessageType(acceptor.DBMessageType v) {
  aMessageType = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMessageType_AsString()
{
  return acceptor.Enum_DBMessageType_ToString (aMessageType);
}

public  bool setMessageType_AsString( string  v)
{
 acceptor.DBMessageType  temp = acceptor.StringTo_Enum_DBMessageType(v);
if (temp >= 0){
  aMessageType = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aFields;

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
public System.Collections.ArrayList allFields()
  {
if (aFields == null){
    setAllFields( new System.Collections.ArrayList() );
} // If
    return aFields;
  }

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
private System.Collections.ArrayList getFields()
  {
    return allFields();
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection of elements which replaces 
///        Fields's current content.</param>
public void setAllFields(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
    NotifyControllers(null);
  }
public void setAllFields(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="el">a DBField to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(System.Collections.IList)"/>
public void appendFields(DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFields(Lock aLock,DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection ofDBFields to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(DBField)"/>
public void appendFields(System.Collections.IList coll)
  {
  __setDirty(true);
  allFields().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFields(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFields().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This insertion function inserts a new element in the
/// collection in Fields</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFields(int idx, DBField el)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFields(int idx, DBField el,Lock aLock)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFields(IXmlBBase el)
  {
  return ((System.Collections.IList) allFields()).IndexOf (el);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFields(int idx)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFields(int idx,Lock aLock)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFields(IXmlBBase obj)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(null);
   }
  }

public void removeFields(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Fields</summary>
/// <returns>the number of elements in Fields</returns>
public int countFields()
  {
  return allFields().Count;
  }

/// <summary>Part of the list interface for Fields
/// This function returns an element from the
/// collection in Fields based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBField getFields(int idx)
{
  return (DBField) ( allFields()[idx]);
}

private System.Collections.ArrayList aPackets;

/// <summary>Part of the list interface for Packets</summary>
/// <returns>a collection of all the elements in Packets</returns>
public System.Collections.ArrayList allPackets()
  {
if (aPackets == null){
    setAllPackets( new System.Collections.ArrayList() );
} // If
    return aPackets;
  }

/// <summary>Part of the list interface for Packets</summary>
/// <returns>a collection of all the elements in Packets</returns>
private System.Collections.ArrayList getPackets()
  {
    return allPackets();
  }

/// <summary>Part of the list interface for Packets</summary>
/// <param name="coll">a collection of elements which replaces 
///        Packets's current content.</param>
public void setAllPackets(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPackets = coll;
    NotifyControllers(null);
  }
public void setAllPackets(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPackets = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets</summary>
/// <param name="el">a DBPacket to add to the collection in 
///           Packets</param>
/// <seealso cref="appendPackets(System.Collections.IList)"/>
public void appendPackets(DBPacket el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPackets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendPackets(Lock aLock,DBPacket el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPackets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Packets</summary>
/// <param name="coll">a collection ofDBPackets to add to the collection in 
///           Packets</param>
/// <seealso cref="appendPackets(DBPacket)"/>
public void appendPackets(System.Collections.IList coll)
  {
  __setDirty(true);
  allPackets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendPackets(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allPackets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets
/// This insertion function inserts a new element in the
/// collection in Packets</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertPackets(int idx, DBPacket el)
  {
  __setDirty(true);
  allPackets().Insert (idx, el);
NotifyControllers(null);
  }

public void insertPackets(int idx, DBPacket el,Lock aLock)
  {
  __setDirty(true);
  allPackets().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfPackets(IXmlBBase el)
  {
  return ((System.Collections.IList) allPackets()).IndexOf (el);
  }

/// <summary>Part of the list interface for Packets
/// This deletion function removes an element from the
/// collection in Packets</summary>
/// <param name="idx">the index of the element to remove</param>
public void deletePackets(int idx)
  {
  __setDirty(true);
  allPackets().RemoveAt(idx);
NotifyControllers(null);
  }

public void deletePackets(int idx,Lock aLock)
  {
  __setDirty(true);
  allPackets().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets
/// This deletion function removes an element from the
/// collection in Packets
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removePackets(IXmlBBase obj)
  {
  int idx = indexOfPackets(obj);
  if (idx >= 0) { deletePackets(idx);
NotifyControllers(null);
   }
  }

public void removePackets(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfPackets(obj);
  if (idx >= 0) { deletePackets(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Packets</summary>
/// <returns>the number of elements in Packets</returns>
public int countPackets()
  {
  return allPackets().Count;
  }

/// <summary>Part of the list interface for Packets
/// This function returns an element from the
/// collection in Packets based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBPacket getPackets(int idx)
{
  return (DBPacket) ( allPackets()[idx]);
}

public DBMessage()
{
DBMessage obj = this;
aMessageOrder=(0);
aMessageType=(0);
aFields=(null);
aPackets=(null);
}

public void copyTo(DBMessage other)
{
base.copyTo(other);
other.aMessageOrder = aMessageOrder;
other.aMessageType = aMessageType;
other.aFields = aFields;
other.aPackets = aPackets;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1413;
DBField fl1415;
bool fl1426;
DBPacket fl1428;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Fields")){
ctxt.skipWhiteSpace();
fl1413 = true ; 
while (fl1413) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1413 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1415 = null;
while(ctxt.lookAheadOpeningTag ("<DBField")) {
fl1415 = acceptor.lAccept_DBField(ctxt, "</DBField>");
appendFields(fl1415);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Fields>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Packets")){
ctxt.skipWhiteSpace();
fl1426 = true ; 
while (fl1426) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1426 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1428 = null;
while(ctxt.lookAheadOpeningTag ("<DBPacket")) {
fl1428 = acceptor.lAccept_DBPacket(ctxt, "</DBPacket>");
appendPackets(fl1428);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Packets>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1439;
bool fl1440;
bool fl1441;
bool fl1442;
bool fl1443;
bool fl1444;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1439 = false ; 
fl1440 = false ; 
fl1441 = false ; 
fl1442 = false ; 
fl1443 = false ; 
fl1444 = true ; 
while (fl1444) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1443;
} else {
indicator = 1445;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1441;
} else {
indicator = 1445;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("essage")){
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 1440;
} else {
indicator = 1445;
} // If
break;
} // Case
case 'O':
{
ctxt.advance();
if (ctxt.lookAheadString("rder=")){
indicator = 1439;
} else {
indicator = 1445;
} // If
break;
} // Case
default:
indicator = 1445;
break;
} // Switch
} else {
indicator = 1445;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1442;
} else {
indicator = 1445;
} // If
break;
} // Case
default:
indicator = 1445;
break;
} // Switch
switch (indicator) {
case 1439: {
// Handling attribute MessageOrder
// Also handles alien attributes with prefix MessageOrder
if (fl1439){
ctxt.fail ("Duplicate attribute: MessageOrder");
} // If
fl1439 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMessageOrder(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1440: {
// Handling attribute MessageType
// Also handles alien attributes with prefix MessageType
if (fl1440){
ctxt.fail ("Duplicate attribute: MessageType");
} // If
fl1440 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMessageType(acceptor.lAcceptEnum_DBMessageType(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1441: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1441){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1441 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1442: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1442){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1442 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1443: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1443){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1443 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1445: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1439){
this.setMessageOrder(0);
} // If
if (!fl1440){
this.setMessageType(acceptor.DBMessageType.aEUROBALISE);
} // If
fl1444 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<DBMessage";
  endingTag = "</DBMessage>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"DBMessage\"");
} // If
pw.Write('\n');
if (this.getMessageOrder() != 0){
pw.Write(" MessageOrder=\"");
acceptor.unParsePcData(pw, this.getMessageOrder());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMessageType() != 0){
pw.Write(" MessageType=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_DBMessageType_ToString(this.getMessageType()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Fields
if (countFields() > 0){
pw.Write("<Fields>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFields(), false, "<DBField", "</DBField>");
pw.Write("</Fields>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Fields
// Unparsing Enclosed
// Testing for empty content: Packets
if (countPackets() > 0){
pw.Write("<Packets>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getPackets(), false, "<DBPacket", "</DBPacket>");
pw.Write("</Packets>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Packets
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFields(); i++) {
  l.Add(getFields(i));
}
for (int i = 0; i < countPackets(); i++) {
  l.Add(getPackets(i));
}
}

}
public partial class DBPacket
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DBPacketController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFields;

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
public System.Collections.ArrayList allFields()
  {
if (aFields == null){
    setAllFields( new System.Collections.ArrayList() );
} // If
    return aFields;
  }

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
private System.Collections.ArrayList getFields()
  {
    return allFields();
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection of elements which replaces 
///        Fields's current content.</param>
public void setAllFields(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
    NotifyControllers(null);
  }
public void setAllFields(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="el">a DBField to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(System.Collections.IList)"/>
public void appendFields(DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFields(Lock aLock,DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection ofDBFields to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(DBField)"/>
public void appendFields(System.Collections.IList coll)
  {
  __setDirty(true);
  allFields().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFields(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFields().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This insertion function inserts a new element in the
/// collection in Fields</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFields(int idx, DBField el)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFields(int idx, DBField el,Lock aLock)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFields(IXmlBBase el)
  {
  return ((System.Collections.IList) allFields()).IndexOf (el);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFields(int idx)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFields(int idx,Lock aLock)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFields(IXmlBBase obj)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(null);
   }
  }

public void removeFields(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Fields</summary>
/// <returns>the number of elements in Fields</returns>
public int countFields()
  {
  return allFields().Count;
  }

/// <summary>Part of the list interface for Fields
/// This function returns an element from the
/// collection in Fields based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBField getFields(int idx)
{
  return (DBField) ( allFields()[idx]);
}

public DBPacket()
{
DBPacket obj = this;
aFields=(null);
}

public void copyTo(DBPacket other)
{
base.copyTo(other);
other.aFields = aFields;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1453;
DBField fl1455;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Fields")){
ctxt.skipWhiteSpace();
fl1453 = true ; 
while (fl1453) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1453 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1455 = null;
while(ctxt.lookAheadOpeningTag ("<DBField")) {
fl1455 = acceptor.lAccept_DBField(ctxt, "</DBField>");
appendFields(fl1455);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Fields>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1466;
bool fl1467;
bool fl1468;
bool fl1469;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1466 = false ; 
fl1467 = false ; 
fl1468 = false ; 
fl1469 = true ; 
while (fl1469) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1468;
} else {
indicator = 1470;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1466;
} else {
indicator = 1470;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1467;
} else {
indicator = 1470;
} // If
break;
} // Case
default:
indicator = 1470;
break;
} // Switch
switch (indicator) {
case 1466: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1466){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1466 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1467: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1467){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1467 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1468: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1468){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1468 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1470: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1469 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<DBPacket";
  endingTag = "</DBPacket>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"DBPacket\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Fields
if (countFields() > 0){
pw.Write("<Fields>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFields(), false, "<DBField", "</DBField>");
pw.Write("</Fields>");
// No formula father defined
pw.Write('\n');
} // If
// After Testing for empty content: Fields
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFields(); i++) {
  l.Add(getFields(i));
}
}

}
public partial class DBField
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getVariable().CompareTo((String) search) == 0)return true;
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DBFieldController.alertChange(aLock, this);
}
private   string  aVariable;

public   string  getVariable() { return aVariable;}

public  void setVariable( string  v) {
  aVariable = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public DBField()
{
DBField obj = this;
aVariable=(null);
aValue=(null);
}

public void copyTo(DBField other)
{
base.copyTo(other);
other.aVariable = aVariable;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1475;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Variable")){
ctxt.skipWhiteSpace();
fl1475 = true ; 
while (fl1475) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1475 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setVariable(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Variable>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1476;
bool fl1477;
bool fl1478;
bool fl1479;
bool fl1480;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1476 = false ; 
fl1477 = false ; 
fl1478 = false ; 
fl1479 = false ; 
fl1480 = true ; 
while (fl1480) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue=")){
indicator = 1476;
} else {
indicator = 1481;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1479;
} else {
indicator = 1481;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1477;
} else {
indicator = 1481;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1478;
} else {
indicator = 1481;
} // If
break;
} // Case
default:
indicator = 1481;
break;
} // Switch
switch (indicator) {
case 1476: {
// Handling attribute Value
// Also handles alien attributes with prefix Value
if (fl1476){
ctxt.fail ("Duplicate attribute: Value");
} // If
fl1476 = true ; 
quoteChar = ctxt.acceptQuote();
this.setValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1477: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1477){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1477 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1478: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1478){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1478 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1479: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1479){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1479 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1481: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1476){
this.setValue("");
} // If
fl1480 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<DBField";
  endingTag = "</DBField>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"DBField\"");
} // If
pw.Write('\n');
if (this.getValue() != null){
pw.Write(" Value=\"");
acceptor.unParsePcData(pw, this.getValue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Variable
if (this.getVariable() != null){
pw.Write("<Variable>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getVariable());
pw.Write("</Variable>");
// No formula father defined
pw.Write('\n');
} // If
// After Testing for empty content: Variable
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class TranslationDictionary
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TranslationDictionaryController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a Folder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(Folder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, Folder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, Folder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Folder getFolders(int idx)
{
  return (Folder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aTranslations;

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
public System.Collections.ArrayList allTranslations()
  {
if (aTranslations == null){
    setAllTranslations( new System.Collections.ArrayList() );
} // If
    return aTranslations;
  }

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
private System.Collections.ArrayList getTranslations()
  {
    return allTranslations();
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Translations's current content.</param>
public void setAllTranslations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
    NotifyControllers(null);
  }
public void setAllTranslations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="el">a Translation to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(System.Collections.IList)"/>
public void appendTranslations(Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTranslations(Lock aLock,Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection ofTranslations to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(Translation)"/>
public void appendTranslations(System.Collections.IList coll)
  {
  __setDirty(true);
  allTranslations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTranslations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTranslations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This insertion function inserts a new element in the
/// collection in Translations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTranslations(int idx, Translation el)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTranslations(int idx, Translation el,Lock aLock)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTranslations(IXmlBBase el)
  {
  return ((System.Collections.IList) allTranslations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTranslations(int idx)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTranslations(int idx,Lock aLock)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTranslations(IXmlBBase obj)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(null);
   }
  }

public void removeTranslations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Translations</summary>
/// <returns>the number of elements in Translations</returns>
public int countTranslations()
  {
  return allTranslations().Count;
  }

/// <summary>Part of the list interface for Translations
/// This function returns an element from the
/// collection in Translations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Translation getTranslations(int idx)
{
  return (Translation) ( allTranslations()[idx]);
}

public TranslationDictionary()
{
TranslationDictionary obj = this;
aFolders=(null);
aTranslations=(null);
}

public void copyTo(TranslationDictionary other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aTranslations = aTranslations;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1487;
Folder fl1489;
bool fl1500;
Translation fl1502;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1487 = true ; 
while (fl1487) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1487 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1489 = null;
while(ctxt.lookAheadOpeningTag ("<Folder")) {
fl1489 = acceptor.lAccept_Folder(ctxt, "</Folder>");
appendFolders(fl1489);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Translations")){
ctxt.skipWhiteSpace();
fl1500 = true ; 
while (fl1500) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1500 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1502 = null;
while(ctxt.lookAheadOpeningTag ("<Translation")) {
fl1502 = acceptor.lAccept_Translation(ctxt, "</Translation>");
appendTranslations(fl1502);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Translations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1513;
bool fl1514;
bool fl1515;
bool fl1516;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1513 = false ; 
fl1514 = false ; 
fl1515 = false ; 
fl1516 = true ; 
while (fl1516) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1515;
} else {
indicator = 1517;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1513;
} else {
indicator = 1517;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1514;
} else {
indicator = 1517;
} // If
break;
} // Case
default:
indicator = 1517;
break;
} // Switch
switch (indicator) {
case 1513: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1513){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1513 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1514: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1514){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1514 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1515: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1515){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1515 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1517: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1516 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<TranslationDictionary";
  endingTag = "</TranslationDictionary>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"TranslationDictionary\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<Folder", "</Folder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Translations
if (countTranslations() > 0){
pw.Write("<Translations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTranslations(), false, "<Translation", "</Translation>");
pw.Write("</Translations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Translations
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countTranslations(); i++) {
  l.Add(getTranslations(i));
}
}

}
public partial class Folder
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FolderController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a Folder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(Folder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, Folder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, Folder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Folder getFolders(int idx)
{
  return (Folder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aTranslations;

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
public System.Collections.ArrayList allTranslations()
  {
if (aTranslations == null){
    setAllTranslations( new System.Collections.ArrayList() );
} // If
    return aTranslations;
  }

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
private System.Collections.ArrayList getTranslations()
  {
    return allTranslations();
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Translations's current content.</param>
public void setAllTranslations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
    NotifyControllers(null);
  }
public void setAllTranslations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="el">a Translation to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(System.Collections.IList)"/>
public void appendTranslations(Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTranslations(Lock aLock,Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection ofTranslations to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(Translation)"/>
public void appendTranslations(System.Collections.IList coll)
  {
  __setDirty(true);
  allTranslations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTranslations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTranslations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This insertion function inserts a new element in the
/// collection in Translations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTranslations(int idx, Translation el)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTranslations(int idx, Translation el,Lock aLock)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTranslations(IXmlBBase el)
  {
  return ((System.Collections.IList) allTranslations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTranslations(int idx)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTranslations(int idx,Lock aLock)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTranslations(IXmlBBase obj)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(null);
   }
  }

public void removeTranslations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Translations</summary>
/// <returns>the number of elements in Translations</returns>
public int countTranslations()
  {
  return allTranslations().Count;
  }

/// <summary>Part of the list interface for Translations
/// This function returns an element from the
/// collection in Translations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Translation getTranslations(int idx)
{
  return (Translation) ( allTranslations()[idx]);
}

public Folder()
{
Folder obj = this;
aFolders=(null);
aTranslations=(null);
}

public void copyTo(Folder other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aTranslations = aTranslations;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1522;
Folder fl1524;
bool fl1535;
Translation fl1537;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1522 = true ; 
while (fl1522) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1522 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1524 = null;
while(ctxt.lookAheadOpeningTag ("<Folder")) {
fl1524 = acceptor.lAccept_Folder(ctxt, "</Folder>");
appendFolders(fl1524);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Translations")){
ctxt.skipWhiteSpace();
fl1535 = true ; 
while (fl1535) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1535 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1537 = null;
while(ctxt.lookAheadOpeningTag ("<Translation")) {
fl1537 = acceptor.lAccept_Translation(ctxt, "</Translation>");
appendTranslations(fl1537);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Translations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1548;
bool fl1549;
bool fl1550;
bool fl1551;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1548 = false ; 
fl1549 = false ; 
fl1550 = false ; 
fl1551 = true ; 
while (fl1551) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1550;
} else {
indicator = 1552;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1548;
} else {
indicator = 1552;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1549;
} else {
indicator = 1552;
} // If
break;
} // Case
default:
indicator = 1552;
break;
} // Switch
switch (indicator) {
case 1548: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1548){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1548 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1549: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1549){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1549 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1550: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1550){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1550 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1552: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1551 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Folder";
  endingTag = "</Folder>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Folder\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<Folder", "</Folder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Translations
if (countTranslations() > 0){
pw.Write("<Translations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTranslations(), false, "<Translation", "</Translation>");
pw.Write("</Translations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Translations
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countTranslations(); i++) {
  l.Add(getTranslations(i));
}
}

}
public partial class Translation
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
if(getObsoleteComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TranslationController.alertChange(aLock, this);
}
private System.Collections.ArrayList aSourceTexts;

/// <summary>Part of the list interface for SourceTexts</summary>
/// <returns>a collection of all the elements in SourceTexts</returns>
public System.Collections.ArrayList allSourceTexts()
  {
if (aSourceTexts == null){
    setAllSourceTexts( new System.Collections.ArrayList() );
} // If
    return aSourceTexts;
  }

/// <summary>Part of the list interface for SourceTexts</summary>
/// <returns>a collection of all the elements in SourceTexts</returns>
private System.Collections.ArrayList getSourceTexts()
  {
    return allSourceTexts();
  }

/// <summary>Part of the list interface for SourceTexts</summary>
/// <param name="coll">a collection of elements which replaces 
///        SourceTexts's current content.</param>
public void setAllSourceTexts(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSourceTexts = coll;
    NotifyControllers(null);
  }
public void setAllSourceTexts(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSourceTexts = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts</summary>
/// <param name="el">a SourceText to add to the collection in 
///           SourceTexts</param>
/// <seealso cref="appendSourceTexts(System.Collections.IList)"/>
public void appendSourceTexts(SourceText el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSourceTexts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSourceTexts(Lock aLock,SourceText el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSourceTexts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SourceTexts</summary>
/// <param name="coll">a collection ofSourceTexts to add to the collection in 
///           SourceTexts</param>
/// <seealso cref="appendSourceTexts(SourceText)"/>
public void appendSourceTexts(System.Collections.IList coll)
  {
  __setDirty(true);
  allSourceTexts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSourceTexts(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSourceTexts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts
/// This insertion function inserts a new element in the
/// collection in SourceTexts</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSourceTexts(int idx, SourceText el)
  {
  __setDirty(true);
  allSourceTexts().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSourceTexts(int idx, SourceText el,Lock aLock)
  {
  __setDirty(true);
  allSourceTexts().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSourceTexts(IXmlBBase el)
  {
  return ((System.Collections.IList) allSourceTexts()).IndexOf (el);
  }

/// <summary>Part of the list interface for SourceTexts
/// This deletion function removes an element from the
/// collection in SourceTexts</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSourceTexts(int idx)
  {
  __setDirty(true);
  allSourceTexts().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSourceTexts(int idx,Lock aLock)
  {
  __setDirty(true);
  allSourceTexts().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts
/// This deletion function removes an element from the
/// collection in SourceTexts
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSourceTexts(IXmlBBase obj)
  {
  int idx = indexOfSourceTexts(obj);
  if (idx >= 0) { deleteSourceTexts(idx);
NotifyControllers(null);
   }
  }

public void removeSourceTexts(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSourceTexts(obj);
  if (idx >= 0) { deleteSourceTexts(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SourceTexts</summary>
/// <returns>the number of elements in SourceTexts</returns>
public int countSourceTexts()
  {
  return allSourceTexts().Count;
  }

/// <summary>Part of the list interface for SourceTexts
/// This function returns an element from the
/// collection in SourceTexts based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SourceText getSourceTexts(int idx)
{
  return (SourceText) ( allSourceTexts()[idx]);
}

private   string  aObsoleteComment;

public   string  getObsoleteComment() { return aObsoleteComment;}

public  void setObsoleteComment( string  v) {
  aObsoleteComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aImplemented;

public  bool getImplemented() { return aImplemented;}

public  void setImplemented(bool v) {
  aImplemented = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSubSteps;

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
public System.Collections.ArrayList allSubSteps()
  {
if (aSubSteps == null){
    setAllSubSteps( new System.Collections.ArrayList() );
} // If
    return aSubSteps;
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
private System.Collections.ArrayList getSubSteps()
  {
    return allSubSteps();
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSteps's current content.</param>
public void setAllSubSteps(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
    NotifyControllers(null);
  }
public void setAllSubSteps(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="el">a SubStep to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(System.Collections.IList)"/>
public void appendSubSteps(SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSteps(Lock aLock,SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection ofSubSteps to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(SubStep)"/>
public void appendSubSteps(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSteps(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This insertion function inserts a new element in the
/// collection in SubSteps</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSteps(int idx, SubStep el)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSteps(int idx, SubStep el,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSteps(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSteps()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSteps(int idx)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSteps(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSteps(IXmlBBase obj)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(null);
   }
  }

public void removeSubSteps(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>the number of elements in SubSteps</returns>
public int countSubSteps()
  {
  return allSubSteps().Count;
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns an element from the
/// collection in SubSteps based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SubStep getSubSteps(int idx)
{
  return (SubStep) ( allSubSteps()[idx]);
}

public Translation()
{
Translation obj = this;
aSourceTexts=(null);
aObsoleteComment=(null);
aImplemented=(false);
aSubSteps=(null);
}

public void copyTo(Translation other)
{
base.copyTo(other);
other.aSourceTexts = aSourceTexts;
other.aObsoleteComment = aObsoleteComment;
other.aImplemented = aImplemented;
other.aSubSteps = aSubSteps;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1557;
SourceText fl1559;
bool fl1570;
SubStep fl1572;
bool fl1583;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SourceTexts")){
ctxt.skipWhiteSpace();
fl1557 = true ; 
while (fl1557) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1557 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1559 = null;
while(ctxt.lookAheadOpeningTag ("<SourceText")) {
fl1559 = acceptor.lAccept_SourceText(ctxt, "</SourceText>");
appendSourceTexts(fl1559);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SourceTexts>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubSteps")){
ctxt.skipWhiteSpace();
fl1570 = true ; 
while (fl1570) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1570 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1572 = null;
while(ctxt.lookAheadOpeningTag ("<SubStep")) {
fl1572 = acceptor.lAccept_SubStep(ctxt, "</SubStep>");
appendSubSteps(fl1572);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSteps>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1583 = true ; 
while (fl1583) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1583 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setObsoleteComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1584;
bool fl1585;
bool fl1586;
bool fl1587;
bool fl1588;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1584 = false ; 
fl1585 = false ; 
fl1586 = false ; 
fl1587 = false ; 
fl1588 = true ; 
while (fl1588) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1587;
} else {
indicator = 1589;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1585;
} else {
indicator = 1589;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1584;
} else {
indicator = 1589;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1586;
} else {
indicator = 1589;
} // If
break;
} // Case
default:
indicator = 1589;
break;
} // Switch
switch (indicator) {
case 1584: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1584){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1584 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1585: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1585){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1585 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1586: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1586){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1586 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1587: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1587){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1587 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1589: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1584){
this.setImplemented( false);
} // If
fl1588 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Translation";
  endingTag = "</Translation>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Translation\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: SourceTexts
if (countSourceTexts() > 0){
pw.Write("<SourceTexts>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSourceTexts(), false, "<SourceText", "</SourceText>");
pw.Write("</SourceTexts>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SourceTexts
// Unparsing Enclosed
// Testing for empty content: SubSteps
if (countSubSteps() > 0){
pw.Write("<SubSteps>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSteps(), false, "<SubStep", "</SubStep>");
pw.Write("</SubSteps>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubSteps
// Unparsing Enclosed
// Testing for empty content: ObsoleteComment
if (this.getObsoleteComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getObsoleteComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: ObsoleteComment
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSourceTexts(); i++) {
  l.Add(getSourceTexts(i));
}
for (int i = 0; i < countSubSteps(); i++) {
  l.Add(getSubSteps(i));
}
}

}
public partial class SourceText
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SourceTextController.alertChange(aLock, this);
}
private System.Collections.ArrayList aComments;

/// <summary>Part of the list interface for Comments</summary>
/// <returns>a collection of all the elements in Comments</returns>
public System.Collections.ArrayList allComments()
  {
if (aComments == null){
    setAllComments( new System.Collections.ArrayList() );
} // If
    return aComments;
  }

/// <summary>Part of the list interface for Comments</summary>
/// <returns>a collection of all the elements in Comments</returns>
private System.Collections.ArrayList getComments()
  {
    return allComments();
  }

/// <summary>Part of the list interface for Comments</summary>
/// <param name="coll">a collection of elements which replaces 
///        Comments's current content.</param>
public void setAllComments(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aComments = coll;
    NotifyControllers(null);
  }
public void setAllComments(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aComments = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Comments</summary>
/// <param name="el">a SourceTextComment to add to the collection in 
///           Comments</param>
/// <seealso cref="appendComments(System.Collections.IList)"/>
public void appendComments(SourceTextComment el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allComments().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendComments(Lock aLock,SourceTextComment el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allComments().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Comments</summary>
/// <param name="coll">a collection ofSourceTextComments to add to the collection in 
///           Comments</param>
/// <seealso cref="appendComments(SourceTextComment)"/>
public void appendComments(System.Collections.IList coll)
  {
  __setDirty(true);
  allComments().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendComments(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allComments().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Comments
/// This insertion function inserts a new element in the
/// collection in Comments</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertComments(int idx, SourceTextComment el)
  {
  __setDirty(true);
  allComments().Insert (idx, el);
NotifyControllers(null);
  }

public void insertComments(int idx, SourceTextComment el,Lock aLock)
  {
  __setDirty(true);
  allComments().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Comments
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfComments(IXmlBBase el)
  {
  return ((System.Collections.IList) allComments()).IndexOf (el);
  }

/// <summary>Part of the list interface for Comments
/// This deletion function removes an element from the
/// collection in Comments</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteComments(int idx)
  {
  __setDirty(true);
  allComments().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteComments(int idx,Lock aLock)
  {
  __setDirty(true);
  allComments().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Comments
/// This deletion function removes an element from the
/// collection in Comments
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeComments(IXmlBBase obj)
  {
  int idx = indexOfComments(obj);
  if (idx >= 0) { deleteComments(idx);
NotifyControllers(null);
   }
  }

public void removeComments(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfComments(obj);
  if (idx >= 0) { deleteComments(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Comments</summary>
/// <returns>the number of elements in Comments</returns>
public int countComments()
  {
  return allComments().Count;
  }

/// <summary>Part of the list interface for Comments
/// This function returns an element from the
/// collection in Comments based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SourceTextComment getComments(int idx)
{
  return (SourceTextComment) ( allComments()[idx]);
}

public SourceText()
{
SourceText obj = this;
aComments=(null);
}

public void copyTo(SourceText other)
{
base.copyTo(other);
other.aComments = aComments;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1595;
SourceTextComment fl1597;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comments")){
ctxt.skipWhiteSpace();
fl1595 = true ; 
while (fl1595) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1595 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1597 = null;
while(ctxt.lookAheadOpeningTag ("<SourceTextComment")) {
fl1597 = acceptor.lAccept_SourceTextComment(ctxt, "</SourceTextComment>");
appendComments(fl1597);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comments>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1608;
bool fl1609;
bool fl1610;
bool fl1611;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1608 = false ; 
fl1609 = false ; 
fl1610 = false ; 
fl1611 = true ; 
while (fl1611) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1610;
} else {
indicator = 1612;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1608;
} else {
indicator = 1612;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1609;
} else {
indicator = 1612;
} // If
break;
} // Case
default:
indicator = 1612;
break;
} // Switch
switch (indicator) {
case 1608: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1608){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1608 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1609: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1609){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1609 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1610: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1610){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1610 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1612: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1611 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SourceText";
  endingTag = "</SourceText>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SourceText\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comments
if (countComments() > 0){
pw.Write("<Comments>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getComments(), false, "<SourceTextComment", "</SourceTextComment>");
pw.Write("</Comments>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comments
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countComments(); i++) {
  l.Add(getComments(i));
}
}

}
public partial class SourceTextComment
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SourceTextCommentController.alertChange(aLock, this);
}
public SourceTextComment()
{
SourceTextComment obj = this;
}

public void copyTo(SourceTextComment other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1617;
bool fl1618;
bool fl1619;
bool fl1620;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1617 = false ; 
fl1618 = false ; 
fl1619 = false ; 
fl1620 = true ; 
while (fl1620) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1619;
} else {
indicator = 1621;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1617;
} else {
indicator = 1621;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1618;
} else {
indicator = 1621;
} // If
break;
} // Case
default:
indicator = 1621;
break;
} // Switch
switch (indicator) {
case 1617: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1617){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1617 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1618: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1618){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1618 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1619: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1619){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1619 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1621: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1620 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SourceTextComment";
  endingTag = "</SourceTextComment>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SourceTextComment\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class ShortcutDictionary
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ShortcutDictionaryController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a ShortcutFolder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofShortcutFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(ShortcutFolder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, ShortcutFolder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, ShortcutFolder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ShortcutFolder getFolders(int idx)
{
  return (ShortcutFolder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aShortcuts;

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
public System.Collections.ArrayList allShortcuts()
  {
if (aShortcuts == null){
    setAllShortcuts( new System.Collections.ArrayList() );
} // If
    return aShortcuts;
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
private System.Collections.ArrayList getShortcuts()
  {
    return allShortcuts();
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection of elements which replaces 
///        Shortcuts's current content.</param>
public void setAllShortcuts(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
    NotifyControllers(null);
  }
public void setAllShortcuts(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="el">a Shortcut to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(System.Collections.IList)"/>
public void appendShortcuts(Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendShortcuts(Lock aLock,Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection ofShortcuts to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(Shortcut)"/>
public void appendShortcuts(System.Collections.IList coll)
  {
  __setDirty(true);
  allShortcuts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendShortcuts(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This insertion function inserts a new element in the
/// collection in Shortcuts</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertShortcuts(int idx, Shortcut el)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(null);
  }

public void insertShortcuts(int idx, Shortcut el,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfShortcuts(IXmlBBase el)
  {
  return ((System.Collections.IList) allShortcuts()).IndexOf (el);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteShortcuts(int idx)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteShortcuts(int idx,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeShortcuts(IXmlBBase obj)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(null);
   }
  }

public void removeShortcuts(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>the number of elements in Shortcuts</returns>
public int countShortcuts()
  {
  return allShortcuts().Count;
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns an element from the
/// collection in Shortcuts based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Shortcut getShortcuts(int idx)
{
  return (Shortcut) ( allShortcuts()[idx]);
}

public ShortcutDictionary()
{
ShortcutDictionary obj = this;
aFolders=(null);
aShortcuts=(null);
}

public void copyTo(ShortcutDictionary other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aShortcuts = aShortcuts;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1626;
ShortcutFolder fl1628;
bool fl1639;
Shortcut fl1641;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1626 = true ; 
while (fl1626) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1626 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1628 = null;
while(ctxt.lookAheadOpeningTag ("<ShortcutFolder")) {
fl1628 = acceptor.lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
appendFolders(fl1628);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Shortcuts")){
ctxt.skipWhiteSpace();
fl1639 = true ; 
while (fl1639) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1639 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1641 = null;
while(ctxt.lookAheadOpeningTag ("<Shortcut")) {
fl1641 = acceptor.lAccept_Shortcut(ctxt, "</Shortcut>");
appendShortcuts(fl1641);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Shortcuts>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1652;
bool fl1653;
bool fl1654;
bool fl1655;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1652 = false ; 
fl1653 = false ; 
fl1654 = false ; 
fl1655 = true ; 
while (fl1655) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1654;
} else {
indicator = 1656;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1652;
} else {
indicator = 1656;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1653;
} else {
indicator = 1656;
} // If
break;
} // Case
default:
indicator = 1656;
break;
} // Switch
switch (indicator) {
case 1652: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1652){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1652 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1653: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1653){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1653 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1654: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1654){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1654 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1656: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1655 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ShortcutDictionary";
  endingTag = "</ShortcutDictionary>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ShortcutDictionary\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<ShortcutFolder", "</ShortcutFolder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Shortcuts
if (countShortcuts() > 0){
pw.Write("<Shortcuts>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getShortcuts(), false, "<Shortcut", "</Shortcut>");
pw.Write("</Shortcuts>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Shortcuts
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countShortcuts(); i++) {
  l.Add(getShortcuts(i));
}
}

}
public partial class ShortcutFolder
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ShortcutFolderController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a ShortcutFolder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofShortcutFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(ShortcutFolder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, ShortcutFolder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, ShortcutFolder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ShortcutFolder getFolders(int idx)
{
  return (ShortcutFolder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aShortcuts;

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
public System.Collections.ArrayList allShortcuts()
  {
if (aShortcuts == null){
    setAllShortcuts( new System.Collections.ArrayList() );
} // If
    return aShortcuts;
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
private System.Collections.ArrayList getShortcuts()
  {
    return allShortcuts();
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection of elements which replaces 
///        Shortcuts's current content.</param>
public void setAllShortcuts(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
    NotifyControllers(null);
  }
public void setAllShortcuts(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="el">a Shortcut to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(System.Collections.IList)"/>
public void appendShortcuts(Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendShortcuts(Lock aLock,Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection ofShortcuts to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(Shortcut)"/>
public void appendShortcuts(System.Collections.IList coll)
  {
  __setDirty(true);
  allShortcuts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendShortcuts(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This insertion function inserts a new element in the
/// collection in Shortcuts</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertShortcuts(int idx, Shortcut el)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(null);
  }

public void insertShortcuts(int idx, Shortcut el,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfShortcuts(IXmlBBase el)
  {
  return ((System.Collections.IList) allShortcuts()).IndexOf (el);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteShortcuts(int idx)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteShortcuts(int idx,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeShortcuts(IXmlBBase obj)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(null);
   }
  }

public void removeShortcuts(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>the number of elements in Shortcuts</returns>
public int countShortcuts()
  {
  return allShortcuts().Count;
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns an element from the
/// collection in Shortcuts based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Shortcut getShortcuts(int idx)
{
  return (Shortcut) ( allShortcuts()[idx]);
}

public ShortcutFolder()
{
ShortcutFolder obj = this;
aFolders=(null);
aShortcuts=(null);
}

public void copyTo(ShortcutFolder other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aShortcuts = aShortcuts;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1661;
ShortcutFolder fl1663;
bool fl1674;
Shortcut fl1676;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1661 = true ; 
while (fl1661) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1661 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1663 = null;
while(ctxt.lookAheadOpeningTag ("<ShortcutFolder")) {
fl1663 = acceptor.lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
appendFolders(fl1663);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Shortcuts")){
ctxt.skipWhiteSpace();
fl1674 = true ; 
while (fl1674) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1674 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1676 = null;
while(ctxt.lookAheadOpeningTag ("<Shortcut")) {
fl1676 = acceptor.lAccept_Shortcut(ctxt, "</Shortcut>");
appendShortcuts(fl1676);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Shortcuts>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1687;
bool fl1688;
bool fl1689;
bool fl1690;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1687 = false ; 
fl1688 = false ; 
fl1689 = false ; 
fl1690 = true ; 
while (fl1690) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1689;
} else {
indicator = 1691;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1687;
} else {
indicator = 1691;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1688;
} else {
indicator = 1691;
} // If
break;
} // Case
default:
indicator = 1691;
break;
} // Switch
switch (indicator) {
case 1687: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1687){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1687 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1688: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1688){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1688 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1689: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1689){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1689 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1691: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1690 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ShortcutFolder";
  endingTag = "</ShortcutFolder>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ShortcutFolder\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<ShortcutFolder", "</ShortcutFolder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Shortcuts
if (countShortcuts() > 0){
pw.Write("<Shortcuts>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getShortcuts(), false, "<Shortcut", "</Shortcut>");
pw.Write("</Shortcuts>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Shortcuts
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countShortcuts(); i++) {
  l.Add(getShortcuts(i));
}
}

}
public partial class Shortcut
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getShortcutName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ShortcutController.alertChange(aLock, this);
}
private   string  aShortcutName;

public   string  getShortcutName() { return aShortcutName;}

public  void setShortcutName( string  v) {
  aShortcutName = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Shortcut()
{
Shortcut obj = this;
aShortcutName=(null);
}

public void copyTo(Shortcut other)
{
base.copyTo(other);
other.aShortcutName = aShortcutName;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1696;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<ShortcutName")){
ctxt.skipWhiteSpace();
fl1696 = true ; 
while (fl1696) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1696 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setShortcutName(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</ShortcutName>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1697;
bool fl1698;
bool fl1699;
bool fl1700;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1697 = false ; 
fl1698 = false ; 
fl1699 = false ; 
fl1700 = true ; 
while (fl1700) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1699;
} else {
indicator = 1701;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1697;
} else {
indicator = 1701;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1698;
} else {
indicator = 1701;
} // If
break;
} // Case
default:
indicator = 1701;
break;
} // Switch
switch (indicator) {
case 1697: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1697){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1697 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1698: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1698){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1698 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1699: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1699){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1699 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1701: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1700 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Shortcut";
  endingTag = "</Shortcut>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Shortcut\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: ShortcutName
if (this.getShortcutName() != null){
pw.Write("<ShortcutName>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getShortcutName());
pw.Write("</ShortcutName>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: ShortcutName
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class RequirementSet
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RequirementSetController.alertChange(aLock, this);
}
private System.Collections.ArrayList aDependancies;

/// <summary>Part of the list interface for Dependancies</summary>
/// <returns>a collection of all the elements in Dependancies</returns>
public System.Collections.ArrayList allDependancies()
  {
if (aDependancies == null){
    setAllDependancies( new System.Collections.ArrayList() );
} // If
    return aDependancies;
  }

/// <summary>Part of the list interface for Dependancies</summary>
/// <returns>a collection of all the elements in Dependancies</returns>
private System.Collections.ArrayList getDependancies()
  {
    return allDependancies();
  }

/// <summary>Part of the list interface for Dependancies</summary>
/// <param name="coll">a collection of elements which replaces 
///        Dependancies's current content.</param>
public void setAllDependancies(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aDependancies = coll;
    NotifyControllers(null);
  }
public void setAllDependancies(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aDependancies = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Dependancies</summary>
/// <param name="el">a RequirementSetDependancy to add to the collection in 
///           Dependancies</param>
/// <seealso cref="appendDependancies(System.Collections.IList)"/>
public void appendDependancies(RequirementSetDependancy el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allDependancies().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendDependancies(Lock aLock,RequirementSetDependancy el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allDependancies().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Dependancies</summary>
/// <param name="coll">a collection ofRequirementSetDependancys to add to the collection in 
///           Dependancies</param>
/// <seealso cref="appendDependancies(RequirementSetDependancy)"/>
public void appendDependancies(System.Collections.IList coll)
  {
  __setDirty(true);
  allDependancies().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendDependancies(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allDependancies().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Dependancies
/// This insertion function inserts a new element in the
/// collection in Dependancies</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertDependancies(int idx, RequirementSetDependancy el)
  {
  __setDirty(true);
  allDependancies().Insert (idx, el);
NotifyControllers(null);
  }

public void insertDependancies(int idx, RequirementSetDependancy el,Lock aLock)
  {
  __setDirty(true);
  allDependancies().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Dependancies
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfDependancies(IXmlBBase el)
  {
  return ((System.Collections.IList) allDependancies()).IndexOf (el);
  }

/// <summary>Part of the list interface for Dependancies
/// This deletion function removes an element from the
/// collection in Dependancies</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteDependancies(int idx)
  {
  __setDirty(true);
  allDependancies().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteDependancies(int idx,Lock aLock)
  {
  __setDirty(true);
  allDependancies().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Dependancies
/// This deletion function removes an element from the
/// collection in Dependancies
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeDependancies(IXmlBBase obj)
  {
  int idx = indexOfDependancies(obj);
  if (idx >= 0) { deleteDependancies(idx);
NotifyControllers(null);
   }
  }

public void removeDependancies(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfDependancies(obj);
  if (idx >= 0) { deleteDependancies(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Dependancies</summary>
/// <returns>the number of elements in Dependancies</returns>
public int countDependancies()
  {
  return allDependancies().Count;
  }

/// <summary>Part of the list interface for Dependancies
/// This function returns an element from the
/// collection in Dependancies based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RequirementSetDependancy getDependancies(int idx)
{
  return (RequirementSetDependancy) ( allDependancies()[idx]);
}

private System.Collections.ArrayList aSubSets;

/// <summary>Part of the list interface for SubSets</summary>
/// <returns>a collection of all the elements in SubSets</returns>
public System.Collections.ArrayList allSubSets()
  {
if (aSubSets == null){
    setAllSubSets( new System.Collections.ArrayList() );
} // If
    return aSubSets;
  }

/// <summary>Part of the list interface for SubSets</summary>
/// <returns>a collection of all the elements in SubSets</returns>
private System.Collections.ArrayList getSubSets()
  {
    return allSubSets();
  }

/// <summary>Part of the list interface for SubSets</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSets's current content.</param>
public void setAllSubSets(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSets = coll;
    NotifyControllers(null);
  }
public void setAllSubSets(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSets = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSets</summary>
/// <param name="el">a RequirementSet to add to the collection in 
///           SubSets</param>
/// <seealso cref="appendSubSets(System.Collections.IList)"/>
public void appendSubSets(RequirementSet el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSets(Lock aLock,RequirementSet el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSets</summary>
/// <param name="coll">a collection ofRequirementSets to add to the collection in 
///           SubSets</param>
/// <seealso cref="appendSubSets(RequirementSet)"/>
public void appendSubSets(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSets(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSets
/// This insertion function inserts a new element in the
/// collection in SubSets</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSets(int idx, RequirementSet el)
  {
  __setDirty(true);
  allSubSets().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSets(int idx, RequirementSet el,Lock aLock)
  {
  __setDirty(true);
  allSubSets().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSets
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSets(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSets()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSets
/// This deletion function removes an element from the
/// collection in SubSets</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSets(int idx)
  {
  __setDirty(true);
  allSubSets().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSets(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSets().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSets
/// This deletion function removes an element from the
/// collection in SubSets
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSets(IXmlBBase obj)
  {
  int idx = indexOfSubSets(obj);
  if (idx >= 0) { deleteSubSets(idx);
NotifyControllers(null);
   }
  }

public void removeSubSets(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSets(obj);
  if (idx >= 0) { deleteSubSets(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSets</summary>
/// <returns>the number of elements in SubSets</returns>
public int countSubSets()
  {
  return allSubSets().Count;
  }

/// <summary>Part of the list interface for SubSets
/// This function returns an element from the
/// collection in SubSets based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RequirementSet getSubSets(int idx)
{
  return (RequirementSet) ( allSubSets()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aRecursiveSelection;

public  bool getRecursiveSelection() { return aRecursiveSelection;}

public  void setRecursiveSelection(bool v) {
  aRecursiveSelection = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.SPEC_IMPLEMENTED_ENUM aObsoleteRequirementsStatus;

public  acceptor.SPEC_IMPLEMENTED_ENUM getObsoleteRequirementsStatus() { return aObsoleteRequirementsStatus;}

public  void setObsoleteRequirementsStatus(acceptor.SPEC_IMPLEMENTED_ENUM v) {
  aObsoleteRequirementsStatus = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getObsoleteRequirementsStatus_AsString()
{
  return acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString (aObsoleteRequirementsStatus);
}

public  bool setObsoleteRequirementsStatus_AsString( string  v)
{
 acceptor.SPEC_IMPLEMENTED_ENUM  temp = acceptor.StringTo_Enum_SPEC_IMPLEMENTED_ENUM(v);
if (temp >= 0){
  aObsoleteRequirementsStatus = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  bool aDefault;

public  bool getDefault() { return aDefault;}

public  void setDefault(bool v) {
  aDefault = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public RequirementSet()
{
RequirementSet obj = this;
aDependancies=(null);
aSubSets=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aRecursiveSelection=(false);
aObsoleteRequirementsStatus=(0);
aDefault=(false);
aPinned=(false);
}

public void copyTo(RequirementSet other)
{
base.copyTo(other);
other.aDependancies = aDependancies;
other.aSubSets = aSubSets;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aRecursiveSelection = aRecursiveSelection;
other.aObsoleteRequirementsStatus = aObsoleteRequirementsStatus;
other.aDefault = aDefault;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1706;
RequirementSetDependancy fl1708;
bool fl1719;
RequirementSet fl1721;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<Dependancies");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl1706 = true ; 
while (fl1706) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1706 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1708 = null;
while(ctxt.lookAheadOpeningTag ("<RequirementSetDependancy")) {
fl1708 = acceptor.lAccept_RequirementSetDependancy(ctxt, "</RequirementSetDependancy>");
appendDependancies(fl1708);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Dependancies>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<SubSets");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl1719 = true ; 
while (fl1719) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1719 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1721 = null;
while(ctxt.lookAheadOpeningTag ("<RequirementSet")) {
fl1721 = acceptor.lAccept_RequirementSet(ctxt, "</RequirementSet>");
appendSubSets(fl1721);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSets>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1732;
bool fl1733;
bool fl1734;
bool fl1735;
bool fl1736;
bool fl1737;
bool fl1738;
bool fl1739;
bool fl1740;
bool fl1741;
bool fl1742;
bool fl1743;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1732 = false ; 
fl1733 = false ; 
fl1734 = false ; 
fl1735 = false ; 
fl1736 = false ; 
fl1737 = false ; 
fl1738 = false ; 
fl1739 = false ; 
fl1740 = false ; 
fl1741 = false ; 
fl1742 = false ; 
fl1743 = true ; 
while (fl1743) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1733;
} else {
indicator = 1744;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1732;
} else {
indicator = 1744;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 1734;
} else {
indicator = 1744;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1742;
} else {
indicator = 1744;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead1('e')){
switch (ctxt.current()) {
case 'q':
{
ctxt.advance();
if (ctxt.lookAheadString("uirementsStatus=")){
indicator = 1737;
} else {
indicator = 1744;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("ursiveSelection=")){
indicator = 1736;
} else {
indicator = 1744;
} // If
break;
} // Case
default:
indicator = 1744;
break;
} // Switch
} else {
indicator = 1744;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 1739;
} else {
indicator = 1744;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1740;
} else {
indicator = 1744;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
if (ctxt.lookAheadString("eight=")){
indicator = 1735;
} else {
indicator = 1744;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1741;
} else {
indicator = 1744;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 1738;
} else {
indicator = 1744;
} // If
break;
} // Case
default:
indicator = 1744;
break;
} // Switch
switch (indicator) {
case 1732: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl1732){
ctxt.fail ("Duplicate attribute: X");
} // If
fl1732 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1733: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl1733){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl1733 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1734: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl1734){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl1734 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1735: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl1735){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl1735 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1736: {
// Handling attribute RecursiveSelection
// Also handles alien attributes with prefix RecursiveSelection
if (fl1736){
ctxt.fail ("Duplicate attribute: RecursiveSelection");
} // If
fl1736 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRecursiveSelection(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1737: {
// Handling attribute RequirementsStatus
// Also handles alien attributes with prefix RequirementsStatus
if (fl1737){
ctxt.fail ("Duplicate attribute: RequirementsStatus");
} // If
fl1737 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteRequirementsStatus(acceptor.lAcceptEnum_SPEC_IMPLEMENTED_ENUM(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1738: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl1738){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl1738 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1739: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl1739){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl1739 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1740: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1740){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1740 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1741: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1741){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1741 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1742: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1742){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1742 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1744: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1732){
this.setX(0);
} // If
if (!fl1733){
this.setY(0);
} // If
if (!fl1734){
this.setWidth(0);
} // If
if (!fl1735){
this.setHeight(0);
} // If
if (!fl1736){
this.setRecursiveSelection( false);
} // If
if (!fl1738){
this.setDefault( false);
} // If
if (!fl1739){
this.setPinned( false);
} // If
fl1743 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RequirementSet";
  endingTag = "</RequirementSet>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RequirementSet\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getRecursiveSelection()){
pw.Write(" RecursiveSelection=\"");
acceptor.unParsePcData(pw, this.getRecursiveSelection());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteRequirementsStatus() != 0){
pw.Write(" RequirementsStatus=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString(this.getObsoleteRequirementsStatus()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault()){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
pw.Write("<Dependancies>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getDependancies(), false, "<RequirementSetDependancy", "</RequirementSetDependancy>");
pw.Write("</Dependancies>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<SubSets>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSets(), false, "<RequirementSet", "</RequirementSet>");
pw.Write("</SubSets>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countDependancies(); i++) {
  l.Add(getDependancies(i));
}
for (int i = 0; i < countSubSets(); i++) {
  l.Add(getSubSets(i));
}
}

}
public partial class RequirementSetDependancy
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getTarget().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RequirementSetDependancyController.alertChange(aLock, this);
}
private   string  aTarget;

public   string  getTarget() { return aTarget;}

public  void setTarget( string  v) {
  aTarget = v;
  __setDirty(true);
  NotifyControllers(null);
}


public RequirementSetDependancy()
{
RequirementSetDependancy obj = this;
aTarget=(null);
}

public void copyTo(RequirementSetDependancy other)
{
base.copyTo(other);
other.aTarget = aTarget;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1758;
bool fl1759;
bool fl1760;
bool fl1761;
bool fl1762;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1758 = false ; 
fl1759 = false ; 
fl1760 = false ; 
fl1761 = false ; 
fl1762 = true ; 
while (fl1762) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1761;
} else {
indicator = 1763;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("arget=")){
indicator = 1758;
} else {
indicator = 1763;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1759;
} else {
indicator = 1763;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1760;
} else {
indicator = 1763;
} // If
break;
} // Case
default:
indicator = 1763;
break;
} // Switch
switch (indicator) {
case 1758: {
// Handling attribute Target
// Also handles alien attributes with prefix Target
if (fl1758){
ctxt.fail ("Duplicate attribute: Target");
} // If
fl1758 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTarget((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1759: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1759){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1759 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1760: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1760){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1760 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1761: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1761){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1761 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1763: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1758){
ctxt.fail ("Mandatory attribute missing: Target in RequirementSetDependancy");
} // If
fl1762 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RequirementSetDependancy";
  endingTag = "</RequirementSetDependancy>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RequirementSetDependancy\"");
} // If
pw.Write('\n');
pw.Write(" Target=\"");
acceptor.unParsePcData(pw, this.getTarget());
pw.Write('"');
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Specification
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getVersion().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SpecificationController.alertChange(aLock, this);
}
private   string  aVersion;

public   string  getVersion() { return aVersion;}

public  void setVersion( string  v) {
  aVersion = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aChapters;

/// <summary>Part of the list interface for Chapters</summary>
/// <returns>a collection of all the elements in Chapters</returns>
public System.Collections.ArrayList allChapters()
  {
if (aChapters == null){
    setAllChapters( new System.Collections.ArrayList() );
} // If
    return aChapters;
  }

/// <summary>Part of the list interface for Chapters</summary>
/// <returns>a collection of all the elements in Chapters</returns>
private System.Collections.ArrayList getChapters()
  {
    return allChapters();
  }

/// <summary>Part of the list interface for Chapters</summary>
/// <param name="coll">a collection of elements which replaces 
///        Chapters's current content.</param>
public void setAllChapters(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapters = coll;
    NotifyControllers(null);
  }
public void setAllChapters(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapters = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters</summary>
/// <param name="el">a Chapter to add to the collection in 
///           Chapters</param>
/// <seealso cref="appendChapters(System.Collections.IList)"/>
public void appendChapters(Chapter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendChapters(Lock aLock,Chapter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Chapters</summary>
/// <param name="coll">a collection ofChapters to add to the collection in 
///           Chapters</param>
/// <seealso cref="appendChapters(Chapter)"/>
public void appendChapters(System.Collections.IList coll)
  {
  __setDirty(true);
  allChapters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendChapters(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allChapters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters
/// This insertion function inserts a new element in the
/// collection in Chapters</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertChapters(int idx, Chapter el)
  {
  __setDirty(true);
  allChapters().Insert (idx, el);
NotifyControllers(null);
  }

public void insertChapters(int idx, Chapter el,Lock aLock)
  {
  __setDirty(true);
  allChapters().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfChapters(IXmlBBase el)
  {
  return ((System.Collections.IList) allChapters()).IndexOf (el);
  }

/// <summary>Part of the list interface for Chapters
/// This deletion function removes an element from the
/// collection in Chapters</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteChapters(int idx)
  {
  __setDirty(true);
  allChapters().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteChapters(int idx,Lock aLock)
  {
  __setDirty(true);
  allChapters().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters
/// This deletion function removes an element from the
/// collection in Chapters
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeChapters(IXmlBBase obj)
  {
  int idx = indexOfChapters(obj);
  if (idx >= 0) { deleteChapters(idx);
NotifyControllers(null);
   }
  }

public void removeChapters(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfChapters(obj);
  if (idx >= 0) { deleteChapters(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Chapters</summary>
/// <returns>the number of elements in Chapters</returns>
public int countChapters()
  {
  return allChapters().Count;
  }

/// <summary>Part of the list interface for Chapters
/// This function returns an element from the
/// collection in Chapters based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Chapter getChapters(int idx)
{
  return (Chapter) ( allChapters()[idx]);
}

private System.Collections.ArrayList aChapterRefs;

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <returns>a collection of all the elements in ChapterRefs</returns>
public System.Collections.ArrayList allChapterRefs()
  {
if (aChapterRefs == null){
    setAllChapterRefs( new System.Collections.ArrayList() );
} // If
    return aChapterRefs;
  }

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <returns>a collection of all the elements in ChapterRefs</returns>
private System.Collections.ArrayList getChapterRefs()
  {
    return allChapterRefs();
  }

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        ChapterRefs's current content.</param>
public void setAllChapterRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapterRefs = coll;
    NotifyControllers(null);
  }
public void setAllChapterRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapterRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <param name="el">a ChapterRef to add to the collection in 
///           ChapterRefs</param>
/// <seealso cref="appendChapterRefs(System.Collections.IList)"/>
public void appendChapterRefs(ChapterRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapterRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendChapterRefs(Lock aLock,ChapterRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapterRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for ChapterRefs</summary>
/// <param name="coll">a collection ofChapterRefs to add to the collection in 
///           ChapterRefs</param>
/// <seealso cref="appendChapterRefs(ChapterRef)"/>
public void appendChapterRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allChapterRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendChapterRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allChapterRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This insertion function inserts a new element in the
/// collection in ChapterRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertChapterRefs(int idx, ChapterRef el)
  {
  __setDirty(true);
  allChapterRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertChapterRefs(int idx, ChapterRef el,Lock aLock)
  {
  __setDirty(true);
  allChapterRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfChapterRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allChapterRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This deletion function removes an element from the
/// collection in ChapterRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteChapterRefs(int idx)
  {
  __setDirty(true);
  allChapterRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteChapterRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allChapterRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This deletion function removes an element from the
/// collection in ChapterRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeChapterRefs(IXmlBBase obj)
  {
  int idx = indexOfChapterRefs(obj);
  if (idx >= 0) { deleteChapterRefs(idx);
NotifyControllers(null);
   }
  }

public void removeChapterRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfChapterRefs(obj);
  if (idx >= 0) { deleteChapterRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <returns>the number of elements in ChapterRefs</returns>
public int countChapterRefs()
  {
  return allChapterRefs().Count;
  }

/// <summary>Part of the list interface for ChapterRefs
/// This function returns an element from the
/// collection in ChapterRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ChapterRef getChapterRefs(int idx)
{
  return (ChapterRef) ( allChapterRefs()[idx]);
}

public Specification()
{
Specification obj = this;
aVersion=(null);
aChapters=(null);
aChapterRefs=(null);
}

public void copyTo(Specification other)
{
base.copyTo(other);
other.aVersion = aVersion;
other.aChapters = aChapters;
other.aChapterRefs = aChapterRefs;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
Chapter fl1770;
ChapterRef fl1782;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl1770 = null;
while(ctxt.lookAheadOpeningTag ("<Chapter")) {
fl1770 = acceptor.lAccept_Chapter(ctxt, "</Chapter>");
appendChapters(fl1770);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl1782 = null;
while(ctxt.lookAheadOpeningTag ("<ChapterRef")) {
fl1782 = acceptor.lAccept_ChapterRef(ctxt, "</ChapterRef>");
appendChapterRefs(fl1782);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1793;
bool fl1794;
bool fl1795;
bool fl1796;
bool fl1797;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1793 = false ; 
fl1794 = false ; 
fl1795 = false ; 
fl1796 = false ; 
fl1797 = true ; 
while (fl1797) { // BeginLoop 
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
if (ctxt.lookAheadString("ersion=")){
indicator = 1793;
} else {
indicator = 1798;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1796;
} else {
indicator = 1798;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1794;
} else {
indicator = 1798;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1795;
} else {
indicator = 1798;
} // If
break;
} // Case
default:
indicator = 1798;
break;
} // Switch
switch (indicator) {
case 1793: {
// Handling attribute version
// Also handles alien attributes with prefix version
if (fl1793){
ctxt.fail ("Duplicate attribute: version");
} // If
fl1793 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVersion((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1794: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1794){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1794 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1795: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1795){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1795 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1796: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1796){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1796 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1798: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1797 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Specification";
  endingTag = "</Specification>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Specification\"");
} // If
pw.Write('\n');
if (this.getVersion() != null){
pw.Write(" version=\"");
acceptor.unParsePcData(pw, this.getVersion());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getChapters(), false, "<Chapter", "</Chapter>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getChapterRefs(), false, "<ChapterRef", "</ChapterRef>");
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countChapters(); i++) {
  l.Add(getChapters(i));
}
for (int i = 0; i < countChapterRefs(); i++) {
  l.Add(getChapterRefs(i));
}
}

}
public partial class ChapterRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ChapterRefController.alertChange(aLock, this);
}
public ChapterRef()
{
ChapterRef obj = this;
}

public void copyTo(ChapterRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1804;
bool fl1805;
bool fl1806;
bool fl1807;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1804 = false ; 
fl1805 = false ; 
fl1806 = false ; 
fl1807 = true ; 
while (fl1807) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1806;
} else {
indicator = 1808;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1804;
} else {
indicator = 1808;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1805;
} else {
indicator = 1808;
} // If
break;
} // Case
default:
indicator = 1808;
break;
} // Switch
switch (indicator) {
case 1804: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1804){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1804 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1805: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1805){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1805 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1806: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1806){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1806 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1808: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1807 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ChapterRef";
  endingTag = "</ChapterRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ChapterRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Chapter
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getId().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ChapterController.alertChange(aLock, this);
}
private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aParagraphs;

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
public System.Collections.ArrayList allParagraphs()
  {
if (aParagraphs == null){
    setAllParagraphs( new System.Collections.ArrayList() );
} // If
    return aParagraphs;
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
private System.Collections.ArrayList getParagraphs()
  {
    return allParagraphs();
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection of elements which replaces 
///        Paragraphs's current content.</param>
public void setAllParagraphs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
    NotifyControllers(null);
  }
public void setAllParagraphs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="el">a Paragraph to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(System.Collections.IList)"/>
public void appendParagraphs(Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParagraphs(Lock aLock,Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection ofParagraphs to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(Paragraph)"/>
public void appendParagraphs(System.Collections.IList coll)
  {
  __setDirty(true);
  allParagraphs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParagraphs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This insertion function inserts a new element in the
/// collection in Paragraphs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParagraphs(int idx, Paragraph el)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParagraphs(int idx, Paragraph el,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParagraphs(IXmlBBase el)
  {
  return ((System.Collections.IList) allParagraphs()).IndexOf (el);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParagraphs(int idx)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParagraphs(int idx,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParagraphs(IXmlBBase obj)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(null);
   }
  }

public void removeParagraphs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>the number of elements in Paragraphs</returns>
public int countParagraphs()
  {
  return allParagraphs().Count;
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns an element from the
/// collection in Paragraphs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Paragraph getParagraphs(int idx)
{
  return (Paragraph) ( allParagraphs()[idx]);
}

private System.Collections.ArrayList aTypeSpecs;

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
public System.Collections.ArrayList allTypeSpecs()
  {
if (aTypeSpecs == null){
    setAllTypeSpecs( new System.Collections.ArrayList() );
} // If
    return aTypeSpecs;
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
private System.Collections.ArrayList getTypeSpecs()
  {
    return allTypeSpecs();
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection of elements which replaces 
///        TypeSpecs's current content.</param>
public void setAllTypeSpecs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
    NotifyControllers(null);
  }
public void setAllTypeSpecs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="el">a TypeSpec to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(System.Collections.IList)"/>
public void appendTypeSpecs(TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTypeSpecs(Lock aLock,TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection ofTypeSpecs to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(TypeSpec)"/>
public void appendTypeSpecs(System.Collections.IList coll)
  {
  __setDirty(true);
  allTypeSpecs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTypeSpecs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This insertion function inserts a new element in the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTypeSpecs(int idx, TypeSpec el)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTypeSpecs(int idx, TypeSpec el,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTypeSpecs(IXmlBBase el)
  {
  return ((System.Collections.IList) allTypeSpecs()).IndexOf (el);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTypeSpecs(int idx)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTypeSpecs(int idx,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTypeSpecs(IXmlBBase obj)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(null);
   }
  }

public void removeTypeSpecs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>the number of elements in TypeSpecs</returns>
public int countTypeSpecs()
  {
  return allTypeSpecs().Count;
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns an element from the
/// collection in TypeSpecs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public TypeSpec getTypeSpecs(int idx)
{
  return (TypeSpec) ( allTypeSpecs()[idx]);
}

public Chapter()
{
Chapter obj = this;
aId=(null);
aParagraphs=(null);
aTypeSpecs=(null);
}

public void copyTo(Chapter other)
{
base.copyTo(other);
other.aId = aId;
other.aParagraphs = aParagraphs;
other.aTypeSpecs = aTypeSpecs;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
Paragraph fl1814;
TypeSpec fl1826;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl1814 = null;
while(ctxt.lookAheadOpeningTag ("<Paragraph")) {
fl1814 = acceptor.lAccept_Paragraph(ctxt, "</Paragraph>");
appendParagraphs(fl1814);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl1826 = null;
while(ctxt.lookAheadOpeningTag ("<TypeSpec")) {
fl1826 = acceptor.lAccept_TypeSpec(ctxt, null);
appendTypeSpecs(fl1826);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1837;
bool fl1838;
bool fl1839;
bool fl1840;
bool fl1841;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1837 = false ; 
fl1838 = false ; 
fl1839 = false ; 
fl1840 = false ; 
fl1841 = true ; 
while (fl1841) { // BeginLoop 
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 1837;
} else {
indicator = 1842;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1840;
} else {
indicator = 1842;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1838;
} else {
indicator = 1842;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1839;
} else {
indicator = 1842;
} // If
break;
} // Case
default:
indicator = 1842;
break;
} // Switch
switch (indicator) {
case 1837: {
// Handling attribute id
// Also handles alien attributes with prefix id
if (fl1837){
ctxt.fail ("Duplicate attribute: id");
} // If
fl1837 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1838: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1838){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1838 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1839: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1839){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1839 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1840: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1840){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1840 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1842: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1837){
ctxt.fail ("Mandatory attribute missing: id in Chapter");
} // If
fl1841 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Chapter";
  endingTag = "</Chapter>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Chapter\"");
} // If
pw.Write('\n');
pw.Write(" id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParagraphs(), false, "<Paragraph", "</Paragraph>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTypeSpecs(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countParagraphs(); i++) {
  l.Add(getParagraphs(i));
}
for (int i = 0; i < countTypeSpecs(); i++) {
  l.Add(getTypeSpecs(i));
}
}

}
public partial class Paragraph
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
if(getId().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
if(getText().CompareTo((String) search) == 0)return true;
if(getVersion().CompareTo((String) search) == 0)return true;
if(getObsoleteFunctionalBlockName().CompareTo((String) search) == 0)return true;
if(getObsoleteGuid().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ParagraphController.alertChange(aLock, this);
}
private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.Paragraph_type aType;

public  acceptor.Paragraph_type getType() { return aType;}

public  void setType(acceptor.Paragraph_type v) {
  aType = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getType_AsString()
{
  return acceptor.Enum_Paragraph_type_ToString (aType);
}

public  bool setType_AsString( string  v)
{
 acceptor.Paragraph_type  temp = acceptor.StringTo_Enum_Paragraph_type(v);
if (temp >= 0){
  aType = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.Paragraph_scope aObsoleteScope;

public  acceptor.Paragraph_scope getObsoleteScope() { return aObsoleteScope;}

public  void setObsoleteScope(acceptor.Paragraph_scope v) {
  aObsoleteScope = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getObsoleteScope_AsString()
{
  return acceptor.Enum_Paragraph_scope_ToString (aObsoleteScope);
}

public  bool setObsoleteScope_AsString( string  v)
{
 acceptor.Paragraph_scope  temp = acceptor.StringTo_Enum_Paragraph_scope(v);
if (temp >= 0){
  aObsoleteScope = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  bool aObsoleteScopeOnBoard;

public  bool getObsoleteScopeOnBoard() { return aObsoleteScopeOnBoard;}

public  void setObsoleteScopeOnBoard(bool v) {
  aObsoleteScopeOnBoard = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aObsoleteScopeTrackside;

public  bool getObsoleteScopeTrackside() { return aObsoleteScopeTrackside;}

public  void setObsoleteScopeTrackside(bool v) {
  aObsoleteScopeTrackside = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aObsoleteScopeRollingStock;

public  bool getObsoleteScopeRollingStock() { return aObsoleteScopeRollingStock;}

public  void setObsoleteScopeRollingStock(bool v) {
  aObsoleteScopeRollingStock = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aOptional;

public  bool getOptional() { return aOptional;}

public  void setOptional(bool v) {
  aOptional = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aTypeSpecs;

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
public System.Collections.ArrayList allTypeSpecs()
  {
if (aTypeSpecs == null){
    setAllTypeSpecs( new System.Collections.ArrayList() );
} // If
    return aTypeSpecs;
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
private System.Collections.ArrayList getTypeSpecs()
  {
    return allTypeSpecs();
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection of elements which replaces 
///        TypeSpecs's current content.</param>
public void setAllTypeSpecs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
    NotifyControllers(null);
  }
public void setAllTypeSpecs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="el">a TypeSpec to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(System.Collections.IList)"/>
public void appendTypeSpecs(TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTypeSpecs(Lock aLock,TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection ofTypeSpecs to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(TypeSpec)"/>
public void appendTypeSpecs(System.Collections.IList coll)
  {
  __setDirty(true);
  allTypeSpecs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTypeSpecs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This insertion function inserts a new element in the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTypeSpecs(int idx, TypeSpec el)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTypeSpecs(int idx, TypeSpec el,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTypeSpecs(IXmlBBase el)
  {
  return ((System.Collections.IList) allTypeSpecs()).IndexOf (el);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTypeSpecs(int idx)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTypeSpecs(int idx,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTypeSpecs(IXmlBBase obj)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(null);
   }
  }

public void removeTypeSpecs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>the number of elements in TypeSpecs</returns>
public int countTypeSpecs()
  {
  return allTypeSpecs().Count;
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns an element from the
/// collection in TypeSpecs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public TypeSpec getTypeSpecs(int idx)
{
  return (TypeSpec) ( allTypeSpecs()[idx]);
}

private   string  aText;

public   string  getText() { return aText;}

public  void setText( string  v) {
  aText = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aVersion;

public   string  getVersion() { return aVersion;}

public  void setVersion( string  v) {
  aVersion = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aReviewed;

public  bool getReviewed() { return aReviewed;}

public  void setReviewed(bool v) {
  aReviewed = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.SPEC_IMPLEMENTED_ENUM aImplementationStatus;

public  acceptor.SPEC_IMPLEMENTED_ENUM getImplementationStatus() { return aImplementationStatus;}

public  void setImplementationStatus(acceptor.SPEC_IMPLEMENTED_ENUM v) {
  aImplementationStatus = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getImplementationStatus_AsString()
{
  return acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString (aImplementationStatus);
}

public  bool setImplementationStatus_AsString( string  v)
{
 acceptor.SPEC_IMPLEMENTED_ENUM  temp = acceptor.StringTo_Enum_SPEC_IMPLEMENTED_ENUM(v);
if (temp >= 0){
  aImplementationStatus = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aParagraphs;

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
public System.Collections.ArrayList allParagraphs()
  {
if (aParagraphs == null){
    setAllParagraphs( new System.Collections.ArrayList() );
} // If
    return aParagraphs;
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
private System.Collections.ArrayList getParagraphs()
  {
    return allParagraphs();
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection of elements which replaces 
///        Paragraphs's current content.</param>
public void setAllParagraphs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
    NotifyControllers(null);
  }
public void setAllParagraphs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="el">a Paragraph to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(System.Collections.IList)"/>
public void appendParagraphs(Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParagraphs(Lock aLock,Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection ofParagraphs to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(Paragraph)"/>
public void appendParagraphs(System.Collections.IList coll)
  {
  __setDirty(true);
  allParagraphs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParagraphs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This insertion function inserts a new element in the
/// collection in Paragraphs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParagraphs(int idx, Paragraph el)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParagraphs(int idx, Paragraph el,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParagraphs(IXmlBBase el)
  {
  return ((System.Collections.IList) allParagraphs()).IndexOf (el);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParagraphs(int idx)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParagraphs(int idx,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParagraphs(IXmlBBase obj)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(null);
   }
  }

public void removeParagraphs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>the number of elements in Paragraphs</returns>
public int countParagraphs()
  {
  return allParagraphs().Count;
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns an element from the
/// collection in Paragraphs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Paragraph getParagraphs(int idx)
{
  return (Paragraph) ( allParagraphs()[idx]);
}

private  ParagraphRevision aRevision;

public  ParagraphRevision getRevision() { return aRevision;}

public  void setRevision(ParagraphRevision v) {
  aRevision = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  Message aMessage;

public  Message getMessage() { return aMessage;}

public  void setMessage(Message v) {
  aMessage = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aMoreInfoRequired;

public  bool getMoreInfoRequired() { return aMoreInfoRequired;}

public  void setMoreInfoRequired(bool v) {
  aMoreInfoRequired = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aSpecIssue;

public  bool getSpecIssue() { return aSpecIssue;}

public  void setSpecIssue(bool v) {
  aSpecIssue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aObsoleteFunctionalBlock;

public  bool getObsoleteFunctionalBlock() { return aObsoleteFunctionalBlock;}

public  void setObsoleteFunctionalBlock(bool v) {
  aObsoleteFunctionalBlock = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aObsoleteFunctionalBlockName;

public   string  getObsoleteFunctionalBlockName() { return aObsoleteFunctionalBlockName;}

public  void setObsoleteFunctionalBlockName( string  v) {
  aObsoleteFunctionalBlockName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aRequirementSets;

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>a collection of all the elements in RequirementSets</returns>
public System.Collections.ArrayList allRequirementSets()
  {
if (aRequirementSets == null){
    setAllRequirementSets( new System.Collections.ArrayList() );
} // If
    return aRequirementSets;
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>a collection of all the elements in RequirementSets</returns>
private System.Collections.ArrayList getRequirementSets()
  {
    return allRequirementSets();
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="coll">a collection of elements which replaces 
///        RequirementSets's current content.</param>
public void setAllRequirementSets(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirementSets = coll;
    NotifyControllers(null);
  }
public void setAllRequirementSets(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirementSets = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="el">a RequirementSetReference to add to the collection in 
///           RequirementSets</param>
/// <seealso cref="appendRequirementSets(System.Collections.IList)"/>
public void appendRequirementSets(RequirementSetReference el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirementSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRequirementSets(Lock aLock,RequirementSetReference el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirementSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="coll">a collection ofRequirementSetReferences to add to the collection in 
///           RequirementSets</param>
/// <seealso cref="appendRequirementSets(RequirementSetReference)"/>
public void appendRequirementSets(System.Collections.IList coll)
  {
  __setDirty(true);
  allRequirementSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRequirementSets(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This insertion function inserts a new element in the
/// collection in RequirementSets</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRequirementSets(int idx, RequirementSetReference el)
  {
  __setDirty(true);
  allRequirementSets().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRequirementSets(int idx, RequirementSetReference el,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRequirementSets(IXmlBBase el)
  {
  return ((System.Collections.IList) allRequirementSets()).IndexOf (el);
  }

/// <summary>Part of the list interface for RequirementSets
/// This deletion function removes an element from the
/// collection in RequirementSets</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRequirementSets(int idx)
  {
  __setDirty(true);
  allRequirementSets().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRequirementSets(int idx,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This deletion function removes an element from the
/// collection in RequirementSets
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRequirementSets(IXmlBBase obj)
  {
  int idx = indexOfRequirementSets(obj);
  if (idx >= 0) { deleteRequirementSets(idx);
NotifyControllers(null);
   }
  }

public void removeRequirementSets(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRequirementSets(obj);
  if (idx >= 0) { deleteRequirementSets(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>the number of elements in RequirementSets</returns>
public int countRequirementSets()
  {
  return allRequirementSets().Count;
  }

/// <summary>Part of the list interface for RequirementSets
/// This function returns an element from the
/// collection in RequirementSets based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RequirementSetReference getRequirementSets(int idx)
{
  return (RequirementSetReference) ( allRequirementSets()[idx]);
}

private   string  aObsoleteGuid;

public   string  getObsoleteGuid() { return aObsoleteGuid;}

public  void setObsoleteGuid( string  v) {
  aObsoleteGuid = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aTested;

public  bool getTested() { return aTested;}

public  void setTested(bool v) {
  aTested = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Paragraph()
{
Paragraph obj = this;
aId=(null);
aType=(0);
aObsoleteScope=(0);
aObsoleteScopeOnBoard=(false);
aObsoleteScopeTrackside=(false);
aObsoleteScopeRollingStock=(false);
aBl=(null);
aOptional=(false);
aTypeSpecs=(null);
aText=(null);
aVersion=(null);
aReviewed=(false);
aImplementationStatus=(0);
aParagraphs=(null);
aRevision=(null);
aMessage=(null);
aMoreInfoRequired=(false);
aSpecIssue=(false);
aObsoleteFunctionalBlock=(false);
aObsoleteFunctionalBlockName=(null);
aRequirementSets=(null);
aObsoleteGuid=(null);
aTested=(false);
}

public void copyTo(Paragraph other)
{
base.copyTo(other);
other.aId = aId;
other.aType = aType;
other.aObsoleteScope = aObsoleteScope;
other.aObsoleteScopeOnBoard = aObsoleteScopeOnBoard;
other.aObsoleteScopeTrackside = aObsoleteScopeTrackside;
other.aObsoleteScopeRollingStock = aObsoleteScopeRollingStock;
other.aBl = aBl;
other.aOptional = aOptional;
other.aTypeSpecs = aTypeSpecs;
other.aText = aText;
other.aVersion = aVersion;
other.aReviewed = aReviewed;
other.aImplementationStatus = aImplementationStatus;
other.aParagraphs = aParagraphs;
other.aRevision = aRevision;
other.aMessage = aMessage;
other.aMoreInfoRequired = aMoreInfoRequired;
other.aSpecIssue = aSpecIssue;
other.aObsoleteFunctionalBlock = aObsoleteFunctionalBlock;
other.aObsoleteFunctionalBlockName = aObsoleteFunctionalBlockName;
other.aRequirementSets = aRequirementSets;
other.aObsoleteGuid = aObsoleteGuid;
other.aTested = aTested;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1848;
Paragraph fl1850;
TypeSpec fl1862;
bool fl1873;
RequirementSetReference fl1875;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Indicator
// Parse PC data
this.setText(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
// Element Ref : Message
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<Message")){
// Parsing sub element
this.setMessage(acceptor.lAccept_Message(ctxt,null));
setSon(this.getMessage());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Element Ref : ParagraphRevision
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<ParagraphRevision")){
// Parsing sub element
this.setRevision(acceptor.lAccept_ParagraphRevision(ctxt,"</ParagraphRevision>"));
setSon(this.getRevision());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Sub")){
ctxt.skipWhiteSpace();
fl1848 = true ; 
while (fl1848) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1848 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1850 = null;
while(ctxt.lookAheadOpeningTag ("<Paragraph")) {
fl1850 = acceptor.lAccept_Paragraph(ctxt, "</Paragraph>");
appendParagraphs(fl1850);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Sub>");
} // If
} // If
// End enclosed
// Repeat
ctxt.skipWhiteSpace();
fl1862 = null;
while(ctxt.lookAheadOpeningTag ("<TypeSpec")) {
fl1862 = acceptor.lAccept_TypeSpec(ctxt, null);
appendTypeSpecs(fl1862);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<RequirementSets")){
ctxt.skipWhiteSpace();
fl1873 = true ; 
while (fl1873) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1873 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1875 = null;
while(ctxt.lookAheadOpeningTag ("<RequirementSetReference")) {
fl1875 = acceptor.lAccept_RequirementSetReference(ctxt, "</RequirementSetReference>");
appendRequirementSets(fl1875);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</RequirementSets>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1886;
bool fl1887;
bool fl1888;
bool fl1889;
bool fl1890;
bool fl1891;
bool fl1892;
bool fl1893;
bool fl1894;
bool fl1895;
bool fl1896;
bool fl1897;
bool fl1898;
bool fl1899;
bool fl1900;
bool fl1901;
bool fl1902;
bool fl1903;
bool fl1904;
bool fl1905;
bool fl1906;
bool fl1907;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1886 = false ; 
fl1887 = false ; 
fl1888 = false ; 
fl1889 = false ; 
fl1890 = false ; 
fl1891 = false ; 
fl1892 = false ; 
fl1893 = false ; 
fl1894 = false ; 
fl1895 = false ; 
fl1896 = false ; 
fl1897 = false ; 
fl1898 = false ; 
fl1899 = false ; 
fl1900 = false ; 
fl1901 = false ; 
fl1902 = false ; 
fl1903 = false ; 
fl1904 = false ; 
fl1905 = false ; 
fl1906 = false ; 
fl1907 = true ; 
while (fl1907) { // BeginLoop 
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
if (ctxt.lookAheadString("ersion=")){
indicator = 1896;
} else {
indicator = 1908;
} // If
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'y':
{
ctxt.advance();
if (ctxt.lookAhead3('p','e','=')){
indicator = 1888;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ackside=")){
indicator = 1902;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("sted=")){
indicator = 1895;
} else {
indicator = 1908;
} // If
break;
} // Case
default:
indicator = 1908;
break;
} // Switch
break;
} // Case
case 's':
{
ctxt.advance();
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAheadString("atus=")){
indicator = 1894;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("ecIssue=")){
indicator = 1898;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("ope=")){
indicator = 1889;
} else {
indicator = 1908;
} // If
break;
} // Case
default:
indicator = 1908;
break;
} // Switch
break;
} // Case
case 'r':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("llinkstock=")){
indicator = 1903;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("viewed=")){
indicator = 1893;
} else {
indicator = 1908;
} // If
break;
} // Case
default:
indicator = 1908;
break;
} // Switch
break;
} // Case
case 'o':
{
ctxt.advance();
switch (ctxt.current()) {
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("tional=")){
indicator = 1891;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("board=")){
indicator = 1901;
} else {
indicator = 1908;
} // If
break;
} // Case
default:
indicator = 1908;
break;
} // Switch
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1892;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("foRequired=")){
indicator = 1897;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'd':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1886;
} else {
indicator = 1908;
} // If
break;
} // Case
default:
indicator = 1908;
break;
} // Switch
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1887;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'f':
{
ctxt.advance();
if (ctxt.lookAheadString("unctionalBlock")){
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1900;
} else {
indicator = 1908;
} // If
break;
} // Case
case '=':
{
ctxt.advance();
indicator = 1899;
break;
} // Case
default:
indicator = 1908;
break;
} // Switch
} else {
indicator = 1908;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1890;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1906;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1904;
} else {
indicator = 1908;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1905;
} else {
indicator = 1908;
} // If
break;
} // Case
default:
indicator = 1908;
break;
} // Switch
switch (indicator) {
case 1886: {
// Handling attribute id
// Also handles alien attributes with prefix id
if (fl1886){
ctxt.fail ("Duplicate attribute: id");
} // If
fl1886 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1887: {
// Handling attribute guid
// Also handles alien attributes with prefix guid
if (fl1887){
ctxt.fail ("Duplicate attribute: guid");
} // If
fl1887 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1888: {
// Handling attribute type
// Also handles alien attributes with prefix type
if (fl1888){
ctxt.fail ("Duplicate attribute: type");
} // If
fl1888 = true ; 
quoteChar = ctxt.acceptQuote();
this.setType(acceptor.lAcceptEnum_Paragraph_type(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1889: {
// Handling attribute scope
// Also handles alien attributes with prefix scope
if (fl1889){
ctxt.fail ("Duplicate attribute: scope");
} // If
fl1889 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteScope(acceptor.lAcceptEnum_Paragraph_scope(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1890: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1890){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1890 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1891: {
// Handling attribute optional
// Also handles alien attributes with prefix optional
if (fl1891){
ctxt.fail ("Duplicate attribute: optional");
} // If
fl1891 = true ; 
quoteChar = ctxt.acceptQuote();
this.setOptional(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1892: {
// Handling attribute name
// Also handles alien attributes with prefix name
if (fl1892){
ctxt.fail ("Duplicate attribute: name");
} // If
fl1892 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1893: {
// Handling attribute reviewed
// Also handles alien attributes with prefix reviewed
if (fl1893){
ctxt.fail ("Duplicate attribute: reviewed");
} // If
fl1893 = true ; 
quoteChar = ctxt.acceptQuote();
this.setReviewed(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1894: {
// Handling attribute status
// Also handles alien attributes with prefix status
if (fl1894){
ctxt.fail ("Duplicate attribute: status");
} // If
fl1894 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplementationStatus(acceptor.lAcceptEnum_SPEC_IMPLEMENTED_ENUM(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1895: {
// Handling attribute tested
// Also handles alien attributes with prefix tested
if (fl1895){
ctxt.fail ("Duplicate attribute: tested");
} // If
fl1895 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTested(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1896: {
// Handling attribute version
// Also handles alien attributes with prefix version
if (fl1896){
ctxt.fail ("Duplicate attribute: version");
} // If
fl1896 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVersion((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1897: {
// Handling attribute infoRequired
// Also handles alien attributes with prefix infoRequired
if (fl1897){
ctxt.fail ("Duplicate attribute: infoRequired");
} // If
fl1897 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMoreInfoRequired(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1898: {
// Handling attribute specIssue
// Also handles alien attributes with prefix specIssue
if (fl1898){
ctxt.fail ("Duplicate attribute: specIssue");
} // If
fl1898 = true ; 
quoteChar = ctxt.acceptQuote();
this.setSpecIssue(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1899: {
// Handling attribute functionalBlock
// Also handles alien attributes with prefix functionalBlock
if (fl1899){
ctxt.fail ("Duplicate attribute: functionalBlock");
} // If
fl1899 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteFunctionalBlock(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1900: {
// Handling attribute functionalBlockName
// Also handles alien attributes with prefix functionalBlockName
if (fl1900){
ctxt.fail ("Duplicate attribute: functionalBlockName");
} // If
fl1900 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteFunctionalBlockName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1901: {
// Handling attribute onboard
// Also handles alien attributes with prefix onboard
if (fl1901){
ctxt.fail ("Duplicate attribute: onboard");
} // If
fl1901 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteScopeOnBoard(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1902: {
// Handling attribute trackside
// Also handles alien attributes with prefix trackside
if (fl1902){
ctxt.fail ("Duplicate attribute: trackside");
} // If
fl1902 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteScopeTrackside(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1903: {
// Handling attribute rollinkstock
// Also handles alien attributes with prefix rollinkstock
if (fl1903){
ctxt.fail ("Duplicate attribute: rollinkstock");
} // If
fl1903 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteScopeRollingStock(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1904: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1904){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1904 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1905: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1905){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1905 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1906: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1906){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1906 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1908: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1886){
ctxt.fail ("Mandatory attribute missing: id in Paragraph");
} // If
if (!fl1887){
this.setObsoleteGuid("");
} // If
if (!fl1888){
this.setType(acceptor.Paragraph_type.aREQUIREMENT);
} // If
if (!fl1889){
this.setObsoleteScope(acceptor.Paragraph_scope.aOBU_AND_TRACK);
} // If
if (!fl1890){
this.setBl("");
} // If
if (!fl1891){
this.setOptional( true);
} // If
if (!fl1892){
this.setName("");
} // If
if (!fl1893){
this.setReviewed( false);
} // If
if (!fl1894){
this.setImplementationStatus(acceptor.SPEC_IMPLEMENTED_ENUM.Impl_NA);
} // If
if (!fl1895){
this.setTested( false);
} // If
if (!fl1896){
this.setVersion("3.0.0");
} // If
if (!fl1897){
this.setMoreInfoRequired( false);
} // If
if (!fl1898){
this.setSpecIssue( false);
} // If
if (!fl1899){
this.setObsoleteFunctionalBlock( false);
} // If
if (!fl1900){
this.setObsoleteFunctionalBlockName("");
} // If
if (!fl1901){
this.setObsoleteScopeOnBoard( false);
} // If
if (!fl1902){
this.setObsoleteScopeTrackside( false);
} // If
if (!fl1903){
this.setObsoleteScopeRollingStock( false);
} // If
fl1907 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Paragraph";
  endingTag = "</Paragraph>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Paragraph\"");
} // If
pw.Write('\n');
pw.Write(" id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
if (this.getObsoleteGuid() != null){
pw.Write(" guid=\"");
acceptor.unParsePcData(pw, this.getObsoleteGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getType() != 0){
pw.Write(" type=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_Paragraph_type_ToString(this.getType()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteScope() != 0){
pw.Write(" scope=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_Paragraph_scope_ToString(this.getObsoleteScope()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getOptional()){
pw.Write(" optional=\"");
acceptor.unParsePcData(pw, this.getOptional());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getReviewed()){
pw.Write(" reviewed=\"");
acceptor.unParsePcData(pw, this.getReviewed());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplementationStatus() != 0){
pw.Write(" status=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString(this.getImplementationStatus()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getTested()){
pw.Write(" tested=\"");
acceptor.unParsePcData(pw, this.getTested());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVersion() != null){
pw.Write(" version=\"");
acceptor.unParsePcData(pw, this.getVersion());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMoreInfoRequired()){
pw.Write(" infoRequired=\"");
acceptor.unParsePcData(pw, this.getMoreInfoRequired());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getSpecIssue()){
pw.Write(" specIssue=\"");
acceptor.unParsePcData(pw, this.getSpecIssue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteFunctionalBlock()){
pw.Write(" functionalBlock=\"");
acceptor.unParsePcData(pw, this.getObsoleteFunctionalBlock());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteFunctionalBlockName() != null){
pw.Write(" functionalBlockName=\"");
acceptor.unParsePcData(pw, this.getObsoleteFunctionalBlockName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteScopeOnBoard()){
pw.Write(" onboard=\"");
acceptor.unParsePcData(pw, this.getObsoleteScopeOnBoard());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteScopeTrackside()){
pw.Write(" trackside=\"");
acceptor.unParsePcData(pw, this.getObsoleteScopeTrackside());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteScopeRollingStock()){
pw.Write(" rollinkstock=\"");
acceptor.unParsePcData(pw, this.getObsoleteScopeRollingStock());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing PcData
acceptor.unParsePcData(pw, this.getText());
// Unparsing ElementRef
if (this.getMessage() != null){
unParse(pw, this.getMessage(), false, null, null);
} // If
// Unparsing ElementRef
if (this.getRevision() != null){
unParse(pw, this.getRevision(),false,"<ParagraphRevision","</ParagraphRevision>");
} // If
// Unparsing Enclosed
// Testing for empty content: Paragraphs
if (countParagraphs() > 0){
pw.Write("<Sub>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParagraphs(), false, "<Paragraph", "</Paragraph>");
pw.Write("</Sub>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Paragraphs
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTypeSpecs(), false, null, null);
// Unparsing Enclosed
// Testing for empty content: RequirementSets
if (countRequirementSets() > 0){
pw.Write("<RequirementSets>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRequirementSets(), false, "<RequirementSetReference", "</RequirementSetReference>");
pw.Write("</RequirementSets>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: RequirementSets
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countTypeSpecs(); i++) {
  l.Add(getTypeSpecs(i));
}
for (int i = 0; i < countParagraphs(); i++) {
  l.Add(getParagraphs(i));
}
l.Add(this.getRevision());
l.Add(this.getMessage());
for (int i = 0; i < countRequirementSets(); i++) {
  l.Add(getRequirementSets(i));
}
}

}
public partial class RequirementSetReference
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getTarget().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RequirementSetReferenceController.alertChange(aLock, this);
}
private   string  aTarget;

public   string  getTarget() { return aTarget;}

public  void setTarget( string  v) {
  aTarget = v;
  __setDirty(true);
  NotifyControllers(null);
}


public RequirementSetReference()
{
RequirementSetReference obj = this;
aTarget=(null);
}

public void copyTo(RequirementSetReference other)
{
base.copyTo(other);
other.aTarget = aTarget;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1937;
bool fl1938;
bool fl1939;
bool fl1940;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1937 = false ; 
fl1938 = false ; 
fl1939 = false ; 
fl1940 = true ; 
while (fl1940) { // BeginLoop 
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 1939;
} else {
indicator = 1941;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("efId=")){
indicator = 1937;
} else {
indicator = 1941;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1938;
} else {
indicator = 1941;
} // If
break;
} // Case
default:
indicator = 1941;
break;
} // Switch
switch (indicator) {
case 1937: {
// Handling attribute RefId
// Also handles alien attributes with prefix RefId
if (fl1937){
ctxt.fail ("Duplicate attribute: RefId");
} // If
fl1937 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTarget((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1938: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1938){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1938 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1939: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl1939){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl1939 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1941: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1937){
ctxt.fail ("Mandatory attribute missing: RefId in RequirementSetReference");
} // If
fl1940 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RequirementSetReference";
  endingTag = "</RequirementSetReference>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RequirementSetReference\"");
} // If
pw.Write('\n');
pw.Write(" RefId=\"");
acceptor.unParsePcData(pw, this.getTarget());
pw.Write('"');
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Message
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getDescription().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.MessageController.alertChange(aLock, this);
}
private   string  aDescription;

public   string  getDescription() { return aDescription;}

public  void setDescription( string  v) {
  aDescription = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.Message_media aMedia;

public  acceptor.Message_media getMedia() { return aMedia;}

public  void setMedia(acceptor.Message_media v) {
  aMedia = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMedia_AsString()
{
  return acceptor.Enum_Message_media_ToString (aMedia);
}

public  bool setMedia_AsString( string  v)
{
 acceptor.Message_media  temp = acceptor.StringTo_Enum_Message_media(v);
if (temp >= 0){
  aMedia = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aMsgVariables;

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
public System.Collections.ArrayList allMsgVariables()
  {
if (aMsgVariables == null){
    setAllMsgVariables( new System.Collections.ArrayList() );
} // If
    return aMsgVariables;
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
private System.Collections.ArrayList getMsgVariables()
  {
    return allMsgVariables();
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection of elements which replaces 
///        MsgVariables's current content.</param>
public void setAllMsgVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
    NotifyControllers(null);
  }
public void setAllMsgVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="el">a MsgVariable to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(System.Collections.IList)"/>
public void appendMsgVariables(MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendMsgVariables(Lock aLock,MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection ofMsgVariables to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(MsgVariable)"/>
public void appendMsgVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allMsgVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendMsgVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This insertion function inserts a new element in the
/// collection in MsgVariables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertMsgVariables(int idx, MsgVariable el)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertMsgVariables(int idx, MsgVariable el,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfMsgVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allMsgVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteMsgVariables(int idx)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteMsgVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeMsgVariables(IXmlBBase obj)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(null);
   }
  }

public void removeMsgVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>the number of elements in MsgVariables</returns>
public int countMsgVariables()
  {
  return allMsgVariables().Count;
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns an element from the
/// collection in MsgVariables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public MsgVariable getMsgVariables(int idx)
{
  return (MsgVariable) ( allMsgVariables()[idx]);
}

public Message()
{
Message obj = this;
aDescription=(null);
aMedia=(0);
aBl=(null);
aMsgVariables=(null);
}

public void copyTo(Message other)
{
other.aDescription = aDescription;
other.aMedia = aMedia;
other.aBl = aBl;
other.aMsgVariables = aMsgVariables;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
MsgVariable fl1947;

ctxt.skipWhiteSpace();
// Repeat
ctxt.skipWhiteSpace();
fl1947 = null;
while(ctxt.lookAheadOpeningTag ("<MsgVariable")) {
fl1947 = acceptor.lAccept_MsgVariable(ctxt, null);
appendMsgVariables(fl1947);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1958;
bool fl1959;
bool fl1960;
bool fl1961;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1958 = false ; 
fl1959 = false ; 
fl1960 = false ; 
fl1961 = true ; 
while (fl1961) { // BeginLoop 
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("edia=")){
indicator = 1959;
} else {
indicator = 1962;
} // If
break;
} // Case
case 'd':
{
ctxt.advance();
if (ctxt.lookAheadString("escription=")){
indicator = 1958;
} else {
indicator = 1962;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1960;
} else {
indicator = 1962;
} // If
break;
} // Case
default:
indicator = 1962;
break;
} // Switch
switch (indicator) {
case 1958: {
// Handling attribute description
// Also handles alien attributes with prefix description
if (fl1958){
ctxt.fail ("Duplicate attribute: description");
} // If
fl1958 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDescription((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1959: {
// Handling attribute media
// Also handles alien attributes with prefix media
if (fl1959){
ctxt.fail ("Duplicate attribute: media");
} // If
fl1959 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMedia(acceptor.lAcceptEnum_Message_media(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1960: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1960){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1960 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1962: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1958){
ctxt.fail ("Mandatory attribute missing: description in Message");
} // If
if (!fl1959){
ctxt.fail ("Mandatory attribute missing: media in Message");
} // If
fl1961 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</Message>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<Message");
if (typeId){
pw.Write(" xsi:type=\"Message\"");
} // If
pw.Write('\n');
pw.Write(" description=\"");
acceptor.unParsePcData(pw, this.getDescription());
pw.Write('"');
pw.Write('\n');
pw.Write(" media=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_Message_media_ToString(this.getMedia()));
pw.Write('"');
pw.Write('\n');
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</Message>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getMsgVariables(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
for (int i = 0; i < countMsgVariables(); i++) {
  l.Add(getMsgVariables(i));
}
}

}
public partial class MsgVariable
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getName().CompareTo((String) search) == 0)return true;
if(getLength().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.MsgVariableController.alertChange(aLock, this);
}
private   string  aName;

public   string  getName() { return aName;}

public  void setName( string  v) {
  aName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aLength;

public   string  getLength() { return aLength;}

public  void setLength( string  v) {
  aLength = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aMsgVariables;

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
public System.Collections.ArrayList allMsgVariables()
  {
if (aMsgVariables == null){
    setAllMsgVariables( new System.Collections.ArrayList() );
} // If
    return aMsgVariables;
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
private System.Collections.ArrayList getMsgVariables()
  {
    return allMsgVariables();
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection of elements which replaces 
///        MsgVariables's current content.</param>
public void setAllMsgVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
    NotifyControllers(null);
  }
public void setAllMsgVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="el">a MsgVariable to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(System.Collections.IList)"/>
public void appendMsgVariables(MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendMsgVariables(Lock aLock,MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection ofMsgVariables to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(MsgVariable)"/>
public void appendMsgVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allMsgVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendMsgVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This insertion function inserts a new element in the
/// collection in MsgVariables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertMsgVariables(int idx, MsgVariable el)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertMsgVariables(int idx, MsgVariable el,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfMsgVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allMsgVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteMsgVariables(int idx)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteMsgVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeMsgVariables(IXmlBBase obj)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(null);
   }
  }

public void removeMsgVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>the number of elements in MsgVariables</returns>
public int countMsgVariables()
  {
  return allMsgVariables().Count;
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns an element from the
/// collection in MsgVariables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public MsgVariable getMsgVariables(int idx)
{
  return (MsgVariable) ( allMsgVariables()[idx]);
}

public MsgVariable()
{
MsgVariable obj = this;
aName=(null);
aLength=(null);
aComment=(null);
aBl=(null);
aMsgVariables=(null);
}

public void copyTo(MsgVariable other)
{
other.aName = aName;
other.aLength = aLength;
other.aComment = aComment;
other.aBl = aBl;
other.aMsgVariables = aMsgVariables;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
MsgVariable fl1968;

ctxt.skipWhiteSpace();
// Repeat
ctxt.skipWhiteSpace();
fl1968 = null;
while(ctxt.lookAheadOpeningTag ("<MsgVariable")) {
fl1968 = acceptor.lAccept_MsgVariable(ctxt, null);
appendMsgVariables(fl1968);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1979;
bool fl1980;
bool fl1981;
bool fl1982;
bool fl1983;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1979 = false ; 
fl1980 = false ; 
fl1981 = false ; 
fl1982 = false ; 
fl1983 = true ; 
while (fl1983) { // BeginLoop 
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1979;
} else {
indicator = 1984;
} // If
break;
} // Case
case 'l':
{
ctxt.advance();
if (ctxt.lookAheadString("ength=")){
indicator = 1980;
} else {
indicator = 1984;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("omment=")){
indicator = 1981;
} else {
indicator = 1984;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1982;
} else {
indicator = 1984;
} // If
break;
} // Case
default:
indicator = 1984;
break;
} // Switch
switch (indicator) {
case 1979: {
// Handling attribute name
// Also handles alien attributes with prefix name
if (fl1979){
ctxt.fail ("Duplicate attribute: name");
} // If
fl1979 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1980: {
// Handling attribute length
// Also handles alien attributes with prefix length
if (fl1980){
ctxt.fail ("Duplicate attribute: length");
} // If
fl1980 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLength((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1981: {
// Handling attribute comment
// Also handles alien attributes with prefix comment
if (fl1981){
ctxt.fail ("Duplicate attribute: comment");
} // If
fl1981 = true ; 
quoteChar = ctxt.acceptQuote();
this.setComment((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1982: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1982){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1982 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1984: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1979){
ctxt.fail ("Mandatory attribute missing: name in MsgVariable");
} // If
if (!fl1981){
ctxt.fail ("Mandatory attribute missing: comment in MsgVariable");
} // If
fl1983 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</MsgVariable>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<MsgVariable");
if (typeId){
pw.Write(" xsi:type=\"MsgVariable\"");
} // If
pw.Write('\n');
pw.Write(" name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
if (this.getLength() != null){
pw.Write(" length=\"");
acceptor.unParsePcData(pw, this.getLength());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write(" comment=\"");
acceptor.unParsePcData(pw, this.getComment());
pw.Write('"');
pw.Write('\n');
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</MsgVariable>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getMsgVariables(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
for (int i = 0; i < countMsgVariables(); i++) {
  l.Add(getMsgVariables(i));
}
}

}
public partial class TypeSpec
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getMinimum_value().CompareTo((String) search) == 0)return true;
if(getMaximum_value().CompareTo((String) search) == 0)return true;
if(getResolution_formula().CompareTo((String) search) == 0)return true;
if(getId().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
if(getDescription().CompareTo((String) search) == 0)return true;
if(getShort_description().CompareTo((String) search) == 0)return true;
if(getReference().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TypeSpecController.alertChange(aLock, this);
}
private  int aLength;

public  int getLength() { return aLength;}

public  void setLength(int v) {
  aLength = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMinimum_value;

public   string  getMinimum_value() { return aMinimum_value;}

public  void setMinimum_value( string  v) {
  aMinimum_value = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMaximum_value;

public   string  getMaximum_value() { return aMaximum_value;}

public  void setMaximum_value( string  v) {
  aMaximum_value = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aResolution_formula;

public   string  getResolution_formula() { return aResolution_formula;}

public  void setResolution_formula( string  v) {
  aResolution_formula = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.TypeSpec_ertms_type aErtms_type;

public  acceptor.TypeSpec_ertms_type getErtms_type() { return aErtms_type;}

public  void setErtms_type(acceptor.TypeSpec_ertms_type v) {
  aErtms_type = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getErtms_type_AsString()
{
  return acceptor.Enum_TypeSpec_ertms_type_ToString (aErtms_type);
}

public  bool setErtms_type_AsString( string  v)
{
 acceptor.TypeSpec_ertms_type  temp = acceptor.StringTo_Enum_TypeSpec_ertms_type(v);
if (temp >= 0){
  aErtms_type = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  Values aValues;

public  Values getValues() { return aValues;}

public  void setValues(Values v) {
  aValues = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  char_value aChar_value;

public  char_value getChar_value() { return aChar_value;}

public  void setChar_value(char_value v) {
  aChar_value = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDescription;

public   string  getDescription() { return aDescription;}

public  void setDescription( string  v) {
  aDescription = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aShort_description;

public   string  getShort_description() { return aShort_description;}

public  void setShort_description( string  v) {
  aShort_description = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aReference;

public   string  getReference() { return aReference;}

public  void setReference( string  v) {
  aReference = v;
  __setDirty(true);
  NotifyControllers(null);
}


public TypeSpec()
{
TypeSpec obj = this;
aLength=(0);
aMinimum_value=(null);
aMaximum_value=(null);
aResolution_formula=(null);
aId=(null);
aErtms_type=(0);
aBl=(null);
aValues=(null);
aChar_value=(null);
aDescription=(null);
aShort_description=(null);
aReference=(null);
}

public void copyTo(TypeSpec other)
{
other.aLength = aLength;
other.aMinimum_value = aMinimum_value;
other.aMaximum_value = aMaximum_value;
other.aResolution_formula = aResolution_formula;
other.aId = aId;
other.aErtms_type = aErtms_type;
other.aBl = aBl;
other.aValues = aValues;
other.aChar_value = aChar_value;
other.aDescription = aDescription;
other.aShort_description = aShort_description;
other.aReference = aReference;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1990;
bool fl1991;
bool fl1992;
int fl1995;

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<short-description")){
ctxt.skipWhiteSpace();
fl1990 = true ; 
while (fl1990) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1990 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setShort_description(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</short-description>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Description")){
ctxt.skipWhiteSpace();
fl1991 = true ; 
while (fl1991) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1991 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Indicator
// Parse PC data
this.setDescription(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Description>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<reference")){
ctxt.skipWhiteSpace();
fl1992 = true ; 
while (fl1992) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1992 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setReference(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</reference>");
} // If
// End enclosed
// Disjunct
ctxt.skipWhiteSpace();
// Nullable formula
fl1995 = ctxt.getPtr();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
switch (ctxt.current()) {
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("har-value")){
indicator = 1994;
} else {
ctxt.moveBack(1);
indicator = 1996;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alues")){
indicator = 1993;
} else {
ctxt.moveBack(1);
indicator = 1996;
} // If
break;
} // Case
default:
indicator = 1996;
break;
} // Switch
break;
} // Case
default:
indicator = 1996;
break;
} // Switch
switch (indicator) {
// Dispatch Lablel
case 1993: {
ctxt.moveBack(7);
// Element Ref : Values
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<Values")){
// Parsing sub element
this.setValues(acceptor.lAccept_Values(ctxt,null));
setSon(this.getValues());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Dispatch Lablel
case 1994: {
ctxt.moveBack(11);
// Element Ref : char-value
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<char-value")){
// Parsing sub element
this.setChar_value(acceptor.lAccept_char_value(ctxt,null));
setSon(this.getChar_value());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Optional of PCdata
case 1996: {
ctxt.setPtr(fl1995);
// Doing nothing, optional disj
break;
} // End of dispatch label
} // Dispatch
// End Disjunct
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2001;
bool fl2002;
bool fl2003;
bool fl2004;
bool fl2005;
bool fl2006;
bool fl2007;
bool fl2008;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl2001 = false ; 
fl2002 = false ; 
fl2003 = false ; 
fl2004 = false ; 
fl2005 = false ; 
fl2006 = false ; 
fl2007 = false ; 
fl2008 = true ; 
while (fl2008) { // BeginLoop 
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("esolution_formula=")){
indicator = 2004;
} else {
indicator = 2009;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nimum_value=")){
indicator = 2002;
} else {
indicator = 2009;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("ximum_value=")){
indicator = 2003;
} else {
indicator = 2009;
} // If
break;
} // Case
default:
indicator = 2009;
break;
} // Switch
break;
} // Case
case 'l':
{
ctxt.advance();
if (ctxt.lookAheadString("ength=")){
indicator = 2001;
} else {
indicator = 2009;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 2005;
} else {
indicator = 2009;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("rtms-type=")){
indicator = 2006;
} else {
indicator = 2009;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 2007;
} else {
indicator = 2009;
} // If
break;
} // Case
default:
indicator = 2009;
break;
} // Switch
switch (indicator) {
case 2001: {
// Handling attribute length
// Also handles alien attributes with prefix length
if (fl2001){
ctxt.fail ("Duplicate attribute: length");
} // If
fl2001 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLength(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 2002: {
// Handling attribute minimum_value
// Also handles alien attributes with prefix minimum_value
if (fl2002){
ctxt.fail ("Duplicate attribute: minimum_value");
} // If
fl2002 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMinimum_value((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 2003: {
// Handling attribute maximum_value
// Also handles alien attributes with prefix maximum_value
if (fl2003){
ctxt.fail ("Duplicate attribute: maximum_value");
} // If
fl2003 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMaximum_value((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 2004: {
// Handling attribute resolution_formula
// Also handles alien attributes with prefix resolution_formula
if (fl2004){
ctxt.fail ("Duplicate attribute: resolution_formula");
} // If
fl2004 = true ; 
quoteChar = ctxt.acceptQuote();
this.setResolution_formula((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 2005: {
// Handling attribute id
// Also handles alien attributes with prefix id
if (fl2005){
ctxt.fail ("Duplicate attribute: id");
} // If
fl2005 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 2006: {
// Handling attribute ertms-type
// Also handles alien attributes with prefix ertms-type
if (fl2006){
ctxt.fail ("Duplicate attribute: ertms-type");
} // If
fl2006 = true ; 
quoteChar = ctxt.acceptQuote();
this.setErtms_type(acceptor.lAcceptEnum_TypeSpec_ertms_type(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 2007: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl2007){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl2007 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 2009: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl2001){
ctxt.fail ("Mandatory attribute missing: length in TypeSpec");
} // If
fl2008 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</TypeSpec>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<TypeSpec");
if (typeId){
pw.Write(" xsi:type=\"TypeSpec\"");
} // If
pw.Write('\n');
pw.Write(" length=\"");
acceptor.unParsePcData(pw, this.getLength());
pw.Write('"');
pw.Write('\n');
if (this.getMinimum_value() != null){
pw.Write(" minimum_value=\"");
acceptor.unParsePcData(pw, this.getMinimum_value());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMaximum_value() != null){
pw.Write(" maximum_value=\"");
acceptor.unParsePcData(pw, this.getMaximum_value());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getResolution_formula() != null){
pw.Write(" resolution_formula=\"");
acceptor.unParsePcData(pw, this.getResolution_formula());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getId() != null){
pw.Write(" id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getErtms_type() != 0){
pw.Write(" ertms-type=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_TypeSpec_ertms_type_ToString(this.getErtms_type()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</TypeSpec>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Enclosed
// Testing for empty content: Short-description
if (this.getShort_description() != null){
pw.Write("<short-description>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getShort_description());
pw.Write("</short-description>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Short-description
// Unparsing Enclosed
// Testing for empty content: Description
if (this.getDescription() != null){
pw.Write("<Description>");
// Unparsing PcData
if (this.getDescription() != null){
acceptor.unParsePcData(pw, this.getDescription());
} // If
pw.Write("</Description>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Description
// Unparsing Enclosed
// Testing for empty content: Reference
if (this.getReference() != null){
pw.Write("<reference>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getReference());
pw.Write("</reference>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Reference
// Unparsing Disjunct
if (this.getValues() != null){
// Unparsing ElementRef
if (this.getValues() != null){
unParse(pw, this.getValues(), false, null, null);
} // If
} else {
if (this.getChar_value() != null){
// Unparsing ElementRef
if (this.getChar_value() != null){
unParse(pw, this.getChar_value(), false, null, null);
} // If
} // If
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
l.Add(this.getValues());
l.Add(this.getChar_value());
}

}
public partial class Values
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ValuesController.alertChange(aLock, this);
}
private  resolution_formula aResolution_formula_1;

public  resolution_formula getResolution_formula_1() { return aResolution_formula_1;}

public  void setResolution_formula_1(resolution_formula v) {
  aResolution_formula_1 = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  special_or_reserved_values aSpecial_or_reserved_values;

public  special_or_reserved_values getSpecial_or_reserved_values() { return aSpecial_or_reserved_values;}

public  void setSpecial_or_reserved_values(special_or_reserved_values v) {
  aSpecial_or_reserved_values = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  special_or_reserved_value aSpecial_or_reserved_value;

public  special_or_reserved_value getSpecial_or_reserved_value() { return aSpecial_or_reserved_value;}

public  void setSpecial_or_reserved_value(special_or_reserved_value v) {
  aSpecial_or_reserved_value = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


public Values()
{
Values obj = this;
aResolution_formula_1=(null);
aSpecial_or_reserved_values=(null);
aSpecial_or_reserved_value=(null);
}

public void copyTo(Values other)
{
other.aResolution_formula_1 = aResolution_formula_1;
other.aSpecial_or_reserved_values = aSpecial_or_reserved_values;
other.aSpecial_or_reserved_value = aSpecial_or_reserved_value;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
int fl2021;

ctxt.skipWhiteSpace();
// Element Ref : resolution-formula
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<resolution-formula")){
// Parsing sub element
this.setResolution_formula_1(acceptor.lAccept_resolution_formula(ctxt,null));
setSon(this.getResolution_formula_1());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Disjunct
ctxt.skipWhiteSpace();
// Nullable formula
fl2021 = ctxt.getPtr();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
if (ctxt.lookAheadString("special-or-reserved-value")){
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
indicator = 2019;
break;
} // Case
default:
indicator = 2020;
break;
} // Switch
} else {
ctxt.moveBack(1);
indicator = 2022;
} // If
break;
} // Case
default:
indicator = 2022;
break;
} // Switch
switch (indicator) {
// Dispatch Lablel
case 2019: {
ctxt.moveBack(27);
// Element Ref : special-or-reserved-values
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<special-or-reserved-values")){
// Parsing sub element
this.setSpecial_or_reserved_values(acceptor.lAccept_special_or_reserved_values(ctxt,null));
setSon(this.getSpecial_or_reserved_values());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Dispatch Lablel
case 2020: {
ctxt.moveBack(26);
// Element Ref : special-or-reserved-value
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<special-or-reserved-value")){
// Parsing sub element
this.setSpecial_or_reserved_value(acceptor.lAccept_special_or_reserved_value(ctxt,null));
setSon(this.getSpecial_or_reserved_value());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Optional of PCdata
case 2022: {
ctxt.setPtr(fl2021);
// Doing nothing, optional disj
break;
} // End of dispatch label
} // Dispatch
// End Disjunct
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2026;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl2026 = true ; 
while (fl2026) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl2026 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</Values>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<Values");
if (typeId){
pw.Write(" xsi:type=\"Values\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</Values>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing ElementRef
if (this.getResolution_formula_1() != null){
unParse(pw, this.getResolution_formula_1(), false, null, null);
} // If
// Unparsing Disjunct
if (this.getSpecial_or_reserved_values() != null){
// Unparsing ElementRef
if (this.getSpecial_or_reserved_values() != null){
unParse(pw, this.getSpecial_or_reserved_values(), false, null, null);
} // If
} else {
if (this.getSpecial_or_reserved_value() != null){
// Unparsing ElementRef
if (this.getSpecial_or_reserved_value() != null){
unParse(pw, this.getSpecial_or_reserved_value(), false, null, null);
} // If
} // If
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
l.Add(this.getResolution_formula_1());
l.Add(this.getSpecial_or_reserved_values());
l.Add(this.getSpecial_or_reserved_value());
}

}
public partial class special_or_reserved_values
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.special_or_reserved_valuesController.alertChange(aLock, this);
}
private System.Collections.ArrayList aSpecial_or_reserved_values;

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <returns>a collection of all the elements in Special_or_reserved_values</returns>
public System.Collections.ArrayList allSpecial_or_reserved_values()
  {
if (aSpecial_or_reserved_values == null){
    setAllSpecial_or_reserved_values( new System.Collections.ArrayList() );
} // If
    return aSpecial_or_reserved_values;
  }

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <returns>a collection of all the elements in Special_or_reserved_values</returns>
private System.Collections.ArrayList getSpecial_or_reserved_values()
  {
    return allSpecial_or_reserved_values();
  }

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <param name="coll">a collection of elements which replaces 
///        Special_or_reserved_values's current content.</param>
public void setAllSpecial_or_reserved_values(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecial_or_reserved_values = coll;
    NotifyControllers(null);
  }
public void setAllSpecial_or_reserved_values(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecial_or_reserved_values = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <param name="el">a special_or_reserved_value to add to the collection in 
///           Special_or_reserved_values</param>
/// <seealso cref="appendSpecial_or_reserved_values(System.Collections.IList)"/>
public void appendSpecial_or_reserved_values(special_or_reserved_value el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecial_or_reserved_values().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSpecial_or_reserved_values(Lock aLock,special_or_reserved_value el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecial_or_reserved_values().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <param name="coll">a collection ofspecial_or_reserved_values to add to the collection in 
///           Special_or_reserved_values</param>
/// <seealso cref="appendSpecial_or_reserved_values(special_or_reserved_value)"/>
public void appendSpecial_or_reserved_values(System.Collections.IList coll)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSpecial_or_reserved_values(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This insertion function inserts a new element in the
/// collection in Special_or_reserved_values</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSpecial_or_reserved_values(int idx, special_or_reserved_value el)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSpecial_or_reserved_values(int idx, special_or_reserved_value el,Lock aLock)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSpecial_or_reserved_values(IXmlBBase el)
  {
  return ((System.Collections.IList) allSpecial_or_reserved_values()).IndexOf (el);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This deletion function removes an element from the
/// collection in Special_or_reserved_values</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSpecial_or_reserved_values(int idx)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSpecial_or_reserved_values(int idx,Lock aLock)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This deletion function removes an element from the
/// collection in Special_or_reserved_values
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSpecial_or_reserved_values(IXmlBBase obj)
  {
  int idx = indexOfSpecial_or_reserved_values(obj);
  if (idx >= 0) { deleteSpecial_or_reserved_values(idx);
NotifyControllers(null);
   }
  }

public void removeSpecial_or_reserved_values(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSpecial_or_reserved_values(obj);
  if (idx >= 0) { deleteSpecial_or_reserved_values(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <returns>the number of elements in Special_or_reserved_values</returns>
public int countSpecial_or_reserved_values()
  {
  return allSpecial_or_reserved_values().Count;
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This function returns an element from the
/// collection in Special_or_reserved_values based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public special_or_reserved_value getSpecial_or_reserved_values(int idx)
{
  return (special_or_reserved_value) ( allSpecial_or_reserved_values()[idx]);
}

public special_or_reserved_values()
{
special_or_reserved_values obj = this;
aSpecial_or_reserved_values=(null);
}

public void copyTo(special_or_reserved_values other)
{
other.aSpecial_or_reserved_values = aSpecial_or_reserved_values;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
special_or_reserved_value fl2028;

ctxt.skipWhiteSpace();
// Repeat
ctxt.skipWhiteSpace();
fl2028 = null;
while(ctxt.lookAheadOpeningTag ("<special-or-reserved-value")) {
fl2028 = acceptor.lAccept_special_or_reserved_value(ctxt, null);
appendSpecial_or_reserved_values(fl2028);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
if (fl2028 == null){
ctxt.fail ("At least one element expected in repetition");
} // If
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2039;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl2039 = true ; 
while (fl2039) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl2039 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</special-or-reserved-values>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<special-or-reserved-values");
if (typeId){
pw.Write(" xsi:type=\"special-or-reserved-values\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</special-or-reserved-values>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSpecial_or_reserved_values(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
for (int i = 0; i < countSpecial_or_reserved_values(); i++) {
  l.Add(getSpecial_or_reserved_values(i));
}
}

}
public partial class special_or_reserved_value
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.special_or_reserved_valueController.alertChange(aLock, this);
}
private  mask aMask;

public  mask getMask() { return aMask;}

public  void setMask(mask v) {
  aMask = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  match aMatch;

public  match getMatch() { return aMatch;}

public  void setMatch(match v) {
  aMatch = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  match_range aMatch_range;

public  match_range getMatch_range() { return aMatch_range;}

public  void setMatch_range(match_range v) {
  aMatch_range = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  meaning aMeaning;

public  meaning getMeaning() { return aMeaning;}

public  void setMeaning(meaning v) {
  aMeaning = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  value aValue;

public  value getValue() { return aValue;}

public  void setValue(value v) {
  aValue = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


public special_or_reserved_value()
{
special_or_reserved_value obj = this;
aMask=(null);
aMatch=(null);
aMatch_range=(null);
aMeaning=(null);
aValue=(null);
}

public void copyTo(special_or_reserved_value other)
{
other.aMask = aMask;
other.aMatch = aMatch;
other.aMatch_range = aMatch_range;
other.aMeaning = aMeaning;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
int fl2042;

ctxt.skipWhiteSpace();
// Element Ref : mask
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<mask")){
// Parsing sub element
this.setMask(acceptor.lAccept_mask(ctxt,null));
setSon(this.getMask());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Disjunct
ctxt.skipWhiteSpace();
// Nullable formula
fl2042 = ctxt.getPtr();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
if (ctxt.lookAheadString("match")){
switch (ctxt.current()) {
case '-':
{
ctxt.advance();
if (ctxt.lookAheadString("range")){
indicator = 2041;
} else {
ctxt.moveBack(1);
indicator = 2040;
} // If
break;
} // Case
default:
indicator = 2040;
break;
} // Switch
} else {
ctxt.moveBack(1);
indicator = 2043;
} // If
break;
} // Case
default:
indicator = 2043;
break;
} // Switch
switch (indicator) {
// Dispatch Lablel
case 2040: {
ctxt.moveBack(6);
// Element Ref : match
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<match")){
// Parsing sub element
this.setMatch(acceptor.lAccept_match(ctxt,null));
setSon(this.getMatch());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Dispatch Lablel
case 2041: {
ctxt.moveBack(12);
// Element Ref : match-range
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<match-range")){
// Parsing sub element
this.setMatch_range(acceptor.lAccept_match_range(ctxt,null));
setSon(this.getMatch_range());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Optional of PCdata
case 2043: {
ctxt.setPtr(fl2042);
// Doing nothing, optional disj
break;
} // End of dispatch label
} // Dispatch
// End Disjunct
// Element Ref : meaning
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<meaning")){
// Parsing sub element
this.setMeaning(acceptor.lAccept_meaning(ctxt,null));
setSon(this.getMeaning());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Element Ref : value
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<value")){
// Parsing sub element
this.setValue(acceptor.lAccept_value(ctxt,null));
setSon(this.getValue());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2047;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl2047 = true ; 
while (fl2047) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl2047 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</special-or-reserved-value>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<special-or-reserved-value");
if (typeId){
pw.Write(" xsi:type=\"special-or-reserved-value\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</special-or-reserved-value>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing ElementRef
if (this.getMask() != null){
unParse(pw, this.getMask(), false, null, null);
} // If
// Unparsing Disjunct
if (this.getMatch() != null){
// Unparsing ElementRef
if (this.getMatch() != null){
unParse(pw, this.getMatch(), false, null, null);
} // If
} else {
if (this.getMatch_range() != null){
// Unparsing ElementRef
if (this.getMatch_range() != null){
unParse(pw, this.getMatch_range(), false, null, null);
} // If
} // If
} // If
// Unparsing ElementRef
if (this.getMeaning() != null){
unParse(pw, this.getMeaning(), false, null, null);
} // If
// Unparsing ElementRef
if (this.getValue() != null){
unParse(pw, this.getValue(), false, null, null);
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
l.Add(this.getMask());
l.Add(this.getMatch());
l.Add(this.getMatch_range());
l.Add(this.getMeaning());
l.Add(this.getValue());
}

}
public partial class mask
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.maskController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public mask()
{
mask obj = this;
aValue=(null);
}

public void copyTo(mask other)
{
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2048;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl2048 = true ; 
while (fl2048) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl2048 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</mask>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<mask");
if (typeId){
pw.Write(" xsi:type=\"mask\"");
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</mask>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class match
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.matchController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public match()
{
match obj = this;
aValue=(null);
}

public void copyTo(match other)
{
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2049;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl2049 = true ; 
while (fl2049) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl2049 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</match>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<match");
if (typeId){
pw.Write(" xsi:type=\"match\"");
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</match>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class meaning
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getBl().CompareTo((String) search) == 0)return true;
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.meaningController.alertChange(aLock, this);
}
private  acceptor.meaning_type aType;

public  acceptor.meaning_type getType() { return aType;}

public  void setType(acceptor.meaning_type v) {
  aType = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getType_AsString()
{
  return acceptor.Enum_meaning_type_ToString (aType);
}

public  bool setType_AsString( string  v)
{
 acceptor.meaning_type  temp = acceptor.StringTo_Enum_meaning_type(v);
if (temp >= 0){
  aType = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public meaning()
{
meaning obj = this;
aType=(0);
aBl=(null);
aValue=(null);
}

public void copyTo(meaning other)
{
other.aType = aType;
other.aBl = aBl;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2050;
bool fl2051;
bool fl2052;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl2050 = false ; 
fl2051 = false ; 
fl2052 = true ; 
while (fl2052) { // BeginLoop 
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 2050;
} else {
indicator = 2053;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 2051;
} else {
indicator = 2053;
} // If
break;
} // Case
default:
indicator = 2053;
break;
} // Switch
switch (indicator) {
case 2050: {
// Handling attribute type
// Also handles alien attributes with prefix type
if (fl2050){
ctxt.fail ("Duplicate attribute: type");
} // If
fl2050 = true ; 
quoteChar = ctxt.acceptQuote();
this.setType(acceptor.lAcceptEnum_meaning_type(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 2051: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl2051){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl2051 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 2053: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl2050){
ctxt.fail ("Mandatory attribute missing: type in meaning");
} // If
fl2052 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</meaning>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<meaning");
if (typeId){
pw.Write(" xsi:type=\"meaning\"");
} // If
pw.Write('\n');
pw.Write(" type=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_meaning_type_ToString(this.getType()));
pw.Write('"');
pw.Write('\n');
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</meaning>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
if (this.getValue() != null){
acceptor.unParsePcData(pw, this.getValue());
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class match_range
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getMinimum().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.match_rangeController.alertChange(aLock, this);
}
private   string  aMinimum;

public   string  getMinimum() { return aMinimum;}

public  void setMinimum( string  v) {
  aMinimum = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.maximum_Value aMaximum;

public  acceptor.maximum_Value getMaximum() { return aMaximum;}

public  void setMaximum(acceptor.maximum_Value v) {
  aMaximum = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMaximum_AsString()
{
  return acceptor.Enum_maximum_Value_ToString (aMaximum);
}

public  bool setMaximum_AsString( string  v)
{
 acceptor.maximum_Value  temp = acceptor.StringTo_Enum_maximum_Value(v);
if (temp >= 0){
  aMaximum = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public match_range()
{
match_range obj = this;
aMinimum=(null);
aMaximum=(0);
}

public void copyTo(match_range other)
{
other.aMinimum = aMinimum;
other.aMaximum = aMaximum;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl2057;
bool fl2058;

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<minimum");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl2057 = true ; 
while (fl2057) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl2057 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setMinimum(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</minimum>");
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<maximum");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl2058 = true ; 
while (fl2058) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl2058 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
ctxt.skipWhiteSpace();
// Parse PC data
this.setMaximum(acceptor.lAcceptEnum_maximum_Value(ctxt));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</maximum>");
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2059;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl2059 = true ; 
while (fl2059) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl2059 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</match-range>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<match-range");
if (typeId){
pw.Write(" xsi:type=\"match-range\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</match-range>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Enclosed
pw.Write("<minimum>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getMinimum());
pw.Write("</minimum>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<maximum>");
// Unparsing PcData
acceptor.unParsePcData(pw,
  acceptor.Enum_maximum_Value_ToString(this.getMaximum()));
pw.Write("</maximum>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class resolution_formula
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.resolution_formulaController.alertChange(aLock, this);
}
private  acceptor.resolution_formula_units aUnits;

public  acceptor.resolution_formula_units getUnits() { return aUnits;}

public  void setUnits(acceptor.resolution_formula_units v) {
  aUnits = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getUnits_AsString()
{
  return acceptor.Enum_resolution_formula_units_ToString (aUnits);
}

public  bool setUnits_AsString( string  v)
{
 acceptor.resolution_formula_units  temp = acceptor.StringTo_Enum_resolution_formula_units(v);
if (temp >= 0){
  aUnits = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.resolution_formula_Value aValue;

public  acceptor.resolution_formula_Value getValue() { return aValue;}

public  void setValue(acceptor.resolution_formula_Value v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getValue_AsString()
{
  return acceptor.Enum_resolution_formula_Value_ToString (aValue);
}

public  bool setValue_AsString( string  v)
{
 acceptor.resolution_formula_Value  temp = acceptor.StringTo_Enum_resolution_formula_Value(v);
if (temp >= 0){
  aValue = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public resolution_formula()
{
resolution_formula obj = this;
aUnits=(0);
aValue=(0);
}

public void copyTo(resolution_formula other)
{
other.aUnits = aUnits;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
ctxt.skipWhiteSpace();
// Parse PC data
this.setValue(acceptor.lAcceptEnum_resolution_formula_Value(ctxt));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2060;
bool fl2061;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl2060 = false ; 
fl2061 = true ; 
while (fl2061) { // BeginLoop 
if (ctxt.lookAheadString("units=")){
indicator = 2060;
} else {
indicator = 2062;
} // If
switch (indicator) {
case 2060: {
// Handling attribute units
// Also handles alien attributes with prefix units
if (fl2060){
ctxt.fail ("Duplicate attribute: units");
} // If
fl2060 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUnits(acceptor.lAcceptEnum_resolution_formula_units(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 2062: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl2061 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</resolution-formula>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<resolution-formula");
if (typeId){
pw.Write(" xsi:type=\"resolution-formula\"");
} // If
pw.Write('\n');
if (this.getUnits() != 0){
pw.Write(" units=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_resolution_formula_units_ToString(this.getUnits()));
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</resolution-formula>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw,
  acceptor.Enum_resolution_formula_Value_ToString(this.getValue()));
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class value
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getUnits().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.valueController.alertChange(aLock, this);
}
private   string  aUnits;

public   string  getUnits() { return aUnits;}

public  void setUnits( string  v) {
  aUnits = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aValue;

public  int getValue() { return aValue;}

public  void setValue(int v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public value()
{
value obj = this;
aUnits=(null);
aValue=(0);
}

public void copyTo(value other)
{
other.aUnits = aUnits;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
ctxt.skipWhiteSpace();
// Parse PC data
this.setValue(ctxt.fetchInteger());
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2064;
bool fl2065;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl2064 = false ; 
fl2065 = true ; 
while (fl2065) { // BeginLoop 
if (ctxt.lookAheadString("units=")){
indicator = 2064;
} else {
indicator = 2066;
} // If
switch (indicator) {
case 2064: {
// Handling attribute units
// Also handles alien attributes with prefix units
if (fl2064){
ctxt.fail ("Duplicate attribute: units");
} // If
fl2064 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUnits((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 2066: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl2064){
ctxt.fail ("Mandatory attribute missing: units in value");
} // If
fl2065 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</value>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<value");
if (typeId){
pw.Write(" xsi:type=\"value\"");
} // If
pw.Write('\n');
pw.Write(" units=\"");
acceptor.unParsePcData(pw, this.getUnits());
pw.Write('"');
pw.Write('\n');
pw.Write('>');
unParseBody(pw);
pw.Write("</value>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class char_value
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getEncoding().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.char_valueController.alertChange(aLock, this);
}
private   string  aEncoding;

public   string  getEncoding() { return aEncoding;}

public  void setEncoding( string  v) {
  aEncoding = v;
  __setDirty(true);
  NotifyControllers(null);
}


public char_value()
{
char_value obj = this;
aEncoding=(null);
}

public void copyTo(char_value other)
{
other.aEncoding = aEncoding;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2068;
bool fl2069;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl2068 = false ; 
fl2069 = true ; 
while (fl2069) { // BeginLoop 
if (ctxt.lookAheadString("encoding=")){
indicator = 2068;
} else {
indicator = 2070;
} // If
switch (indicator) {
case 2068: {
// Handling attribute encoding
// Also handles alien attributes with prefix encoding
if (fl2068){
ctxt.fail ("Duplicate attribute: encoding");
} // If
fl2068 = true ; 
quoteChar = ctxt.acceptQuote();
this.setEncoding((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 2070: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl2068){
ctxt.fail ("Mandatory attribute missing: encoding in char-value");
} // If
fl2069 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</char-value>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<char-value");
if (typeId){
pw.Write(" xsi:type=\"char-value\"");
} // If
pw.Write('\n');
pw.Write(" encoding=\"");
acceptor.unParsePcData(pw, this.getEncoding());
pw.Write('"');
pw.Write('\n');
pw.Write("/>");
pw.Write('\n');
unParseBody(pw);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class ParagraphRevision
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getText().CompareTo((String) search) == 0)return true;
if(getVersion().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ParagraphRevisionController.alertChange(aLock, this);
}
private   string  aText;

public   string  getText() { return aText;}

public  void setText( string  v) {
  aText = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aVersion;

public   string  getVersion() { return aVersion;}

public  void setVersion( string  v) {
  aVersion = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ParagraphRevision()
{
ParagraphRevision obj = this;
aText=(null);
aVersion=(null);
}

public void copyTo(ParagraphRevision other)
{
base.copyTo(other);
other.aText = aText;
other.aVersion = aVersion;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Indicator
// Parse PC data
this.setText(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl2072;
bool fl2073;
bool fl2074;
bool fl2075;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl2072 = false ; 
fl2073 = false ; 
fl2074 = false ; 
fl2075 = true ; 
while (fl2075) { // BeginLoop 
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
if (ctxt.lookAheadString("ersion=")){
indicator = 2072;
} else {
indicator = 2076;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdates=")){
indicator = 2074;
} else {
indicator = 2076;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 2073;
} else {
indicator = 2076;
} // If
break;
} // Case
default:
indicator = 2076;
break;
} // Switch
switch (indicator) {
case 2072: {
// Handling attribute version
// Also handles alien attributes with prefix version
if (fl2072){
ctxt.fail ("Duplicate attribute: version");
} // If
fl2072 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVersion((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 2073: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl2073){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl2073 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 2074: {
// Handling attribute Updates
// Also handles alien attributes with prefix Updates
if (fl2074){
ctxt.fail ("Duplicate attribute: Updates");
} // If
fl2074 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUpdates((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 2076: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl2072){
ctxt.fail ("Mandatory attribute missing: version in ParagraphRevision");
} // If
fl2075 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ParagraphRevision";
  endingTag = "</ParagraphRevision>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ParagraphRevision\"");
} // If
pw.Write('\n');
pw.Write(" version=\"");
acceptor.unParsePcData(pw, this.getVersion());
pw.Write('"');
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getUpdates() != null){
pw.Write(" Updates=\"");
acceptor.unParsePcData(pw, this.getUpdates());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing PcData
acceptor.unParsePcData(pw, this.getText());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class ControllersManager
{
//BaseModelElement  BaseModelElement
public static Controller<BaseModelElement, IListener<BaseModelElement>> BaseModelElementController = new Controller<BaseModelElement, IListener<BaseModelElement>>();
//Namable  Namable
public static Controller<Namable, IListener<Namable>> NamableController = new Controller<Namable, IListener<Namable>>();
//ReferencesParagraph  ReferencesParagraph
public static Controller<ReferencesParagraph, IListener<ReferencesParagraph>> ReferencesParagraphController = new Controller<ReferencesParagraph, IListener<ReferencesParagraph>>();
//ReqRelated  ReqRelated
public static Controller<ReqRelated, IListener<ReqRelated>> ReqRelatedController = new Controller<ReqRelated, IListener<ReqRelated>>();
//Dictionary  Dictionary
public static Controller<Dictionary, IListener<Dictionary>> DictionaryController = new Controller<Dictionary, IListener<Dictionary>>();
//RuleDisabling  RuleDisabling
public static Controller<RuleDisabling, IListener<RuleDisabling>> RuleDisablingController = new Controller<RuleDisabling, IListener<RuleDisabling>>();
//NameSpaceRef  NameSpaceRef
public static Controller<NameSpaceRef, IListener<NameSpaceRef>> NameSpaceRefController = new Controller<NameSpaceRef, IListener<NameSpaceRef>>();
//NameSpace  NameSpace
public static Controller<NameSpace, IListener<NameSpace>> NameSpaceController = new Controller<NameSpace, IListener<NameSpace>>();
//ReqRef  ReqRef
public static Controller<ReqRef, IListener<ReqRef>> ReqRefController = new Controller<ReqRef, IListener<ReqRef>>();
//Type  Type
public static Controller<Type, IListener<Type>> TypeController = new Controller<Type, IListener<Type>>();
//Enum  Enum
public static Controller<Enum, IListener<Enum>> EnumController = new Controller<Enum, IListener<Enum>>();
//EnumValue  EnumValue
public static Controller<EnumValue, IListener<EnumValue>> EnumValueController = new Controller<EnumValue, IListener<EnumValue>>();
//Range  Range
public static Controller<Range, IListener<Range>> RangeController = new Controller<Range, IListener<Range>>();
//Structure  Structure
public static Controller<Structure, IListener<Structure>> StructureController = new Controller<Structure, IListener<Structure>>();
//StructureRef  StructureRef
public static Controller<StructureRef, IListener<StructureRef>> StructureRefController = new Controller<StructureRef, IListener<StructureRef>>();
//StructureElement  StructureElement
public static Controller<StructureElement, IListener<StructureElement>> StructureElementController = new Controller<StructureElement, IListener<StructureElement>>();
//Collection  Collection
public static Controller<Collection, IListener<Collection>> CollectionController = new Controller<Collection, IListener<Collection>>();
//Function  Function
public static Controller<Function, IListener<Function>> FunctionController = new Controller<Function, IListener<Function>>();
//Parameter  Parameter
public static Controller<Parameter, IListener<Parameter>> ParameterController = new Controller<Parameter, IListener<Parameter>>();
//Case  Case
public static Controller<Case, IListener<Case>> CaseController = new Controller<Case, IListener<Case>>();
//Procedure  Procedure
public static Controller<Procedure, IListener<Procedure>> ProcedureController = new Controller<Procedure, IListener<Procedure>>();
//StateMachine  StateMachine
public static Controller<StateMachine, IListener<StateMachine>> StateMachineController = new Controller<StateMachine, IListener<StateMachine>>();
//State  State
public static Controller<State, IListener<State>> StateController = new Controller<State, IListener<State>>();
//Variable  Variable
public static Controller<Variable, IListener<Variable>> VariableController = new Controller<Variable, IListener<Variable>>();
//Rule  Rule
public static Controller<Rule, IListener<Rule>> RuleController = new Controller<Rule, IListener<Rule>>();
//RuleCondition  RuleCondition
public static Controller<RuleCondition, IListener<RuleCondition>> RuleConditionController = new Controller<RuleCondition, IListener<RuleCondition>>();
//PreCondition  PreCondition
public static Controller<PreCondition, IListener<PreCondition>> PreConditionController = new Controller<PreCondition, IListener<PreCondition>>();
//Action  Action
public static Controller<Action, IListener<Action>> ActionController = new Controller<Action, IListener<Action>>();
//FrameRef  FrameRef
public static Controller<FrameRef, IListener<FrameRef>> FrameRefController = new Controller<FrameRef, IListener<FrameRef>>();
//Frame  Frame
public static Controller<Frame, IListener<Frame>> FrameController = new Controller<Frame, IListener<Frame>>();
//SubSequence  SubSequence
public static Controller<SubSequence, IListener<SubSequence>> SubSequenceController = new Controller<SubSequence, IListener<SubSequence>>();
//TestCase  TestCase
public static Controller<TestCase, IListener<TestCase>> TestCaseController = new Controller<TestCase, IListener<TestCase>>();
//Step  Step
public static Controller<Step, IListener<Step>> StepController = new Controller<Step, IListener<Step>>();
//SubStep  SubStep
public static Controller<SubStep, IListener<SubStep>> SubStepController = new Controller<SubStep, IListener<SubStep>>();
//Expectation  Expectation
public static Controller<Expectation, IListener<Expectation>> ExpectationController = new Controller<Expectation, IListener<Expectation>>();
//DBMessage  DBMessage
public static Controller<DBMessage, IListener<DBMessage>> DBMessageController = new Controller<DBMessage, IListener<DBMessage>>();
//DBPacket  DBPacket
public static Controller<DBPacket, IListener<DBPacket>> DBPacketController = new Controller<DBPacket, IListener<DBPacket>>();
//DBField  DBField
public static Controller<DBField, IListener<DBField>> DBFieldController = new Controller<DBField, IListener<DBField>>();
//TranslationDictionary  TranslationDictionary
public static Controller<TranslationDictionary, IListener<TranslationDictionary>> TranslationDictionaryController = new Controller<TranslationDictionary, IListener<TranslationDictionary>>();
//Folder  Folder
public static Controller<Folder, IListener<Folder>> FolderController = new Controller<Folder, IListener<Folder>>();
//Translation  Translation
public static Controller<Translation, IListener<Translation>> TranslationController = new Controller<Translation, IListener<Translation>>();
//SourceText  SourceText
public static Controller<SourceText, IListener<SourceText>> SourceTextController = new Controller<SourceText, IListener<SourceText>>();
//SourceTextComment  SourceTextComment
public static Controller<SourceTextComment, IListener<SourceTextComment>> SourceTextCommentController = new Controller<SourceTextComment, IListener<SourceTextComment>>();
//ShortcutDictionary  ShortcutDictionary
public static Controller<ShortcutDictionary, IListener<ShortcutDictionary>> ShortcutDictionaryController = new Controller<ShortcutDictionary, IListener<ShortcutDictionary>>();
//ShortcutFolder  ShortcutFolder
public static Controller<ShortcutFolder, IListener<ShortcutFolder>> ShortcutFolderController = new Controller<ShortcutFolder, IListener<ShortcutFolder>>();
//Shortcut  Shortcut
public static Controller<Shortcut, IListener<Shortcut>> ShortcutController = new Controller<Shortcut, IListener<Shortcut>>();
//RequirementSet  RequirementSet
public static Controller<RequirementSet, IListener<RequirementSet>> RequirementSetController = new Controller<RequirementSet, IListener<RequirementSet>>();
//RequirementSetDependancy  RequirementSetDependancy
public static Controller<RequirementSetDependancy, IListener<RequirementSetDependancy>> RequirementSetDependancyController = new Controller<RequirementSetDependancy, IListener<RequirementSetDependancy>>();
//Specification  Specification
public static Controller<Specification, IListener<Specification>> SpecificationController = new Controller<Specification, IListener<Specification>>();
//ChapterRef  ChapterRef
public static Controller<ChapterRef, IListener<ChapterRef>> ChapterRefController = new Controller<ChapterRef, IListener<ChapterRef>>();
//Chapter  Chapter
public static Controller<Chapter, IListener<Chapter>> ChapterController = new Controller<Chapter, IListener<Chapter>>();
//Paragraph  Paragraph
public static Controller<Paragraph, IListener<Paragraph>> ParagraphController = new Controller<Paragraph, IListener<Paragraph>>();
//RequirementSetReference  RequirementSetReference
public static Controller<RequirementSetReference, IListener<RequirementSetReference>> RequirementSetReferenceController = new Controller<RequirementSetReference, IListener<RequirementSetReference>>();
//Message  Message
public static Controller<Message, IListener<Message>> MessageController = new Controller<Message, IListener<Message>>();
//MsgVariable  MsgVariable
public static Controller<MsgVariable, IListener<MsgVariable>> MsgVariableController = new Controller<MsgVariable, IListener<MsgVariable>>();
//TypeSpec  TypeSpec
public static Controller<TypeSpec, IListener<TypeSpec>> TypeSpecController = new Controller<TypeSpec, IListener<TypeSpec>>();
//Values  Values
public static Controller<Values, IListener<Values>> ValuesController = new Controller<Values, IListener<Values>>();
//special-or-reserved-values  special_or_reserved_values
public static Controller<special_or_reserved_values, IListener<special_or_reserved_values>> special_or_reserved_valuesController = new Controller<special_or_reserved_values, IListener<special_or_reserved_values>>();
//special-or-reserved-value  special_or_reserved_value
public static Controller<special_or_reserved_value, IListener<special_or_reserved_value>> special_or_reserved_valueController = new Controller<special_or_reserved_value, IListener<special_or_reserved_value>>();
//mask  mask
public static Controller<mask, IListener<mask>> maskController = new Controller<mask, IListener<mask>>();
//match  match
public static Controller<match, IListener<match>> matchController = new Controller<match, IListener<match>>();
//meaning  meaning
public static Controller<meaning, IListener<meaning>> meaningController = new Controller<meaning, IListener<meaning>>();
//match-range  match_range
public static Controller<match_range, IListener<match_range>> match_rangeController = new Controller<match_range, IListener<match_range>>();
//resolution-formula  resolution_formula
public static Controller<resolution_formula, IListener<resolution_formula>> resolution_formulaController = new Controller<resolution_formula, IListener<resolution_formula>>();
//value  value
public static Controller<value, IListener<value>> valueController = new Controller<value, IListener<value>>();
//char-value  char_value
public static Controller<char_value, IListener<char_value>> char_valueController = new Controller<char_value, IListener<char_value>>();
//ParagraphRevision  ParagraphRevision
public static Controller<ParagraphRevision, IListener<ParagraphRevision>> ParagraphRevisionController = new Controller<ParagraphRevision, IListener<ParagraphRevision>>();
public static void ActivateAllNotifications(){
BaseModelElementController.ActivateNotification();
NamableController.ActivateNotification();
ReferencesParagraphController.ActivateNotification();
ReqRelatedController.ActivateNotification();
DictionaryController.ActivateNotification();
RuleDisablingController.ActivateNotification();
NameSpaceRefController.ActivateNotification();
NameSpaceController.ActivateNotification();
ReqRefController.ActivateNotification();
TypeController.ActivateNotification();
EnumController.ActivateNotification();
EnumValueController.ActivateNotification();
RangeController.ActivateNotification();
StructureController.ActivateNotification();
StructureRefController.ActivateNotification();
StructureElementController.ActivateNotification();
CollectionController.ActivateNotification();
FunctionController.ActivateNotification();
ParameterController.ActivateNotification();
CaseController.ActivateNotification();
ProcedureController.ActivateNotification();
StateMachineController.ActivateNotification();
StateController.ActivateNotification();
VariableController.ActivateNotification();
RuleController.ActivateNotification();
RuleConditionController.ActivateNotification();
PreConditionController.ActivateNotification();
ActionController.ActivateNotification();
FrameRefController.ActivateNotification();
FrameController.ActivateNotification();
SubSequenceController.ActivateNotification();
TestCaseController.ActivateNotification();
StepController.ActivateNotification();
SubStepController.ActivateNotification();
ExpectationController.ActivateNotification();
DBMessageController.ActivateNotification();
DBPacketController.ActivateNotification();
DBFieldController.ActivateNotification();
TranslationDictionaryController.ActivateNotification();
FolderController.ActivateNotification();
TranslationController.ActivateNotification();
SourceTextController.ActivateNotification();
SourceTextCommentController.ActivateNotification();
ShortcutDictionaryController.ActivateNotification();
ShortcutFolderController.ActivateNotification();
ShortcutController.ActivateNotification();
RequirementSetController.ActivateNotification();
RequirementSetDependancyController.ActivateNotification();
SpecificationController.ActivateNotification();
ChapterRefController.ActivateNotification();
ChapterController.ActivateNotification();
ParagraphController.ActivateNotification();
RequirementSetReferenceController.ActivateNotification();
MessageController.ActivateNotification();
MsgVariableController.ActivateNotification();
TypeSpecController.ActivateNotification();
ValuesController.ActivateNotification();
special_or_reserved_valuesController.ActivateNotification();
special_or_reserved_valueController.ActivateNotification();
maskController.ActivateNotification();
matchController.ActivateNotification();
meaningController.ActivateNotification();
match_rangeController.ActivateNotification();
resolution_formulaController.ActivateNotification();
valueController.ActivateNotification();
char_valueController.ActivateNotification();
ParagraphRevisionController.ActivateNotification();
}
public static void DesactivateAllNotifications(){
BaseModelElementController.DesactivateNotification();
NamableController.DesactivateNotification();
ReferencesParagraphController.DesactivateNotification();
ReqRelatedController.DesactivateNotification();
DictionaryController.DesactivateNotification();
RuleDisablingController.DesactivateNotification();
NameSpaceRefController.DesactivateNotification();
NameSpaceController.DesactivateNotification();
ReqRefController.DesactivateNotification();
TypeController.DesactivateNotification();
EnumController.DesactivateNotification();
EnumValueController.DesactivateNotification();
RangeController.DesactivateNotification();
StructureController.DesactivateNotification();
StructureRefController.DesactivateNotification();
StructureElementController.DesactivateNotification();
CollectionController.DesactivateNotification();
FunctionController.DesactivateNotification();
ParameterController.DesactivateNotification();
CaseController.DesactivateNotification();
ProcedureController.DesactivateNotification();
StateMachineController.DesactivateNotification();
StateController.DesactivateNotification();
VariableController.DesactivateNotification();
RuleController.DesactivateNotification();
RuleConditionController.DesactivateNotification();
PreConditionController.DesactivateNotification();
ActionController.DesactivateNotification();
FrameRefController.DesactivateNotification();
FrameController.DesactivateNotification();
SubSequenceController.DesactivateNotification();
TestCaseController.DesactivateNotification();
StepController.DesactivateNotification();
SubStepController.DesactivateNotification();
ExpectationController.DesactivateNotification();
DBMessageController.DesactivateNotification();
DBPacketController.DesactivateNotification();
DBFieldController.DesactivateNotification();
TranslationDictionaryController.DesactivateNotification();
FolderController.DesactivateNotification();
TranslationController.DesactivateNotification();
SourceTextController.DesactivateNotification();
SourceTextCommentController.DesactivateNotification();
ShortcutDictionaryController.DesactivateNotification();
ShortcutFolderController.DesactivateNotification();
ShortcutController.DesactivateNotification();
RequirementSetController.DesactivateNotification();
RequirementSetDependancyController.DesactivateNotification();
SpecificationController.DesactivateNotification();
ChapterRefController.DesactivateNotification();
ChapterController.DesactivateNotification();
ParagraphController.DesactivateNotification();
RequirementSetReferenceController.DesactivateNotification();
MessageController.DesactivateNotification();
MsgVariableController.DesactivateNotification();
TypeSpecController.DesactivateNotification();
ValuesController.DesactivateNotification();
special_or_reserved_valuesController.DesactivateNotification();
special_or_reserved_valueController.DesactivateNotification();
maskController.DesactivateNotification();
matchController.DesactivateNotification();
meaningController.DesactivateNotification();
match_rangeController.DesactivateNotification();
resolution_formulaController.DesactivateNotification();
valueController.DesactivateNotification();
char_valueController.DesactivateNotification();
ParagraphRevisionController.DesactivateNotification();
}
}
public partial class acceptor
: XmlBBaseAcceptor
{

public enum Paragraph_type {
     defaultParagraph_type,
     aTITLE,
     aDEFINITION,
     aNOTE,
     aDELETED,
     aREQUIREMENT,
     aTABLE_HEADER,
     aPROBLEM
};

public enum Paragraph_scope {
     defaultParagraph_scope,
     aOBU_AND_TRACK,
     aTRACK,
     aOBU,
     aROLLING_STOCK,
     aFLAGS
};

public enum Message_media {
     defaultMessage_media,
     aBalise_RBC,
     aAny,
     aRBC,
     aBalise,
     aBalise_loop_RIU,
     aLoop,
     aBalise_RBC_RIU,
     aAny_,
     aRIU,
     aRBC_RIU,
     aBalise_loop
};

public enum TypeSpec_ertms_type {
     defaultTypeSpec_ertms_type,
     adistance,
     agradient,
     alength,
     amiscellaneous,
     aclass_number,
     aidentity_number,
     aqualifier,
     atime_or_date,
     aspeed,
     atext
};

public enum meaning_type {
     defaultmeaning_type,
     ainvalid,
     aenum,
     aunknown,
     ainfinite
};

public enum maximum_Value {
     defaultmaximum_Value,
     a11,
     a15,
     a127,
     a1022,
     a255,
     aC_7,
     a1_55,
     a126,
     aE,
     a254,
     a125
};

public enum resolution_formula_units {
     defaultresolution_formula_units,
     m_s2,
     q_scale,
     percent,
     abyte,
     abit,
     text_string_element,
     m,
     A,
     s,
     ms,
     km_h
};

public enum resolution_formula_Value {
     defaultresolution_formula_Value,
     a0_05,
     aC_1,
     a10,
     a0_02,
     aintegers,
     aNumbers,
     aBinary_Coded_Decimal,
     aNumber,
     aBitset,
     aC_5
};

public enum VariableModeEnumType {
     defaultVariableModeEnumType,
     aIncoming,
     aOutgoing,
     aInternal,
     aInOut,
     aConstant
};

public enum MessageEnumType {
     defaultMessageEnumType,
     aEurobalise,
     aEuroloop,
     aValidatedTrainData,
     aRequestForShunting,
     aMARequest,
     aTrainPositionReport,
     aRequestToShortenMAIsGranted,
     aRequestToShortenMAIsRejected,
     aAcknowledgement,
     aAcknowledgementOfEmergencyStop,
     aTrackAheadFreeGranted,
     aEndOfMission,
     aRadioInFillRequest,
     aTrain_NoCompatibleVersionSupported,
     aTrain_InitiationOfACommunicationSession,
     aTrain_TerminationOfACommunicationSession,
     aSoMPositionReport,
     aTrain_SessionEstablished,
     aSRAuthorization,
     aMovementAuthority,
     aRecognitionOfExitFromTripMode,
     aAcknowledgementOfTrainData,
     aRequestToShortenMA,
     aConditionalEmergencyStop,
     aUnconditionalEmergencyStop,
     aRevocationOfEmergencyStop,
     aGeneralMessage,
     aSHRefused,
     aSHAuthorized,
     aRBCRIUSystemVersion,
     aMAWithShiftedLocationReference,
     aTrackAheadFreeRequest,
     aInFillMA,
     aTrack_InitiationOfACommunicationSession,
     aAcknowledgementOfTerminationOfACommunicationSession,
     aTrainRejected,
     aTrainAccepted,
     aSomPositionReportConfirmedByRBC,
     aAssignmentOfCoordinateSystem
};

public enum MessageDirectionEnumType {
     defaultMessageDirectionEnumType,
     aTrainToTrack,
     aTrackToTrain
};

public enum SPEC_IMPLEMENTED_ENUM {
     defaultSPEC_IMPLEMENTED_ENUM,
     Impl_NA,
     Impl_Implemented,
     Impl_NotImplementable,
     Impl_NewRevisionAvailable
};

public enum ST_IO {
     defaultST_IO,
     StIO_NA,
     StIO_In,
     StIO_Out
};

public enum ST_INTERFACE {
     defaultST_INTERFACE,
     StInterface_NA,
     StInterface_DMI,
     StInterface_RTM,
     StInterface_JRU,
     StInterface_TIU
};

public enum ST_LEVEL {
     defaultST_LEVEL,
     StLevel_NA,
     StLevel_L0,
     StLevel_L1,
     StLevel_LSTM,
     StLevel_L2,
     StLevel_L3
};

public enum ST_MODE {
     defaultST_MODE,
     Mode_NA,
     Mode_IS,
     Mode_NP,
     Mode_SF,
     Mode_SL,
     Mode_SB,
     Mode_SH,
     Mode_FS,
     Mode_UF,
     Mode_SR,
     Mode_OS,
     Mode_TR,
     Mode_PT,
     Mode_NL,
     Mode_SN,
     Mode_RE,
     Mode_LS,
     Mode_PSH
};

public enum RulePriority {
     defaultRulePriority,
     aVerification,
     aUpdateINTERNAL,
     aProcessing,
     aUpdateOUT,
     aCleanUp
};

public enum PrecisionEnum {
     defaultPrecisionEnum,
     aIntegerPrecision,
     aDoublePrecision
};

public enum DBMessageType {
     defaultDBMessageType,
     aEUROBALISE,
     aEUROLOOP,
     aEURORADIO
};

public enum ExpectationKind {
     defaultExpectationKind,
     aInstantaneous,
     aContinuous
};

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Paragraph_type lAcceptEnum_Paragraph_type (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  Paragraph_type res = Paragraph_type.defaultParagraph_type;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
ctxt.accept3('T','L','E');
res = Paragraph_type.aTITLE;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("BLE_HEADER");
res = Paragraph_type.aTABLE_HEADER;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2084)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("EQUIREMENT")){
res = Paragraph_type.aREQUIREMENT;
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("ROBLEM")){
res = Paragraph_type.aPROBLEM;
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead3('O','T','E')){
res = Paragraph_type.aNOTE;
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAhead1('E')){
switch (ctxt.current()) {
case 'L':
{
ctxt.advance();
ctxt.acceptString ("ETED");
res = Paragraph_type.aDELETED;
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.acceptString ("INITION");
res = Paragraph_type.aDEFINITION;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2091)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
default:
res = Paragraph_type.aREQUIREMENT;
break;
} // Switch
return res;
}

public static  string  Enum_Paragraph_type_ToString (Paragraph_type v)
{
switch (v) {
 case Paragraph_type.aTITLE: return "TITLE";
 case Paragraph_type.aDEFINITION: return "DEFINITION";
 case Paragraph_type.aNOTE: return "NOTE";
 case Paragraph_type.aDELETED: return "DELETED";
 case Paragraph_type.aREQUIREMENT: return "REQUIREMENT";
 case Paragraph_type.aTABLE_HEADER: return "TABLE_HEADER";
 case Paragraph_type.aPROBLEM: return "PROBLEM";
} return "";
}

public static Paragraph_type StringTo_Enum_Paragraph_type( string  str)
{
if (str.Equals("TITLE")){
  return Paragraph_type.aTITLE;
} // If
if (str.Equals("DEFINITION")){
  return Paragraph_type.aDEFINITION;
} // If
if (str.Equals("NOTE")){
  return Paragraph_type.aNOTE;
} // If
if (str.Equals("DELETED")){
  return Paragraph_type.aDELETED;
} // If
if (str.Equals("REQUIREMENT")){
  return Paragraph_type.aREQUIREMENT;
} // If
if (str.Equals("TABLE_HEADER")){
  return Paragraph_type.aTABLE_HEADER;
} // If
if (str.Equals("PROBLEM")){
  return Paragraph_type.aPROBLEM;
} // If
return Paragraph_type.defaultParagraph_type;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Paragraph_scope lAcceptEnum_Paragraph_scope (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  Paragraph_scope res = Paragraph_scope.defaultParagraph_scope;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("RACK")){
res = Paragraph_scope.aTRACK;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("OLLING_STOCK")){
res = Paragraph_scope.aROLLING_STOCK;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead2('B','U')){
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
if (ctxt.lookAheadString("AND_TRACK")){
res = Paragraph_scope.aOBU_AND_TRACK;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU;
} // If
break;
} // Case
default:
res = Paragraph_scope.aOBU;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("LAGS")){
res = Paragraph_scope.aFLAGS;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
default:
res = Paragraph_scope.aOBU_AND_TRACK;
break;
} // Switch
return res;
}

public static  string  Enum_Paragraph_scope_ToString (Paragraph_scope v)
{
switch (v) {
 case Paragraph_scope.aOBU_AND_TRACK: return "OBU_AND_TRACK";
 case Paragraph_scope.aTRACK: return "TRACK";
 case Paragraph_scope.aOBU: return "OBU";
 case Paragraph_scope.aROLLING_STOCK: return "ROLLING_STOCK";
 case Paragraph_scope.aFLAGS: return "FLAGS";
} return "";
}

public static Paragraph_scope StringTo_Enum_Paragraph_scope( string  str)
{
if (str.Equals("OBU_AND_TRACK")){
  return Paragraph_scope.aOBU_AND_TRACK;
} // If
if (str.Equals("TRACK")){
  return Paragraph_scope.aTRACK;
} // If
if (str.Equals("OBU")){
  return Paragraph_scope.aOBU;
} // If
if (str.Equals("ROLLING_STOCK")){
  return Paragraph_scope.aROLLING_STOCK;
} // If
if (str.Equals("FLAGS")){
  return Paragraph_scope.aFLAGS;
} // If
return Paragraph_scope.defaultParagraph_scope;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Message_media lAcceptEnum_Message_media (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  Message_media res = Message_media.defaultMessage_media;
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
ctxt.accept('U');
res = Message_media.aRIU;
break;
} // Case
case 'B':
{
ctxt.advance();
ctxt.accept('C');
switch (ctxt.current()) {
case ',':
{
ctxt.advance();
if (ctxt.lookAheadString(" RIU")){
res = Message_media.aRBC_RIU;
} else {
ctxt.moveBack(1);
res = Message_media.aRBC;
} // If
break;
} // Case
default:
res = Message_media.aRBC;
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2101)");
break;
} // Switch
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAhead3('o','o','p')){
res = Message_media.aLoop;
} else {
ctxt.moveBack(1);
res = Message_media.aAny_;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
if (ctxt.lookAheadString("alise")){
switch (ctxt.current()) {
case ',':
{
ctxt.advance();
if (ctxt.lookAhead1(' ')){
switch (ctxt.current()) {
case 'l':
{
ctxt.advance();
ctxt.acceptString ("oop, RIU");
res = Message_media.aBalise_loop_RIU;
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.accept2('B','C');
switch (ctxt.current()) {
case ',':
{
ctxt.advance();
if (ctxt.lookAheadString(" RIU")){
res = Message_media.aBalise_RBC_RIU;
} else {
ctxt.moveBack(1);
res = Message_media.aBalise_RBC;
} // If
break;
} // Case
default:
res = Message_media.aBalise_RBC;
break;
} // Switch
break;
} // Case
case 'L':
{
ctxt.advance();
ctxt.accept3('o','o','p');
res = Message_media.aBalise_loop;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2109)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Message_media.aBalise;
} // If
break;
} // Case
default:
res = Message_media.aBalise;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Message_media.aAny_;
} // If
break;
} // Case
case 'A':
{
ctxt.advance();
if (ctxt.lookAhead2('n','y')){
switch (ctxt.current()) {
case ' ':
{
ctxt.advance();
res = Message_media.aAny_;
break;
} // Case
default:
res = Message_media.aAny;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Message_media.aAny_;
} // If
break;
} // Case
default:
res = Message_media.aAny_;
break;
} // Switch
return res;
}

public static  string  Enum_Message_media_ToString (Message_media v)
{
switch (v) {
 case Message_media.aBalise_RBC: return "Balise, RBC";
 case Message_media.aAny: return "Any";
 case Message_media.aRBC: return "RBC";
 case Message_media.aBalise: return "Balise";
 case Message_media.aBalise_loop_RIU: return "Balise, loop, RIU";
 case Message_media.aLoop: return "Loop";
 case Message_media.aBalise_RBC_RIU: return "Balise, RBC, RIU";
 case Message_media.aAny_: return "Any ";
 case Message_media.aRIU: return "RIU";
 case Message_media.aRBC_RIU: return "RBC, RIU";
 case Message_media.aBalise_loop: return "Balise, Loop";
} return "";
}

public static Message_media StringTo_Enum_Message_media( string  str)
{
if (str.Equals("Balise, RBC")){
  return Message_media.aBalise_RBC;
} // If
if (str.Equals("Any")){
  return Message_media.aAny;
} // If
if (str.Equals("RBC")){
  return Message_media.aRBC;
} // If
if (str.Equals("Balise")){
  return Message_media.aBalise;
} // If
if (str.Equals("Balise, loop, RIU")){
  return Message_media.aBalise_loop_RIU;
} // If
if (str.Equals("Loop")){
  return Message_media.aLoop;
} // If
if (str.Equals("Balise, RBC, RIU")){
  return Message_media.aBalise_RBC_RIU;
} // If
if (str.Equals("Any ")){
  return Message_media.aAny_;
} // If
if (str.Equals("RIU")){
  return Message_media.aRIU;
} // If
if (str.Equals("RBC, RIU")){
  return Message_media.aRBC_RIU;
} // If
if (str.Equals("Balise, Loop")){
  return Message_media.aBalise_loop;
} // If
return Message_media.defaultMessage_media;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TypeSpec_ertms_type lAcceptEnum_TypeSpec_ertms_type (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  TypeSpec_ertms_type res = TypeSpec_ertms_type.defaultTypeSpec_ertms_type;
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.acceptString ("me-or-date");
res = TypeSpec_ertms_type.atime_or_date;
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.accept2('x','t');
res = TypeSpec_ertms_type.atext;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2115)");
break;
} // Switch
break;
} // Case
case 's':
{
ctxt.advance();
if (ctxt.lookAheadString("peed")){
res = TypeSpec_ertms_type.aspeed;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'q':
{
ctxt.advance();
if (ctxt.lookAheadString("ualifier")){
res = TypeSpec_ertms_type.aqualifier;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("iscellaneous")){
res = TypeSpec_ertms_type.amiscellaneous;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'l':
{
ctxt.advance();
if (ctxt.lookAheadString("ength")){
res = TypeSpec_ertms_type.alength;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dentity-number")){
res = TypeSpec_ertms_type.aidentity_number;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("radient")){
res = TypeSpec_ertms_type.agradient;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'd':
{
ctxt.advance();
if (ctxt.lookAheadString("istance")){
res = TypeSpec_ertms_type.adistance;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("lass-number")){
res = TypeSpec_ertms_type.aclass_number;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_TypeSpec_ertms_type_ToString (TypeSpec_ertms_type v)
{
switch (v) {
 case TypeSpec_ertms_type.adistance: return "distance";
 case TypeSpec_ertms_type.agradient: return "gradient";
 case TypeSpec_ertms_type.alength: return "length";
 case TypeSpec_ertms_type.amiscellaneous: return "miscellaneous";
 case TypeSpec_ertms_type.aclass_number: return "class-number";
 case TypeSpec_ertms_type.aidentity_number: return "identity-number";
 case TypeSpec_ertms_type.aqualifier: return "qualifier";
 case TypeSpec_ertms_type.atime_or_date: return "time-or-date";
 case TypeSpec_ertms_type.aspeed: return "speed";
 case TypeSpec_ertms_type.atext: return "text";
} return "";
}

public static TypeSpec_ertms_type StringTo_Enum_TypeSpec_ertms_type( string  str)
{
if (str.Equals("distance")){
  return TypeSpec_ertms_type.adistance;
} // If
if (str.Equals("gradient")){
  return TypeSpec_ertms_type.agradient;
} // If
if (str.Equals("length")){
  return TypeSpec_ertms_type.alength;
} // If
if (str.Equals("miscellaneous")){
  return TypeSpec_ertms_type.amiscellaneous;
} // If
if (str.Equals("class-number")){
  return TypeSpec_ertms_type.aclass_number;
} // If
if (str.Equals("identity-number")){
  return TypeSpec_ertms_type.aidentity_number;
} // If
if (str.Equals("qualifier")){
  return TypeSpec_ertms_type.aqualifier;
} // If
if (str.Equals("time-or-date")){
  return TypeSpec_ertms_type.atime_or_date;
} // If
if (str.Equals("speed")){
  return TypeSpec_ertms_type.aspeed;
} // If
if (str.Equals("text")){
  return TypeSpec_ertms_type.atext;
} // If
return TypeSpec_ertms_type.defaultTypeSpec_ertms_type;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static meaning_type lAcceptEnum_meaning_type (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  meaning_type res = meaning_type.defaultmeaning_type;
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("nknown")){
res = meaning_type.aunknown;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAhead1('n')){
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
ctxt.acceptString ("alid");
res = meaning_type.ainvalid;
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.acceptString ("inite");
res = meaning_type.ainfinite;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2128)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
res = meaning_type.aenum;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_meaning_type_ToString (meaning_type v)
{
switch (v) {
 case meaning_type.ainvalid: return "invalid";
 case meaning_type.aenum: return "enum";
 case meaning_type.aunknown: return "unknown";
 case meaning_type.ainfinite: return "infinite";
} return "";
}

public static meaning_type StringTo_Enum_meaning_type( string  str)
{
if (str.Equals("invalid")){
  return meaning_type.ainvalid;
} // If
if (str.Equals("enum")){
  return meaning_type.aenum;
} // If
if (str.Equals("unknown")){
  return meaning_type.aunknown;
} // If
if (str.Equals("infinite")){
  return meaning_type.ainfinite;
} // If
return meaning_type.defaultmeaning_type;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static maximum_Value lAcceptEnum_maximum_Value (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  maximum_Value res = maximum_Value.defaultmaximum_Value;
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
res = maximum_Value.aE;
break;
} // Case
case '7':
{
ctxt.advance();
res = maximum_Value.aC_7;
break;
} // Case
case '2':
{
ctxt.advance();
if (ctxt.lookAhead1('5')){
switch (ctxt.current()) {
case '5':
{
ctxt.advance();
res = maximum_Value.a255;
break;
} // Case
case '4':
{
ctxt.advance();
res = maximum_Value.a254;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2135)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case '1':
{
ctxt.advance();
switch (ctxt.current()) {
case '5':
{
ctxt.advance();
res = maximum_Value.a15;
break;
} // Case
case '2':
{
ctxt.advance();
switch (ctxt.current()) {
case '7':
{
ctxt.advance();
res = maximum_Value.a127;
break;
} // Case
case '6':
{
ctxt.advance();
res = maximum_Value.a126;
break;
} // Case
case '5':
{
ctxt.advance();
res = maximum_Value.a125;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2142)");
break;
} // Switch
break;
} // Case
case '1':
{
ctxt.advance();
res = maximum_Value.a11;
break;
} // Case
case '0':
{
ctxt.advance();
ctxt.accept2('2','2');
res = maximum_Value.a1022;
break;
} // Case
case '.':
{
ctxt.advance();
ctxt.accept2('5','5');
res = maximum_Value.a1_55;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2146)");
break;
} // Switch
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_maximum_Value_ToString (maximum_Value v)
{
switch (v) {
 case maximum_Value.a11: return "11";
 case maximum_Value.a15: return "15";
 case maximum_Value.a127: return "127";
 case maximum_Value.a1022: return "1022";
 case maximum_Value.a255: return "255";
 case maximum_Value.aC_7: return "7";
 case maximum_Value.a1_55: return "1.55";
 case maximum_Value.a126: return "126";
 case maximum_Value.aE: return "E";
 case maximum_Value.a254: return "254";
 case maximum_Value.a125: return "125";
} return "";
}

public static maximum_Value StringTo_Enum_maximum_Value( string  str)
{
if (str.Equals("11")){
  return maximum_Value.a11;
} // If
if (str.Equals("15")){
  return maximum_Value.a15;
} // If
if (str.Equals("127")){
  return maximum_Value.a127;
} // If
if (str.Equals("1022")){
  return maximum_Value.a1022;
} // If
if (str.Equals("255")){
  return maximum_Value.a255;
} // If
if (str.Equals("7")){
  return maximum_Value.aC_7;
} // If
if (str.Equals("1.55")){
  return maximum_Value.a1_55;
} // If
if (str.Equals("126")){
  return maximum_Value.a126;
} // If
if (str.Equals("E")){
  return maximum_Value.aE;
} // If
if (str.Equals("254")){
  return maximum_Value.a254;
} // If
if (str.Equals("125")){
  return maximum_Value.a125;
} // If
return maximum_Value.defaultmaximum_Value;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static resolution_formula_units lAcceptEnum_resolution_formula_units (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  resolution_formula_units res = resolution_formula_units.defaultresolution_formula_units;
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAheadString("ext-string-element")){
res = resolution_formula_units.text_string_element;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 's':
{
ctxt.advance();
res = resolution_formula_units.s;
break;
} // Case
case 'q':
{
ctxt.advance();
if (ctxt.lookAheadString("_scale")){
res = resolution_formula_units.q_scale;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
res = resolution_formula_units.ms;
break;
} // Case
case '/':
{
ctxt.advance();
if (ctxt.lookAhead2('s','2')){
res = resolution_formula_units.m_s2;
} else {
ctxt.moveBack(1);
res = resolution_formula_units.m;
} // If
break;
} // Case
default:
res = resolution_formula_units.m;
break;
} // Switch
break;
} // Case
case 'k':
{
ctxt.advance();
if (ctxt.lookAhead3('m','/','h')){
res = resolution_formula_units.km_h;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
switch (ctxt.current()) {
case 'y':
{
ctxt.advance();
ctxt.accept2('t','e');
res = resolution_formula_units.abyte;
break;
} // Case
case 'i':
{
ctxt.advance();
ctxt.accept('t');
res = resolution_formula_units.abit;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2157)");
break;
} // Switch
break;
} // Case
case 'A':
{
ctxt.advance();
res = resolution_formula_units.A;
break;
} // Case
case '%':
{
ctxt.advance();
res = resolution_formula_units.percent;
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_resolution_formula_units_ToString (resolution_formula_units v)
{
switch (v) {
 case resolution_formula_units.m_s2: return "m/s2";
 case resolution_formula_units.q_scale: return "q_scale";
 case resolution_formula_units.percent: return "%";
 case resolution_formula_units.abyte: return "byte";
 case resolution_formula_units.abit: return "bit";
 case resolution_formula_units.text_string_element: return "text-string-element";
 case resolution_formula_units.m: return "m";
 case resolution_formula_units.A: return "A";
 case resolution_formula_units.s: return "s";
 case resolution_formula_units.ms: return "ms";
 case resolution_formula_units.km_h: return "km/h";
} return "";
}

public static resolution_formula_units StringTo_Enum_resolution_formula_units( string  str)
{
if (str.Equals("m/s2")){
  return resolution_formula_units.m_s2;
} // If
if (str.Equals("q_scale")){
  return resolution_formula_units.q_scale;
} // If
if (str.Equals("%")){
  return resolution_formula_units.percent;
} // If
if (str.Equals("byte")){
  return resolution_formula_units.abyte;
} // If
if (str.Equals("bit")){
  return resolution_formula_units.abit;
} // If
if (str.Equals("text-string-element")){
  return resolution_formula_units.text_string_element;
} // If
if (str.Equals("m")){
  return resolution_formula_units.m;
} // If
if (str.Equals("A")){
  return resolution_formula_units.A;
} // If
if (str.Equals("s")){
  return resolution_formula_units.s;
} // If
if (str.Equals("ms")){
  return resolution_formula_units.ms;
} // If
if (str.Equals("km/h")){
  return resolution_formula_units.km_h;
} // If
return resolution_formula_units.defaultresolution_formula_units;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static resolution_formula_Value lAcceptEnum_resolution_formula_Value (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  resolution_formula_Value res = resolution_formula_Value.defaultresolution_formula_Value;
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("ntegers")){
res = resolution_formula_Value.aintegers;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("umber")){
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
res = resolution_formula_Value.aNumbers;
break;
} // Case
default:
res = resolution_formula_Value.aNumber;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
if (ctxt.lookAhead1('i')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
ctxt.accept3('s','e','t');
res = resolution_formula_Value.aBitset;
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.acceptString ("ary Coded Decimal");
res = resolution_formula_Value.aBinary_Coded_Decimal;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2166)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case '5':
{
ctxt.advance();
res = resolution_formula_Value.aC_5;
break;
} // Case
case '1':
{
ctxt.advance();
switch (ctxt.current()) {
case '0':
{
ctxt.advance();
res = resolution_formula_Value.a10;
break;
} // Case
default:
res = resolution_formula_Value.aC_1;
break;
} // Switch
break;
} // Case
case '0':
{
ctxt.advance();
if (ctxt.lookAhead2('.','0')){
switch (ctxt.current()) {
case '5':
{
ctxt.advance();
res = resolution_formula_Value.a0_05;
break;
} // Case
case '2':
{
ctxt.advance();
res = resolution_formula_Value.a0_02;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2173)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_resolution_formula_Value_ToString (resolution_formula_Value v)
{
switch (v) {
 case resolution_formula_Value.a0_05: return "0.05";
 case resolution_formula_Value.aC_1: return "1";
 case resolution_formula_Value.a10: return "10";
 case resolution_formula_Value.a0_02: return "0.02";
 case resolution_formula_Value.aintegers: return "integers";
 case resolution_formula_Value.aNumbers: return "Numbers";
 case resolution_formula_Value.aBinary_Coded_Decimal: return "Binary Coded Decimal";
 case resolution_formula_Value.aNumber: return "Number";
 case resolution_formula_Value.aBitset: return "Bitset";
 case resolution_formula_Value.aC_5: return "5";
} return "";
}

public static resolution_formula_Value StringTo_Enum_resolution_formula_Value( string  str)
{
if (str.Equals("0.05")){
  return resolution_formula_Value.a0_05;
} // If
if (str.Equals("1")){
  return resolution_formula_Value.aC_1;
} // If
if (str.Equals("10")){
  return resolution_formula_Value.a10;
} // If
if (str.Equals("0.02")){
  return resolution_formula_Value.a0_02;
} // If
if (str.Equals("integers")){
  return resolution_formula_Value.aintegers;
} // If
if (str.Equals("Numbers")){
  return resolution_formula_Value.aNumbers;
} // If
if (str.Equals("Binary Coded Decimal")){
  return resolution_formula_Value.aBinary_Coded_Decimal;
} // If
if (str.Equals("Number")){
  return resolution_formula_Value.aNumber;
} // If
if (str.Equals("Bitset")){
  return resolution_formula_Value.aBitset;
} // If
if (str.Equals("5")){
  return resolution_formula_Value.aC_5;
} // If
return resolution_formula_Value.defaultresolution_formula_Value;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static VariableModeEnumType lAcceptEnum_VariableModeEnumType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  VariableModeEnumType res = VariableModeEnumType.defaultVariableModeEnumType;
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAheadString("utgoing")){
res = VariableModeEnumType.aOutgoing;
} else {
ctxt.moveBack(1);
res = VariableModeEnumType.aInternal;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('n')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
ctxt.acceptString ("ernal");
res = VariableModeEnumType.aInternal;
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("oming");
res = VariableModeEnumType.aIncoming;
break;
} // Case
case 'O':
{
ctxt.advance();
ctxt.accept2('u','t');
res = VariableModeEnumType.aInOut;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2179)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = VariableModeEnumType.aInternal;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("onstant")){
res = VariableModeEnumType.aConstant;
} else {
ctxt.moveBack(1);
res = VariableModeEnumType.aInternal;
} // If
break;
} // Case
default:
res = VariableModeEnumType.aInternal;
break;
} // Switch
return res;
}

public static  string  Enum_VariableModeEnumType_ToString (VariableModeEnumType v)
{
switch (v) {
 case VariableModeEnumType.aIncoming: return "Incoming";
 case VariableModeEnumType.aOutgoing: return "Outgoing";
 case VariableModeEnumType.aInternal: return "Internal";
 case VariableModeEnumType.aInOut: return "InOut";
 case VariableModeEnumType.aConstant: return "Constant";
} return "";
}

public static VariableModeEnumType StringTo_Enum_VariableModeEnumType( string  str)
{
if (str.Equals("Incoming")){
  return VariableModeEnumType.aIncoming;
} // If
if (str.Equals("Outgoing")){
  return VariableModeEnumType.aOutgoing;
} // If
if (str.Equals("Internal")){
  return VariableModeEnumType.aInternal;
} // If
if (str.Equals("InOut")){
  return VariableModeEnumType.aInOut;
} // If
if (str.Equals("Constant")){
  return VariableModeEnumType.aConstant;
} // If
return VariableModeEnumType.defaultVariableModeEnumType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static MessageEnumType lAcceptEnum_MessageEnumType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  MessageEnumType res = MessageEnumType.defaultMessageEnumType;
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alidatedTrainData")){
res = MessageEnumType.aValidatedTrainData;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("nconditionalEmergencyStop")){
res = MessageEnumType.aUnconditionalEmergencyStop;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.accept('n');
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
ctxt.acceptString ("erminationOfACommunicationSession");
res = MessageEnumType.aTrain_TerminationOfACommunicationSession;
break;
} // Case
case 'S':
{
ctxt.advance();
ctxt.acceptString ("essionEstablished");
res = MessageEnumType.aTrain_SessionEstablished;
break;
} // Case
case 'N':
{
ctxt.advance();
ctxt.acceptString ("oCompatibleVersionSupported");
res = MessageEnumType.aTrain_NoCompatibleVersionSupported;
break;
} // Case
case 'I':
{
ctxt.advance();
ctxt.acceptString ("nitiationOfACommunicationSession");
res = MessageEnumType.aTrain_InitiationOfACommunicationSession;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2190)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.acceptString ("ejected");
res = MessageEnumType.aTrainRejected;
break;
} // Case
case 'P':
{
ctxt.advance();
ctxt.acceptString ("ositionReport");
res = MessageEnumType.aTrainPositionReport;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("ccepted");
res = MessageEnumType.aTrainAccepted;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2194)");
break;
} // Switch
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.accept('k');
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
ctxt.acceptString ("InitiationOfACommunicationSession");
res = MessageEnumType.aTrack_InitiationOfACommunicationSession;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("headFree");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("equest");
res = MessageEnumType.aTrackAheadFreeRequest;
break;
} // Case
case 'G':
{
ctxt.advance();
ctxt.acceptString ("ranted");
res = MessageEnumType.aTrackAheadFreeGranted;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2200)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2201)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2202)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
ctxt.acceptString ("PositionReportConfirmedByRBC");
res = MessageEnumType.aSomPositionReportConfirmedByRBC;
break;
} // Case
case 'M':
{
ctxt.advance();
ctxt.acceptString ("PositionReport");
res = MessageEnumType.aSoMPositionReport;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2207)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.acceptString ("Authorization");
res = MessageEnumType.aSRAuthorization;
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("efused");
res = MessageEnumType.aSHRefused;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("uthorized");
res = MessageEnumType.aSHAuthorized;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2212)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2213)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
ctxt.acceptString ("ocationOfEmergencyStop");
res = MessageEnumType.aRevocationOfEmergencyStop;
break;
} // Case
case 'q':
{
ctxt.advance();
ctxt.acceptString ("uest");
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
ctxt.acceptString ("oShortenMA");
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('s')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("ejected");
res = MessageEnumType.aRequestToShortenMAIsRejected;
break;
} // Case
case 'G':
{
ctxt.advance();
ctxt.acceptString ("ranted");
res = MessageEnumType.aRequestToShortenMAIsGranted;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2222)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = MessageEnumType.aRequestToShortenMA;
} // If
break;
} // Case
default:
res = MessageEnumType.aRequestToShortenMA;
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.acceptString ("orShunting");
res = MessageEnumType.aRequestForShunting;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2224)");
break;
} // Switch
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("ognitionOfExitFromTripMode");
res = MessageEnumType.aRecognitionOfExitFromTripMode;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2226)");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.acceptString ("dioInFillRequest");
res = MessageEnumType.aRadioInFillRequest;
break;
} // Case
case 'B':
{
ctxt.advance();
ctxt.acceptString ("CRIUSystemVersion");
res = MessageEnumType.aRBCRIUSystemVersion;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2229)");
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("vementAuthority");
res = MessageEnumType.aMovementAuthority;
break;
} // Case
case 'A':
{
ctxt.advance();
switch (ctxt.current()) {
case 'W':
{
ctxt.advance();
ctxt.acceptString ("ithShiftedLocationReference");
res = MessageEnumType.aMAWithShiftedLocationReference;
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.acceptString ("equest");
res = MessageEnumType.aMARequest;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2235)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2236)");
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("nFillMA")){
res = MessageEnumType.aInFillMA;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("eneralMessage")){
res = MessageEnumType.aGeneralMessage;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.accept2('r','o');
switch (ctxt.current()) {
case 'l':
{
ctxt.advance();
ctxt.accept3('o','o','p');
res = MessageEnumType.aEuroloop;
break;
} // Case
case 'b':
{
ctxt.advance();
ctxt.acceptString ("alise");
res = MessageEnumType.aEurobalise;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2243)");
break;
} // Switch
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.acceptString ("dOfMission");
res = MessageEnumType.aEndOfMission;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2245)");
break;
} // Switch
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("onditionalEmergencyStop")){
res = MessageEnumType.aConditionalEmergencyStop;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'A':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
ctxt.acceptString ("signmentOfCoordinateSystem");
res = MessageEnumType.aAssignmentOfCoordinateSystem;
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("knowledgement");
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead1('f')){
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.acceptString ("ainData");
res = MessageEnumType.aAcknowledgementOfTrainData;
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("rminationOfACommunicationSession");
res = MessageEnumType.aAcknowledgementOfTerminationOfACommunicationSession;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2254)");
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
ctxt.acceptString ("mergencyStop");
res = MessageEnumType.aAcknowledgementOfEmergencyStop;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2256)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = MessageEnumType.aAcknowledgement;
} // If
break;
} // Case
default:
res = MessageEnumType.aAcknowledgement;
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2257)");
break;
} // Switch
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_MessageEnumType_ToString (MessageEnumType v)
{
switch (v) {
 case MessageEnumType.aEurobalise: return "Eurobalise";
 case MessageEnumType.aEuroloop: return "Euroloop";
 case MessageEnumType.aValidatedTrainData: return "ValidatedTrainData";
 case MessageEnumType.aRequestForShunting: return "RequestForShunting";
 case MessageEnumType.aMARequest: return "MARequest";
 case MessageEnumType.aTrainPositionReport: return "TrainPositionReport";
 case MessageEnumType.aRequestToShortenMAIsGranted: return "RequestToShortenMAIsGranted";
 case MessageEnumType.aRequestToShortenMAIsRejected: return "RequestToShortenMAIsRejected";
 case MessageEnumType.aAcknowledgement: return "Acknowledgement";
 case MessageEnumType.aAcknowledgementOfEmergencyStop: return "AcknowledgementOfEmergencyStop";
 case MessageEnumType.aTrackAheadFreeGranted: return "TrackAheadFreeGranted";
 case MessageEnumType.aEndOfMission: return "EndOfMission";
 case MessageEnumType.aRadioInFillRequest: return "RadioInFillRequest";
 case MessageEnumType.aTrain_NoCompatibleVersionSupported: return "Train_NoCompatibleVersionSupported";
 case MessageEnumType.aTrain_InitiationOfACommunicationSession: return "Train_InitiationOfACommunicationSession";
 case MessageEnumType.aTrain_TerminationOfACommunicationSession: return "Train_TerminationOfACommunicationSession";
 case MessageEnumType.aSoMPositionReport: return "SoMPositionReport";
 case MessageEnumType.aTrain_SessionEstablished: return "Train_SessionEstablished";
 case MessageEnumType.aSRAuthorization: return "SRAuthorization";
 case MessageEnumType.aMovementAuthority: return "MovementAuthority";
 case MessageEnumType.aRecognitionOfExitFromTripMode: return "RecognitionOfExitFromTripMode";
 case MessageEnumType.aAcknowledgementOfTrainData: return "AcknowledgementOfTrainData";
 case MessageEnumType.aRequestToShortenMA: return "RequestToShortenMA";
 case MessageEnumType.aConditionalEmergencyStop: return "ConditionalEmergencyStop";
 case MessageEnumType.aUnconditionalEmergencyStop: return "UnconditionalEmergencyStop";
 case MessageEnumType.aRevocationOfEmergencyStop: return "RevocationOfEmergencyStop";
 case MessageEnumType.aGeneralMessage: return "GeneralMessage";
 case MessageEnumType.aSHRefused: return "SHRefused";
 case MessageEnumType.aSHAuthorized: return "SHAuthorized";
 case MessageEnumType.aRBCRIUSystemVersion: return "RBCRIUSystemVersion";
 case MessageEnumType.aMAWithShiftedLocationReference: return "MAWithShiftedLocationReference";
 case MessageEnumType.aTrackAheadFreeRequest: return "TrackAheadFreeRequest";
 case MessageEnumType.aInFillMA: return "InFillMA";
 case MessageEnumType.aTrack_InitiationOfACommunicationSession: return "Track_InitiationOfACommunicationSession";
 case MessageEnumType.aAcknowledgementOfTerminationOfACommunicationSession: return "AcknowledgementOfTerminationOfACommunicationSession";
 case MessageEnumType.aTrainRejected: return "TrainRejected";
 case MessageEnumType.aTrainAccepted: return "TrainAccepted";
 case MessageEnumType.aSomPositionReportConfirmedByRBC: return "SomPositionReportConfirmedByRBC";
 case MessageEnumType.aAssignmentOfCoordinateSystem: return "AssignmentOfCoordinateSystem";
} return "";
}

public static MessageEnumType StringTo_Enum_MessageEnumType( string  str)
{
if (str.Equals("Eurobalise")){
  return MessageEnumType.aEurobalise;
} // If
if (str.Equals("Euroloop")){
  return MessageEnumType.aEuroloop;
} // If
if (str.Equals("ValidatedTrainData")){
  return MessageEnumType.aValidatedTrainData;
} // If
if (str.Equals("RequestForShunting")){
  return MessageEnumType.aRequestForShunting;
} // If
if (str.Equals("MARequest")){
  return MessageEnumType.aMARequest;
} // If
if (str.Equals("TrainPositionReport")){
  return MessageEnumType.aTrainPositionReport;
} // If
if (str.Equals("RequestToShortenMAIsGranted")){
  return MessageEnumType.aRequestToShortenMAIsGranted;
} // If
if (str.Equals("RequestToShortenMAIsRejected")){
  return MessageEnumType.aRequestToShortenMAIsRejected;
} // If
if (str.Equals("Acknowledgement")){
  return MessageEnumType.aAcknowledgement;
} // If
if (str.Equals("AcknowledgementOfEmergencyStop")){
  return MessageEnumType.aAcknowledgementOfEmergencyStop;
} // If
if (str.Equals("TrackAheadFreeGranted")){
  return MessageEnumType.aTrackAheadFreeGranted;
} // If
if (str.Equals("EndOfMission")){
  return MessageEnumType.aEndOfMission;
} // If
if (str.Equals("RadioInFillRequest")){
  return MessageEnumType.aRadioInFillRequest;
} // If
if (str.Equals("Train_NoCompatibleVersionSupported")){
  return MessageEnumType.aTrain_NoCompatibleVersionSupported;
} // If
if (str.Equals("Train_InitiationOfACommunicationSession")){
  return MessageEnumType.aTrain_InitiationOfACommunicationSession;
} // If
if (str.Equals("Train_TerminationOfACommunicationSession")){
  return MessageEnumType.aTrain_TerminationOfACommunicationSession;
} // If
if (str.Equals("SoMPositionReport")){
  return MessageEnumType.aSoMPositionReport;
} // If
if (str.Equals("Train_SessionEstablished")){
  return MessageEnumType.aTrain_SessionEstablished;
} // If
if (str.Equals("SRAuthorization")){
  return MessageEnumType.aSRAuthorization;
} // If
if (str.Equals("MovementAuthority")){
  return MessageEnumType.aMovementAuthority;
} // If
if (str.Equals("RecognitionOfExitFromTripMode")){
  return MessageEnumType.aRecognitionOfExitFromTripMode;
} // If
if (str.Equals("AcknowledgementOfTrainData")){
  return MessageEnumType.aAcknowledgementOfTrainData;
} // If
if (str.Equals("RequestToShortenMA")){
  return MessageEnumType.aRequestToShortenMA;
} // If
if (str.Equals("ConditionalEmergencyStop")){
  return MessageEnumType.aConditionalEmergencyStop;
} // If
if (str.Equals("UnconditionalEmergencyStop")){
  return MessageEnumType.aUnconditionalEmergencyStop;
} // If
if (str.Equals("RevocationOfEmergencyStop")){
  return MessageEnumType.aRevocationOfEmergencyStop;
} // If
if (str.Equals("GeneralMessage")){
  return MessageEnumType.aGeneralMessage;
} // If
if (str.Equals("SHRefused")){
  return MessageEnumType.aSHRefused;
} // If
if (str.Equals("SHAuthorized")){
  return MessageEnumType.aSHAuthorized;
} // If
if (str.Equals("RBCRIUSystemVersion")){
  return MessageEnumType.aRBCRIUSystemVersion;
} // If
if (str.Equals("MAWithShiftedLocationReference")){
  return MessageEnumType.aMAWithShiftedLocationReference;
} // If
if (str.Equals("TrackAheadFreeRequest")){
  return MessageEnumType.aTrackAheadFreeRequest;
} // If
if (str.Equals("InFillMA")){
  return MessageEnumType.aInFillMA;
} // If
if (str.Equals("Track_InitiationOfACommunicationSession")){
  return MessageEnumType.aTrack_InitiationOfACommunicationSession;
} // If
if (str.Equals("AcknowledgementOfTerminationOfACommunicationSession")){
  return MessageEnumType.aAcknowledgementOfTerminationOfACommunicationSession;
} // If
if (str.Equals("TrainRejected")){
  return MessageEnumType.aTrainRejected;
} // If
if (str.Equals("TrainAccepted")){
  return MessageEnumType.aTrainAccepted;
} // If
if (str.Equals("SomPositionReportConfirmedByRBC")){
  return MessageEnumType.aSomPositionReportConfirmedByRBC;
} // If
if (str.Equals("AssignmentOfCoordinateSystem")){
  return MessageEnumType.aAssignmentOfCoordinateSystem;
} // If
return MessageEnumType.defaultMessageEnumType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static MessageDirectionEnumType lAcceptEnum_MessageDirectionEnumType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  MessageDirectionEnumType res = MessageDirectionEnumType.defaultMessageDirectionEnumType;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.acceptString ("nToTrack");
res = MessageDirectionEnumType.aTrainToTrack;
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("kToTrain");
res = MessageDirectionEnumType.aTrackToTrain;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2261)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_MessageDirectionEnumType_ToString (MessageDirectionEnumType v)
{
switch (v) {
 case MessageDirectionEnumType.aTrainToTrack: return "TrainToTrack";
 case MessageDirectionEnumType.aTrackToTrain: return "TrackToTrain";
} return "";
}

public static MessageDirectionEnumType StringTo_Enum_MessageDirectionEnumType( string  str)
{
if (str.Equals("TrainToTrack")){
  return MessageDirectionEnumType.aTrainToTrack;
} // If
if (str.Equals("TrackToTrain")){
  return MessageDirectionEnumType.aTrackToTrain;
} // If
return MessageDirectionEnumType.defaultMessageDirectionEnumType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SPEC_IMPLEMENTED_ENUM lAcceptEnum_SPEC_IMPLEMENTED_ENUM (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  SPEC_IMPLEMENTED_ENUM res = SPEC_IMPLEMENTED_ENUM.defaultSPEC_IMPLEMENTED_ENUM;
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("tImplementable");
res = SPEC_IMPLEMENTED_ENUM.Impl_NotImplementable;
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("wRevisionAvailable");
res = SPEC_IMPLEMENTED_ENUM.Impl_NewRevisionAvailable;
break;
} // Case
case 'A':
{
ctxt.advance();
res = SPEC_IMPLEMENTED_ENUM.Impl_NA;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2266)");
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented")){
res = SPEC_IMPLEMENTED_ENUM.Impl_Implemented;
} else {
ctxt.moveBack(1);
res = SPEC_IMPLEMENTED_ENUM.Impl_NA;
} // If
break;
} // Case
default:
res = SPEC_IMPLEMENTED_ENUM.Impl_NA;
break;
} // Switch
return res;
}

public static  string  Enum_SPEC_IMPLEMENTED_ENUM_ToString (SPEC_IMPLEMENTED_ENUM v)
{
switch (v) {
 case SPEC_IMPLEMENTED_ENUM.Impl_NA: return "NA";
 case SPEC_IMPLEMENTED_ENUM.Impl_Implemented: return "Implemented";
 case SPEC_IMPLEMENTED_ENUM.Impl_NotImplementable: return "NotImplementable";
 case SPEC_IMPLEMENTED_ENUM.Impl_NewRevisionAvailable: return "NewRevisionAvailable";
} return "";
}

public static SPEC_IMPLEMENTED_ENUM StringTo_Enum_SPEC_IMPLEMENTED_ENUM( string  str)
{
if (str.Equals("NA")){
  return SPEC_IMPLEMENTED_ENUM.Impl_NA;
} // If
if (str.Equals("Implemented")){
  return SPEC_IMPLEMENTED_ENUM.Impl_Implemented;
} // If
if (str.Equals("NotImplementable")){
  return SPEC_IMPLEMENTED_ENUM.Impl_NotImplementable;
} // If
if (str.Equals("NewRevisionAvailable")){
  return SPEC_IMPLEMENTED_ENUM.Impl_NewRevisionAvailable;
} // If
return SPEC_IMPLEMENTED_ENUM.defaultSPEC_IMPLEMENTED_ENUM;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_IO lAcceptEnum_ST_IO (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_IO res = ST_IO.defaultST_IO;
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead2('u','t')){
res = ST_IO.StIO_Out;
} else {
ctxt.moveBack(1);
res = ST_IO.StIO_NA;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead1('A')){
res = ST_IO.StIO_NA;
} else {
ctxt.moveBack(1);
res = ST_IO.StIO_NA;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('n')){
res = ST_IO.StIO_In;
} else {
ctxt.moveBack(1);
res = ST_IO.StIO_NA;
} // If
break;
} // Case
default:
res = ST_IO.StIO_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_IO_ToString (ST_IO v)
{
switch (v) {
 case ST_IO.StIO_NA: return "NA";
 case ST_IO.StIO_In: return "In";
 case ST_IO.StIO_Out: return "Out";
} return "";
}

public static ST_IO StringTo_Enum_ST_IO( string  str)
{
if (str.Equals("NA")){
  return ST_IO.StIO_NA;
} // If
if (str.Equals("In")){
  return ST_IO.StIO_In;
} // If
if (str.Equals("Out")){
  return ST_IO.StIO_Out;
} // If
return ST_IO.defaultST_IO;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_INTERFACE lAcceptEnum_ST_INTERFACE (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_INTERFACE res = ST_INTERFACE.defaultST_INTERFACE;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead2('I','U')){
res = ST_INTERFACE.StInterface_TIU;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('T','M')){
res = ST_INTERFACE.StInterface_RTM;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead1('A')){
res = ST_INTERFACE.StInterface_NA;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'J':
{
ctxt.advance();
if (ctxt.lookAhead2('R','U')){
res = ST_INTERFACE.StInterface_JRU;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAhead2('M','I')){
res = ST_INTERFACE.StInterface_DMI;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
default:
res = ST_INTERFACE.StInterface_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_INTERFACE_ToString (ST_INTERFACE v)
{
switch (v) {
 case ST_INTERFACE.StInterface_NA: return "NA";
 case ST_INTERFACE.StInterface_DMI: return "DMI";
 case ST_INTERFACE.StInterface_RTM: return "RTM";
 case ST_INTERFACE.StInterface_JRU: return "JRU";
 case ST_INTERFACE.StInterface_TIU: return "TIU";
} return "";
}

public static ST_INTERFACE StringTo_Enum_ST_INTERFACE( string  str)
{
if (str.Equals("NA")){
  return ST_INTERFACE.StInterface_NA;
} // If
if (str.Equals("DMI")){
  return ST_INTERFACE.StInterface_DMI;
} // If
if (str.Equals("RTM")){
  return ST_INTERFACE.StInterface_RTM;
} // If
if (str.Equals("JRU")){
  return ST_INTERFACE.StInterface_JRU;
} // If
if (str.Equals("TIU")){
  return ST_INTERFACE.StInterface_TIU;
} // If
return ST_INTERFACE.defaultST_INTERFACE;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_LEVEL lAcceptEnum_ST_LEVEL (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_LEVEL res = ST_LEVEL.defaultST_LEVEL;
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead1('A')){
res = ST_LEVEL.StLevel_NA;
} else {
ctxt.moveBack(1);
res = ST_LEVEL.StLevel_NA;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
ctxt.accept2('T','M');
res = ST_LEVEL.StLevel_LSTM;
break;
} // Case
case '3':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L3;
break;
} // Case
case '2':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L2;
break;
} // Case
case '1':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L1;
break;
} // Case
case '0':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L0;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2283)");
break;
} // Switch
break;
} // Case
default:
res = ST_LEVEL.StLevel_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_LEVEL_ToString (ST_LEVEL v)
{
switch (v) {
 case ST_LEVEL.StLevel_NA: return "NA";
 case ST_LEVEL.StLevel_L0: return "L0";
 case ST_LEVEL.StLevel_L1: return "L1";
 case ST_LEVEL.StLevel_LSTM: return "LSTM";
 case ST_LEVEL.StLevel_L2: return "L2";
 case ST_LEVEL.StLevel_L3: return "L3";
} return "";
}

public static ST_LEVEL StringTo_Enum_ST_LEVEL( string  str)
{
if (str.Equals("NA")){
  return ST_LEVEL.StLevel_NA;
} // If
if (str.Equals("L0")){
  return ST_LEVEL.StLevel_L0;
} // If
if (str.Equals("L1")){
  return ST_LEVEL.StLevel_L1;
} // If
if (str.Equals("LSTM")){
  return ST_LEVEL.StLevel_LSTM;
} // If
if (str.Equals("L2")){
  return ST_LEVEL.StLevel_L2;
} // If
if (str.Equals("L3")){
  return ST_LEVEL.StLevel_L3;
} // If
return ST_LEVEL.defaultST_LEVEL;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_MODE lAcceptEnum_ST_MODE (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_MODE res = ST_MODE.defaultST_MODE;
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAhead1('F')){
res = ST_MODE.Mode_UF;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead1('R')){
res = ST_MODE.Mode_TR;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
res = ST_MODE.Mode_SR;
break;
} // Case
case 'N':
{
ctxt.advance();
res = ST_MODE.Mode_SN;
break;
} // Case
case 'L':
{
ctxt.advance();
res = ST_MODE.Mode_SL;
break;
} // Case
case 'H':
{
ctxt.advance();
res = ST_MODE.Mode_SH;
break;
} // Case
case 'F':
{
ctxt.advance();
res = ST_MODE.Mode_SF;
break;
} // Case
case 'B':
{
ctxt.advance();
res = ST_MODE.Mode_SB;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2293)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead1('E')){
res = ST_MODE.Mode_RE;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
res = ST_MODE.Mode_PT;
break;
} // Case
case 'S':
{
ctxt.advance();
ctxt.accept('H');
res = ST_MODE.Mode_PSH;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2298)");
break;
} // Switch
break;
} // Case
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_OS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
res = ST_MODE.Mode_NP;
break;
} // Case
case 'L':
{
ctxt.advance();
res = ST_MODE.Mode_NL;
break;
} // Case
case 'A':
{
ctxt.advance();
res = ST_MODE.Mode_NA;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2304)");
break;
} // Switch
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_LS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_IS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_FS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
default:
res = ST_MODE.Mode_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_MODE_ToString (ST_MODE v)
{
switch (v) {
 case ST_MODE.Mode_NA: return "NA";
 case ST_MODE.Mode_IS: return "IS";
 case ST_MODE.Mode_NP: return "NP";
 case ST_MODE.Mode_SF: return "SF";
 case ST_MODE.Mode_SL: return "SL";
 case ST_MODE.Mode_SB: return "SB";
 case ST_MODE.Mode_SH: return "SH";
 case ST_MODE.Mode_FS: return "FS";
 case ST_MODE.Mode_UF: return "UF";
 case ST_MODE.Mode_SR: return "SR";
 case ST_MODE.Mode_OS: return "OS";
 case ST_MODE.Mode_TR: return "TR";
 case ST_MODE.Mode_PT: return "PT";
 case ST_MODE.Mode_NL: return "NL";
 case ST_MODE.Mode_SN: return "SN";
 case ST_MODE.Mode_RE: return "RE";
 case ST_MODE.Mode_LS: return "LS";
 case ST_MODE.Mode_PSH: return "PSH";
} return "";
}

public static ST_MODE StringTo_Enum_ST_MODE( string  str)
{
if (str.Equals("NA")){
  return ST_MODE.Mode_NA;
} // If
if (str.Equals("IS")){
  return ST_MODE.Mode_IS;
} // If
if (str.Equals("NP")){
  return ST_MODE.Mode_NP;
} // If
if (str.Equals("SF")){
  return ST_MODE.Mode_SF;
} // If
if (str.Equals("SL")){
  return ST_MODE.Mode_SL;
} // If
if (str.Equals("SB")){
  return ST_MODE.Mode_SB;
} // If
if (str.Equals("SH")){
  return ST_MODE.Mode_SH;
} // If
if (str.Equals("FS")){
  return ST_MODE.Mode_FS;
} // If
if (str.Equals("UF")){
  return ST_MODE.Mode_UF;
} // If
if (str.Equals("SR")){
  return ST_MODE.Mode_SR;
} // If
if (str.Equals("OS")){
  return ST_MODE.Mode_OS;
} // If
if (str.Equals("TR")){
  return ST_MODE.Mode_TR;
} // If
if (str.Equals("PT")){
  return ST_MODE.Mode_PT;
} // If
if (str.Equals("NL")){
  return ST_MODE.Mode_NL;
} // If
if (str.Equals("SN")){
  return ST_MODE.Mode_SN;
} // If
if (str.Equals("RE")){
  return ST_MODE.Mode_RE;
} // If
if (str.Equals("LS")){
  return ST_MODE.Mode_LS;
} // If
if (str.Equals("PSH")){
  return ST_MODE.Mode_PSH;
} // If
return ST_MODE.defaultST_MODE;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RulePriority lAcceptEnum_RulePriority (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  RulePriority res = RulePriority.defaultRulePriority;
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erification")){
res = RulePriority.aVerification;
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdate")){
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
ctxt.accept2('U','T');
res = RulePriority.aUpdateOUT;
break;
} // Case
case 'I':
{
ctxt.advance();
ctxt.acceptString ("NTERNAL");
res = RulePriority.aUpdateINTERNAL;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2312)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("rocessing")){
res = RulePriority.aProcessing;
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("leanUp")){
res = RulePriority.aCleanUp;
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
default:
res = RulePriority.aProcessing;
break;
} // Switch
return res;
}

public static  string  Enum_RulePriority_ToString (RulePriority v)
{
switch (v) {
 case RulePriority.aVerification: return "Verification";
 case RulePriority.aUpdateINTERNAL: return "UpdateINTERNAL";
 case RulePriority.aProcessing: return "Processing";
 case RulePriority.aUpdateOUT: return "UpdateOUT";
 case RulePriority.aCleanUp: return "CleanUp";
} return "";
}

public static RulePriority StringTo_Enum_RulePriority( string  str)
{
if (str.Equals("Verification")){
  return RulePriority.aVerification;
} // If
if (str.Equals("UpdateINTERNAL")){
  return RulePriority.aUpdateINTERNAL;
} // If
if (str.Equals("Processing")){
  return RulePriority.aProcessing;
} // If
if (str.Equals("UpdateOUT")){
  return RulePriority.aUpdateOUT;
} // If
if (str.Equals("CleanUp")){
  return RulePriority.aCleanUp;
} // If
return RulePriority.defaultRulePriority;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static PrecisionEnum lAcceptEnum_PrecisionEnum (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  PrecisionEnum res = PrecisionEnum.defaultPrecisionEnum;
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("ntegerPrecision")){
res = PrecisionEnum.aIntegerPrecision;
} else {
ctxt.moveBack(1);
res = PrecisionEnum.aIntegerPrecision;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("oublePrecision")){
res = PrecisionEnum.aDoublePrecision;
} else {
ctxt.moveBack(1);
res = PrecisionEnum.aIntegerPrecision;
} // If
break;
} // Case
default:
res = PrecisionEnum.aIntegerPrecision;
break;
} // Switch
return res;
}

public static  string  Enum_PrecisionEnum_ToString (PrecisionEnum v)
{
switch (v) {
 case PrecisionEnum.aIntegerPrecision: return "IntegerPrecision";
 case PrecisionEnum.aDoublePrecision: return "DoublePrecision";
} return "";
}

public static PrecisionEnum StringTo_Enum_PrecisionEnum( string  str)
{
if (str.Equals("IntegerPrecision")){
  return PrecisionEnum.aIntegerPrecision;
} // If
if (str.Equals("DoublePrecision")){
  return PrecisionEnum.aDoublePrecision;
} // If
return PrecisionEnum.defaultPrecisionEnum;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBMessageType lAcceptEnum_DBMessageType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  DBMessageType res = DBMessageType.defaultDBMessageType;
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('U','R','O')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("ADIO");
res = DBMessageType.aEURORADIO;
break;
} // Case
case 'L':
{
ctxt.advance();
ctxt.accept3('O','O','P');
res = DBMessageType.aEUROLOOP;
break;
} // Case
case 'B':
{
ctxt.advance();
ctxt.acceptString ("ALISE");
res = DBMessageType.aEUROBALISE;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2321)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_DBMessageType_ToString (DBMessageType v)
{
switch (v) {
 case DBMessageType.aEUROBALISE: return "EUROBALISE";
 case DBMessageType.aEUROLOOP: return "EUROLOOP";
 case DBMessageType.aEURORADIO: return "EURORADIO";
} return "";
}

public static DBMessageType StringTo_Enum_DBMessageType( string  str)
{
if (str.Equals("EUROBALISE")){
  return DBMessageType.aEUROBALISE;
} // If
if (str.Equals("EUROLOOP")){
  return DBMessageType.aEUROLOOP;
} // If
if (str.Equals("EURORADIO")){
  return DBMessageType.aEURORADIO;
} // If
return DBMessageType.defaultDBMessageType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ExpectationKind lAcceptEnum_ExpectationKind (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ExpectationKind res = ExpectationKind.defaultExpectationKind;
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("nstantaneous")){
res = ExpectationKind.aInstantaneous;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ontinuous")){
res = ExpectationKind.aContinuous;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_ExpectationKind_ToString (ExpectationKind v)
{
switch (v) {
 case ExpectationKind.aInstantaneous: return "Instantaneous";
 case ExpectationKind.aContinuous: return "Continuous";
} return "";
}

public static ExpectationKind StringTo_Enum_ExpectationKind( string  str)
{
if (str.Equals("Instantaneous")){
  return ExpectationKind.aInstantaneous;
} // If
if (str.Equals("Continuous")){
  return ExpectationKind.aContinuous;
} // If
return ExpectationKind.defaultExpectationKind;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static bool lAcceptBoolean (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator = 0;
#pragma warning restore 0168, 0219
  bool res = false;
switch (ctxt.current()) {
case 'y':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('s')){
res = true;
} else {
res = true;
} // If
break;
} // Case
default:
res = true;
break;
} // Switch
break;
} // Case
case 't':
{
ctxt.advance();
ctxt.accept3('r','u','e');
res = true;
break;
} // Case
case 'o':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
res = true;
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.accept('f');
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2330)");
break;
} // Switch
break;
} // Case
case 'n':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
res = false;
break;
} // Case
default:
res = false;
break;
} // Switch
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.acceptString ("alse");
res = false;
break;
} // Case
case 'Y':
{
ctxt.advance();
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = true;
} else {
res = true;
} // If
break;
} // Case
default:
res = true;
break;
} // Switch
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.accept2('u','e');
res = true;
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.accept2('U','E');
res = true;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2339)");
break;
} // Switch
break;
} // Case
case 'O':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
res = true;
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.accept('f');
res = false;
break;
} // Case
case 'N':
{
ctxt.advance();
res = true;
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.accept('F');
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2345)");
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
res = false;
break;
} // Case
default:
res = false;
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'a':
{
ctxt.advance();
ctxt.accept3('l','s','e');
res = false;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.accept3('L','S','E');
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2351)");
break;
} // Switch
break;
} // Case
case '1':
{
ctxt.advance();
res = true;
break;
} // Case
case '0':
{
ctxt.advance();
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2354)");
break;
} // Switch
return res;
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static BaseModelElement lAccept_Poly_BaseModelElement (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    BaseModelElement res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslation")){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_TranslationDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("stCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('b','S')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAhead2('e','p')){
ctxt.accept(quoteChar);
res = lAccept_SubStep(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("quence")){
ctxt.accept(quoteChar);
res = lAccept_SubSequence(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_StructureRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('p')){
ctxt.accept(quoteChar);
res = lAccept_Step(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("ecification")){
ctxt.accept(quoteChar);
res = lAccept_Specification(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("urceText")){
switch (ctxt.current()) {
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("omment")){
ctxt.accept(quoteChar);
res = lAccept_SourceTextComment(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("ortcut")){
switch (ctxt.current()) {
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("older")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutFolder(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('q')){
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("irementSet")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("eference")){
ctxt.accept(quoteChar);
res = lAccept_RequirementSetReference(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ependancy")){
ctxt.accept(quoteChar);
res = lAccept_RequirementSetDependancy(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_ReqRef(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("cedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("Condition")){
ctxt.accept(quoteChar);
res = lAccept_PreCondition(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("eter")){
ctxt.accept(quoteChar);
res = lAccept_Parameter(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("raph")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("evision")){
ctxt.accept(quoteChar);
res = lAccept_ParagraphRevision(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ameSpace")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_NameSpaceRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("nction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'r':
{
ctxt.advance();
if (ctxt.lookAhead3('a','m','e')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_FrameRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("lder")){
ctxt.accept(quoteChar);
res = lAccept_Folder(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
if (ctxt.lookAheadString("pectation")){
ctxt.accept(quoteChar);
res = lAccept_Expectation(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAhead2('u','m')){
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue")){
ctxt.accept(quoteChar);
res = lAccept_EnumValue(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'D':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("ctionary")){
ctxt.accept(quoteChar);
res = lAccept_Dictionary(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("acket")){
ctxt.accept(quoteChar);
res = lAccept_DBPacket(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("essage")){
ctxt.accept(quoteChar);
res = lAccept_DBMessage(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("ield")){
ctxt.accept(quoteChar);
res = lAccept_DBField(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'C':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("llection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("apter")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_ChapterRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('s','e')){
ctxt.accept(quoteChar);
res = lAccept_Case(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'A':
{
ctxt.advance();
if (ctxt.lookAheadString("ction")){
ctxt.accept(quoteChar);
res = lAccept_Action(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Namable lAccept_Poly_Namable (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    Namable res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslation")){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_TranslationDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("stCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('b','S')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAhead2('e','p')){
ctxt.accept(quoteChar);
res = lAccept_SubStep(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("quence")){
ctxt.accept(quoteChar);
res = lAccept_SubSequence(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_StructureRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('p')){
ctxt.accept(quoteChar);
res = lAccept_Step(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("ecification")){
ctxt.accept(quoteChar);
res = lAccept_Specification(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("urceText")){
switch (ctxt.current()) {
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("omment")){
ctxt.accept(quoteChar);
res = lAccept_SourceTextComment(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("ortcut")){
switch (ctxt.current()) {
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("older")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutFolder(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("quirementSet")){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ependancy")){
ctxt.accept(quoteChar);
res = lAccept_RequirementSetDependancy(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ocedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("eter")){
ctxt.accept(quoteChar);
res = lAccept_Parameter(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("raph")){
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ameSpace")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_NameSpaceRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("nction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'r':
{
ctxt.advance();
if (ctxt.lookAhead3('a','m','e')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_FrameRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("lder")){
ctxt.accept(quoteChar);
res = lAccept_Folder(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
if (ctxt.lookAheadString("pectation")){
ctxt.accept(quoteChar);
res = lAccept_Expectation(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAhead2('u','m')){
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue")){
ctxt.accept(quoteChar);
res = lAccept_EnumValue(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAhead1('B')){
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("acket")){
ctxt.accept(quoteChar);
res = lAccept_DBPacket(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("essage")){
ctxt.accept(quoteChar);
res = lAccept_DBMessage(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("ield")){
ctxt.accept(quoteChar);
res = lAccept_DBField(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("llection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("apter")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_ChapterRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('s','e')){
ctxt.accept(quoteChar);
res = lAccept_Case(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ReferencesParagraph lAccept_Poly_ReferencesParagraph (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    ReferencesParagraph res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslation")){
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("stCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
if (ctxt.lookAhead1('t')){
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('p')){
ctxt.accept(quoteChar);
res = lAccept_Step(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ocedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("ragraph")){
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("unction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ollection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ReqRelated lAccept_Poly_ReqRelated (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    ReqRelated res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("estCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
if (ctxt.lookAhead1('t')){
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("rocedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("unction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ollection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Dictionary lAccept_Dictionary (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Dictionary>";
  Dictionary res = aFactory.createDictionary();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RuleDisabling lAccept_RuleDisabling (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RuleDisabling>";
  RuleDisabling res = aFactory.createRuleDisabling();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static NameSpaceRef lAccept_NameSpaceRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</NameSpaceRef>";
  NameSpaceRef res = aFactory.createNameSpaceRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static NameSpace lAccept_NameSpace (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</NameSpace>";
  NameSpace res = aFactory.createNameSpace();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ReqRef lAccept_ReqRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ReqRef>";
  ReqRef res = aFactory.createReqRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Type lAccept_Poly_Type (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    Type res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
if (ctxt.lookAhead1('t')){
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("teMachine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("ange")){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("unction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ollection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Enum lAccept_Enum (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Enum>";
  Enum res = aFactory.createEnum();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static EnumValue lAccept_EnumValue (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</EnumValue>";
  EnumValue res = aFactory.createEnumValue();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Range lAccept_Range (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Range>";
  Range res = aFactory.createRange();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Structure lAccept_Structure (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Structure>";
  Structure res = aFactory.createStructure();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static StructureRef lAccept_StructureRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</StructureRef>";
  StructureRef res = aFactory.createStructureRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static StructureElement lAccept_StructureElement (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</StructureElement>";
  StructureElement res = aFactory.createStructureElement();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Collection lAccept_Collection (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Collection>";
  Collection res = aFactory.createCollection();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Function lAccept_Function (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Function>";
  Function res = aFactory.createFunction();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Parameter lAccept_Parameter (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Parameter>";
  Parameter res = aFactory.createParameter();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Case lAccept_Case (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Case>";
  Case res = aFactory.createCase();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Procedure lAccept_Procedure (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Procedure>";
  Procedure res = aFactory.createProcedure();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static StateMachine lAccept_StateMachine (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</StateMachine>";
  StateMachine res = aFactory.createStateMachine();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static State lAccept_State (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</State>";
  State res = aFactory.createState();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Variable lAccept_Variable (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Variable>";
  Variable res = aFactory.createVariable();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Rule lAccept_Rule (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Rule>";
  Rule res = aFactory.createRule();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RuleCondition lAccept_RuleCondition (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RuleCondition>";
  RuleCondition res = aFactory.createRuleCondition();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static PreCondition lAccept_PreCondition (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</PreCondition>";
  PreCondition res = aFactory.createPreCondition();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Action lAccept_Action (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Action>";
  Action res = aFactory.createAction();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static FrameRef lAccept_FrameRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</FrameRef>";
  FrameRef res = aFactory.createFrameRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Frame lAccept_Frame (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Frame>";
  Frame res = aFactory.createFrame();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SubSequence lAccept_SubSequence (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SubSequence>";
  SubSequence res = aFactory.createSubSequence();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TestCase lAccept_TestCase (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</TestCase>";
  TestCase res = aFactory.createTestCase();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Step lAccept_Step (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Step>";
  Step res = aFactory.createStep();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SubStep lAccept_SubStep (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SubStep>";
  SubStep res = aFactory.createSubStep();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Expectation lAccept_Expectation (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Expectation>";
  Expectation res = aFactory.createExpectation();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBMessage lAccept_DBMessage (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</DBMessage>";
  DBMessage res = aFactory.createDBMessage();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBPacket lAccept_DBPacket (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</DBPacket>";
  DBPacket res = aFactory.createDBPacket();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBField lAccept_DBField (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</DBField>";
  DBField res = aFactory.createDBField();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TranslationDictionary lAccept_TranslationDictionary (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</TranslationDictionary>";
  TranslationDictionary res = aFactory.createTranslationDictionary();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Folder lAccept_Folder (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Folder>";
  Folder res = aFactory.createFolder();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Translation lAccept_Translation (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Translation>";
  Translation res = aFactory.createTranslation();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SourceText lAccept_SourceText (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SourceText>";
  SourceText res = aFactory.createSourceText();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SourceTextComment lAccept_SourceTextComment (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SourceTextComment>";
  SourceTextComment res = aFactory.createSourceTextComment();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ShortcutDictionary lAccept_ShortcutDictionary (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ShortcutDictionary>";
  ShortcutDictionary res = aFactory.createShortcutDictionary();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ShortcutFolder lAccept_ShortcutFolder (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ShortcutFolder>";
  ShortcutFolder res = aFactory.createShortcutFolder();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Shortcut lAccept_Shortcut (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Shortcut>";
  Shortcut res = aFactory.createShortcut();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RequirementSet lAccept_RequirementSet (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RequirementSet>";
  RequirementSet res = aFactory.createRequirementSet();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RequirementSetDependancy lAccept_RequirementSetDependancy (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RequirementSetDependancy>";
  RequirementSetDependancy res = aFactory.createRequirementSetDependancy();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Specification lAccept_Specification (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Specification>";
  Specification res = aFactory.createSpecification();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ChapterRef lAccept_ChapterRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ChapterRef>";
  ChapterRef res = aFactory.createChapterRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Chapter lAccept_Chapter (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Chapter>";
  Chapter res = aFactory.createChapter();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Paragraph lAccept_Paragraph (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Paragraph>";
  Paragraph res = aFactory.createParagraph();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RequirementSetReference lAccept_RequirementSetReference (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RequirementSetReference>";
  RequirementSetReference res = aFactory.createRequirementSetReference();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Message lAccept_Message (XmlBContext ctxt, 
                          string  endingTag)

  {
  Message res = aFactory.createMessage();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static MsgVariable lAccept_MsgVariable (XmlBContext ctxt, 
                          string  endingTag)

  {
  MsgVariable res = aFactory.createMsgVariable();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TypeSpec lAccept_TypeSpec (XmlBContext ctxt, 
                          string  endingTag)

  {
  TypeSpec res = aFactory.createTypeSpec();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Values lAccept_Values (XmlBContext ctxt, 
                          string  endingTag)

  {
  Values res = aFactory.createValues();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static special_or_reserved_values lAccept_special_or_reserved_values (XmlBContext ctxt, 
                          string  endingTag)

  {
  special_or_reserved_values res = aFactory.createspecial_or_reserved_values();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static special_or_reserved_value lAccept_special_or_reserved_value (XmlBContext ctxt, 
                          string  endingTag)

  {
  special_or_reserved_value res = aFactory.createspecial_or_reserved_value();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static mask lAccept_mask (XmlBContext ctxt, 
                          string  endingTag)

  {
  mask res = aFactory.createmask();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static match lAccept_match (XmlBContext ctxt, 
                          string  endingTag)

  {
  match res = aFactory.creatematch();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static meaning lAccept_meaning (XmlBContext ctxt, 
                          string  endingTag)

  {
  meaning res = aFactory.createmeaning();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static match_range lAccept_match_range (XmlBContext ctxt, 
                          string  endingTag)

  {
  match_range res = aFactory.creatematch_range();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static resolution_formula lAccept_resolution_formula (XmlBContext ctxt, 
                          string  endingTag)

  {
  resolution_formula res = aFactory.createresolution_formula();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static value lAccept_value (XmlBContext ctxt, 
                          string  endingTag)

  {
  value res = aFactory.createvalue();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static char_value lAccept_char_value (XmlBContext ctxt, 
                          string  endingTag)

  {
  char_value res = aFactory.createchar_value();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ParagraphRevision lAccept_ParagraphRevision (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ParagraphRevision>";
  ParagraphRevision res = aFactory.createParagraphRevision();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <summary>Utility function which parse an entity character 
/// as defined in the XMLBooster configuration.</summary>
/// <param name="ctxt">the context from which the data must be parsed</param>
static char lAcceptPcDataChr(XmlBContext ctxt)

{
    char c = (char)0;
    int indicator=0;
switch (ctxt.current()) {
case 'q':
{
ctxt.advance();
ctxt.acceptString ("uot;");
indicator = 2520;
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.acceptString ("bsp;");
indicator = 2519;
break;
} // Case
case 'l':
{
ctxt.advance();
ctxt.accept2('t',';');
indicator = 2517;
break;
} // Case
case 'g':
{
ctxt.advance();
ctxt.accept2('t',';');
indicator = 2518;
break;
} // Case
case 'a':
{
ctxt.advance();
switch (ctxt.current()) {
case 'p':
{
ctxt.advance();
ctxt.accept3('o','s',';');
indicator = 2521;
break;
} // Case
case 'm':
{
ctxt.advance();
ctxt.accept2('p',';');
indicator = 2516;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2529)");
break;
} // Switch
break;
} // Case
case '#':
{
ctxt.advance();
ctxt.accept('x');
indicator = 2522;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2531)");
break;
} // Switch
switch (indicator) {
case 2516: {
c = XMLB_AMPERSAND;
break;
} // End of dispatch label
case 2517: {
c = XMLB_LESS;
break;
} // End of dispatch label
case 2518: {
c = XMLB_GREATER;
break;
} // End of dispatch label
case 2519: {
c = XMLB_NBSP;
break;
} // End of dispatch label
case 2520: {
c = XMLB_QUOT;
break;
} // End of dispatch label
case 2521: {
c = XMLB_APOS;
break;
} // End of dispatch label
case 2522: {
c = (char) ctxt.acceptHexa();
ctxt.accept(';');
break;
} // End of dispatch label
} // Dispatch
return c;
}
/// <summary>Utility function which parse a PCDATA component 
/// from a context. It takes the entities defined in the
/// in the configuration into account.</summary>
/// <param name="ctxt">the context from which the data must be 
///        parsed</param>
/// <param name="maxLen">the maximal number of characters that 
///        can be read.</param>
/// <param name="closingCh">a character on which parsing must stop
///        in addition to the standard &lt; character.</param>
/// <param name="wsMode">indicates PRESERVE (default), REPLACE or COLLAPSE.</param>
public static  string  lAcceptPcData(XmlBContext ctxt, 
                                   int maxLen,
                                   char closingCh,
                                   int wsMode)

 {
    char ch;
    char lastch = '.';
    System.Text.StringBuilder buff;
     string  res;

  buff = new System.Text.StringBuilder();
  bool go_on = true;
  while (go_on) 
{
  go_on = false;
  while ((ctxt.current() != '<') && (ctxt.current() != closingCh)) // while 1 
{
    ch = ctxt.current();
ctxt.advance();
if (ch == '&'){
ch = lAcceptPcDataChr(ctxt);
} else {
if (wsMode >= WS_REPLACE){
if (ch == '\t' || ch == '\n' || ch == '\r'){
ch = ' ';
} // If
if (wsMode == WS_COLLAPSE){
if ((ch == ' ') && ((lastch == ' ') || (buff.Length == 0))){
ch = (char)0;
} else {
lastch = ch;
} // If
} else {
lastch = ch;
} // If
} // If
} // If
if (ch != '\0'){
buff.Append (ch);
} // If
}
// end while
if (ctxt.current() == '<'){
if (ctxt.lookAheadString("<![CDATA[")){
     string  cdata = ctxt.acceptUntil("]]>", true);
    buff.Append (cdata);
    go_on = true;
} else {
if (ctxt.lookAhead2('<','?')){
ctxt.skipTill ('?');
ctxt.accept2('?','>');
go_on = true;
} else {
} // If
} // If
} // If
}
if (wsMode == WS_COLLAPSE && lastch == ' ' && buff. Length > 0){
res = buff.ToString (0, buff.Length -1);
} else {
res = buff.ToString();
} // If
if ((maxLen > 0) && (res.Length > maxLen)){
ctxt.recoverableFail ("Maximum length exceeded");
} // If
return res;
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  private static bool requiresEscape (char a)
  {
    switch (a)
    {
      case XMLB_AMPERSAND:
      case XMLB_LESS:
      case XMLB_GREATER:
      case XMLB_QUOT:
      case XMLB_APOS:
        return true;
      default: break;
    }
    return false;
  }
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  private static bool requiresEscape ( string  a)
  {
    for (int i=0; i < a.Length; i++)
    {
      if (requiresEscape(a[i]))
        return true;
    }
    return false	;
  }
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw,  string  a)
    {
      bool escaped = false;
      
      if (a == null)
      {
          return;
      }
      escaped = requiresEscape (a);
      if (! escaped)
        pw.Write (a);
      else
      {
        char c;
        for (int i = 0; i < a.Length; i++)
        {
          c = a[i];
          switch (c)
            {
              case XMLB_AMPERSAND:
                  pw.Write("&amp;"); 
                  break;
              case XMLB_LESS:
                  pw.Write("&lt;"); 
                  break;
              case XMLB_GREATER:
                  pw.Write("&gt;"); 
                  break;
              case XMLB_QUOT:
                  pw.Write("&quot;"); 
                  break;
              case XMLB_APOS:
                  pw.Write("&apos;"); 
                  break;
               default: 
                   pw.Write(c);
                   break;
            }
        }
      }
    }
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, bool flag)
    {
      if (flag)
        pw.Write ("TRUE");
       else
        pw.Write("FALSE");
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, object obj)
    {
      if (obj != null)
        unParsePcData (pw, obj.ToString());
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, int val)
    {
      pw.Write (val);
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, long val)
    {
      pw.Write (val);
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, double val)
    {
      XmlBConverter conv;
      conv = getConverter();
      if(conv != null)
        pw.Write(conv.doubleToString(val));
       else
        pw.Write (val);
    }



private static Factory aFactory;
/// <summary>Sets the factory to introduce an indirection level
/// so that the user can externally define derived classes
/// to be used in place of the XMLBooster-generated 
/// classes.</summary>
public static void setFactory (Factory f) { aFactory = f; }

/// <returns>the currently active factory.</returns>
public static Factory getFactory () { return aFactory; }
static private acceptor theOne = null;
static public acceptor getUnique()
{
  if (theOne == null) { theOne = new acceptor(); }
  return theOne;
}

static public void setUnique(acceptor acc)
{
  theOne = acc;
}


/// <summary>Top level function to parse an Dictionary from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Dictionary acceptDictionary(XmlBContext ctxt)

  {
Dictionary res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Dictionary");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Dictionary(ctxt, "</Dictionary>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RuleDisabling from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RuleDisabling acceptRuleDisabling(XmlBContext ctxt)

  {
RuleDisabling res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RuleDisabling");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RuleDisabling(ctxt, "</RuleDisabling>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an NameSpace from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static NameSpace acceptNameSpace(XmlBContext ctxt)

  {
NameSpace res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<NameSpace");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_NameSpace(ctxt, "</NameSpace>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ReqRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ReqRef acceptReqRef(XmlBContext ctxt)

  {
ReqRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ReqRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ReqRef(ctxt, "</ReqRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Enum from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Enum acceptEnum(XmlBContext ctxt)

  {
Enum res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Enum");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Enum(ctxt, "</Enum>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an EnumValue from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static EnumValue acceptEnumValue(XmlBContext ctxt)

  {
EnumValue res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<EnumValue");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_EnumValue(ctxt, "</EnumValue>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Range from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Range acceptRange(XmlBContext ctxt)

  {
Range res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Range");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Range(ctxt, "</Range>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Structure from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Structure acceptStructure(XmlBContext ctxt)

  {
Structure res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Structure");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Structure(ctxt, "</Structure>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an StructureElement from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static StructureElement acceptStructureElement(XmlBContext ctxt)

  {
StructureElement res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<StructureElement");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_StructureElement(ctxt, "</StructureElement>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Collection from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Collection acceptCollection(XmlBContext ctxt)

  {
Collection res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Collection");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Collection(ctxt, "</Collection>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Function from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Function acceptFunction(XmlBContext ctxt)

  {
Function res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Function");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Function(ctxt, "</Function>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Parameter from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Parameter acceptParameter(XmlBContext ctxt)

  {
Parameter res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Parameter");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Parameter(ctxt, "</Parameter>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Case from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Case acceptCase(XmlBContext ctxt)

  {
Case res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Case");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Case(ctxt, "</Case>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Procedure from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Procedure acceptProcedure(XmlBContext ctxt)

  {
Procedure res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Procedure");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Procedure(ctxt, "</Procedure>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an StateMachine from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static StateMachine acceptStateMachine(XmlBContext ctxt)

  {
StateMachine res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<StateMachine");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_StateMachine(ctxt, "</StateMachine>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an State from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static State acceptState(XmlBContext ctxt)

  {
State res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<State");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_State(ctxt, "</State>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Variable from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Variable acceptVariable(XmlBContext ctxt)

  {
Variable res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Variable");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Variable(ctxt, "</Variable>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Rule from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Rule acceptRule(XmlBContext ctxt)

  {
Rule res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Rule");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Rule(ctxt, "</Rule>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RuleCondition from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RuleCondition acceptRuleCondition(XmlBContext ctxt)

  {
RuleCondition res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RuleCondition");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RuleCondition(ctxt, "</RuleCondition>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an PreCondition from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static PreCondition acceptPreCondition(XmlBContext ctxt)

  {
PreCondition res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<PreCondition");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_PreCondition(ctxt, "</PreCondition>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Action from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Action acceptAction(XmlBContext ctxt)

  {
Action res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Action");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Action(ctxt, "</Action>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Frame from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Frame acceptFrame(XmlBContext ctxt)

  {
Frame res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Frame");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Frame(ctxt, "</Frame>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SubSequence from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SubSequence acceptSubSequence(XmlBContext ctxt)

  {
SubSequence res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SubSequence");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SubSequence(ctxt, "</SubSequence>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an TestCase from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static TestCase acceptTestCase(XmlBContext ctxt)

  {
TestCase res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<TestCase");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_TestCase(ctxt, "</TestCase>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Step from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Step acceptStep(XmlBContext ctxt)

  {
Step res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Step");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Step(ctxt, "</Step>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SubStep from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SubStep acceptSubStep(XmlBContext ctxt)

  {
SubStep res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SubStep");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SubStep(ctxt, "</SubStep>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Expectation from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Expectation acceptExpectation(XmlBContext ctxt)

  {
Expectation res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Expectation");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Expectation(ctxt, "</Expectation>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an DBMessage from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static DBMessage acceptDBMessage(XmlBContext ctxt)

  {
DBMessage res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<DBMessage");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_DBMessage(ctxt, "</DBMessage>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an DBPacket from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static DBPacket acceptDBPacket(XmlBContext ctxt)

  {
DBPacket res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<DBPacket");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_DBPacket(ctxt, "</DBPacket>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an DBField from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static DBField acceptDBField(XmlBContext ctxt)

  {
DBField res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<DBField");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_DBField(ctxt, "</DBField>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an TranslationDictionary from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static TranslationDictionary acceptTranslationDictionary(XmlBContext ctxt)

  {
TranslationDictionary res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<TranslationDictionary");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_TranslationDictionary(ctxt, "</TranslationDictionary>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Folder from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Folder acceptFolder(XmlBContext ctxt)

  {
Folder res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Folder");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Folder(ctxt, "</Folder>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Translation from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Translation acceptTranslation(XmlBContext ctxt)

  {
Translation res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Translation");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Translation(ctxt, "</Translation>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SourceText from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SourceText acceptSourceText(XmlBContext ctxt)

  {
SourceText res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SourceText");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SourceText(ctxt, "</SourceText>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SourceTextComment from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SourceTextComment acceptSourceTextComment(XmlBContext ctxt)

  {
SourceTextComment res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SourceTextComment");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SourceTextComment(ctxt, "</SourceTextComment>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ShortcutDictionary from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ShortcutDictionary acceptShortcutDictionary(XmlBContext ctxt)

  {
ShortcutDictionary res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ShortcutDictionary");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ShortcutDictionary(ctxt, "</ShortcutDictionary>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ShortcutFolder from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ShortcutFolder acceptShortcutFolder(XmlBContext ctxt)

  {
ShortcutFolder res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ShortcutFolder");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Shortcut from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Shortcut acceptShortcut(XmlBContext ctxt)

  {
Shortcut res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Shortcut");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Shortcut(ctxt, "</Shortcut>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RequirementSet from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RequirementSet acceptRequirementSet(XmlBContext ctxt)

  {
RequirementSet res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RequirementSet");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RequirementSet(ctxt, "</RequirementSet>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RequirementSetDependancy from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RequirementSetDependancy acceptRequirementSetDependancy(XmlBContext ctxt)

  {
RequirementSetDependancy res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RequirementSetDependancy");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RequirementSetDependancy(ctxt, "</RequirementSetDependancy>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Specification from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Specification acceptSpecification(XmlBContext ctxt)

  {
Specification res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Specification");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Specification(ctxt, "</Specification>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Chapter from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Chapter acceptChapter(XmlBContext ctxt)

  {
Chapter res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Chapter");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Chapter(ctxt, "</Chapter>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Paragraph from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Paragraph acceptParagraph(XmlBContext ctxt)

  {
Paragraph res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Paragraph");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Paragraph(ctxt, "</Paragraph>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RequirementSetReference from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RequirementSetReference acceptRequirementSetReference(XmlBContext ctxt)

  {
RequirementSetReference res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RequirementSetReference");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RequirementSetReference(ctxt, "</RequirementSetReference>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ParagraphRevision from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ParagraphRevision acceptParagraphRevision(XmlBContext ctxt)

  {
ParagraphRevision res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ParagraphRevision");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ParagraphRevision(ctxt, "</ParagraphRevision>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an NameSpaceRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static NameSpaceRef acceptNameSpaceRef(XmlBContext ctxt)

  {
NameSpaceRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<NameSpaceRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an StructureRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static StructureRef acceptStructureRef(XmlBContext ctxt)

  {
StructureRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<StructureRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_StructureRef(ctxt, "</StructureRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an FrameRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static FrameRef acceptFrameRef(XmlBContext ctxt)

  {
FrameRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<FrameRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_FrameRef(ctxt, "</FrameRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ChapterRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ChapterRef acceptChapterRef(XmlBContext ctxt)

  {
ChapterRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ChapterRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ChapterRef(ctxt, "</ChapterRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

public static IXmlBBase accept(XmlBContext ctxt)

{
  IXmlBBase res = null;
ctxt.skipWhiteSpace();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
ctxt.acceptString ("ariable");
  res =  lAccept_Variable(ctxt, "</Variable>");
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.acceptString ("anslation");
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
  res =  lAccept_TranslationDictionary(ctxt, "</TranslationDictionary>");
} else {
  res =  lAccept_Translation(ctxt, "</Translation>");
} // If
break;
} // Case
default:
  res =  lAccept_Translation(ctxt, "</Translation>");
break;
} // Switch
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("stCase");
  res =  lAccept_TestCase(ctxt, "</TestCase>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2539)");
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.accept2('b','S');
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
ctxt.accept2('e','p');
  res =  lAccept_SubStep(ctxt, "</SubStep>");
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("quence");
  res =  lAccept_SubSequence(ctxt, "</SubSequence>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2544)");
break;
} // Switch
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.acceptString ("ucture");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_StructureRef(ctxt, "</StructureRef>");
} else {
  res =  lAccept_Structure(ctxt, "</Structure>");
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
  res =  lAccept_StructureElement(ctxt, "</StructureElement>");
} else {
  res =  lAccept_Structure(ctxt, "</Structure>");
} // If
break;
} // Case
default:
  res =  lAccept_Structure(ctxt, "</Structure>");
break;
} // Switch
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.accept('p');
  res =  lAccept_Step(ctxt, "</Step>");
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept2('t','e');
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
  res =  lAccept_StateMachine(ctxt, "</StateMachine>");
} else {
  res =  lAccept_State(ctxt, "</State>");
} // If
break;
} // Case
default:
  res =  lAccept_State(ctxt, "</State>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2552)");
break;
} // Switch
break;
} // Case
case 'p':
{
ctxt.advance();
ctxt.acceptString ("ecification");
  res =  lAccept_Specification(ctxt, "</Specification>");
break;
} // Case
case 'o':
{
ctxt.advance();
ctxt.acceptString ("urceText");
switch (ctxt.current()) {
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("omment")){
  res =  lAccept_SourceTextComment(ctxt, "</SourceTextComment>");
} else {
  res =  lAccept_SourceText(ctxt, "</SourceText>");
} // If
break;
} // Case
default:
  res =  lAccept_SourceText(ctxt, "</SourceText>");
break;
} // Switch
break;
} // Case
case 'h':
{
ctxt.advance();
ctxt.acceptString ("ortcut");
switch (ctxt.current()) {
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("older")){
  res =  lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
} else {
  res =  lAccept_Shortcut(ctxt, "</Shortcut>");
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
  res =  lAccept_ShortcutDictionary(ctxt, "</ShortcutDictionary>");
} else {
  res =  lAccept_Shortcut(ctxt, "</Shortcut>");
} // If
break;
} // Case
default:
  res =  lAccept_Shortcut(ctxt, "</Shortcut>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2559)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.accept2('l','e');
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
  res =  lAccept_RuleDisabling(ctxt, "</RuleDisabling>");
} else {
  res =  lAccept_Rule(ctxt, "</Rule>");
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
  res =  lAccept_RuleCondition(ctxt, "</RuleCondition>");
} else {
  res =  lAccept_Rule(ctxt, "</Rule>");
} // If
break;
} // Case
default:
  res =  lAccept_Rule(ctxt, "</Rule>");
break;
} // Switch
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.accept('q');
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.acceptString ("irementSet");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("eference")){
  res =  lAccept_RequirementSetReference(ctxt, "</RequirementSetReference>");
} else {
  res =  lAccept_RequirementSet(ctxt, "</RequirementSet>");
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ependancy")){
  res =  lAccept_RequirementSetDependancy(ctxt, "</RequirementSetDependancy>");
} else {
  res =  lAccept_RequirementSet(ctxt, "</RequirementSet>");
} // If
break;
} // Case
default:
  res =  lAccept_RequirementSet(ctxt, "</RequirementSet>");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.accept2('e','f');
  res =  lAccept_ReqRef(ctxt, "</ReqRef>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2569)");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept3('n','g','e');
  res =  lAccept_Range(ctxt, "</Range>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2571)");
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("cedure");
  res =  lAccept_Procedure(ctxt, "</Procedure>");
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("Condition");
  res =  lAccept_PreCondition(ctxt, "</PreCondition>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2576)");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept2('r','a');
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
ctxt.acceptString ("eter");
  res =  lAccept_Parameter(ctxt, "</Parameter>");
break;
} // Case
case 'g':
{
ctxt.advance();
ctxt.acceptString ("raph");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("evision")){
  res =  lAccept_ParagraphRevision(ctxt, "</ParagraphRevision>");
} else {
  res =  lAccept_Paragraph(ctxt, "</Paragraph>");
} // If
break;
} // Case
default:
  res =  lAccept_Paragraph(ctxt, "</Paragraph>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2581)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2582)");
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
ctxt.acceptString ("ameSpace");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
} else {
  res =  lAccept_NameSpace(ctxt, "</NameSpace>");
} // If
break;
} // Case
default:
  res =  lAccept_NameSpace(ctxt, "</NameSpace>");
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.acceptString ("nction");
  res =  lAccept_Function(ctxt, "</Function>");
break;
} // Case
case 'r':
{
ctxt.advance();
ctxt.accept3('a','m','e');
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_FrameRef(ctxt, "</FrameRef>");
} else {
  res =  lAccept_Frame(ctxt, "</Frame>");
} // If
break;
} // Case
default:
  res =  lAccept_Frame(ctxt, "</Frame>");
break;
} // Switch
break;
} // Case
case 'o':
{
ctxt.advance();
ctxt.acceptString ("lder");
  res =  lAccept_Folder(ctxt, "</Folder>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2590)");
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
ctxt.acceptString ("pectation");
  res =  lAccept_Expectation(ctxt, "</Expectation>");
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.accept2('u','m');
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue")){
  res =  lAccept_EnumValue(ctxt, "</EnumValue>");
} else {
  res =  lAccept_Enum(ctxt, "</Enum>");
} // If
break;
} // Case
default:
  res =  lAccept_Enum(ctxt, "</Enum>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2595)");
break;
} // Switch
break;
} // Case
case 'D':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.acceptString ("ctionary");
  res =  lAccept_Dictionary(ctxt, "</Dictionary>");
break;
} // Case
case 'B':
{
ctxt.advance();
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
ctxt.acceptString ("acket");
  res =  lAccept_DBPacket(ctxt, "</DBPacket>");
break;
} // Case
case 'M':
{
ctxt.advance();
ctxt.acceptString ("essage");
  res =  lAccept_DBMessage(ctxt, "</DBMessage>");
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.acceptString ("ield");
  res =  lAccept_DBField(ctxt, "</DBField>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2602)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2603)");
break;
} // Switch
break;
} // Case
case 'C':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("llection");
  res =  lAccept_Collection(ctxt, "</Collection>");
break;
} // Case
case 'h':
{
ctxt.advance();
ctxt.acceptString ("apter");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_ChapterRef(ctxt, "</ChapterRef>");
} else {
  res =  lAccept_Chapter(ctxt, "</Chapter>");
} // If
break;
} // Case
default:
  res =  lAccept_Chapter(ctxt, "</Chapter>");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept2('s','e');
  res =  lAccept_Case(ctxt, "</Case>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2609)");
break;
} // Switch
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("ction");
  res =  lAccept_Action(ctxt, "</Action>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2611)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2612)");
break;
} // Switch
return res;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override bool genericUnParse(TextWriter pw, IXmlBBase obj)
{
  ((XmlBBase ) obj).unParse(pw, false);
  return true;
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static IXmlBBase[] subElements(IXmlBBase obj)
{
  return ((XmlBBase ) obj).subElements();
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  IXmlBBase[] genericSubElements(IXmlBBase obj)
{
  return ((XmlBBase ) obj).subElements();
}
public  override IXmlBBase genericAccept (XmlBContext ctxt)

  {
    return accept(ctxt);
  }
}
public abstract partial class Factory
{
public abstract Dictionary createDictionary();
public abstract RuleDisabling createRuleDisabling();
public abstract NameSpaceRef createNameSpaceRef();
public abstract NameSpace createNameSpace();
public abstract ReqRef createReqRef();
public abstract Enum createEnum();
public abstract EnumValue createEnumValue();
public abstract Range createRange();
public abstract Structure createStructure();
public abstract StructureRef createStructureRef();
public abstract StructureElement createStructureElement();
public abstract Collection createCollection();
public abstract Function createFunction();
public abstract Parameter createParameter();
public abstract Case createCase();
public abstract Procedure createProcedure();
public abstract StateMachine createStateMachine();
public abstract State createState();
public abstract Variable createVariable();
public abstract Rule createRule();
public abstract RuleCondition createRuleCondition();
public abstract PreCondition createPreCondition();
public abstract Action createAction();
public abstract FrameRef createFrameRef();
public abstract Frame createFrame();
public abstract SubSequence createSubSequence();
public abstract TestCase createTestCase();
public abstract Step createStep();
public abstract SubStep createSubStep();
public abstract Expectation createExpectation();
public abstract DBMessage createDBMessage();
public abstract DBPacket createDBPacket();
public abstract DBField createDBField();
public abstract TranslationDictionary createTranslationDictionary();
public abstract Folder createFolder();
public abstract Translation createTranslation();
public abstract SourceText createSourceText();
public abstract SourceTextComment createSourceTextComment();
public abstract ShortcutDictionary createShortcutDictionary();
public abstract ShortcutFolder createShortcutFolder();
public abstract Shortcut createShortcut();
public abstract RequirementSet createRequirementSet();
public abstract RequirementSetDependancy createRequirementSetDependancy();
public abstract Specification createSpecification();
public abstract ChapterRef createChapterRef();
public abstract Chapter createChapter();
public abstract Paragraph createParagraph();
public abstract RequirementSetReference createRequirementSetReference();
public abstract Message createMessage();
public abstract MsgVariable createMsgVariable();
public abstract TypeSpec createTypeSpec();
public abstract Values createValues();
public abstract special_or_reserved_values createspecial_or_reserved_values();
public abstract special_or_reserved_value createspecial_or_reserved_value();
public abstract mask createmask();
public abstract match creatematch();
public abstract meaning createmeaning();
public abstract match_range creatematch_range();
public abstract resolution_formula createresolution_formula();
public abstract value createvalue();
public abstract char_value createchar_value();
public abstract ParagraphRevision createParagraphRevision();
}

public partial class TestParser
{
public static void main( string [] args)
  {
   XmlBTester tester = new  XmlBTester();
   tester.performTest (acceptor.getUnique(), args);
  }
}

public partial class Visitor
: XmlBBaseVisitor
{
public virtual void visit(BaseModelElement obj)
{
  visit(obj, true);
}

public virtual void visit(BaseModelElement obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Namable obj)
{
  visit(obj, true);
}

public virtual void visit(Namable obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ReferencesParagraph obj)
{
  visit(obj, true);
}

public virtual void visit(ReferencesParagraph obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ReqRelated obj)
{
  visit(obj, true);
}

public virtual void visit(ReqRelated obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Dictionary obj)
{
  visit(obj, true);
}

public virtual void visit(Dictionary obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RuleDisabling obj)
{
  visit(obj, true);
}

public virtual void visit(RuleDisabling obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(NameSpaceRef obj)
{
  visit(obj, true);
}

public virtual void visit(NameSpaceRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(NameSpace obj)
{
  visit(obj, true);
}

public virtual void visit(NameSpace obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ReqRef obj)
{
  visit(obj, true);
}

public virtual void visit(ReqRef obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Type obj)
{
  visit(obj, true);
}

public virtual void visit(Type obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Enum obj)
{
  visit(obj, true);
}

public virtual void visit(Enum obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(EnumValue obj)
{
  visit(obj, true);
}

public virtual void visit(EnumValue obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Range obj)
{
  visit(obj, true);
}

public virtual void visit(Range obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Structure obj)
{
  visit(obj, true);
}

public virtual void visit(Structure obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(StructureRef obj)
{
  visit(obj, true);
}

public virtual void visit(StructureRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(StructureElement obj)
{
  visit(obj, true);
}

public virtual void visit(StructureElement obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Collection obj)
{
  visit(obj, true);
}

public virtual void visit(Collection obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Function obj)
{
  visit(obj, true);
}

public virtual void visit(Function obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Parameter obj)
{
  visit(obj, true);
}

public virtual void visit(Parameter obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Case obj)
{
  visit(obj, true);
}

public virtual void visit(Case obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Procedure obj)
{
  visit(obj, true);
}

public virtual void visit(Procedure obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(StateMachine obj)
{
  visit(obj, true);
}

public virtual void visit(StateMachine obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(State obj)
{
  visit(obj, true);
}

public virtual void visit(State obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Variable obj)
{
  visit(obj, true);
}

public virtual void visit(Variable obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Rule obj)
{
  visit(obj, true);
}

public virtual void visit(Rule obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RuleCondition obj)
{
  visit(obj, true);
}

public virtual void visit(RuleCondition obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(PreCondition obj)
{
  visit(obj, true);
}

public virtual void visit(PreCondition obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Action obj)
{
  visit(obj, true);
}

public virtual void visit(Action obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(FrameRef obj)
{
  visit(obj, true);
}

public virtual void visit(FrameRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Frame obj)
{
  visit(obj, true);
}

public virtual void visit(Frame obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SubSequence obj)
{
  visit(obj, true);
}

public virtual void visit(SubSequence obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(TestCase obj)
{
  visit(obj, true);
}

public virtual void visit(TestCase obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Step obj)
{
  visit(obj, true);
}

public virtual void visit(Step obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SubStep obj)
{
  visit(obj, true);
}

public virtual void visit(SubStep obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Expectation obj)
{
  visit(obj, true);
}

public virtual void visit(Expectation obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(DBMessage obj)
{
  visit(obj, true);
}

public virtual void visit(DBMessage obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(DBPacket obj)
{
  visit(obj, true);
}

public virtual void visit(DBPacket obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(DBField obj)
{
  visit(obj, true);
}

public virtual void visit(DBField obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(TranslationDictionary obj)
{
  visit(obj, true);
}

public virtual void visit(TranslationDictionary obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Folder obj)
{
  visit(obj, true);
}

public virtual void visit(Folder obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Translation obj)
{
  visit(obj, true);
}

public virtual void visit(Translation obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SourceText obj)
{
  visit(obj, true);
}

public virtual void visit(SourceText obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SourceTextComment obj)
{
  visit(obj, true);
}

public virtual void visit(SourceTextComment obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ShortcutDictionary obj)
{
  visit(obj, true);
}

public virtual void visit(ShortcutDictionary obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ShortcutFolder obj)
{
  visit(obj, true);
}

public virtual void visit(ShortcutFolder obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Shortcut obj)
{
  visit(obj, true);
}

public virtual void visit(Shortcut obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RequirementSet obj)
{
  visit(obj, true);
}

public virtual void visit(RequirementSet obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RequirementSetDependancy obj)
{
  visit(obj, true);
}

public virtual void visit(RequirementSetDependancy obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Specification obj)
{
  visit(obj, true);
}

public virtual void visit(Specification obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ChapterRef obj)
{
  visit(obj, true);
}

public virtual void visit(ChapterRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Chapter obj)
{
  visit(obj, true);
}

public virtual void visit(Chapter obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Paragraph obj)
{
  visit(obj, true);
}

public virtual void visit(Paragraph obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RequirementSetReference obj)
{
  visit(obj, true);
}

public virtual void visit(RequirementSetReference obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Message obj)
{
  visit(obj, true);
}

public virtual void visit(Message obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(MsgVariable obj)
{
  visit(obj, true);
}

public virtual void visit(MsgVariable obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(TypeSpec obj)
{
  visit(obj, true);
}

public virtual void visit(TypeSpec obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Values obj)
{
  visit(obj, true);
}

public virtual void visit(Values obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(special_or_reserved_values obj)
{
  visit(obj, true);
}

public virtual void visit(special_or_reserved_values obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(special_or_reserved_value obj)
{
  visit(obj, true);
}

public virtual void visit(special_or_reserved_value obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(mask obj)
{
  visit(obj, true);
}

public virtual void visit(mask obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(match obj)
{
  visit(obj, true);
}

public virtual void visit(match obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(meaning obj)
{
  visit(obj, true);
}

public virtual void visit(meaning obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(match_range obj)
{
  visit(obj, true);
}

public virtual void visit(match_range obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(resolution_formula obj)
{
  visit(obj, true);
}

public virtual void visit(resolution_formula obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(value obj)
{
  visit(obj, true);
}

public virtual void visit(value obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(char_value obj)
{
  visit(obj, true);
}

public virtual void visit(char_value obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ParagraphRevision obj)
{
  visit(obj, true);
}

public virtual void visit(ParagraphRevision obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public  override  void dispatch(IXmlBBase obj)
{
  dispatch (obj, true);
}

public  override  void dispatch(IXmlBBase obj, bool visitSubNodes)
{
if (obj == null){
return;
} // If
((XmlBBase)obj).dispatch(this, visitSubNodes);
} // End of dispatch methods

}
}
