
using XmlBooster;
using System.IO;
using System.Collections;
using System;

/// <remarks>XMLBooster-generated code (Version 2.22.11.0)
/// This code is generated automatically. It is not meant
/// to be maintained or even read. As it is generated, 
/// it does not follow any coding standard. Please refrain
/// from performing any change directly on this generated 
/// code, as it might be overwritten anytime.
/// This documentation is provided for information purposes
/// only, in order to make the generated API somewhat more
/// understandable. It is meant to be a maintenance guide,
/// as this code is not meant to be maintained at all.</remarks>
namespace DataDictionary.Generated{
public abstract partial class BaseModelElement
: Utils.ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getGuid().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.BaseModelElementController.alertChange(aLock, this);
}
private   string  aGuid;

public   string  getGuid() { return aGuid;}

public  void setGuid( string  v) {
  aGuid = v;
  __setDirty(true);
  NotifyControllers(null);
}


public BaseModelElement()
{
BaseModelElement obj = this;
aGuid=(null);
}

public void copyTo(BaseModelElement other)
{
other.aGuid = aGuid;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl101;
bool fl102;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl101 = false ; 
fl102 = true ; 
while (fl102) { // BeginLoop 
if (ctxt.lookAheadString("Guid=")){
indicator = 101;
} else {
indicator = 103;
} // If
switch (indicator) {
case 101: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl101){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl101 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 103: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl102 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<BaseModelElement";
  endingTag = "</BaseModelElement>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"BaseModelElement\"");
} // If
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write("/>");
pw.Write('\n');
unParseBody(pw);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public abstract partial class Namable
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.NamableController.alertChange(aLock, this);
}
private   string  aName;

public   string  getName() { return aName;}

public  void setName( string  v) {
  aName = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Namable()
{
Namable obj = this;
aName=(null);
}

public void copyTo(Namable other)
{
base.copyTo(other);
other.aName = aName;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl105;
bool fl106;
bool fl107;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl105 = false ; 
fl106 = false ; 
fl107 = true ; 
while (fl107) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 105;
} else {
indicator = 108;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 106;
} else {
indicator = 108;
} // If
break;
} // Case
default:
indicator = 108;
break;
} // Switch
switch (indicator) {
case 105: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl105){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl105 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 106: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl106){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl106 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 108: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl107 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Namable";
  endingTag = "</Namable>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Namable\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public abstract partial class ReferencesParagraph
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ReferencesParagraphController.alertChange(aLock, this);
}
private System.Collections.ArrayList aRequirements;

/// <summary>Part of the list interface for Requirements</summary>
/// <returns>a collection of all the elements in Requirements</returns>
public System.Collections.ArrayList allRequirements()
  {
if (aRequirements == null){
    setAllRequirements( new System.Collections.ArrayList() );
} // If
    return aRequirements;
  }

/// <summary>Part of the list interface for Requirements</summary>
/// <returns>a collection of all the elements in Requirements</returns>
private System.Collections.ArrayList getRequirements()
  {
    return allRequirements();
  }

/// <summary>Part of the list interface for Requirements</summary>
/// <param name="coll">a collection of elements which replaces 
///        Requirements's current content.</param>
public void setAllRequirements(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirements = coll;
    NotifyControllers(null);
  }
public void setAllRequirements(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirements = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements</summary>
/// <param name="el">a ReqRef to add to the collection in 
///           Requirements</param>
/// <seealso cref="appendRequirements(System.Collections.IList)"/>
public void appendRequirements(ReqRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRequirements(Lock aLock,ReqRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Requirements</summary>
/// <param name="coll">a collection ofReqRefs to add to the collection in 
///           Requirements</param>
/// <seealso cref="appendRequirements(ReqRef)"/>
public void appendRequirements(System.Collections.IList coll)
  {
  __setDirty(true);
  allRequirements().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRequirements(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRequirements().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements
/// This insertion function inserts a new element in the
/// collection in Requirements</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRequirements(int idx, ReqRef el)
  {
  __setDirty(true);
  allRequirements().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRequirements(int idx, ReqRef el,Lock aLock)
  {
  __setDirty(true);
  allRequirements().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRequirements(IXmlBBase el)
  {
  return ((System.Collections.IList) allRequirements()).IndexOf (el);
  }

/// <summary>Part of the list interface for Requirements
/// This deletion function removes an element from the
/// collection in Requirements</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRequirements(int idx)
  {
  __setDirty(true);
  allRequirements().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRequirements(int idx,Lock aLock)
  {
  __setDirty(true);
  allRequirements().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Requirements
/// This deletion function removes an element from the
/// collection in Requirements
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRequirements(IXmlBBase obj)
  {
  int idx = indexOfRequirements(obj);
  if (idx >= 0) { deleteRequirements(idx);
NotifyControllers(null);
   }
  }

public void removeRequirements(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRequirements(obj);
  if (idx >= 0) { deleteRequirements(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Requirements</summary>
/// <returns>the number of elements in Requirements</returns>
public int countRequirements()
  {
  return allRequirements().Count;
  }

/// <summary>Part of the list interface for Requirements
/// This function returns an element from the
/// collection in Requirements based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ReqRef getRequirements(int idx)
{
  return (ReqRef) ( allRequirements()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ReferencesParagraph()
{
ReferencesParagraph obj = this;
aRequirements=(null);
aComment=(null);
}

public void copyTo(ReferencesParagraph other)
{
base.copyTo(other);
other.aRequirements = aRequirements;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
ReqRef fl113;
bool fl124;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl113 = null;
while(ctxt.lookAheadOpeningTag ("<ReqRef")) {
fl113 = acceptor.lAccept_ReqRef(ctxt, "</ReqRef>");
appendRequirements(fl113);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl124 = true ; 
while (fl124) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl124 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl125;
bool fl126;
bool fl127;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl125 = false ; 
fl126 = false ; 
fl127 = true ; 
while (fl127) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 125;
} else {
indicator = 128;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 126;
} else {
indicator = 128;
} // If
break;
} // Case
default:
indicator = 128;
break;
} // Switch
switch (indicator) {
case 125: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl125){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl125 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 126: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl126){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl126 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 128: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl127 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ReferencesParagraph";
  endingTag = "</ReferencesParagraph>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ReferencesParagraph\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRequirements(), false, "<ReqRef", "</ReqRef>");
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countRequirements(); i++) {
  l.Add(getRequirements(i));
}
}

}
public abstract partial class ReqRelated
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ReqRelatedController.alertChange(aLock, this);
}
private  bool aImplemented;

public  bool getImplemented() { return aImplemented;}

public  void setImplemented(bool v) {
  aImplemented = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aVerified;

public  bool getVerified() { return aVerified;}

public  void setVerified(bool v) {
  aVerified = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aNeedsRequirement;

public  bool getNeedsRequirement() { return aNeedsRequirement;}

public  void setNeedsRequirement(bool v) {
  aNeedsRequirement = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ReqRelated()
{
ReqRelated obj = this;
aImplemented=(false);
aVerified=(false);
aNeedsRequirement=(false);
}

public void copyTo(ReqRelated other)
{
base.copyTo(other);
other.aImplemented = aImplemented;
other.aVerified = aVerified;
other.aNeedsRequirement = aNeedsRequirement;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl132;
bool fl133;
bool fl134;
bool fl135;
bool fl136;
bool fl137;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl132 = false ; 
fl133 = false ; 
fl134 = false ; 
fl135 = false ; 
fl136 = false ; 
fl137 = true ; 
while (fl137) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 133;
} else {
indicator = 138;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 134;
} else {
indicator = 138;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 135;
} else {
indicator = 138;
} // If
break;
} // Case
default:
indicator = 138;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 132;
} else {
indicator = 138;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 136;
} else {
indicator = 138;
} // If
break;
} // Case
default:
indicator = 138;
break;
} // Switch
switch (indicator) {
case 132: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl132){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl132 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 133: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl133){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl133 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 134: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl134){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl134 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 135: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl135){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl135 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 136: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl136){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl136 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 138: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl132){
this.setImplemented( false);
} // If
if (!fl133){
this.setVerified( false);
} // If
if (!fl134){
this.setNeedsRequirement( true);
} // If
fl137 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ReqRelated";
  endingTag = "</ReqRelated>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ReqRelated\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Dictionary
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getXsi().CompareTo((String) search) == 0)return true;
if(getXsiLocation().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DictionaryController.alertChange(aLock, this);
}
private System.Collections.ArrayList aSpecifications;

/// <summary>Part of the list interface for Specifications</summary>
/// <returns>a collection of all the elements in Specifications</returns>
public System.Collections.ArrayList allSpecifications()
  {
if (aSpecifications == null){
    setAllSpecifications( new System.Collections.ArrayList() );
} // If
    return aSpecifications;
  }

/// <summary>Part of the list interface for Specifications</summary>
/// <returns>a collection of all the elements in Specifications</returns>
private System.Collections.ArrayList getSpecifications()
  {
    return allSpecifications();
  }

/// <summary>Part of the list interface for Specifications</summary>
/// <param name="coll">a collection of elements which replaces 
///        Specifications's current content.</param>
public void setAllSpecifications(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecifications = coll;
    NotifyControllers(null);
  }
public void setAllSpecifications(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecifications = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications</summary>
/// <param name="el">a Specification to add to the collection in 
///           Specifications</param>
/// <seealso cref="appendSpecifications(System.Collections.IList)"/>
public void appendSpecifications(Specification el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecifications().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSpecifications(Lock aLock,Specification el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecifications().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Specifications</summary>
/// <param name="coll">a collection ofSpecifications to add to the collection in 
///           Specifications</param>
/// <seealso cref="appendSpecifications(Specification)"/>
public void appendSpecifications(System.Collections.IList coll)
  {
  __setDirty(true);
  allSpecifications().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSpecifications(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSpecifications().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications
/// This insertion function inserts a new element in the
/// collection in Specifications</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSpecifications(int idx, Specification el)
  {
  __setDirty(true);
  allSpecifications().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSpecifications(int idx, Specification el,Lock aLock)
  {
  __setDirty(true);
  allSpecifications().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSpecifications(IXmlBBase el)
  {
  return ((System.Collections.IList) allSpecifications()).IndexOf (el);
  }

/// <summary>Part of the list interface for Specifications
/// This deletion function removes an element from the
/// collection in Specifications</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSpecifications(int idx)
  {
  __setDirty(true);
  allSpecifications().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSpecifications(int idx,Lock aLock)
  {
  __setDirty(true);
  allSpecifications().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Specifications
/// This deletion function removes an element from the
/// collection in Specifications
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSpecifications(IXmlBBase obj)
  {
  int idx = indexOfSpecifications(obj);
  if (idx >= 0) { deleteSpecifications(idx);
NotifyControllers(null);
   }
  }

public void removeSpecifications(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSpecifications(obj);
  if (idx >= 0) { deleteSpecifications(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Specifications</summary>
/// <returns>the number of elements in Specifications</returns>
public int countSpecifications()
  {
  return allSpecifications().Count;
  }

/// <summary>Part of the list interface for Specifications
/// This function returns an element from the
/// collection in Specifications based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Specification getSpecifications(int idx)
{
  return (Specification) ( allSpecifications()[idx]);
}

private System.Collections.ArrayList aRequirementSets;

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>a collection of all the elements in RequirementSets</returns>
public System.Collections.ArrayList allRequirementSets()
  {
if (aRequirementSets == null){
    setAllRequirementSets( new System.Collections.ArrayList() );
} // If
    return aRequirementSets;
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>a collection of all the elements in RequirementSets</returns>
private System.Collections.ArrayList getRequirementSets()
  {
    return allRequirementSets();
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="coll">a collection of elements which replaces 
///        RequirementSets's current content.</param>
public void setAllRequirementSets(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirementSets = coll;
    NotifyControllers(null);
  }
public void setAllRequirementSets(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirementSets = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="el">a RequirementSet to add to the collection in 
///           RequirementSets</param>
/// <seealso cref="appendRequirementSets(System.Collections.IList)"/>
public void appendRequirementSets(RequirementSet el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirementSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRequirementSets(Lock aLock,RequirementSet el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirementSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="coll">a collection ofRequirementSets to add to the collection in 
///           RequirementSets</param>
/// <seealso cref="appendRequirementSets(RequirementSet)"/>
public void appendRequirementSets(System.Collections.IList coll)
  {
  __setDirty(true);
  allRequirementSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRequirementSets(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This insertion function inserts a new element in the
/// collection in RequirementSets</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRequirementSets(int idx, RequirementSet el)
  {
  __setDirty(true);
  allRequirementSets().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRequirementSets(int idx, RequirementSet el,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRequirementSets(IXmlBBase el)
  {
  return ((System.Collections.IList) allRequirementSets()).IndexOf (el);
  }

/// <summary>Part of the list interface for RequirementSets
/// This deletion function removes an element from the
/// collection in RequirementSets</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRequirementSets(int idx)
  {
  __setDirty(true);
  allRequirementSets().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRequirementSets(int idx,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This deletion function removes an element from the
/// collection in RequirementSets
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRequirementSets(IXmlBBase obj)
  {
  int idx = indexOfRequirementSets(obj);
  if (idx >= 0) { deleteRequirementSets(idx);
NotifyControllers(null);
   }
  }

public void removeRequirementSets(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRequirementSets(obj);
  if (idx >= 0) { deleteRequirementSets(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>the number of elements in RequirementSets</returns>
public int countRequirementSets()
  {
  return allRequirementSets().Count;
  }

/// <summary>Part of the list interface for RequirementSets
/// This function returns an element from the
/// collection in RequirementSets based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RequirementSet getRequirementSets(int idx)
{
  return (RequirementSet) ( allRequirementSets()[idx]);
}

private System.Collections.ArrayList aRuleDisablings;

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <returns>a collection of all the elements in RuleDisablings</returns>
public System.Collections.ArrayList allRuleDisablings()
  {
if (aRuleDisablings == null){
    setAllRuleDisablings( new System.Collections.ArrayList() );
} // If
    return aRuleDisablings;
  }

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <returns>a collection of all the elements in RuleDisablings</returns>
private System.Collections.ArrayList getRuleDisablings()
  {
    return allRuleDisablings();
  }

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <param name="coll">a collection of elements which replaces 
///        RuleDisablings's current content.</param>
public void setAllRuleDisablings(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRuleDisablings = coll;
    NotifyControllers(null);
  }
public void setAllRuleDisablings(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRuleDisablings = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <param name="el">a RuleDisabling to add to the collection in 
///           RuleDisablings</param>
/// <seealso cref="appendRuleDisablings(System.Collections.IList)"/>
public void appendRuleDisablings(RuleDisabling el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRuleDisablings().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRuleDisablings(Lock aLock,RuleDisabling el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRuleDisablings().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for RuleDisablings</summary>
/// <param name="coll">a collection ofRuleDisablings to add to the collection in 
///           RuleDisablings</param>
/// <seealso cref="appendRuleDisablings(RuleDisabling)"/>
public void appendRuleDisablings(System.Collections.IList coll)
  {
  __setDirty(true);
  allRuleDisablings().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRuleDisablings(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRuleDisablings().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This insertion function inserts a new element in the
/// collection in RuleDisablings</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRuleDisablings(int idx, RuleDisabling el)
  {
  __setDirty(true);
  allRuleDisablings().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRuleDisablings(int idx, RuleDisabling el,Lock aLock)
  {
  __setDirty(true);
  allRuleDisablings().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRuleDisablings(IXmlBBase el)
  {
  return ((System.Collections.IList) allRuleDisablings()).IndexOf (el);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This deletion function removes an element from the
/// collection in RuleDisablings</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRuleDisablings(int idx)
  {
  __setDirty(true);
  allRuleDisablings().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRuleDisablings(int idx,Lock aLock)
  {
  __setDirty(true);
  allRuleDisablings().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RuleDisablings
/// This deletion function removes an element from the
/// collection in RuleDisablings
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRuleDisablings(IXmlBBase obj)
  {
  int idx = indexOfRuleDisablings(obj);
  if (idx >= 0) { deleteRuleDisablings(idx);
NotifyControllers(null);
   }
  }

public void removeRuleDisablings(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRuleDisablings(obj);
  if (idx >= 0) { deleteRuleDisablings(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for RuleDisablings</summary>
/// <returns>the number of elements in RuleDisablings</returns>
public int countRuleDisablings()
  {
  return allRuleDisablings().Count;
  }

/// <summary>Part of the list interface for RuleDisablings
/// This function returns an element from the
/// collection in RuleDisablings based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RuleDisabling getRuleDisablings(int idx)
{
  return (RuleDisabling) ( allRuleDisablings()[idx]);
}

private System.Collections.ArrayList aNameSpaces;

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
public System.Collections.ArrayList allNameSpaces()
  {
if (aNameSpaces == null){
    setAllNameSpaces( new System.Collections.ArrayList() );
} // If
    return aNameSpaces;
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
private System.Collections.ArrayList getNameSpaces()
  {
    return allNameSpaces();
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaces's current content.</param>
public void setAllNameSpaces(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaces(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="el">a NameSpace to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(System.Collections.IList)"/>
public void appendNameSpaces(NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaces(Lock aLock,NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection ofNameSpaces to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(NameSpace)"/>
public void appendNameSpaces(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaces(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This insertion function inserts a new element in the
/// collection in NameSpaces</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaces(int idx, NameSpace el)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaces(int idx, NameSpace el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaces(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaces()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaces(int idx)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaces(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaces(IXmlBBase obj)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaces(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>the number of elements in NameSpaces</returns>
public int countNameSpaces()
  {
  return allNameSpaces().Count;
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns an element from the
/// collection in NameSpaces based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpace getNameSpaces(int idx)
{
  return (NameSpace) ( allNameSpaces()[idx]);
}

private System.Collections.ArrayList aNameSpaceRefs;

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
public System.Collections.ArrayList allNameSpaceRefs()
  {
if (aNameSpaceRefs == null){
    setAllNameSpaceRefs( new System.Collections.ArrayList() );
} // If
    return aNameSpaceRefs;
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
private System.Collections.ArrayList getNameSpaceRefs()
  {
    return allNameSpaceRefs();
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaceRefs's current content.</param>
public void setAllNameSpaceRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaceRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="el">a NameSpaceRef to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(System.Collections.IList)"/>
public void appendNameSpaceRefs(NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(Lock aLock,NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection ofNameSpaceRefs to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(NameSpaceRef)"/>
public void appendNameSpaceRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaceRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This insertion function inserts a new element in the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaceRefs(int idx, NameSpaceRef el)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaceRefs(int idx, NameSpaceRef el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaceRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaceRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaceRefs(int idx)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaceRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaceRefs(IXmlBBase obj)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaceRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>the number of elements in NameSpaceRefs</returns>
public int countNameSpaceRefs()
  {
  return allNameSpaceRefs().Count;
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns an element from the
/// collection in NameSpaceRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpaceRef getNameSpaceRefs(int idx)
{
  return (NameSpaceRef) ( allNameSpaceRefs()[idx]);
}

private System.Collections.ArrayList aTests;

/// <summary>Part of the list interface for Tests</summary>
/// <returns>a collection of all the elements in Tests</returns>
public System.Collections.ArrayList allTests()
  {
if (aTests == null){
    setAllTests( new System.Collections.ArrayList() );
} // If
    return aTests;
  }

/// <summary>Part of the list interface for Tests</summary>
/// <returns>a collection of all the elements in Tests</returns>
private System.Collections.ArrayList getTests()
  {
    return allTests();
  }

/// <summary>Part of the list interface for Tests</summary>
/// <param name="coll">a collection of elements which replaces 
///        Tests's current content.</param>
public void setAllTests(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTests = coll;
    NotifyControllers(null);
  }
public void setAllTests(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTests = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests</summary>
/// <param name="el">a Frame to add to the collection in 
///           Tests</param>
/// <seealso cref="appendTests(System.Collections.IList)"/>
public void appendTests(Frame el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTests().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTests(Lock aLock,Frame el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTests().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Tests</summary>
/// <param name="coll">a collection ofFrames to add to the collection in 
///           Tests</param>
/// <seealso cref="appendTests(Frame)"/>
public void appendTests(System.Collections.IList coll)
  {
  __setDirty(true);
  allTests().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTests(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTests().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests
/// This insertion function inserts a new element in the
/// collection in Tests</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTests(int idx, Frame el)
  {
  __setDirty(true);
  allTests().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTests(int idx, Frame el,Lock aLock)
  {
  __setDirty(true);
  allTests().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTests(IXmlBBase el)
  {
  return ((System.Collections.IList) allTests()).IndexOf (el);
  }

/// <summary>Part of the list interface for Tests
/// This deletion function removes an element from the
/// collection in Tests</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTests(int idx)
  {
  __setDirty(true);
  allTests().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTests(int idx,Lock aLock)
  {
  __setDirty(true);
  allTests().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Tests
/// This deletion function removes an element from the
/// collection in Tests
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTests(IXmlBBase obj)
  {
  int idx = indexOfTests(obj);
  if (idx >= 0) { deleteTests(idx);
NotifyControllers(null);
   }
  }

public void removeTests(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTests(obj);
  if (idx >= 0) { deleteTests(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Tests</summary>
/// <returns>the number of elements in Tests</returns>
public int countTests()
  {
  return allTests().Count;
  }

/// <summary>Part of the list interface for Tests
/// This function returns an element from the
/// collection in Tests based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Frame getTests(int idx)
{
  return (Frame) ( allTests()[idx]);
}

private System.Collections.ArrayList aTestRefs;

/// <summary>Part of the list interface for TestRefs</summary>
/// <returns>a collection of all the elements in TestRefs</returns>
public System.Collections.ArrayList allTestRefs()
  {
if (aTestRefs == null){
    setAllTestRefs( new System.Collections.ArrayList() );
} // If
    return aTestRefs;
  }

/// <summary>Part of the list interface for TestRefs</summary>
/// <returns>a collection of all the elements in TestRefs</returns>
private System.Collections.ArrayList getTestRefs()
  {
    return allTestRefs();
  }

/// <summary>Part of the list interface for TestRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        TestRefs's current content.</param>
public void setAllTestRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestRefs = coll;
    NotifyControllers(null);
  }
public void setAllTestRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs</summary>
/// <param name="el">a FrameRef to add to the collection in 
///           TestRefs</param>
/// <seealso cref="appendTestRefs(System.Collections.IList)"/>
public void appendTestRefs(FrameRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTestRefs(Lock aLock,FrameRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TestRefs</summary>
/// <param name="coll">a collection ofFrameRefs to add to the collection in 
///           TestRefs</param>
/// <seealso cref="appendTestRefs(FrameRef)"/>
public void appendTestRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allTestRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTestRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTestRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs
/// This insertion function inserts a new element in the
/// collection in TestRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTestRefs(int idx, FrameRef el)
  {
  __setDirty(true);
  allTestRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTestRefs(int idx, FrameRef el,Lock aLock)
  {
  __setDirty(true);
  allTestRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTestRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allTestRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for TestRefs
/// This deletion function removes an element from the
/// collection in TestRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTestRefs(int idx)
  {
  __setDirty(true);
  allTestRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTestRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allTestRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestRefs
/// This deletion function removes an element from the
/// collection in TestRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTestRefs(IXmlBBase obj)
  {
  int idx = indexOfTestRefs(obj);
  if (idx >= 0) { deleteTestRefs(idx);
NotifyControllers(null);
   }
  }

public void removeTestRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTestRefs(obj);
  if (idx >= 0) { deleteTestRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TestRefs</summary>
/// <returns>the number of elements in TestRefs</returns>
public int countTestRefs()
  {
  return allTestRefs().Count;
  }

/// <summary>Part of the list interface for TestRefs
/// This function returns an element from the
/// collection in TestRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public FrameRef getTestRefs(int idx)
{
  return (FrameRef) ( allTestRefs()[idx]);
}

private  TranslationDictionary aTranslationDictionary;

public  TranslationDictionary getTranslationDictionary() { return aTranslationDictionary;}

public  void setTranslationDictionary(TranslationDictionary v) {
  aTranslationDictionary = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  ShortcutDictionary aShortcutDictionary;

public  ShortcutDictionary getShortcutDictionary() { return aShortcutDictionary;}

public  void setShortcutDictionary(ShortcutDictionary v) {
  aShortcutDictionary = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aXsi;

public   string  getXsi() { return aXsi;}

public  void setXsi( string  v) {
  aXsi = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aXsiLocation;

public   string  getXsiLocation() { return aXsiLocation;}

public  void setXsiLocation( string  v) {
  aXsiLocation = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Dictionary()
{
Dictionary obj = this;
aSpecifications=(null);
aRequirementSets=(null);
aRuleDisablings=(null);
aNameSpaces=(null);
aNameSpaceRefs=(null);
aTests=(null);
aTestRefs=(null);
aTranslationDictionary=(null);
aShortcutDictionary=(null);
aXsi=(null);
aXsiLocation=(null);
}

public void copyTo(Dictionary other)
{
base.copyTo(other);
other.aSpecifications = aSpecifications;
other.aRequirementSets = aRequirementSets;
other.aRuleDisablings = aRuleDisablings;
other.aNameSpaces = aNameSpaces;
other.aNameSpaceRefs = aNameSpaceRefs;
other.aTests = aTests;
other.aTestRefs = aTestRefs;
other.aTranslationDictionary = aTranslationDictionary;
other.aShortcutDictionary = aShortcutDictionary;
other.aXsi = aXsi;
other.aXsiLocation = aXsiLocation;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
Specification fl147;
bool fl158;
RequirementSet fl160;
bool fl171;
RuleDisabling fl173;
bool fl184;
NameSpace fl186;
NameSpaceRef fl198;
bool fl209;
Frame fl211;
FrameRef fl223;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl147 = null;
while(ctxt.lookAheadOpeningTag ("<Specification")) {
fl147 = acceptor.lAccept_Specification(ctxt, "</Specification>");
appendSpecifications(fl147);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<RequirementSets")){
ctxt.skipWhiteSpace();
fl158 = true ; 
while (fl158) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl158 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl160 = null;
while(ctxt.lookAheadOpeningTag ("<RequirementSet")) {
fl160 = acceptor.lAccept_RequirementSet(ctxt, "</RequirementSet>");
appendRequirementSets(fl160);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</RequirementSets>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<RuleDisabling")){
ctxt.skipWhiteSpace();
fl171 = true ; 
while (fl171) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl171 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl173 = null;
while(ctxt.lookAheadOpeningTag ("<RuleDisabling")) {
fl173 = acceptor.lAccept_RuleDisabling(ctxt, "</RuleDisabling>");
appendRuleDisablings(fl173);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</RuleDisabling>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<NameSpaces");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl184 = true ; 
while (fl184) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl184 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl186 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpace")) {
fl186 = acceptor.lAccept_NameSpace(ctxt, "</NameSpace>");
appendNameSpaces(fl186);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl198 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpaceRef")) {
fl198 = acceptor.lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
appendNameSpaceRefs(fl198);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</NameSpaces>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Tests")){
ctxt.skipWhiteSpace();
fl209 = true ; 
while (fl209) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl209 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl211 = null;
while(ctxt.lookAheadOpeningTag ("<Frame")) {
fl211 = acceptor.lAccept_Frame(ctxt, "</Frame>");
appendTests(fl211);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl223 = null;
while(ctxt.lookAheadOpeningTag ("<FrameRef")) {
fl223 = acceptor.lAccept_FrameRef(ctxt, "</FrameRef>");
appendTestRefs(fl223);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Tests>");
} // If
} // If
// End enclosed
// Element Ref : TranslationDictionary
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<TranslationDictionary")){
// Parsing sub element
this.setTranslationDictionary(acceptor.lAccept_TranslationDictionary(ctxt,"</TranslationDictionary>"));
setSon(this.getTranslationDictionary());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Element Ref : ShortcutDictionary
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<ShortcutDictionary")){
// Parsing sub element
this.setShortcutDictionary(acceptor.lAccept_ShortcutDictionary(ctxt,"</ShortcutDictionary>"));
setSon(this.getShortcutDictionary());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl234;
bool fl235;
bool fl236;
bool fl237;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl234 = false ; 
fl235 = false ; 
fl236 = false ; 
fl237 = true ; 
while (fl237) { // BeginLoop 
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
if (ctxt.lookAheadString("i:noNamespaceSchemaLocation=")){
indicator = 235;
} else {
indicator = 238;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("lns:xsi=")){
indicator = 234;
} else {
indicator = 238;
} // If
break;
} // Case
default:
indicator = 238;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 236;
} else {
indicator = 238;
} // If
break;
} // Case
default:
indicator = 238;
break;
} // Switch
switch (indicator) {
case 234: {
// Handling attribute xmlns:xsi
// Also handles alien attributes with prefix xmlns:xsi
if (fl234){
ctxt.fail ("Duplicate attribute: xmlns:xsi");
} // If
fl234 = true ; 
quoteChar = ctxt.acceptQuote();
this.setXsi((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 235: {
// Handling attribute xsi:noNamespaceSchemaLocation
// Also handles alien attributes with prefix xsi:noNamespaceSchemaLocation
if (fl235){
ctxt.fail ("Duplicate attribute: xsi:noNamespaceSchemaLocation");
} // If
fl235 = true ; 
quoteChar = ctxt.acceptQuote();
this.setXsiLocation((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 236: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl236){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl236 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 238: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl234){
ctxt.fail ("Mandatory attribute missing: xmlns:xsi in Dictionary");
} // If
if (!fl235){
ctxt.fail ("Mandatory attribute missing: xsi:noNamespaceSchemaLocation in Dictionary");
} // If
fl237 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Dictionary";
  endingTag = "</Dictionary>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Dictionary\"");
} // If
pw.Write('\n');
pw.Write(" xmlns:xsi=\"");
acceptor.unParsePcData(pw, this.getXsi());
pw.Write('"');
pw.Write('\n');
pw.Write(" xsi:noNamespaceSchemaLocation=\"");
acceptor.unParsePcData(pw, this.getXsiLocation());
pw.Write('"');
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSpecifications(), false, "<Specification", "</Specification>");
// Unparsing Enclosed
// Testing for empty content: RequirementSets
if (countRequirementSets() > 0){
pw.Write("<RequirementSets>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRequirementSets(), false, "<RequirementSet", "</RequirementSet>");
pw.Write("</RequirementSets>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: RequirementSets
// Unparsing Enclosed
// Testing for empty content: RuleDisablings
if (countRuleDisablings() > 0){
pw.Write("<RuleDisabling>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRuleDisablings(), false, "<RuleDisabling", "</RuleDisabling>");
pw.Write("</RuleDisabling>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: RuleDisablings
// Unparsing Enclosed
pw.Write("<NameSpaces>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaces(), false, "<NameSpace", "</NameSpace>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaceRefs(), false, "<NameSpaceRef", "</NameSpaceRef>");
pw.Write("</NameSpaces>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<Tests>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTests(), false, "<Frame", "</Frame>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTestRefs(), false, "<FrameRef", "</FrameRef>");
pw.Write("</Tests>");
// Father is not a mixed
pw.Write('\n');
// Unparsing ElementRef
if (this.getTranslationDictionary() != null){
unParse(pw, this.getTranslationDictionary(),false,"<TranslationDictionary","</TranslationDictionary>");
} // If
// Unparsing ElementRef
if (this.getShortcutDictionary() != null){
unParse(pw, this.getShortcutDictionary(),false,"<ShortcutDictionary","</ShortcutDictionary>");
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSpecifications(); i++) {
  l.Add(getSpecifications(i));
}
for (int i = 0; i < countRequirementSets(); i++) {
  l.Add(getRequirementSets(i));
}
for (int i = 0; i < countRuleDisablings(); i++) {
  l.Add(getRuleDisablings(i));
}
for (int i = 0; i < countNameSpaces(); i++) {
  l.Add(getNameSpaces(i));
}
for (int i = 0; i < countNameSpaceRefs(); i++) {
  l.Add(getNameSpaceRefs(i));
}
for (int i = 0; i < countTests(); i++) {
  l.Add(getTests(i));
}
for (int i = 0; i < countTestRefs(); i++) {
  l.Add(getTestRefs(i));
}
l.Add(this.getTranslationDictionary());
l.Add(this.getShortcutDictionary());
}

}
public partial class RuleDisabling
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getRule().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RuleDisablingController.alertChange(aLock, this);
}
private   string  aRule;

public   string  getRule() { return aRule;}

public  void setRule( string  v) {
  aRule = v;
  __setDirty(true);
  NotifyControllers(null);
}


public RuleDisabling()
{
RuleDisabling obj = this;
aRule=(null);
}

public void copyTo(RuleDisabling other)
{
base.copyTo(other);
other.aRule = aRule;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl244;
bool fl245;
bool fl246;
bool fl247;
bool fl248;
bool fl249;
bool fl250;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl244 = false ; 
fl245 = false ; 
fl246 = false ; 
fl247 = false ; 
fl248 = false ; 
fl249 = false ; 
fl250 = true ; 
while (fl250) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 246;
} else {
indicator = 251;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("ule=")){
indicator = 244;
} else {
indicator = 251;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 247;
} else {
indicator = 251;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 248;
} else {
indicator = 251;
} // If
break;
} // Case
default:
indicator = 251;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 245;
} else {
indicator = 251;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 249;
} else {
indicator = 251;
} // If
break;
} // Case
default:
indicator = 251;
break;
} // Switch
switch (indicator) {
case 244: {
// Handling attribute Rule
// Also handles alien attributes with prefix Rule
if (fl244){
ctxt.fail ("Duplicate attribute: Rule");
} // If
fl244 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRule((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 245: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl245){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl245 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 246: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl246){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl246 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 247: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl247){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl247 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 248: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl248){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl248 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 249: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl249){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl249 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 251: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl244){
ctxt.fail ("Mandatory attribute missing: Rule in RuleDisabling");
} // If
if (!fl245){
this.setImplemented( false);
} // If
if (!fl246){
this.setVerified( false);
} // If
if (!fl247){
this.setNeedsRequirement( true);
} // If
fl250 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RuleDisabling";
  endingTag = "</RuleDisabling>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RuleDisabling\"");
} // If
pw.Write('\n');
pw.Write(" Rule=\"");
acceptor.unParsePcData(pw, this.getRule());
pw.Write('"');
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class NameSpaceRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.NameSpaceRefController.alertChange(aLock, this);
}
public NameSpaceRef()
{
NameSpaceRef obj = this;
}

public void copyTo(NameSpaceRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl260;
bool fl261;
bool fl262;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl260 = false ; 
fl261 = false ; 
fl262 = true ; 
while (fl262) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 260;
} else {
indicator = 263;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 261;
} else {
indicator = 263;
} // If
break;
} // Case
default:
indicator = 263;
break;
} // Switch
switch (indicator) {
case 260: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl260){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl260 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 261: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl261){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl261 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 263: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl262 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<NameSpaceRef";
  endingTag = "</NameSpaceRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"NameSpaceRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class NameSpace
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.NameSpaceController.alertChange(aLock, this);
}
private System.Collections.ArrayList aNameSpaces;

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
public System.Collections.ArrayList allNameSpaces()
  {
if (aNameSpaces == null){
    setAllNameSpaces( new System.Collections.ArrayList() );
} // If
    return aNameSpaces;
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>a collection of all the elements in NameSpaces</returns>
private System.Collections.ArrayList getNameSpaces()
  {
    return allNameSpaces();
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaces's current content.</param>
public void setAllNameSpaces(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaces(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaces = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="el">a NameSpace to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(System.Collections.IList)"/>
public void appendNameSpaces(NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaces(Lock aLock,NameSpace el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaces</summary>
/// <param name="coll">a collection ofNameSpaces to add to the collection in 
///           NameSpaces</param>
/// <seealso cref="appendNameSpaces(NameSpace)"/>
public void appendNameSpaces(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaces(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This insertion function inserts a new element in the
/// collection in NameSpaces</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaces(int idx, NameSpace el)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaces(int idx, NameSpace el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaces(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaces()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaces(int idx)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaces(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaces().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaces
/// This deletion function removes an element from the
/// collection in NameSpaces
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaces(IXmlBBase obj)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaces(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaces(obj);
  if (idx >= 0) { deleteNameSpaces(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaces</summary>
/// <returns>the number of elements in NameSpaces</returns>
public int countNameSpaces()
  {
  return allNameSpaces().Count;
  }

/// <summary>Part of the list interface for NameSpaces
/// This function returns an element from the
/// collection in NameSpaces based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpace getNameSpaces(int idx)
{
  return (NameSpace) ( allNameSpaces()[idx]);
}

private System.Collections.ArrayList aNameSpaceRefs;

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
public System.Collections.ArrayList allNameSpaceRefs()
  {
if (aNameSpaceRefs == null){
    setAllNameSpaceRefs( new System.Collections.ArrayList() );
} // If
    return aNameSpaceRefs;
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>a collection of all the elements in NameSpaceRefs</returns>
private System.Collections.ArrayList getNameSpaceRefs()
  {
    return allNameSpaceRefs();
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        NameSpaceRefs's current content.</param>
public void setAllNameSpaceRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
    NotifyControllers(null);
  }
public void setAllNameSpaceRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aNameSpaceRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="el">a NameSpaceRef to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(System.Collections.IList)"/>
public void appendNameSpaceRefs(NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(Lock aLock,NameSpaceRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allNameSpaceRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <param name="coll">a collection ofNameSpaceRefs to add to the collection in 
///           NameSpaceRefs</param>
/// <seealso cref="appendNameSpaceRefs(NameSpaceRef)"/>
public void appendNameSpaceRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allNameSpaceRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendNameSpaceRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This insertion function inserts a new element in the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertNameSpaceRefs(int idx, NameSpaceRef el)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertNameSpaceRefs(int idx, NameSpaceRef el,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfNameSpaceRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allNameSpaceRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteNameSpaceRefs(int idx)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteNameSpaceRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allNameSpaceRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This deletion function removes an element from the
/// collection in NameSpaceRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeNameSpaceRefs(IXmlBBase obj)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(null);
   }
  }

public void removeNameSpaceRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfNameSpaceRefs(obj);
  if (idx >= 0) { deleteNameSpaceRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for NameSpaceRefs</summary>
/// <returns>the number of elements in NameSpaceRefs</returns>
public int countNameSpaceRefs()
  {
  return allNameSpaceRefs().Count;
  }

/// <summary>Part of the list interface for NameSpaceRefs
/// This function returns an element from the
/// collection in NameSpaceRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public NameSpaceRef getNameSpaceRefs(int idx)
{
  return (NameSpaceRef) ( allNameSpaceRefs()[idx]);
}

private System.Collections.ArrayList aRanges;

/// <summary>Part of the list interface for Ranges</summary>
/// <returns>a collection of all the elements in Ranges</returns>
public System.Collections.ArrayList allRanges()
  {
if (aRanges == null){
    setAllRanges( new System.Collections.ArrayList() );
} // If
    return aRanges;
  }

/// <summary>Part of the list interface for Ranges</summary>
/// <returns>a collection of all the elements in Ranges</returns>
private System.Collections.ArrayList getRanges()
  {
    return allRanges();
  }

/// <summary>Part of the list interface for Ranges</summary>
/// <param name="coll">a collection of elements which replaces 
///        Ranges's current content.</param>
public void setAllRanges(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRanges = coll;
    NotifyControllers(null);
  }
public void setAllRanges(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRanges = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges</summary>
/// <param name="el">a Range to add to the collection in 
///           Ranges</param>
/// <seealso cref="appendRanges(System.Collections.IList)"/>
public void appendRanges(Range el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRanges().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRanges(Lock aLock,Range el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRanges().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Ranges</summary>
/// <param name="coll">a collection ofRanges to add to the collection in 
///           Ranges</param>
/// <seealso cref="appendRanges(Range)"/>
public void appendRanges(System.Collections.IList coll)
  {
  __setDirty(true);
  allRanges().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRanges(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRanges().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges
/// This insertion function inserts a new element in the
/// collection in Ranges</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRanges(int idx, Range el)
  {
  __setDirty(true);
  allRanges().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRanges(int idx, Range el,Lock aLock)
  {
  __setDirty(true);
  allRanges().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRanges(IXmlBBase el)
  {
  return ((System.Collections.IList) allRanges()).IndexOf (el);
  }

/// <summary>Part of the list interface for Ranges
/// This deletion function removes an element from the
/// collection in Ranges</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRanges(int idx)
  {
  __setDirty(true);
  allRanges().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRanges(int idx,Lock aLock)
  {
  __setDirty(true);
  allRanges().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Ranges
/// This deletion function removes an element from the
/// collection in Ranges
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRanges(IXmlBBase obj)
  {
  int idx = indexOfRanges(obj);
  if (idx >= 0) { deleteRanges(idx);
NotifyControllers(null);
   }
  }

public void removeRanges(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRanges(obj);
  if (idx >= 0) { deleteRanges(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Ranges</summary>
/// <returns>the number of elements in Ranges</returns>
public int countRanges()
  {
  return allRanges().Count;
  }

/// <summary>Part of the list interface for Ranges
/// This function returns an element from the
/// collection in Ranges based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Range getRanges(int idx)
{
  return (Range) ( allRanges()[idx]);
}

private System.Collections.ArrayList aEnumerations;

/// <summary>Part of the list interface for Enumerations</summary>
/// <returns>a collection of all the elements in Enumerations</returns>
public System.Collections.ArrayList allEnumerations()
  {
if (aEnumerations == null){
    setAllEnumerations( new System.Collections.ArrayList() );
} // If
    return aEnumerations;
  }

/// <summary>Part of the list interface for Enumerations</summary>
/// <returns>a collection of all the elements in Enumerations</returns>
private System.Collections.ArrayList getEnumerations()
  {
    return allEnumerations();
  }

/// <summary>Part of the list interface for Enumerations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Enumerations's current content.</param>
public void setAllEnumerations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aEnumerations = coll;
    NotifyControllers(null);
  }
public void setAllEnumerations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aEnumerations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations</summary>
/// <param name="el">a Enum to add to the collection in 
///           Enumerations</param>
/// <seealso cref="appendEnumerations(System.Collections.IList)"/>
public void appendEnumerations(Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allEnumerations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendEnumerations(Lock aLock,Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allEnumerations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Enumerations</summary>
/// <param name="coll">a collection ofEnums to add to the collection in 
///           Enumerations</param>
/// <seealso cref="appendEnumerations(Enum)"/>
public void appendEnumerations(System.Collections.IList coll)
  {
  __setDirty(true);
  allEnumerations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendEnumerations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allEnumerations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations
/// This insertion function inserts a new element in the
/// collection in Enumerations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertEnumerations(int idx, Enum el)
  {
  __setDirty(true);
  allEnumerations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertEnumerations(int idx, Enum el,Lock aLock)
  {
  __setDirty(true);
  allEnumerations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfEnumerations(IXmlBBase el)
  {
  return ((System.Collections.IList) allEnumerations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Enumerations
/// This deletion function removes an element from the
/// collection in Enumerations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteEnumerations(int idx)
  {
  __setDirty(true);
  allEnumerations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteEnumerations(int idx,Lock aLock)
  {
  __setDirty(true);
  allEnumerations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Enumerations
/// This deletion function removes an element from the
/// collection in Enumerations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeEnumerations(IXmlBBase obj)
  {
  int idx = indexOfEnumerations(obj);
  if (idx >= 0) { deleteEnumerations(idx);
NotifyControllers(null);
   }
  }

public void removeEnumerations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfEnumerations(obj);
  if (idx >= 0) { deleteEnumerations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Enumerations</summary>
/// <returns>the number of elements in Enumerations</returns>
public int countEnumerations()
  {
  return allEnumerations().Count;
  }

/// <summary>Part of the list interface for Enumerations
/// This function returns an element from the
/// collection in Enumerations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Enum getEnumerations(int idx)
{
  return (Enum) ( allEnumerations()[idx]);
}

private System.Collections.ArrayList aStructures;

/// <summary>Part of the list interface for Structures</summary>
/// <returns>a collection of all the elements in Structures</returns>
public System.Collections.ArrayList allStructures()
  {
if (aStructures == null){
    setAllStructures( new System.Collections.ArrayList() );
} // If
    return aStructures;
  }

/// <summary>Part of the list interface for Structures</summary>
/// <returns>a collection of all the elements in Structures</returns>
private System.Collections.ArrayList getStructures()
  {
    return allStructures();
  }

/// <summary>Part of the list interface for Structures</summary>
/// <param name="coll">a collection of elements which replaces 
///        Structures's current content.</param>
public void setAllStructures(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStructures = coll;
    NotifyControllers(null);
  }
public void setAllStructures(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStructures = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures</summary>
/// <param name="el">a Structure to add to the collection in 
///           Structures</param>
/// <seealso cref="appendStructures(System.Collections.IList)"/>
public void appendStructures(Structure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStructures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStructures(Lock aLock,Structure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStructures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Structures</summary>
/// <param name="coll">a collection ofStructures to add to the collection in 
///           Structures</param>
/// <seealso cref="appendStructures(Structure)"/>
public void appendStructures(System.Collections.IList coll)
  {
  __setDirty(true);
  allStructures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStructures(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStructures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures
/// This insertion function inserts a new element in the
/// collection in Structures</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStructures(int idx, Structure el)
  {
  __setDirty(true);
  allStructures().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStructures(int idx, Structure el,Lock aLock)
  {
  __setDirty(true);
  allStructures().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStructures(IXmlBBase el)
  {
  return ((System.Collections.IList) allStructures()).IndexOf (el);
  }

/// <summary>Part of the list interface for Structures
/// This deletion function removes an element from the
/// collection in Structures</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStructures(int idx)
  {
  __setDirty(true);
  allStructures().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStructures(int idx,Lock aLock)
  {
  __setDirty(true);
  allStructures().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Structures
/// This deletion function removes an element from the
/// collection in Structures
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStructures(IXmlBBase obj)
  {
  int idx = indexOfStructures(obj);
  if (idx >= 0) { deleteStructures(idx);
NotifyControllers(null);
   }
  }

public void removeStructures(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStructures(obj);
  if (idx >= 0) { deleteStructures(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Structures</summary>
/// <returns>the number of elements in Structures</returns>
public int countStructures()
  {
  return allStructures().Count;
  }

/// <summary>Part of the list interface for Structures
/// This function returns an element from the
/// collection in Structures based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Structure getStructures(int idx)
{
  return (Structure) ( allStructures()[idx]);
}

private System.Collections.ArrayList aCollections;

/// <summary>Part of the list interface for Collections</summary>
/// <returns>a collection of all the elements in Collections</returns>
public System.Collections.ArrayList allCollections()
  {
if (aCollections == null){
    setAllCollections( new System.Collections.ArrayList() );
} // If
    return aCollections;
  }

/// <summary>Part of the list interface for Collections</summary>
/// <returns>a collection of all the elements in Collections</returns>
private System.Collections.ArrayList getCollections()
  {
    return allCollections();
  }

/// <summary>Part of the list interface for Collections</summary>
/// <param name="coll">a collection of elements which replaces 
///        Collections's current content.</param>
public void setAllCollections(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCollections = coll;
    NotifyControllers(null);
  }
public void setAllCollections(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCollections = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections</summary>
/// <param name="el">a Collection to add to the collection in 
///           Collections</param>
/// <seealso cref="appendCollections(System.Collections.IList)"/>
public void appendCollections(Collection el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCollections().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendCollections(Lock aLock,Collection el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCollections().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Collections</summary>
/// <param name="coll">a collection ofCollections to add to the collection in 
///           Collections</param>
/// <seealso cref="appendCollections(Collection)"/>
public void appendCollections(System.Collections.IList coll)
  {
  __setDirty(true);
  allCollections().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendCollections(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allCollections().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections
/// This insertion function inserts a new element in the
/// collection in Collections</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertCollections(int idx, Collection el)
  {
  __setDirty(true);
  allCollections().Insert (idx, el);
NotifyControllers(null);
  }

public void insertCollections(int idx, Collection el,Lock aLock)
  {
  __setDirty(true);
  allCollections().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfCollections(IXmlBBase el)
  {
  return ((System.Collections.IList) allCollections()).IndexOf (el);
  }

/// <summary>Part of the list interface for Collections
/// This deletion function removes an element from the
/// collection in Collections</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteCollections(int idx)
  {
  __setDirty(true);
  allCollections().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteCollections(int idx,Lock aLock)
  {
  __setDirty(true);
  allCollections().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Collections
/// This deletion function removes an element from the
/// collection in Collections
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeCollections(IXmlBBase obj)
  {
  int idx = indexOfCollections(obj);
  if (idx >= 0) { deleteCollections(idx);
NotifyControllers(null);
   }
  }

public void removeCollections(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfCollections(obj);
  if (idx >= 0) { deleteCollections(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Collections</summary>
/// <returns>the number of elements in Collections</returns>
public int countCollections()
  {
  return allCollections().Count;
  }

/// <summary>Part of the list interface for Collections
/// This function returns an element from the
/// collection in Collections based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Collection getCollections(int idx)
{
  return (Collection) ( allCollections()[idx]);
}

private System.Collections.ArrayList aStateMachines;

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
public System.Collections.ArrayList allStateMachines()
  {
if (aStateMachines == null){
    setAllStateMachines( new System.Collections.ArrayList() );
} // If
    return aStateMachines;
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
private System.Collections.ArrayList getStateMachines()
  {
    return allStateMachines();
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection of elements which replaces 
///        StateMachines's current content.</param>
public void setAllStateMachines(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
    NotifyControllers(null);
  }
public void setAllStateMachines(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="el">a StateMachine to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(System.Collections.IList)"/>
public void appendStateMachines(StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStateMachines(Lock aLock,StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection ofStateMachines to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(StateMachine)"/>
public void appendStateMachines(System.Collections.IList coll)
  {
  __setDirty(true);
  allStateMachines().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStateMachines(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This insertion function inserts a new element in the
/// collection in StateMachines</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStateMachines(int idx, StateMachine el)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStateMachines(int idx, StateMachine el,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStateMachines(IXmlBBase el)
  {
  return ((System.Collections.IList) allStateMachines()).IndexOf (el);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStateMachines(int idx)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStateMachines(int idx,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStateMachines(IXmlBBase obj)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(null);
   }
  }

public void removeStateMachines(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>the number of elements in StateMachines</returns>
public int countStateMachines()
  {
  return allStateMachines().Count;
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns an element from the
/// collection in StateMachines based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StateMachine getStateMachines(int idx)
{
  return (StateMachine) ( allStateMachines()[idx]);
}

private System.Collections.ArrayList aFunctions;

/// <summary>Part of the list interface for Functions</summary>
/// <returns>a collection of all the elements in Functions</returns>
public System.Collections.ArrayList allFunctions()
  {
if (aFunctions == null){
    setAllFunctions( new System.Collections.ArrayList() );
} // If
    return aFunctions;
  }

/// <summary>Part of the list interface for Functions</summary>
/// <returns>a collection of all the elements in Functions</returns>
private System.Collections.ArrayList getFunctions()
  {
    return allFunctions();
  }

/// <summary>Part of the list interface for Functions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Functions's current content.</param>
public void setAllFunctions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFunctions = coll;
    NotifyControllers(null);
  }
public void setAllFunctions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFunctions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions</summary>
/// <param name="el">a Function to add to the collection in 
///           Functions</param>
/// <seealso cref="appendFunctions(System.Collections.IList)"/>
public void appendFunctions(Function el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFunctions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFunctions(Lock aLock,Function el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFunctions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Functions</summary>
/// <param name="coll">a collection ofFunctions to add to the collection in 
///           Functions</param>
/// <seealso cref="appendFunctions(Function)"/>
public void appendFunctions(System.Collections.IList coll)
  {
  __setDirty(true);
  allFunctions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFunctions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFunctions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions
/// This insertion function inserts a new element in the
/// collection in Functions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFunctions(int idx, Function el)
  {
  __setDirty(true);
  allFunctions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFunctions(int idx, Function el,Lock aLock)
  {
  __setDirty(true);
  allFunctions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFunctions(IXmlBBase el)
  {
  return ((System.Collections.IList) allFunctions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Functions
/// This deletion function removes an element from the
/// collection in Functions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFunctions(int idx)
  {
  __setDirty(true);
  allFunctions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFunctions(int idx,Lock aLock)
  {
  __setDirty(true);
  allFunctions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Functions
/// This deletion function removes an element from the
/// collection in Functions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFunctions(IXmlBBase obj)
  {
  int idx = indexOfFunctions(obj);
  if (idx >= 0) { deleteFunctions(idx);
NotifyControllers(null);
   }
  }

public void removeFunctions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFunctions(obj);
  if (idx >= 0) { deleteFunctions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Functions</summary>
/// <returns>the number of elements in Functions</returns>
public int countFunctions()
  {
  return allFunctions().Count;
  }

/// <summary>Part of the list interface for Functions
/// This function returns an element from the
/// collection in Functions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Function getFunctions(int idx)
{
  return (Function) ( allFunctions()[idx]);
}

private System.Collections.ArrayList aProcedures;

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
public System.Collections.ArrayList allProcedures()
  {
if (aProcedures == null){
    setAllProcedures( new System.Collections.ArrayList() );
} // If
    return aProcedures;
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
private System.Collections.ArrayList getProcedures()
  {
    return allProcedures();
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection of elements which replaces 
///        Procedures's current content.</param>
public void setAllProcedures(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
    NotifyControllers(null);
  }
public void setAllProcedures(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="el">a Procedure to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(System.Collections.IList)"/>
public void appendProcedures(Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendProcedures(Lock aLock,Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection ofProcedures to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(Procedure)"/>
public void appendProcedures(System.Collections.IList coll)
  {
  __setDirty(true);
  allProcedures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendProcedures(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allProcedures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This insertion function inserts a new element in the
/// collection in Procedures</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertProcedures(int idx, Procedure el)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(null);
  }

public void insertProcedures(int idx, Procedure el,Lock aLock)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfProcedures(IXmlBBase el)
  {
  return ((System.Collections.IList) allProcedures()).IndexOf (el);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteProcedures(int idx)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteProcedures(int idx,Lock aLock)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeProcedures(IXmlBBase obj)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(null);
   }
  }

public void removeProcedures(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>the number of elements in Procedures</returns>
public int countProcedures()
  {
  return allProcedures().Count;
  }

/// <summary>Part of the list interface for Procedures
/// This function returns an element from the
/// collection in Procedures based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Procedure getProcedures(int idx)
{
  return (Procedure) ( allProcedures()[idx]);
}

private System.Collections.ArrayList aVariables;

/// <summary>Part of the list interface for Variables</summary>
/// <returns>a collection of all the elements in Variables</returns>
public System.Collections.ArrayList allVariables()
  {
if (aVariables == null){
    setAllVariables( new System.Collections.ArrayList() );
} // If
    return aVariables;
  }

/// <summary>Part of the list interface for Variables</summary>
/// <returns>a collection of all the elements in Variables</returns>
private System.Collections.ArrayList getVariables()
  {
    return allVariables();
  }

/// <summary>Part of the list interface for Variables</summary>
/// <param name="coll">a collection of elements which replaces 
///        Variables's current content.</param>
public void setAllVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aVariables = coll;
    NotifyControllers(null);
  }
public void setAllVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables</summary>
/// <param name="el">a Variable to add to the collection in 
///           Variables</param>
/// <seealso cref="appendVariables(System.Collections.IList)"/>
public void appendVariables(Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendVariables(Lock aLock,Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Variables</summary>
/// <param name="coll">a collection ofVariables to add to the collection in 
///           Variables</param>
/// <seealso cref="appendVariables(Variable)"/>
public void appendVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables
/// This insertion function inserts a new element in the
/// collection in Variables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertVariables(int idx, Variable el)
  {
  __setDirty(true);
  allVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertVariables(int idx, Variable el,Lock aLock)
  {
  __setDirty(true);
  allVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for Variables
/// This deletion function removes an element from the
/// collection in Variables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteVariables(int idx)
  {
  __setDirty(true);
  allVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Variables
/// This deletion function removes an element from the
/// collection in Variables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeVariables(IXmlBBase obj)
  {
  int idx = indexOfVariables(obj);
  if (idx >= 0) { deleteVariables(idx);
NotifyControllers(null);
   }
  }

public void removeVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfVariables(obj);
  if (idx >= 0) { deleteVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Variables</summary>
/// <returns>the number of elements in Variables</returns>
public int countVariables()
  {
  return allVariables().Count;
  }

/// <summary>Part of the list interface for Variables
/// This function returns an element from the
/// collection in Variables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Variable getVariables(int idx)
{
  return (Variable) ( allVariables()[idx]);
}

private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public NameSpace()
{
NameSpace obj = this;
aNameSpaces=(null);
aNameSpaceRefs=(null);
aRanges=(null);
aEnumerations=(null);
aStructures=(null);
aCollections=(null);
aStateMachines=(null);
aFunctions=(null);
aProcedures=(null);
aVariables=(null);
aRules=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
aComment=(null);
}

public void copyTo(NameSpace other)
{
base.copyTo(other);
other.aNameSpaces = aNameSpaces;
other.aNameSpaceRefs = aNameSpaceRefs;
other.aRanges = aRanges;
other.aEnumerations = aEnumerations;
other.aStructures = aStructures;
other.aCollections = aCollections;
other.aStateMachines = aStateMachines;
other.aFunctions = aFunctions;
other.aProcedures = aProcedures;
other.aVariables = aVariables;
other.aRules = aRules;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl267;
bool fl268;
NameSpace fl270;
NameSpaceRef fl282;
bool fl293;
Range fl295;
bool fl306;
Enum fl308;
bool fl319;
Structure fl321;
bool fl332;
Collection fl334;
bool fl345;
StateMachine fl347;
bool fl358;
Function fl360;
bool fl371;
Procedure fl373;
bool fl384;
Variable fl386;
bool fl397;
Rule fl399;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl267 = true ; 
while (fl267) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl267 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<NameSpaces")){
ctxt.skipWhiteSpace();
fl268 = true ; 
while (fl268) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl268 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl270 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpace")) {
fl270 = acceptor.lAccept_NameSpace(ctxt, "</NameSpace>");
appendNameSpaces(fl270);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl282 = null;
while(ctxt.lookAheadOpeningTag ("<NameSpaceRef")) {
fl282 = acceptor.lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
appendNameSpaceRefs(fl282);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</NameSpaces>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Ranges")){
ctxt.skipWhiteSpace();
fl293 = true ; 
while (fl293) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl293 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl295 = null;
while(ctxt.lookAheadOpeningTag ("<Range")) {
fl295 = acceptor.lAccept_Range(ctxt, "</Range>");
appendRanges(fl295);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Ranges>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Enumerations")){
ctxt.skipWhiteSpace();
fl306 = true ; 
while (fl306) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl306 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl308 = null;
while(ctxt.lookAheadOpeningTag ("<Enum")) {
fl308 = acceptor.lAccept_Enum(ctxt, "</Enum>");
appendEnumerations(fl308);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Enumerations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Structures")){
ctxt.skipWhiteSpace();
fl319 = true ; 
while (fl319) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl319 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl321 = null;
while(ctxt.lookAheadOpeningTag ("<Structure")) {
fl321 = acceptor.lAccept_Structure(ctxt, "</Structure>");
appendStructures(fl321);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Structures>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Collections")){
ctxt.skipWhiteSpace();
fl332 = true ; 
while (fl332) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl332 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl334 = null;
while(ctxt.lookAheadOpeningTag ("<Collection")) {
fl334 = acceptor.lAccept_Collection(ctxt, "</Collection>");
appendCollections(fl334);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Collections>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<StateMachines")){
ctxt.skipWhiteSpace();
fl345 = true ; 
while (fl345) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl345 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl347 = null;
while(ctxt.lookAheadOpeningTag ("<StateMachine")) {
fl347 = acceptor.lAccept_StateMachine(ctxt, "</StateMachine>");
appendStateMachines(fl347);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</StateMachines>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Functions")){
ctxt.skipWhiteSpace();
fl358 = true ; 
while (fl358) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl358 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl360 = null;
while(ctxt.lookAheadOpeningTag ("<Function")) {
fl360 = acceptor.lAccept_Function(ctxt, "</Function>");
appendFunctions(fl360);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Functions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Procedures")){
ctxt.skipWhiteSpace();
fl371 = true ; 
while (fl371) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl371 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl373 = null;
while(ctxt.lookAheadOpeningTag ("<Procedure")) {
fl373 = acceptor.lAccept_Procedure(ctxt, "</Procedure>");
appendProcedures(fl373);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Procedures>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Variables")){
ctxt.skipWhiteSpace();
fl384 = true ; 
while (fl384) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl384 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl386 = null;
while(ctxt.lookAheadOpeningTag ("<Variable")) {
fl386 = acceptor.lAccept_Variable(ctxt, "</Variable>");
appendVariables(fl386);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Variables>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl397 = true ; 
while (fl397) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl397 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl399 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl399 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl399);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl410;
bool fl411;
bool fl412;
bool fl413;
bool fl414;
bool fl415;
bool fl416;
bool fl417;
bool fl418;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl410 = false ; 
fl411 = false ; 
fl412 = false ; 
fl413 = false ; 
fl414 = false ; 
fl415 = false ; 
fl416 = false ; 
fl417 = false ; 
fl418 = true ; 
while (fl418) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 411;
} else {
indicator = 419;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 410;
} else {
indicator = 419;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 412;
} else {
indicator = 419;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 415;
} else {
indicator = 419;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 416;
} else {
indicator = 419;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 414;
} else {
indicator = 419;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 413;
} else {
indicator = 419;
} // If
break;
} // Case
default:
indicator = 419;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 417;
} else {
indicator = 419;
} // If
break;
} // Case
default:
indicator = 419;
break;
} // Switch
switch (indicator) {
case 410: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl410){
ctxt.fail ("Duplicate attribute: X");
} // If
fl410 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 411: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl411){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl411 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 412: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl412){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl412 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 413: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl413){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl413 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 414: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl414){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl414 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 415: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl415){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl415 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 416: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl416){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl416 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 417: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl417){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl417 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 419: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl410){
this.setX(0);
} // If
if (!fl411){
this.setY(0);
} // If
if (!fl412){
this.setWidth(0);
} // If
if (!fl413){
this.setHeight(0);
} // If
if (!fl414){
this.setHidden( false);
} // If
if (!fl415){
this.setPinned( false);
} // If
fl418 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<NameSpace";
  endingTag = "</NameSpace>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"NameSpace\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
pw.Write("<NameSpaces>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaces(), false, "<NameSpace", "</NameSpace>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getNameSpaceRefs(), false, "<NameSpaceRef", "</NameSpaceRef>");
pw.Write("</NameSpaces>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: Ranges
if (countRanges() > 0){
pw.Write("<Ranges>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRanges(), false, "<Range", "</Range>");
pw.Write("</Ranges>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Ranges
// Unparsing Enclosed
// Testing for empty content: Enumerations
if (countEnumerations() > 0){
pw.Write("<Enumerations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getEnumerations(), false, "<Enum", "</Enum>");
pw.Write("</Enumerations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Enumerations
// Unparsing Enclosed
// Testing for empty content: Structures
if (countStructures() > 0){
pw.Write("<Structures>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStructures(), false, "<Structure", "</Structure>");
pw.Write("</Structures>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Structures
// Unparsing Enclosed
// Testing for empty content: Collections
if (countCollections() > 0){
pw.Write("<Collections>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getCollections(), false, "<Collection", "</Collection>");
pw.Write("</Collections>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Collections
// Unparsing Enclosed
// Testing for empty content: StateMachines
if (countStateMachines() > 0){
pw.Write("<StateMachines>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStateMachines(), false, "<StateMachine", "</StateMachine>");
pw.Write("</StateMachines>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: StateMachines
// Unparsing Enclosed
// Testing for empty content: Functions
if (countFunctions() > 0){
pw.Write("<Functions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFunctions(), false, "<Function", "</Function>");
pw.Write("</Functions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Functions
// Unparsing Enclosed
// Testing for empty content: Procedures
if (countProcedures() > 0){
pw.Write("<Procedures>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getProcedures(), false, "<Procedure", "</Procedure>");
pw.Write("</Procedures>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Procedures
// Unparsing Enclosed
// Testing for empty content: Variables
if (countVariables() > 0){
pw.Write("<Variables>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getVariables(), false, "<Variable", "</Variable>");
pw.Write("</Variables>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Variables
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countNameSpaces(); i++) {
  l.Add(getNameSpaces(i));
}
for (int i = 0; i < countNameSpaceRefs(); i++) {
  l.Add(getNameSpaceRefs(i));
}
for (int i = 0; i < countRanges(); i++) {
  l.Add(getRanges(i));
}
for (int i = 0; i < countEnumerations(); i++) {
  l.Add(getEnumerations(i));
}
for (int i = 0; i < countStructures(); i++) {
  l.Add(getStructures(i));
}
for (int i = 0; i < countCollections(); i++) {
  l.Add(getCollections(i));
}
for (int i = 0; i < countStateMachines(); i++) {
  l.Add(getStateMachines(i));
}
for (int i = 0; i < countFunctions(); i++) {
  l.Add(getFunctions(i));
}
for (int i = 0; i < countProcedures(); i++) {
  l.Add(getProcedures(i));
}
for (int i = 0; i < countVariables(); i++) {
  l.Add(getVariables(i));
}
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
}

}
public partial class ReqRef
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getId().CompareTo((String) search) == 0)return true;
if(getSpecId().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ReqRefController.alertChange(aLock, this);
}
private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aSpecId;

public   string  getSpecId() { return aSpecId;}

public  void setSpecId( string  v) {
  aSpecId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ReqRef()
{
ReqRef obj = this;
aId=(null);
aSpecId=(null);
aComment=(null);
}

public void copyTo(ReqRef other)
{
base.copyTo(other);
other.aId = aId;
other.aSpecId = aSpecId;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl430;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl430 = true ; 
while (fl430) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl430 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl431;
bool fl432;
bool fl433;
bool fl434;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl431 = false ; 
fl432 = false ; 
fl433 = false ; 
fl434 = true ; 
while (fl434) { // BeginLoop 
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
if (ctxt.lookAheadString("pecId=")){
indicator = 432;
} else {
indicator = 435;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 431;
} else {
indicator = 435;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 433;
} else {
indicator = 435;
} // If
break;
} // Case
default:
indicator = 435;
break;
} // Switch
switch (indicator) {
case 431: {
// Handling attribute Id
// Also handles alien attributes with prefix Id
if (fl431){
ctxt.fail ("Duplicate attribute: Id");
} // If
fl431 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 432: {
// Handling attribute SpecId
// Also handles alien attributes with prefix SpecId
if (fl432){
ctxt.fail ("Duplicate attribute: SpecId");
} // If
fl432 = true ; 
quoteChar = ctxt.acceptQuote();
this.setSpecId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 433: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl433){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl433 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 435: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl431){
ctxt.fail ("Mandatory attribute missing: Id in ReqRef");
} // If
fl434 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ReqRef";
  endingTag = "</ReqRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ReqRef\"");
} // If
pw.Write('\n');
pw.Write(" Id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
if (this.getSpecId() != null){
pw.Write(" SpecId=\"");
acceptor.unParsePcData(pw, this.getSpecId());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public abstract partial class Type
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getDefault().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TypeController.alertChange(aLock, this);
}
private   string  aDefault;

public   string  getDefault() { return aDefault;}

public  void setDefault( string  v) {
  aDefault = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Type()
{
Type obj = this;
aDefault=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
}

public void copyTo(Type other)
{
base.copyTo(other);
other.aDefault = aDefault;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl440;
bool fl441;
bool fl442;
bool fl443;
bool fl444;
bool fl445;
bool fl446;
bool fl447;
bool fl448;
bool fl449;
bool fl450;
bool fl451;
bool fl452;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl440 = false ; 
fl441 = false ; 
fl442 = false ; 
fl443 = false ; 
fl444 = false ; 
fl445 = false ; 
fl446 = false ; 
fl447 = false ; 
fl448 = false ; 
fl449 = false ; 
fl450 = false ; 
fl451 = false ; 
fl452 = true ; 
while (fl452) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 442;
} else {
indicator = 453;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 441;
} else {
indicator = 453;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 443;
} else {
indicator = 453;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 448;
} else {
indicator = 453;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 446;
} else {
indicator = 453;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 449;
} else {
indicator = 453;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 450;
} else {
indicator = 453;
} // If
break;
} // Case
default:
indicator = 453;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 447;
} else {
indicator = 453;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 445;
} else {
indicator = 453;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 444;
} else {
indicator = 453;
} // If
break;
} // Case
default:
indicator = 453;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 451;
} else {
indicator = 453;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 440;
} else {
indicator = 453;
} // If
break;
} // Case
default:
indicator = 453;
break;
} // Switch
switch (indicator) {
case 440: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl440){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl440 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 441: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl441){
ctxt.fail ("Duplicate attribute: X");
} // If
fl441 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 442: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl442){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl442 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 443: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl443){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl443 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 444: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl444){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl444 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 445: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl445){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl445 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 446: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl446){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl446 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 447: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl447){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl447 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 448: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl448){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl448 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 449: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl449){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl449 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 450: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl450){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl450 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 451: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl451){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl451 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 453: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl441){
this.setX(0);
} // If
if (!fl442){
this.setY(0);
} // If
if (!fl443){
this.setWidth(0);
} // If
if (!fl444){
this.setHeight(0);
} // If
if (!fl445){
this.setHidden( false);
} // If
if (!fl446){
this.setPinned( false);
} // If
if (!fl447){
this.setImplemented( false);
} // If
if (!fl448){
this.setVerified( false);
} // If
if (!fl449){
this.setNeedsRequirement( true);
} // If
fl452 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Type";
  endingTag = "</Type>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Type\"");
} // If
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Enum
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.EnumController.alertChange(aLock, this);
}
private System.Collections.ArrayList aValues;

/// <summary>Part of the list interface for Values</summary>
/// <returns>a collection of all the elements in Values</returns>
public System.Collections.ArrayList allValues()
  {
if (aValues == null){
    setAllValues( new System.Collections.ArrayList() );
} // If
    return aValues;
  }

/// <summary>Part of the list interface for Values</summary>
/// <returns>a collection of all the elements in Values</returns>
private System.Collections.ArrayList getValues()
  {
    return allValues();
  }

/// <summary>Part of the list interface for Values</summary>
/// <param name="coll">a collection of elements which replaces 
///        Values's current content.</param>
public void setAllValues(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aValues = coll;
    NotifyControllers(null);
  }
public void setAllValues(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aValues = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values</summary>
/// <param name="el">a EnumValue to add to the collection in 
///           Values</param>
/// <seealso cref="appendValues(System.Collections.IList)"/>
public void appendValues(EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendValues(Lock aLock,EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Values</summary>
/// <param name="coll">a collection ofEnumValues to add to the collection in 
///           Values</param>
/// <seealso cref="appendValues(EnumValue)"/>
public void appendValues(System.Collections.IList coll)
  {
  __setDirty(true);
  allValues().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendValues(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allValues().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values
/// This insertion function inserts a new element in the
/// collection in Values</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertValues(int idx, EnumValue el)
  {
  __setDirty(true);
  allValues().Insert (idx, el);
NotifyControllers(null);
  }

public void insertValues(int idx, EnumValue el,Lock aLock)
  {
  __setDirty(true);
  allValues().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfValues(IXmlBBase el)
  {
  return ((System.Collections.IList) allValues()).IndexOf (el);
  }

/// <summary>Part of the list interface for Values
/// This deletion function removes an element from the
/// collection in Values</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteValues(int idx)
  {
  __setDirty(true);
  allValues().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteValues(int idx,Lock aLock)
  {
  __setDirty(true);
  allValues().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Values
/// This deletion function removes an element from the
/// collection in Values
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeValues(IXmlBBase obj)
  {
  int idx = indexOfValues(obj);
  if (idx >= 0) { deleteValues(idx);
NotifyControllers(null);
   }
  }

public void removeValues(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfValues(obj);
  if (idx >= 0) { deleteValues(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Values</summary>
/// <returns>the number of elements in Values</returns>
public int countValues()
  {
  return allValues().Count;
  }

/// <summary>Part of the list interface for Values
/// This function returns an element from the
/// collection in Values based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public EnumValue getValues(int idx)
{
  return (EnumValue) ( allValues()[idx]);
}

private System.Collections.ArrayList aSubEnums;

/// <summary>Part of the list interface for SubEnums</summary>
/// <returns>a collection of all the elements in SubEnums</returns>
public System.Collections.ArrayList allSubEnums()
  {
if (aSubEnums == null){
    setAllSubEnums( new System.Collections.ArrayList() );
} // If
    return aSubEnums;
  }

/// <summary>Part of the list interface for SubEnums</summary>
/// <returns>a collection of all the elements in SubEnums</returns>
private System.Collections.ArrayList getSubEnums()
  {
    return allSubEnums();
  }

/// <summary>Part of the list interface for SubEnums</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubEnums's current content.</param>
public void setAllSubEnums(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubEnums = coll;
    NotifyControllers(null);
  }
public void setAllSubEnums(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubEnums = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums</summary>
/// <param name="el">a Enum to add to the collection in 
///           SubEnums</param>
/// <seealso cref="appendSubEnums(System.Collections.IList)"/>
public void appendSubEnums(Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubEnums().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubEnums(Lock aLock,Enum el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubEnums().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubEnums</summary>
/// <param name="coll">a collection ofEnums to add to the collection in 
///           SubEnums</param>
/// <seealso cref="appendSubEnums(Enum)"/>
public void appendSubEnums(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubEnums().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubEnums(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubEnums().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums
/// This insertion function inserts a new element in the
/// collection in SubEnums</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubEnums(int idx, Enum el)
  {
  __setDirty(true);
  allSubEnums().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubEnums(int idx, Enum el,Lock aLock)
  {
  __setDirty(true);
  allSubEnums().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubEnums(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubEnums()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubEnums
/// This deletion function removes an element from the
/// collection in SubEnums</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubEnums(int idx)
  {
  __setDirty(true);
  allSubEnums().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubEnums(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubEnums().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubEnums
/// This deletion function removes an element from the
/// collection in SubEnums
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubEnums(IXmlBBase obj)
  {
  int idx = indexOfSubEnums(obj);
  if (idx >= 0) { deleteSubEnums(idx);
NotifyControllers(null);
   }
  }

public void removeSubEnums(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubEnums(obj);
  if (idx >= 0) { deleteSubEnums(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubEnums</summary>
/// <returns>the number of elements in SubEnums</returns>
public int countSubEnums()
  {
  return allSubEnums().Count;
  }

/// <summary>Part of the list interface for SubEnums
/// This function returns an element from the
/// collection in SubEnums based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Enum getSubEnums(int idx)
{
  return (Enum) ( allSubEnums()[idx]);
}

public Enum()
{
Enum obj = this;
aValues=(null);
aSubEnums=(null);
}

public void copyTo(Enum other)
{
base.copyTo(other);
other.aValues = aValues;
other.aSubEnums = aSubEnums;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl469;
EnumValue fl471;
bool fl482;
Enum fl484;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Values")){
ctxt.skipWhiteSpace();
fl469 = true ; 
while (fl469) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl469 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl471 = null;
while(ctxt.lookAheadOpeningTag ("<EnumValue")) {
fl471 = acceptor.lAccept_EnumValue(ctxt, "</EnumValue>");
appendValues(fl471);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Values>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubEnums")){
ctxt.skipWhiteSpace();
fl482 = true ; 
while (fl482) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl482 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl484 = null;
while(ctxt.lookAheadOpeningTag ("<Enum")) {
fl484 = acceptor.lAccept_Enum(ctxt, "</Enum>");
appendSubEnums(fl484);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubEnums>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl495;
bool fl496;
bool fl497;
bool fl498;
bool fl499;
bool fl500;
bool fl501;
bool fl502;
bool fl503;
bool fl504;
bool fl505;
bool fl506;
bool fl507;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl495 = false ; 
fl496 = false ; 
fl497 = false ; 
fl498 = false ; 
fl499 = false ; 
fl500 = false ; 
fl501 = false ; 
fl502 = false ; 
fl503 = false ; 
fl504 = false ; 
fl505 = false ; 
fl506 = false ; 
fl507 = true ; 
while (fl507) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 497;
} else {
indicator = 508;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 496;
} else {
indicator = 508;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 498;
} else {
indicator = 508;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 503;
} else {
indicator = 508;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 501;
} else {
indicator = 508;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 504;
} else {
indicator = 508;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 505;
} else {
indicator = 508;
} // If
break;
} // Case
default:
indicator = 508;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 502;
} else {
indicator = 508;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 500;
} else {
indicator = 508;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 499;
} else {
indicator = 508;
} // If
break;
} // Case
default:
indicator = 508;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 506;
} else {
indicator = 508;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 495;
} else {
indicator = 508;
} // If
break;
} // Case
default:
indicator = 508;
break;
} // Switch
switch (indicator) {
case 495: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl495){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl495 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 496: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl496){
ctxt.fail ("Duplicate attribute: X");
} // If
fl496 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 497: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl497){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl497 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 498: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl498){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl498 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 499: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl499){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl499 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 500: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl500){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl500 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 501: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl501){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl501 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 502: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl502){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl502 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 503: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl503){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl503 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 504: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl504){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl504 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 505: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl505){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl505 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 506: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl506){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl506 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 508: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl496){
this.setX(0);
} // If
if (!fl497){
this.setY(0);
} // If
if (!fl498){
this.setWidth(0);
} // If
if (!fl499){
this.setHeight(0);
} // If
if (!fl500){
this.setHidden( false);
} // If
if (!fl501){
this.setPinned( false);
} // If
if (!fl502){
this.setImplemented( false);
} // If
if (!fl503){
this.setVerified( false);
} // If
if (!fl504){
this.setNeedsRequirement( true);
} // If
fl507 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Enum";
  endingTag = "</Enum>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Enum\"");
} // If
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Values
if (countValues() > 0){
pw.Write("<Values>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getValues(), false, "<EnumValue", "</EnumValue>");
pw.Write("</Values>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Values
// Unparsing Enclosed
// Testing for empty content: SubEnums
if (countSubEnums() > 0){
pw.Write("<SubEnums>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubEnums(), false, "<Enum", "</Enum>");
pw.Write("</SubEnums>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubEnums
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countValues(); i++) {
  l.Add(getValues(i));
}
for (int i = 0; i < countSubEnums(); i++) {
  l.Add(getSubEnums(i));
}
}

}
public partial class EnumValue
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.EnumValueController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aForbidArithmeticOperation;

public  bool getForbidArithmeticOperation() { return aForbidArithmeticOperation;}

public  void setForbidArithmeticOperation(bool v) {
  aForbidArithmeticOperation = v;
  __setDirty(true);
  NotifyControllers(null);
}


public EnumValue()
{
EnumValue obj = this;
aValue=(null);
aForbidArithmeticOperation=(false);
}

public void copyTo(EnumValue other)
{
base.copyTo(other);
other.aValue = aValue;
other.aForbidArithmeticOperation = aForbidArithmeticOperation;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl524;
bool fl525;
bool fl526;
bool fl527;
bool fl528;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl524 = false ; 
fl525 = false ; 
fl526 = false ; 
fl527 = false ; 
fl528 = true ; 
while (fl528) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue=")){
indicator = 524;
} else {
indicator = 529;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 526;
} else {
indicator = 529;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 527;
} else {
indicator = 529;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("orbidArithmeticOperation=")){
indicator = 525;
} else {
indicator = 529;
} // If
break;
} // Case
default:
indicator = 529;
break;
} // Switch
switch (indicator) {
case 524: {
// Handling attribute Value
// Also handles alien attributes with prefix Value
if (fl524){
ctxt.fail ("Duplicate attribute: Value");
} // If
fl524 = true ; 
quoteChar = ctxt.acceptQuote();
this.setValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 525: {
// Handling attribute ForbidArithmeticOperation
// Also handles alien attributes with prefix ForbidArithmeticOperation
if (fl525){
ctxt.fail ("Duplicate attribute: ForbidArithmeticOperation");
} // If
fl525 = true ; 
quoteChar = ctxt.acceptQuote();
this.setForbidArithmeticOperation(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 526: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl526){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl526 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 527: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl527){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl527 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 529: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl524){
this.setValue("0");
} // If
if (!fl525){
this.setForbidArithmeticOperation( false);
} // If
fl528 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<EnumValue";
  endingTag = "</EnumValue>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"EnumValue\"");
} // If
pw.Write('\n');
if (this.getValue() != null){
pw.Write(" Value=\"");
acceptor.unParsePcData(pw, this.getValue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getForbidArithmeticOperation()){
pw.Write(" ForbidArithmeticOperation=\"");
acceptor.unParsePcData(pw, this.getForbidArithmeticOperation());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Range
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getMinValue().CompareTo((String) search) == 0)return true;
if(getMaxValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RangeController.alertChange(aLock, this);
}
private   string  aMinValue;

public   string  getMinValue() { return aMinValue;}

public  void setMinValue( string  v) {
  aMinValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMaxValue;

public   string  getMaxValue() { return aMaxValue;}

public  void setMaxValue( string  v) {
  aMaxValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSpecialValues;

/// <summary>Part of the list interface for SpecialValues</summary>
/// <returns>a collection of all the elements in SpecialValues</returns>
public System.Collections.ArrayList allSpecialValues()
  {
if (aSpecialValues == null){
    setAllSpecialValues( new System.Collections.ArrayList() );
} // If
    return aSpecialValues;
  }

/// <summary>Part of the list interface for SpecialValues</summary>
/// <returns>a collection of all the elements in SpecialValues</returns>
private System.Collections.ArrayList getSpecialValues()
  {
    return allSpecialValues();
  }

/// <summary>Part of the list interface for SpecialValues</summary>
/// <param name="coll">a collection of elements which replaces 
///        SpecialValues's current content.</param>
public void setAllSpecialValues(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecialValues = coll;
    NotifyControllers(null);
  }
public void setAllSpecialValues(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecialValues = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues</summary>
/// <param name="el">a EnumValue to add to the collection in 
///           SpecialValues</param>
/// <seealso cref="appendSpecialValues(System.Collections.IList)"/>
public void appendSpecialValues(EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecialValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSpecialValues(Lock aLock,EnumValue el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecialValues().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SpecialValues</summary>
/// <param name="coll">a collection ofEnumValues to add to the collection in 
///           SpecialValues</param>
/// <seealso cref="appendSpecialValues(EnumValue)"/>
public void appendSpecialValues(System.Collections.IList coll)
  {
  __setDirty(true);
  allSpecialValues().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSpecialValues(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSpecialValues().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues
/// This insertion function inserts a new element in the
/// collection in SpecialValues</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSpecialValues(int idx, EnumValue el)
  {
  __setDirty(true);
  allSpecialValues().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSpecialValues(int idx, EnumValue el,Lock aLock)
  {
  __setDirty(true);
  allSpecialValues().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSpecialValues(IXmlBBase el)
  {
  return ((System.Collections.IList) allSpecialValues()).IndexOf (el);
  }

/// <summary>Part of the list interface for SpecialValues
/// This deletion function removes an element from the
/// collection in SpecialValues</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSpecialValues(int idx)
  {
  __setDirty(true);
  allSpecialValues().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSpecialValues(int idx,Lock aLock)
  {
  __setDirty(true);
  allSpecialValues().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SpecialValues
/// This deletion function removes an element from the
/// collection in SpecialValues
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSpecialValues(IXmlBBase obj)
  {
  int idx = indexOfSpecialValues(obj);
  if (idx >= 0) { deleteSpecialValues(idx);
NotifyControllers(null);
   }
  }

public void removeSpecialValues(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSpecialValues(obj);
  if (idx >= 0) { deleteSpecialValues(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SpecialValues</summary>
/// <returns>the number of elements in SpecialValues</returns>
public int countSpecialValues()
  {
  return allSpecialValues().Count;
  }

/// <summary>Part of the list interface for SpecialValues
/// This function returns an element from the
/// collection in SpecialValues based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public EnumValue getSpecialValues(int idx)
{
  return (EnumValue) ( allSpecialValues()[idx]);
}

private  acceptor.PrecisionEnum aPrecision;

public  acceptor.PrecisionEnum getPrecision() { return aPrecision;}

public  void setPrecision(acceptor.PrecisionEnum v) {
  aPrecision = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getPrecision_AsString()
{
  return acceptor.Enum_PrecisionEnum_ToString (aPrecision);
}

public  bool setPrecision_AsString( string  v)
{
 acceptor.PrecisionEnum  temp = acceptor.StringTo_Enum_PrecisionEnum(v);
if (temp >= 0){
  aPrecision = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public Range()
{
Range obj = this;
aMinValue=(null);
aMaxValue=(null);
aSpecialValues=(null);
aPrecision=(0);
}

public void copyTo(Range other)
{
base.copyTo(other);
other.aMinValue = aMinValue;
other.aMaxValue = aMaxValue;
other.aSpecialValues = aSpecialValues;
other.aPrecision = aPrecision;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl535;
EnumValue fl537;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SpecialValues")){
ctxt.skipWhiteSpace();
fl535 = true ; 
while (fl535) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl535 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl537 = null;
while(ctxt.lookAheadOpeningTag ("<EnumValue")) {
fl537 = acceptor.lAccept_EnumValue(ctxt, "</EnumValue>");
appendSpecialValues(fl537);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SpecialValues>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl548;
bool fl549;
bool fl550;
bool fl551;
bool fl552;
bool fl553;
bool fl554;
bool fl555;
bool fl556;
bool fl557;
bool fl558;
bool fl559;
bool fl560;
bool fl561;
bool fl562;
bool fl563;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl548 = false ; 
fl549 = false ; 
fl550 = false ; 
fl551 = false ; 
fl552 = false ; 
fl553 = false ; 
fl554 = false ; 
fl555 = false ; 
fl556 = false ; 
fl557 = false ; 
fl558 = false ; 
fl559 = false ; 
fl560 = false ; 
fl561 = false ; 
fl562 = false ; 
fl563 = true ; 
while (fl563) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 553;
} else {
indicator = 564;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 552;
} else {
indicator = 564;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 554;
} else {
indicator = 564;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 559;
} else {
indicator = 564;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ecision=")){
indicator = 550;
} else {
indicator = 564;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nned=")){
indicator = 557;
} else {
indicator = 564;
} // If
break;
} // Case
default:
indicator = 564;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 560;
} else {
indicator = 564;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 561;
} else {
indicator = 564;
} // If
break;
} // Case
default:
indicator = 564;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nValue=")){
indicator = 548;
} else {
indicator = 564;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("xValue=")){
indicator = 549;
} else {
indicator = 564;
} // If
break;
} // Case
default:
indicator = 564;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 558;
} else {
indicator = 564;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 556;
} else {
indicator = 564;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 555;
} else {
indicator = 564;
} // If
break;
} // Case
default:
indicator = 564;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 562;
} else {
indicator = 564;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 551;
} else {
indicator = 564;
} // If
break;
} // Case
default:
indicator = 564;
break;
} // Switch
switch (indicator) {
case 548: {
// Handling attribute MinValue
// Also handles alien attributes with prefix MinValue
if (fl548){
ctxt.fail ("Duplicate attribute: MinValue");
} // If
fl548 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMinValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 549: {
// Handling attribute MaxValue
// Also handles alien attributes with prefix MaxValue
if (fl549){
ctxt.fail ("Duplicate attribute: MaxValue");
} // If
fl549 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMaxValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 550: {
// Handling attribute Precision
// Also handles alien attributes with prefix Precision
if (fl550){
ctxt.fail ("Duplicate attribute: Precision");
} // If
fl550 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPrecision(acceptor.lAcceptEnum_PrecisionEnum(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 551: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl551){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl551 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 552: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl552){
ctxt.fail ("Duplicate attribute: X");
} // If
fl552 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 553: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl553){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl553 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 554: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl554){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl554 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 555: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl555){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl555 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 556: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl556){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl556 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 557: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl557){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl557 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 558: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl558){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl558 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 559: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl559){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl559 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 560: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl560){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl560 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 561: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl561){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl561 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 562: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl562){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl562 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 564: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl548){
ctxt.fail ("Mandatory attribute missing: MinValue in Range");
} // If
if (!fl549){
ctxt.fail ("Mandatory attribute missing: MaxValue in Range");
} // If
if (!fl550){
this.setPrecision(acceptor.PrecisionEnum.aIntegerPrecision);
} // If
if (!fl552){
this.setX(0);
} // If
if (!fl553){
this.setY(0);
} // If
if (!fl554){
this.setWidth(0);
} // If
if (!fl555){
this.setHeight(0);
} // If
if (!fl556){
this.setHidden( false);
} // If
if (!fl557){
this.setPinned( false);
} // If
if (!fl558){
this.setImplemented( false);
} // If
if (!fl559){
this.setVerified( false);
} // If
if (!fl560){
this.setNeedsRequirement( true);
} // If
fl563 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Range";
  endingTag = "</Range>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Range\"");
} // If
pw.Write('\n');
pw.Write(" MinValue=\"");
acceptor.unParsePcData(pw, this.getMinValue());
pw.Write('"');
pw.Write('\n');
pw.Write(" MaxValue=\"");
acceptor.unParsePcData(pw, this.getMaxValue());
pw.Write('"');
pw.Write('\n');
if (this.getPrecision() != 0){
pw.Write(" Precision=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_PrecisionEnum_ToString(this.getPrecision()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: SpecialValues
if (countSpecialValues() > 0){
pw.Write("<SpecialValues>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSpecialValues(), false, "<EnumValue", "</EnumValue>");
pw.Write("</SpecialValues>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SpecialValues
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSpecialValues(); i++) {
  l.Add(getSpecialValues(i));
}
}

}
public partial class Structure
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StructureController.alertChange(aLock, this);
}
private System.Collections.ArrayList aElements;

/// <summary>Part of the list interface for Elements</summary>
/// <returns>a collection of all the elements in Elements</returns>
public System.Collections.ArrayList allElements()
  {
if (aElements == null){
    setAllElements( new System.Collections.ArrayList() );
} // If
    return aElements;
  }

/// <summary>Part of the list interface for Elements</summary>
/// <returns>a collection of all the elements in Elements</returns>
private System.Collections.ArrayList getElements()
  {
    return allElements();
  }

/// <summary>Part of the list interface for Elements</summary>
/// <param name="coll">a collection of elements which replaces 
///        Elements's current content.</param>
public void setAllElements(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aElements = coll;
    NotifyControllers(null);
  }
public void setAllElements(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aElements = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements</summary>
/// <param name="el">a StructureElement to add to the collection in 
///           Elements</param>
/// <seealso cref="appendElements(System.Collections.IList)"/>
public void appendElements(StructureElement el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allElements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendElements(Lock aLock,StructureElement el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allElements().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Elements</summary>
/// <param name="coll">a collection ofStructureElements to add to the collection in 
///           Elements</param>
/// <seealso cref="appendElements(StructureElement)"/>
public void appendElements(System.Collections.IList coll)
  {
  __setDirty(true);
  allElements().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendElements(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allElements().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements
/// This insertion function inserts a new element in the
/// collection in Elements</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertElements(int idx, StructureElement el)
  {
  __setDirty(true);
  allElements().Insert (idx, el);
NotifyControllers(null);
  }

public void insertElements(int idx, StructureElement el,Lock aLock)
  {
  __setDirty(true);
  allElements().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfElements(IXmlBBase el)
  {
  return ((System.Collections.IList) allElements()).IndexOf (el);
  }

/// <summary>Part of the list interface for Elements
/// This deletion function removes an element from the
/// collection in Elements</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteElements(int idx)
  {
  __setDirty(true);
  allElements().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteElements(int idx,Lock aLock)
  {
  __setDirty(true);
  allElements().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Elements
/// This deletion function removes an element from the
/// collection in Elements
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeElements(IXmlBBase obj)
  {
  int idx = indexOfElements(obj);
  if (idx >= 0) { deleteElements(idx);
NotifyControllers(null);
   }
  }

public void removeElements(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfElements(obj);
  if (idx >= 0) { deleteElements(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Elements</summary>
/// <returns>the number of elements in Elements</returns>
public int countElements()
  {
  return allElements().Count;
  }

/// <summary>Part of the list interface for Elements
/// This function returns an element from the
/// collection in Elements based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StructureElement getElements(int idx)
{
  return (StructureElement) ( allElements()[idx]);
}

private System.Collections.ArrayList aProcedures;

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
public System.Collections.ArrayList allProcedures()
  {
if (aProcedures == null){
    setAllProcedures( new System.Collections.ArrayList() );
} // If
    return aProcedures;
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>a collection of all the elements in Procedures</returns>
private System.Collections.ArrayList getProcedures()
  {
    return allProcedures();
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection of elements which replaces 
///        Procedures's current content.</param>
public void setAllProcedures(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
    NotifyControllers(null);
  }
public void setAllProcedures(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aProcedures = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures</summary>
/// <param name="el">a Procedure to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(System.Collections.IList)"/>
public void appendProcedures(Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendProcedures(Lock aLock,Procedure el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allProcedures().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Procedures</summary>
/// <param name="coll">a collection ofProcedures to add to the collection in 
///           Procedures</param>
/// <seealso cref="appendProcedures(Procedure)"/>
public void appendProcedures(System.Collections.IList coll)
  {
  __setDirty(true);
  allProcedures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendProcedures(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allProcedures().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This insertion function inserts a new element in the
/// collection in Procedures</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertProcedures(int idx, Procedure el)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(null);
  }

public void insertProcedures(int idx, Procedure el,Lock aLock)
  {
  __setDirty(true);
  allProcedures().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfProcedures(IXmlBBase el)
  {
  return ((System.Collections.IList) allProcedures()).IndexOf (el);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteProcedures(int idx)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteProcedures(int idx,Lock aLock)
  {
  __setDirty(true);
  allProcedures().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Procedures
/// This deletion function removes an element from the
/// collection in Procedures
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeProcedures(IXmlBBase obj)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(null);
   }
  }

public void removeProcedures(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfProcedures(obj);
  if (idx >= 0) { deleteProcedures(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Procedures</summary>
/// <returns>the number of elements in Procedures</returns>
public int countProcedures()
  {
  return allProcedures().Count;
  }

/// <summary>Part of the list interface for Procedures
/// This function returns an element from the
/// collection in Procedures based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Procedure getProcedures(int idx)
{
  return (Procedure) ( allProcedures()[idx]);
}

private System.Collections.ArrayList aStateMachines;

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
public System.Collections.ArrayList allStateMachines()
  {
if (aStateMachines == null){
    setAllStateMachines( new System.Collections.ArrayList() );
} // If
    return aStateMachines;
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>a collection of all the elements in StateMachines</returns>
private System.Collections.ArrayList getStateMachines()
  {
    return allStateMachines();
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection of elements which replaces 
///        StateMachines's current content.</param>
public void setAllStateMachines(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
    NotifyControllers(null);
  }
public void setAllStateMachines(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStateMachines = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="el">a StateMachine to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(System.Collections.IList)"/>
public void appendStateMachines(StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStateMachines(Lock aLock,StateMachine el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStateMachines().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for StateMachines</summary>
/// <param name="coll">a collection ofStateMachines to add to the collection in 
///           StateMachines</param>
/// <seealso cref="appendStateMachines(StateMachine)"/>
public void appendStateMachines(System.Collections.IList coll)
  {
  __setDirty(true);
  allStateMachines().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStateMachines(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This insertion function inserts a new element in the
/// collection in StateMachines</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStateMachines(int idx, StateMachine el)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStateMachines(int idx, StateMachine el,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStateMachines(IXmlBBase el)
  {
  return ((System.Collections.IList) allStateMachines()).IndexOf (el);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStateMachines(int idx)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStateMachines(int idx,Lock aLock)
  {
  __setDirty(true);
  allStateMachines().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for StateMachines
/// This deletion function removes an element from the
/// collection in StateMachines
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStateMachines(IXmlBBase obj)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(null);
   }
  }

public void removeStateMachines(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStateMachines(obj);
  if (idx >= 0) { deleteStateMachines(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for StateMachines</summary>
/// <returns>the number of elements in StateMachines</returns>
public int countStateMachines()
  {
  return allStateMachines().Count;
  }

/// <summary>Part of the list interface for StateMachines
/// This function returns an element from the
/// collection in StateMachines based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StateMachine getStateMachines(int idx)
{
  return (StateMachine) ( allStateMachines()[idx]);
}

private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

private System.Collections.ArrayList aInterfaces;

/// <summary>Part of the list interface for Interfaces</summary>
/// <returns>a collection of all the elements in Interfaces</returns>
public System.Collections.ArrayList allInterfaces()
  {
if (aInterfaces == null){
    setAllInterfaces( new System.Collections.ArrayList() );
} // If
    return aInterfaces;
  }

/// <summary>Part of the list interface for Interfaces</summary>
/// <returns>a collection of all the elements in Interfaces</returns>
private System.Collections.ArrayList getInterfaces()
  {
    return allInterfaces();
  }

/// <summary>Part of the list interface for Interfaces</summary>
/// <param name="coll">a collection of elements which replaces 
///        Interfaces's current content.</param>
public void setAllInterfaces(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aInterfaces = coll;
    NotifyControllers(null);
  }
public void setAllInterfaces(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aInterfaces = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Interfaces</summary>
/// <param name="el">a StructureRef to add to the collection in 
///           Interfaces</param>
/// <seealso cref="appendInterfaces(System.Collections.IList)"/>
public void appendInterfaces(StructureRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allInterfaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendInterfaces(Lock aLock,StructureRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allInterfaces().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Interfaces</summary>
/// <param name="coll">a collection ofStructureRefs to add to the collection in 
///           Interfaces</param>
/// <seealso cref="appendInterfaces(StructureRef)"/>
public void appendInterfaces(System.Collections.IList coll)
  {
  __setDirty(true);
  allInterfaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendInterfaces(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allInterfaces().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Interfaces
/// This insertion function inserts a new element in the
/// collection in Interfaces</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertInterfaces(int idx, StructureRef el)
  {
  __setDirty(true);
  allInterfaces().Insert (idx, el);
NotifyControllers(null);
  }

public void insertInterfaces(int idx, StructureRef el,Lock aLock)
  {
  __setDirty(true);
  allInterfaces().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Interfaces
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfInterfaces(IXmlBBase el)
  {
  return ((System.Collections.IList) allInterfaces()).IndexOf (el);
  }

/// <summary>Part of the list interface for Interfaces
/// This deletion function removes an element from the
/// collection in Interfaces</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteInterfaces(int idx)
  {
  __setDirty(true);
  allInterfaces().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteInterfaces(int idx,Lock aLock)
  {
  __setDirty(true);
  allInterfaces().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Interfaces
/// This deletion function removes an element from the
/// collection in Interfaces
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeInterfaces(IXmlBBase obj)
  {
  int idx = indexOfInterfaces(obj);
  if (idx >= 0) { deleteInterfaces(idx);
NotifyControllers(null);
   }
  }

public void removeInterfaces(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfInterfaces(obj);
  if (idx >= 0) { deleteInterfaces(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Interfaces</summary>
/// <returns>the number of elements in Interfaces</returns>
public int countInterfaces()
  {
  return allInterfaces().Count;
  }

/// <summary>Part of the list interface for Interfaces
/// This function returns an element from the
/// collection in Interfaces based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public StructureRef getInterfaces(int idx)
{
  return (StructureRef) ( allInterfaces()[idx]);
}

private  bool aIsAbstract;

public  bool getIsAbstract() { return aIsAbstract;}

public  void setIsAbstract(bool v) {
  aIsAbstract = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Structure()
{
Structure obj = this;
aElements=(null);
aProcedures=(null);
aStateMachines=(null);
aRules=(null);
aInterfaces=(null);
aIsAbstract=(false);
}

public void copyTo(Structure other)
{
base.copyTo(other);
other.aElements = aElements;
other.aProcedures = aProcedures;
other.aStateMachines = aStateMachines;
other.aRules = aRules;
other.aInterfaces = aInterfaces;
other.aIsAbstract = aIsAbstract;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl585;
Rule fl587;
bool fl598;
Procedure fl600;
StructureElement fl612;
bool fl623;
StateMachine fl625;
bool fl636;
StructureRef fl638;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl585 = true ; 
while (fl585) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl585 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl587 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl587 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl587);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Procedures")){
ctxt.skipWhiteSpace();
fl598 = true ; 
while (fl598) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl598 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl600 = null;
while(ctxt.lookAheadOpeningTag ("<Procedure")) {
fl600 = acceptor.lAccept_Procedure(ctxt, "</Procedure>");
appendProcedures(fl600);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Procedures>");
} // If
} // If
// End enclosed
// Repeat
ctxt.skipWhiteSpace();
fl612 = null;
while(ctxt.lookAheadOpeningTag ("<StructureElement")) {
fl612 = acceptor.lAccept_StructureElement(ctxt, "</StructureElement>");
appendElements(fl612);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<StateMachines")){
ctxt.skipWhiteSpace();
fl623 = true ; 
while (fl623) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl623 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl625 = null;
while(ctxt.lookAheadOpeningTag ("<StateMachine")) {
fl625 = acceptor.lAccept_StateMachine(ctxt, "</StateMachine>");
appendStateMachines(fl625);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</StateMachines>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Interfaces")){
ctxt.skipWhiteSpace();
fl636 = true ; 
while (fl636) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl636 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl638 = null;
while(ctxt.lookAheadOpeningTag ("<StructureRef")) {
fl638 = acceptor.lAccept_StructureRef(ctxt, "</StructureRef>");
appendInterfaces(fl638);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Interfaces>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl649;
bool fl650;
bool fl651;
bool fl652;
bool fl653;
bool fl654;
bool fl655;
bool fl656;
bool fl657;
bool fl658;
bool fl659;
bool fl660;
bool fl661;
bool fl662;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl649 = false ; 
fl650 = false ; 
fl651 = false ; 
fl652 = false ; 
fl653 = false ; 
fl654 = false ; 
fl655 = false ; 
fl656 = false ; 
fl657 = false ; 
fl658 = false ; 
fl659 = false ; 
fl660 = false ; 
fl661 = false ; 
fl662 = true ; 
while (fl662) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 652;
} else {
indicator = 663;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 651;
} else {
indicator = 663;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 653;
} else {
indicator = 663;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 658;
} else {
indicator = 663;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 656;
} else {
indicator = 663;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 659;
} else {
indicator = 663;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 660;
} else {
indicator = 663;
} // If
break;
} // Case
default:
indicator = 663;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
if (ctxt.lookAheadString("Abstract=")){
indicator = 649;
} else {
indicator = 663;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("plemented=")){
indicator = 657;
} else {
indicator = 663;
} // If
break;
} // Case
default:
indicator = 663;
break;
} // Switch
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 655;
} else {
indicator = 663;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 654;
} else {
indicator = 663;
} // If
break;
} // Case
default:
indicator = 663;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 661;
} else {
indicator = 663;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 650;
} else {
indicator = 663;
} // If
break;
} // Case
default:
indicator = 663;
break;
} // Switch
switch (indicator) {
case 649: {
// Handling attribute IsAbstract
// Also handles alien attributes with prefix IsAbstract
if (fl649){
ctxt.fail ("Duplicate attribute: IsAbstract");
} // If
fl649 = true ; 
quoteChar = ctxt.acceptQuote();
this.setIsAbstract(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 650: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl650){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl650 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 651: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl651){
ctxt.fail ("Duplicate attribute: X");
} // If
fl651 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 652: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl652){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl652 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 653: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl653){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl653 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 654: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl654){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl654 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 655: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl655){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl655 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 656: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl656){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl656 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 657: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl657){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl657 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 658: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl658){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl658 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 659: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl659){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl659 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 660: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl660){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl660 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 661: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl661){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl661 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 663: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl649){
this.setIsAbstract( false);
} // If
if (!fl651){
this.setX(0);
} // If
if (!fl652){
this.setY(0);
} // If
if (!fl653){
this.setWidth(0);
} // If
if (!fl654){
this.setHeight(0);
} // If
if (!fl655){
this.setHidden( false);
} // If
if (!fl656){
this.setPinned( false);
} // If
if (!fl657){
this.setImplemented( false);
} // If
if (!fl658){
this.setVerified( false);
} // If
if (!fl659){
this.setNeedsRequirement( true);
} // If
fl662 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Structure";
  endingTag = "</Structure>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Structure\"");
} // If
pw.Write('\n');
if (this.getIsAbstract()){
pw.Write(" IsAbstract=\"");
acceptor.unParsePcData(pw, this.getIsAbstract());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
// Unparsing Enclosed
// Testing for empty content: Procedures
if (countProcedures() > 0){
pw.Write("<Procedures>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getProcedures(), false, "<Procedure", "</Procedure>");
pw.Write("</Procedures>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Procedures
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getElements(), false, "<StructureElement", "</StructureElement>");
// Unparsing Enclosed
// Testing for empty content: StateMachines
if (countStateMachines() > 0){
pw.Write("<StateMachines>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStateMachines(), false, "<StateMachine", "</StateMachine>");
pw.Write("</StateMachines>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: StateMachines
// Unparsing Enclosed
// Testing for empty content: Interfaces
if (countInterfaces() > 0){
pw.Write("<Interfaces>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getInterfaces(), false, "<StructureRef", "</StructureRef>");
pw.Write("</Interfaces>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Interfaces
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countElements(); i++) {
  l.Add(getElements(i));
}
for (int i = 0; i < countProcedures(); i++) {
  l.Add(getProcedures(i));
}
for (int i = 0; i < countStateMachines(); i++) {
  l.Add(getStateMachines(i));
}
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
for (int i = 0; i < countInterfaces(); i++) {
  l.Add(getInterfaces(i));
}
}

}
public partial class StructureRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StructureRefController.alertChange(aLock, this);
}
public StructureRef()
{
StructureRef obj = this;
}

public void copyTo(StructureRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl681;
bool fl682;
bool fl683;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl681 = false ; 
fl682 = false ; 
fl683 = true ; 
while (fl683) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 681;
} else {
indicator = 684;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 682;
} else {
indicator = 684;
} // If
break;
} // Case
default:
indicator = 684;
break;
} // Switch
switch (indicator) {
case 681: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl681){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl681 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 682: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl682){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl682 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 684: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl683 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<StructureRef";
  endingTag = "</StructureRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"StructureRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class StructureElement
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
if(getDefault().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StructureElementController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDefault;

public   string  getDefault() { return aDefault;}

public  void setDefault( string  v) {
  aDefault = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.VariableModeEnumType aMode;

public  acceptor.VariableModeEnumType getMode() { return aMode;}

public  void setMode(acceptor.VariableModeEnumType v) {
  aMode = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMode_AsString()
{
  return acceptor.Enum_VariableModeEnumType_ToString (aMode);
}

public  bool setMode_AsString( string  v)
{
 acceptor.VariableModeEnumType  temp = acceptor.StringTo_Enum_VariableModeEnumType(v);
if (temp >= 0){
  aMode = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public StructureElement()
{
StructureElement obj = this;
aTypeName=(null);
aDefault=(null);
aMode=(0);
}

public void copyTo(StructureElement other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
other.aDefault = aDefault;
other.aMode = aMode;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl688;
bool fl689;
bool fl690;
bool fl691;
bool fl692;
bool fl693;
bool fl694;
bool fl695;
bool fl696;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl688 = false ; 
fl689 = false ; 
fl690 = false ; 
fl691 = false ; 
fl692 = false ; 
fl693 = false ; 
fl694 = false ; 
fl695 = false ; 
fl696 = true ; 
while (fl696) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 692;
} else {
indicator = 697;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ypeName=")){
indicator = 688;
} else {
indicator = 697;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 693;
} else {
indicator = 697;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 694;
} else {
indicator = 697;
} // If
break;
} // Case
default:
indicator = 697;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("ode=")){
indicator = 690;
} else {
indicator = 697;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 691;
} else {
indicator = 697;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 695;
} else {
indicator = 697;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 689;
} else {
indicator = 697;
} // If
break;
} // Case
default:
indicator = 697;
break;
} // Switch
switch (indicator) {
case 688: {
// Handling attribute TypeName
// Also handles alien attributes with prefix TypeName
if (fl688){
ctxt.fail ("Duplicate attribute: TypeName");
} // If
fl688 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 689: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl689){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl689 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 690: {
// Handling attribute Mode
// Also handles alien attributes with prefix Mode
if (fl690){
ctxt.fail ("Duplicate attribute: Mode");
} // If
fl690 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMode(acceptor.lAcceptEnum_VariableModeEnumType(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 691: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl691){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl691 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 692: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl692){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl692 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 693: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl693){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl693 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 694: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl694){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl694 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 695: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl695){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl695 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 697: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl688){
ctxt.fail ("Mandatory attribute missing: TypeName in StructureElement");
} // If
if (!fl689){
this.setDefault("");
} // If
if (!fl690){
this.setMode(acceptor.VariableModeEnumType.aInternal);
} // If
if (!fl691){
this.setImplemented( false);
} // If
if (!fl692){
this.setVerified( false);
} // If
if (!fl693){
this.setNeedsRequirement( true);
} // If
fl696 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<StructureElement";
  endingTag = "</StructureElement>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"StructureElement\"");
} // If
pw.Write('\n');
pw.Write(" TypeName=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMode() != 0){
pw.Write(" Mode=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_VariableModeEnumType_ToString(this.getMode()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Collection
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.CollectionController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aMaxSize;

public  int getMaxSize() { return aMaxSize;}

public  void setMaxSize(int v) {
  aMaxSize = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Collection()
{
Collection obj = this;
aTypeName=(null);
aMaxSize=(0);
}

public void copyTo(Collection other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
other.aMaxSize = aMaxSize;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl708;
bool fl709;
bool fl710;
bool fl711;
bool fl712;
bool fl713;
bool fl714;
bool fl715;
bool fl716;
bool fl717;
bool fl718;
bool fl719;
bool fl720;
bool fl721;
bool fl722;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl708 = false ; 
fl709 = false ; 
fl710 = false ; 
fl711 = false ; 
fl712 = false ; 
fl713 = false ; 
fl714 = false ; 
fl715 = false ; 
fl716 = false ; 
fl717 = false ; 
fl718 = false ; 
fl719 = false ; 
fl720 = false ; 
fl721 = false ; 
fl722 = true ; 
while (fl722) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 712;
} else {
indicator = 723;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 711;
} else {
indicator = 723;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 713;
} else {
indicator = 723;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 718;
} else {
indicator = 723;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ypeName=")){
indicator = 708;
} else {
indicator = 723;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 716;
} else {
indicator = 723;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 719;
} else {
indicator = 723;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 720;
} else {
indicator = 723;
} // If
break;
} // Case
default:
indicator = 723;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("axSize=")){
indicator = 709;
} else {
indicator = 723;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 717;
} else {
indicator = 723;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 715;
} else {
indicator = 723;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 714;
} else {
indicator = 723;
} // If
break;
} // Case
default:
indicator = 723;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 721;
} else {
indicator = 723;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 710;
} else {
indicator = 723;
} // If
break;
} // Case
default:
indicator = 723;
break;
} // Switch
switch (indicator) {
case 708: {
// Handling attribute TypeName
// Also handles alien attributes with prefix TypeName
if (fl708){
ctxt.fail ("Duplicate attribute: TypeName");
} // If
fl708 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 709: {
// Handling attribute MaxSize
// Also handles alien attributes with prefix MaxSize
if (fl709){
ctxt.fail ("Duplicate attribute: MaxSize");
} // If
fl709 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMaxSize(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 710: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl710){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl710 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 711: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl711){
ctxt.fail ("Duplicate attribute: X");
} // If
fl711 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 712: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl712){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl712 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 713: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl713){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl713 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 714: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl714){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl714 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 715: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl715){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl715 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 716: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl716){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl716 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 717: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl717){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl717 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 718: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl718){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl718 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 719: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl719){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl719 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 720: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl720){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl720 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 721: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl721){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl721 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 723: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl708){
ctxt.fail ("Mandatory attribute missing: TypeName in Collection");
} // If
if (!fl709){
this.setMaxSize(10);
} // If
if (!fl711){
this.setX(0);
} // If
if (!fl712){
this.setY(0);
} // If
if (!fl713){
this.setWidth(0);
} // If
if (!fl714){
this.setHeight(0);
} // If
if (!fl715){
this.setHidden( false);
} // If
if (!fl716){
this.setPinned( false);
} // If
if (!fl717){
this.setImplemented( false);
} // If
if (!fl718){
this.setVerified( false);
} // If
if (!fl719){
this.setNeedsRequirement( true);
} // If
fl722 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Collection";
  endingTag = "</Collection>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Collection\"");
} // If
pw.Write('\n');
pw.Write(" TypeName=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
if (this.getMaxSize() != 10){
pw.Write(" MaxSize=\"");
acceptor.unParsePcData(pw, this.getMaxSize());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Function
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FunctionController.alertChange(aLock, this);
}
private System.Collections.ArrayList aParameters;

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
public System.Collections.ArrayList allParameters()
  {
if (aParameters == null){
    setAllParameters( new System.Collections.ArrayList() );
} // If
    return aParameters;
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
private System.Collections.ArrayList getParameters()
  {
    return allParameters();
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection of elements which replaces 
///        Parameters's current content.</param>
public void setAllParameters(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
    NotifyControllers(null);
  }
public void setAllParameters(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="el">a Parameter to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(System.Collections.IList)"/>
public void appendParameters(Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParameters(Lock aLock,Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection ofParameters to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(Parameter)"/>
public void appendParameters(System.Collections.IList coll)
  {
  __setDirty(true);
  allParameters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParameters(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParameters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This insertion function inserts a new element in the
/// collection in Parameters</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParameters(int idx, Parameter el)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParameters(int idx, Parameter el,Lock aLock)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParameters(IXmlBBase el)
  {
  return ((System.Collections.IList) allParameters()).IndexOf (el);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParameters(int idx)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParameters(int idx,Lock aLock)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParameters(IXmlBBase obj)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(null);
   }
  }

public void removeParameters(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>the number of elements in Parameters</returns>
public int countParameters()
  {
  return allParameters().Count;
  }

/// <summary>Part of the list interface for Parameters
/// This function returns an element from the
/// collection in Parameters based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Parameter getParameters(int idx)
{
  return (Parameter) ( allParameters()[idx]);
}

private System.Collections.ArrayList aCases;

/// <summary>Part of the list interface for Cases</summary>
/// <returns>a collection of all the elements in Cases</returns>
public System.Collections.ArrayList allCases()
  {
if (aCases == null){
    setAllCases( new System.Collections.ArrayList() );
} // If
    return aCases;
  }

/// <summary>Part of the list interface for Cases</summary>
/// <returns>a collection of all the elements in Cases</returns>
private System.Collections.ArrayList getCases()
  {
    return allCases();
  }

/// <summary>Part of the list interface for Cases</summary>
/// <param name="coll">a collection of elements which replaces 
///        Cases's current content.</param>
public void setAllCases(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCases = coll;
    NotifyControllers(null);
  }
public void setAllCases(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aCases = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases</summary>
/// <param name="el">a Case to add to the collection in 
///           Cases</param>
/// <seealso cref="appendCases(System.Collections.IList)"/>
public void appendCases(Case el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendCases(Lock aLock,Case el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Cases</summary>
/// <param name="coll">a collection ofCases to add to the collection in 
///           Cases</param>
/// <seealso cref="appendCases(Case)"/>
public void appendCases(System.Collections.IList coll)
  {
  __setDirty(true);
  allCases().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendCases(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allCases().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases
/// This insertion function inserts a new element in the
/// collection in Cases</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertCases(int idx, Case el)
  {
  __setDirty(true);
  allCases().Insert (idx, el);
NotifyControllers(null);
  }

public void insertCases(int idx, Case el,Lock aLock)
  {
  __setDirty(true);
  allCases().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfCases(IXmlBBase el)
  {
  return ((System.Collections.IList) allCases()).IndexOf (el);
  }

/// <summary>Part of the list interface for Cases
/// This deletion function removes an element from the
/// collection in Cases</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteCases(int idx)
  {
  __setDirty(true);
  allCases().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteCases(int idx,Lock aLock)
  {
  __setDirty(true);
  allCases().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Cases
/// This deletion function removes an element from the
/// collection in Cases
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeCases(IXmlBBase obj)
  {
  int idx = indexOfCases(obj);
  if (idx >= 0) { deleteCases(idx);
NotifyControllers(null);
   }
  }

public void removeCases(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfCases(obj);
  if (idx >= 0) { deleteCases(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Cases</summary>
/// <returns>the number of elements in Cases</returns>
public int countCases()
  {
  return allCases().Count;
  }

/// <summary>Part of the list interface for Cases
/// This function returns an element from the
/// collection in Cases based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Case getCases(int idx)
{
  return (Case) ( allCases()[idx]);
}

private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aCacheable;

public  bool getCacheable() { return aCacheable;}

public  void setCacheable(bool v) {
  aCacheable = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Function()
{
Function obj = this;
aParameters=(null);
aCases=(null);
aTypeName=(null);
aCacheable=(false);
}

public void copyTo(Function other)
{
base.copyTo(other);
other.aParameters = aParameters;
other.aCases = aCases;
other.aTypeName = aTypeName;
other.aCacheable = aCacheable;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl741;
Parameter fl743;
bool fl754;
Case fl756;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Parameters")){
ctxt.skipWhiteSpace();
fl741 = true ; 
while (fl741) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl741 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl743 = null;
while(ctxt.lookAheadOpeningTag ("<Parameter")) {
fl743 = acceptor.lAccept_Parameter(ctxt, "</Parameter>");
appendParameters(fl743);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Parameters>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<Cases");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl754 = true ; 
while (fl754) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl754 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl756 = null;
while(ctxt.lookAheadOpeningTag ("<Case")) {
fl756 = acceptor.lAccept_Case(ctxt, "</Case>");
appendCases(fl756);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Cases>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl767;
bool fl768;
bool fl769;
bool fl770;
bool fl771;
bool fl772;
bool fl773;
bool fl774;
bool fl775;
bool fl776;
bool fl777;
bool fl778;
bool fl779;
bool fl780;
bool fl781;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl767 = false ; 
fl768 = false ; 
fl769 = false ; 
fl770 = false ; 
fl771 = false ; 
fl772 = false ; 
fl773 = false ; 
fl774 = false ; 
fl775 = false ; 
fl776 = false ; 
fl777 = false ; 
fl778 = false ; 
fl779 = false ; 
fl780 = false ; 
fl781 = true ; 
while (fl781) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 771;
} else {
indicator = 782;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 770;
} else {
indicator = 782;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 772;
} else {
indicator = 782;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 777;
} else {
indicator = 782;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 767;
} else {
indicator = 782;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 775;
} else {
indicator = 782;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 778;
} else {
indicator = 782;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 779;
} else {
indicator = 782;
} // If
break;
} // Case
default:
indicator = 782;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 776;
} else {
indicator = 782;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 774;
} else {
indicator = 782;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 773;
} else {
indicator = 782;
} // If
break;
} // Case
default:
indicator = 782;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 780;
} else {
indicator = 782;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 769;
} else {
indicator = 782;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("acheable=")){
indicator = 768;
} else {
indicator = 782;
} // If
break;
} // Case
default:
indicator = 782;
break;
} // Switch
switch (indicator) {
case 767: {
// Handling attribute Type
// Also handles alien attributes with prefix Type
if (fl767){
ctxt.fail ("Duplicate attribute: Type");
} // If
fl767 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 768: {
// Handling attribute Cacheable
// Also handles alien attributes with prefix Cacheable
if (fl768){
ctxt.fail ("Duplicate attribute: Cacheable");
} // If
fl768 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCacheable(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 769: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl769){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl769 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 770: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl770){
ctxt.fail ("Duplicate attribute: X");
} // If
fl770 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 771: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl771){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl771 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 772: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl772){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl772 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 773: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl773){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl773 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 774: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl774){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl774 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 775: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl775){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl775 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 776: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl776){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl776 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 777: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl777){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl777 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 778: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl778){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl778 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 779: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl779){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl779 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 780: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl780){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl780 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 782: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl768){
this.setCacheable( false);
} // If
if (!fl770){
this.setX(0);
} // If
if (!fl771){
this.setY(0);
} // If
if (!fl772){
this.setWidth(0);
} // If
if (!fl773){
this.setHeight(0);
} // If
if (!fl774){
this.setHidden( false);
} // If
if (!fl775){
this.setPinned( false);
} // If
if (!fl776){
this.setImplemented( false);
} // If
if (!fl777){
this.setVerified( false);
} // If
if (!fl778){
this.setNeedsRequirement( true);
} // If
fl781 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Function";
  endingTag = "</Function>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Function\"");
} // If
pw.Write('\n');
if (this.getTypeName() != null){
pw.Write(" Type=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getCacheable()){
pw.Write(" Cacheable=\"");
acceptor.unParsePcData(pw, this.getCacheable());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Parameters
if (countParameters() > 0){
pw.Write("<Parameters>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParameters(), false, "<Parameter", "</Parameter>");
pw.Write("</Parameters>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Parameters
// Unparsing Enclosed
pw.Write("<Cases>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getCases(), false, "<Case", "</Case>");
pw.Write("</Cases>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countParameters(); i++) {
  l.Add(getParameters(i));
}
for (int i = 0; i < countCases(); i++) {
  l.Add(getCases(i));
}
}

}
public partial class Parameter
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ParameterController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Parameter()
{
Parameter obj = this;
aTypeName=(null);
}

public void copyTo(Parameter other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl800;
bool fl801;
bool fl802;
bool fl803;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl800 = false ; 
fl801 = false ; 
fl802 = false ; 
fl803 = true ; 
while (fl803) { // BeginLoop 
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 800;
} else {
indicator = 804;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 801;
} else {
indicator = 804;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 802;
} else {
indicator = 804;
} // If
break;
} // Case
default:
indicator = 804;
break;
} // Switch
switch (indicator) {
case 800: {
// Handling attribute Type
// Also handles alien attributes with prefix Type
if (fl800){
ctxt.fail ("Duplicate attribute: Type");
} // If
fl800 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 801: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl801){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl801 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 802: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl802){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl802 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 804: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl800){
ctxt.fail ("Mandatory attribute missing: Type in Parameter");
} // If
fl803 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Parameter";
  endingTag = "</Parameter>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Parameter\"");
} // If
pw.Write('\n');
pw.Write(" Type=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Case
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getExpression().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.CaseController.alertChange(aLock, this);
}
private System.Collections.ArrayList aPreConditions;

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
public System.Collections.ArrayList allPreConditions()
  {
if (aPreConditions == null){
    setAllPreConditions( new System.Collections.ArrayList() );
} // If
    return aPreConditions;
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
private System.Collections.ArrayList getPreConditions()
  {
    return allPreConditions();
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection of elements which replaces 
///        PreConditions's current content.</param>
public void setAllPreConditions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
    NotifyControllers(null);
  }
public void setAllPreConditions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="el">a PreCondition to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(System.Collections.IList)"/>
public void appendPreConditions(PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendPreConditions(Lock aLock,PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection ofPreConditions to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(PreCondition)"/>
public void appendPreConditions(System.Collections.IList coll)
  {
  __setDirty(true);
  allPreConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendPreConditions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This insertion function inserts a new element in the
/// collection in PreConditions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertPreConditions(int idx, PreCondition el)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertPreConditions(int idx, PreCondition el,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfPreConditions(IXmlBBase el)
  {
  return ((System.Collections.IList) allPreConditions()).IndexOf (el);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deletePreConditions(int idx)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deletePreConditions(int idx,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removePreConditions(IXmlBBase obj)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(null);
   }
  }

public void removePreConditions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>the number of elements in PreConditions</returns>
public int countPreConditions()
  {
  return allPreConditions().Count;
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns an element from the
/// collection in PreConditions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public PreCondition getPreConditions(int idx)
{
  return (PreCondition) ( allPreConditions()[idx]);
}

private   string  aExpression;

public   string  getExpression() { return aExpression;}

public  void setExpression( string  v) {
  aExpression = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Case()
{
Case obj = this;
aPreConditions=(null);
aExpression=(null);
aComment=(null);
}

public void copyTo(Case other)
{
base.copyTo(other);
other.aPreConditions = aPreConditions;
other.aExpression = aExpression;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl809;
bool fl810;
PreCondition fl812;
bool fl823;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl809 = true ; 
while (fl809) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl809 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<PreConditions")){
ctxt.skipWhiteSpace();
fl810 = true ; 
while (fl810) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl810 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl812 = null;
while(ctxt.lookAheadOpeningTag ("<PreCondition")) {
fl812 = acceptor.lAccept_PreCondition(ctxt, "</PreCondition>");
appendPreConditions(fl812);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</PreConditions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<Expression");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl823 = true ; 
while (fl823) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl823 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setExpression(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Expression>");
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl824;
bool fl825;
bool fl826;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl824 = false ; 
fl825 = false ; 
fl826 = true ; 
while (fl826) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 824;
} else {
indicator = 827;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 825;
} else {
indicator = 827;
} // If
break;
} // Case
default:
indicator = 827;
break;
} // Switch
switch (indicator) {
case 824: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl824){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl824 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 825: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl825){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl825 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 827: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl826 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Case";
  endingTag = "</Case>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Case\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: PreConditions
if (countPreConditions() > 0){
pw.Write("<PreConditions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getPreConditions(), false, "<PreCondition", "</PreCondition>");
pw.Write("</PreConditions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: PreConditions
// Unparsing Enclosed
pw.Write("<Expression>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getExpression());
pw.Write("</Expression>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countPreConditions(); i++) {
  l.Add(getPreConditions(i));
}
}

}
public partial class Procedure
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ProcedureController.alertChange(aLock, this);
}
private  StateMachine aStateMachine;

public  StateMachine getStateMachine() { return aStateMachine;}

public  void setStateMachine(StateMachine v) {
  aStateMachine = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

private System.Collections.ArrayList aParameters;

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
public System.Collections.ArrayList allParameters()
  {
if (aParameters == null){
    setAllParameters( new System.Collections.ArrayList() );
} // If
    return aParameters;
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>a collection of all the elements in Parameters</returns>
private System.Collections.ArrayList getParameters()
  {
    return allParameters();
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection of elements which replaces 
///        Parameters's current content.</param>
public void setAllParameters(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
    NotifyControllers(null);
  }
public void setAllParameters(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParameters = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters</summary>
/// <param name="el">a Parameter to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(System.Collections.IList)"/>
public void appendParameters(Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParameters(Lock aLock,Parameter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParameters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Parameters</summary>
/// <param name="coll">a collection ofParameters to add to the collection in 
///           Parameters</param>
/// <seealso cref="appendParameters(Parameter)"/>
public void appendParameters(System.Collections.IList coll)
  {
  __setDirty(true);
  allParameters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParameters(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParameters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This insertion function inserts a new element in the
/// collection in Parameters</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParameters(int idx, Parameter el)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParameters(int idx, Parameter el,Lock aLock)
  {
  __setDirty(true);
  allParameters().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParameters(IXmlBBase el)
  {
  return ((System.Collections.IList) allParameters()).IndexOf (el);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParameters(int idx)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParameters(int idx,Lock aLock)
  {
  __setDirty(true);
  allParameters().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Parameters
/// This deletion function removes an element from the
/// collection in Parameters
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParameters(IXmlBBase obj)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(null);
   }
  }

public void removeParameters(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParameters(obj);
  if (idx >= 0) { deleteParameters(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Parameters</summary>
/// <returns>the number of elements in Parameters</returns>
public int countParameters()
  {
  return allParameters().Count;
  }

/// <summary>Part of the list interface for Parameters
/// This function returns an element from the
/// collection in Parameters based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Parameter getParameters(int idx)
{
  return (Parameter) ( allParameters()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Procedure()
{
Procedure obj = this;
aStateMachine=(null);
aRules=(null);
aParameters=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
}

public void copyTo(Procedure other)
{
base.copyTo(other);
other.aStateMachine = aStateMachine;
other.aRules = aRules;
other.aParameters = aParameters;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl831;
Parameter fl833;
bool fl844;
Rule fl846;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Parameters")){
ctxt.skipWhiteSpace();
fl831 = true ; 
while (fl831) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl831 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl833 = null;
while(ctxt.lookAheadOpeningTag ("<Parameter")) {
fl833 = acceptor.lAccept_Parameter(ctxt, "</Parameter>");
appendParameters(fl833);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Parameters>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl844 = true ; 
while (fl844) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl844 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl846 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl846 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl846);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
// Element Ref : StateMachine
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<StateMachine")){
// Parsing sub element
this.setStateMachine(acceptor.lAccept_StateMachine(ctxt,"</StateMachine>"));
setSon(this.getStateMachine());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl857;
bool fl858;
bool fl859;
bool fl860;
bool fl861;
bool fl862;
bool fl863;
bool fl864;
bool fl865;
bool fl866;
bool fl867;
bool fl868;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl857 = false ; 
fl858 = false ; 
fl859 = false ; 
fl860 = false ; 
fl861 = false ; 
fl862 = false ; 
fl863 = false ; 
fl864 = false ; 
fl865 = false ; 
fl866 = false ; 
fl867 = false ; 
fl868 = true ; 
while (fl868) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 858;
} else {
indicator = 869;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 857;
} else {
indicator = 869;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 859;
} else {
indicator = 869;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 864;
} else {
indicator = 869;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 862;
} else {
indicator = 869;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 865;
} else {
indicator = 869;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 866;
} else {
indicator = 869;
} // If
break;
} // Case
default:
indicator = 869;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 863;
} else {
indicator = 869;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 861;
} else {
indicator = 869;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 860;
} else {
indicator = 869;
} // If
break;
} // Case
default:
indicator = 869;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 867;
} else {
indicator = 869;
} // If
break;
} // Case
default:
indicator = 869;
break;
} // Switch
switch (indicator) {
case 857: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl857){
ctxt.fail ("Duplicate attribute: X");
} // If
fl857 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 858: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl858){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl858 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 859: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl859){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl859 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 860: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl860){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl860 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 861: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl861){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl861 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 862: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl862){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl862 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 863: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl863){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl863 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 864: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl864){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl864 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 865: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl865){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl865 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 866: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl866){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl866 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 867: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl867){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl867 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 869: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl857){
this.setX(0);
} // If
if (!fl858){
this.setY(0);
} // If
if (!fl859){
this.setWidth(0);
} // If
if (!fl860){
this.setHeight(0);
} // If
if (!fl861){
this.setHidden( false);
} // If
if (!fl862){
this.setPinned( false);
} // If
if (!fl863){
this.setImplemented( false);
} // If
if (!fl864){
this.setVerified( false);
} // If
if (!fl865){
this.setNeedsRequirement( true);
} // If
fl868 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Procedure";
  endingTag = "</Procedure>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Procedure\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Parameters
if (countParameters() > 0){
pw.Write("<Parameters>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParameters(), false, "<Parameter", "</Parameter>");
pw.Write("</Parameters>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Parameters
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
// Unparsing ElementRef
if (this.getStateMachine() != null){
unParse(pw, this.getStateMachine(),false,"<StateMachine","</StateMachine>");
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
l.Add(this.getStateMachine());
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
for (int i = 0; i < countParameters(); i++) {
  l.Add(getParameters(i));
}
}

}
public partial class StateMachine
: DataDictionary.Types.Type
{
public  override  bool find(Object search){
if (search is String ) {
if(getInitialState().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StateMachineController.alertChange(aLock, this);
}
private   string  aInitialState;

public   string  getInitialState() { return aInitialState;}

public  void setInitialState( string  v) {
  aInitialState = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aStates;

/// <summary>Part of the list interface for States</summary>
/// <returns>a collection of all the elements in States</returns>
public System.Collections.ArrayList allStates()
  {
if (aStates == null){
    setAllStates( new System.Collections.ArrayList() );
} // If
    return aStates;
  }

/// <summary>Part of the list interface for States</summary>
/// <returns>a collection of all the elements in States</returns>
private System.Collections.ArrayList getStates()
  {
    return allStates();
  }

/// <summary>Part of the list interface for States</summary>
/// <param name="coll">a collection of elements which replaces 
///        States's current content.</param>
public void setAllStates(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStates = coll;
    NotifyControllers(null);
  }
public void setAllStates(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aStates = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States</summary>
/// <param name="el">a State to add to the collection in 
///           States</param>
/// <seealso cref="appendStates(System.Collections.IList)"/>
public void appendStates(State el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStates().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendStates(Lock aLock,State el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allStates().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for States</summary>
/// <param name="coll">a collection ofStates to add to the collection in 
///           States</param>
/// <seealso cref="appendStates(State)"/>
public void appendStates(System.Collections.IList coll)
  {
  __setDirty(true);
  allStates().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendStates(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allStates().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States
/// This insertion function inserts a new element in the
/// collection in States</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertStates(int idx, State el)
  {
  __setDirty(true);
  allStates().Insert (idx, el);
NotifyControllers(null);
  }

public void insertStates(int idx, State el,Lock aLock)
  {
  __setDirty(true);
  allStates().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfStates(IXmlBBase el)
  {
  return ((System.Collections.IList) allStates()).IndexOf (el);
  }

/// <summary>Part of the list interface for States
/// This deletion function removes an element from the
/// collection in States</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteStates(int idx)
  {
  __setDirty(true);
  allStates().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteStates(int idx,Lock aLock)
  {
  __setDirty(true);
  allStates().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for States
/// This deletion function removes an element from the
/// collection in States
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeStates(IXmlBBase obj)
  {
  int idx = indexOfStates(obj);
  if (idx >= 0) { deleteStates(idx);
NotifyControllers(null);
   }
  }

public void removeStates(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfStates(obj);
  if (idx >= 0) { deleteStates(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for States</summary>
/// <returns>the number of elements in States</returns>
public int countStates()
  {
  return allStates().Count;
  }

/// <summary>Part of the list interface for States
/// This function returns an element from the
/// collection in States based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public State getStates(int idx)
{
  return (State) ( allStates()[idx]);
}

private System.Collections.ArrayList aRules;

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
public System.Collections.ArrayList allRules()
  {
if (aRules == null){
    setAllRules( new System.Collections.ArrayList() );
} // If
    return aRules;
  }

/// <summary>Part of the list interface for Rules</summary>
/// <returns>a collection of all the elements in Rules</returns>
private System.Collections.ArrayList getRules()
  {
    return allRules();
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection of elements which replaces 
///        Rules's current content.</param>
public void setAllRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
    NotifyControllers(null);
  }
public void setAllRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules</summary>
/// <param name="el">a Rule to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(System.Collections.IList)"/>
public void appendRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Rules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           Rules</param>
/// <seealso cref="appendRules(Rule)"/>
public void appendRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This insertion function inserts a new element in the
/// collection in Rules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRules(int idx, Rule el)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRules(int idx)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Rules
/// This deletion function removes an element from the
/// collection in Rules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRules(IXmlBBase obj)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(null);
   }
  }

public void removeRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRules(obj);
  if (idx >= 0) { deleteRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Rules</summary>
/// <returns>the number of elements in Rules</returns>
public int countRules()
  {
  return allRules().Count;
  }

/// <summary>Part of the list interface for Rules
/// This function returns an element from the
/// collection in Rules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getRules(int idx)
{
  return (Rule) ( allRules()[idx]);
}

public StateMachine()
{
StateMachine obj = this;
aInitialState=(null);
aStates=(null);
aRules=(null);
}

public void copyTo(StateMachine other)
{
base.copyTo(other);
other.aInitialState = aInitialState;
other.aStates = aStates;
other.aRules = aRules;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl884;
State fl886;
bool fl897;
Rule fl899;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<States")){
ctxt.skipWhiteSpace();
fl884 = true ; 
while (fl884) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl884 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl886 = null;
while(ctxt.lookAheadOpeningTag ("<State")) {
fl886 = acceptor.lAccept_State(ctxt, "</State>");
appendStates(fl886);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</States>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Rules")){
ctxt.skipWhiteSpace();
fl897 = true ; 
while (fl897) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl897 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl899 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl899 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendRules(fl899);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Rules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl910;
bool fl911;
bool fl912;
bool fl913;
bool fl914;
bool fl915;
bool fl916;
bool fl917;
bool fl918;
bool fl919;
bool fl920;
bool fl921;
bool fl922;
bool fl923;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl910 = false ; 
fl911 = false ; 
fl912 = false ; 
fl913 = false ; 
fl914 = false ; 
fl915 = false ; 
fl916 = false ; 
fl917 = false ; 
fl918 = false ; 
fl919 = false ; 
fl920 = false ; 
fl921 = false ; 
fl922 = false ; 
fl923 = true ; 
while (fl923) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 913;
} else {
indicator = 924;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 912;
} else {
indicator = 924;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 914;
} else {
indicator = 924;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 919;
} else {
indicator = 924;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 917;
} else {
indicator = 924;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 920;
} else {
indicator = 924;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 921;
} else {
indicator = 924;
} // If
break;
} // Case
default:
indicator = 924;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("itialState=")){
indicator = 910;
} else {
indicator = 924;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("plemented=")){
indicator = 918;
} else {
indicator = 924;
} // If
break;
} // Case
default:
indicator = 924;
break;
} // Switch
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 916;
} else {
indicator = 924;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 915;
} else {
indicator = 924;
} // If
break;
} // Case
default:
indicator = 924;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 922;
} else {
indicator = 924;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 911;
} else {
indicator = 924;
} // If
break;
} // Case
default:
indicator = 924;
break;
} // Switch
switch (indicator) {
case 910: {
// Handling attribute InitialState
// Also handles alien attributes with prefix InitialState
if (fl910){
ctxt.fail ("Duplicate attribute: InitialState");
} // If
fl910 = true ; 
quoteChar = ctxt.acceptQuote();
this.setInitialState((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 911: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl911){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl911 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 912: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl912){
ctxt.fail ("Duplicate attribute: X");
} // If
fl912 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 913: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl913){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl913 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 914: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl914){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl914 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 915: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl915){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl915 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 916: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl916){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl916 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 917: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl917){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl917 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 918: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl918){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl918 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 919: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl919){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl919 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 920: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl920){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl920 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 921: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl921){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl921 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 922: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl922){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl922 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 924: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl912){
this.setX(0);
} // If
if (!fl913){
this.setY(0);
} // If
if (!fl914){
this.setWidth(0);
} // If
if (!fl915){
this.setHeight(0);
} // If
if (!fl916){
this.setHidden( false);
} // If
if (!fl917){
this.setPinned( false);
} // If
if (!fl918){
this.setImplemented( false);
} // If
if (!fl919){
this.setVerified( false);
} // If
if (!fl920){
this.setNeedsRequirement( true);
} // If
fl923 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<StateMachine";
  endingTag = "</StateMachine>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"StateMachine\"");
} // If
pw.Write('\n');
if (this.getInitialState() != null){
pw.Write(" InitialState=\"");
acceptor.unParsePcData(pw, this.getInitialState());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault() != null){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: States
if (countStates() > 0){
pw.Write("<States>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getStates(), false, "<State", "</State>");
pw.Write("</States>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: States
// Unparsing Enclosed
// Testing for empty content: Rules
if (countRules() > 0){
pw.Write("<Rules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRules(), false, "<Rule", "</Rule>");
pw.Write("</Rules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Rules
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countStates(); i++) {
  l.Add(getStates(i));
}
for (int i = 0; i < countRules(); i++) {
  l.Add(getRules(i));
}
}

}
public partial class State
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StateController.alertChange(aLock, this);
}
private  StateMachine aStateMachine;

public  StateMachine getStateMachine() { return aStateMachine;}

public  void setStateMachine(StateMachine v) {
  aStateMachine = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  Rule aEnterAction;

public  Rule getEnterAction() { return aEnterAction;}

public  void setEnterAction(Rule v) {
  aEnterAction = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  Rule aLeaveAction;

public  Rule getLeaveAction() { return aLeaveAction;}

public  void setLeaveAction(Rule v) {
  aLeaveAction = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


public State()
{
State obj = this;
aStateMachine=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aPinned=(false);
aEnterAction=(null);
aLeaveAction=(null);
}

public void copyTo(State other)
{
base.copyTo(other);
other.aStateMachine = aStateMachine;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aPinned = aPinned;
other.aEnterAction = aEnterAction;
other.aLeaveAction = aLeaveAction;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl942;
bool fl943;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Element Ref : StateMachine
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<StateMachine")){
// Parsing sub element
this.setStateMachine(acceptor.lAccept_StateMachine(ctxt,"</StateMachine>"));
setSon(this.getStateMachine());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<EnterAction")){
ctxt.skipWhiteSpace();
fl942 = true ; 
while (fl942) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl942 = false ; 
} // If
} // While
ctxt.accept('>');
// Element Ref : Rule
ctxt.skipWhiteSpace();
ctxt.acceptString ("<Rule");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
// Parsing sub element
this.setEnterAction(acceptor.lAccept_Rule(ctxt,"</Rule>"));
setSon(this.getEnterAction());
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
ctxt.acceptString ("</EnterAction>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<LeaveAction")){
ctxt.skipWhiteSpace();
fl943 = true ; 
while (fl943) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl943 = false ; 
} // If
} // While
ctxt.accept('>');
// Element Ref : Rule
ctxt.skipWhiteSpace();
ctxt.acceptString ("<Rule");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
// Parsing sub element
this.setLeaveAction(acceptor.lAccept_Rule(ctxt,"</Rule>"));
setSon(this.getLeaveAction());
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
ctxt.acceptString ("</LeaveAction>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl944;
bool fl945;
bool fl946;
bool fl947;
bool fl948;
bool fl949;
bool fl950;
bool fl951;
bool fl952;
bool fl953;
bool fl954;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl944 = false ; 
fl945 = false ; 
fl946 = false ; 
fl947 = false ; 
fl948 = false ; 
fl949 = false ; 
fl950 = false ; 
fl951 = false ; 
fl952 = false ; 
fl953 = false ; 
fl954 = true ; 
while (fl954) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 945;
} else {
indicator = 955;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 944;
} else {
indicator = 955;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 946;
} else {
indicator = 955;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 950;
} else {
indicator = 955;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 948;
} else {
indicator = 955;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 951;
} else {
indicator = 955;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 952;
} else {
indicator = 955;
} // If
break;
} // Case
default:
indicator = 955;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 949;
} else {
indicator = 955;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
if (ctxt.lookAheadString("eight=")){
indicator = 947;
} else {
indicator = 955;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 953;
} else {
indicator = 955;
} // If
break;
} // Case
default:
indicator = 955;
break;
} // Switch
switch (indicator) {
case 944: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl944){
ctxt.fail ("Duplicate attribute: X");
} // If
fl944 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 945: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl945){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl945 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 946: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl946){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl946 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 947: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl947){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl947 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 948: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl948){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl948 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 949: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl949){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl949 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 950: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl950){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl950 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 951: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl951){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl951 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 952: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl952){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl952 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 953: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl953){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl953 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 955: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl944){
this.setX(0);
} // If
if (!fl945){
this.setY(0);
} // If
if (!fl946){
this.setWidth(0);
} // If
if (!fl947){
this.setHeight(0);
} // If
if (!fl948){
this.setPinned( false);
} // If
if (!fl949){
this.setImplemented( false);
} // If
if (!fl950){
this.setVerified( false);
} // If
if (!fl951){
this.setNeedsRequirement( true);
} // If
fl954 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<State";
  endingTag = "</State>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"State\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing ElementRef
if (this.getStateMachine() != null){
unParse(pw, this.getStateMachine(),false,"<StateMachine","</StateMachine>");
} // If
// Unparsing Enclosed
// Testing for empty content: EnterAction
if (this.getEnterAction() != null){
pw.Write("<EnterAction>");
pw.Write('\n');
// Unparsing ElementRef
unParse(pw, this.getEnterAction(),false,"<Rule","</Rule>");
pw.Write("</EnterAction>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: EnterAction
// Unparsing Enclosed
// Testing for empty content: LeaveAction
if (this.getLeaveAction() != null){
pw.Write("<LeaveAction>");
pw.Write('\n');
// Unparsing ElementRef
unParse(pw, this.getLeaveAction(),false,"<Rule","</Rule>");
pw.Write("</LeaveAction>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: LeaveAction
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
l.Add(this.getStateMachine());
l.Add(this.getEnterAction());
l.Add(this.getLeaveAction());
}

}
public partial class Variable
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getTypeName().CompareTo((String) search) == 0)return true;
if(getDefaultValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.VariableController.alertChange(aLock, this);
}
private   string  aTypeName;

public   string  getTypeName() { return aTypeName;}

public  void setTypeName( string  v) {
  aTypeName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDefaultValue;

public   string  getDefaultValue() { return aDefaultValue;}

public  void setDefaultValue( string  v) {
  aDefaultValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.VariableModeEnumType aVariableMode;

public  acceptor.VariableModeEnumType getVariableMode() { return aVariableMode;}

public  void setVariableMode(acceptor.VariableModeEnumType v) {
  aVariableMode = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getVariableMode_AsString()
{
  return acceptor.Enum_VariableModeEnumType_ToString (aVariableMode);
}

public  bool setVariableMode_AsString( string  v)
{
 acceptor.VariableModeEnumType  temp = acceptor.StringTo_Enum_VariableModeEnumType(v);
if (temp >= 0){
  aVariableMode = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aSubVariables;

/// <summary>Part of the list interface for SubVariables</summary>
/// <returns>a collection of all the elements in SubVariables</returns>
public System.Collections.ArrayList allSubVariables()
  {
if (aSubVariables == null){
    setAllSubVariables( new System.Collections.ArrayList() );
} // If
    return aSubVariables;
  }

/// <summary>Part of the list interface for SubVariables</summary>
/// <returns>a collection of all the elements in SubVariables</returns>
private System.Collections.ArrayList getSubVariables()
  {
    return allSubVariables();
  }

/// <summary>Part of the list interface for SubVariables</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubVariables's current content.</param>
public void setAllSubVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubVariables = coll;
    NotifyControllers(null);
  }
public void setAllSubVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables</summary>
/// <param name="el">a Variable to add to the collection in 
///           SubVariables</param>
/// <seealso cref="appendSubVariables(System.Collections.IList)"/>
public void appendSubVariables(Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubVariables(Lock aLock,Variable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubVariables</summary>
/// <param name="coll">a collection ofVariables to add to the collection in 
///           SubVariables</param>
/// <seealso cref="appendSubVariables(Variable)"/>
public void appendSubVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables
/// This insertion function inserts a new element in the
/// collection in SubVariables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubVariables(int idx, Variable el)
  {
  __setDirty(true);
  allSubVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubVariables(int idx, Variable el,Lock aLock)
  {
  __setDirty(true);
  allSubVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubVariables
/// This deletion function removes an element from the
/// collection in SubVariables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubVariables(int idx)
  {
  __setDirty(true);
  allSubVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubVariables
/// This deletion function removes an element from the
/// collection in SubVariables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubVariables(IXmlBBase obj)
  {
  int idx = indexOfSubVariables(obj);
  if (idx >= 0) { deleteSubVariables(idx);
NotifyControllers(null);
   }
  }

public void removeSubVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubVariables(obj);
  if (idx >= 0) { deleteSubVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubVariables</summary>
/// <returns>the number of elements in SubVariables</returns>
public int countSubVariables()
  {
  return allSubVariables().Count;
  }

/// <summary>Part of the list interface for SubVariables
/// This function returns an element from the
/// collection in SubVariables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Variable getSubVariables(int idx)
{
  return (Variable) ( allSubVariables()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Variable()
{
Variable obj = this;
aTypeName=(null);
aDefaultValue=(null);
aVariableMode=(0);
aSubVariables=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
}

public void copyTo(Variable other)
{
base.copyTo(other);
other.aTypeName = aTypeName;
other.aDefaultValue = aDefaultValue;
other.aVariableMode = aVariableMode;
other.aSubVariables = aSubVariables;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl968;
Variable fl970;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubVariables")){
ctxt.skipWhiteSpace();
fl968 = true ; 
while (fl968) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl968 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl970 = null;
while(ctxt.lookAheadOpeningTag ("<Variable")) {
fl970 = acceptor.lAccept_Variable(ctxt, "</Variable>");
appendSubVariables(fl970);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubVariables>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl981;
bool fl982;
bool fl983;
bool fl984;
bool fl985;
bool fl986;
bool fl987;
bool fl988;
bool fl989;
bool fl990;
bool fl991;
bool fl992;
bool fl993;
bool fl994;
bool fl995;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl981 = false ; 
fl982 = false ; 
fl983 = false ; 
fl984 = false ; 
fl985 = false ; 
fl986 = false ; 
fl987 = false ; 
fl988 = false ; 
fl989 = false ; 
fl990 = false ; 
fl991 = false ; 
fl992 = false ; 
fl993 = false ; 
fl994 = false ; 
fl995 = true ; 
while (fl995) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 985;
} else {
indicator = 996;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 984;
} else {
indicator = 996;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 986;
} else {
indicator = 996;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("rified=")){
indicator = 991;
} else {
indicator = 996;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("riableMode=")){
indicator = 983;
} else {
indicator = 996;
} // If
break;
} // Case
default:
indicator = 996;
break;
} // Switch
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 981;
} else {
indicator = 996;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 989;
} else {
indicator = 996;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 992;
} else {
indicator = 996;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 993;
} else {
indicator = 996;
} // If
break;
} // Case
default:
indicator = 996;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 990;
} else {
indicator = 996;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 988;
} else {
indicator = 996;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 987;
} else {
indicator = 996;
} // If
break;
} // Case
default:
indicator = 996;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 994;
} else {
indicator = 996;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efaultValue=")){
indicator = 982;
} else {
indicator = 996;
} // If
break;
} // Case
default:
indicator = 996;
break;
} // Switch
switch (indicator) {
case 981: {
// Handling attribute Type
// Also handles alien attributes with prefix Type
if (fl981){
ctxt.fail ("Duplicate attribute: Type");
} // If
fl981 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTypeName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 982: {
// Handling attribute DefaultValue
// Also handles alien attributes with prefix DefaultValue
if (fl982){
ctxt.fail ("Duplicate attribute: DefaultValue");
} // If
fl982 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefaultValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 983: {
// Handling attribute VariableMode
// Also handles alien attributes with prefix VariableMode
if (fl983){
ctxt.fail ("Duplicate attribute: VariableMode");
} // If
fl983 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVariableMode(acceptor.lAcceptEnum_VariableModeEnumType(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 984: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl984){
ctxt.fail ("Duplicate attribute: X");
} // If
fl984 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 985: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl985){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl985 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 986: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl986){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl986 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 987: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl987){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl987 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 988: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl988){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl988 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 989: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl989){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl989 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 990: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl990){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl990 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 991: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl991){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl991 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 992: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl992){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl992 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 993: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl993){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl993 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 994: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl994){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl994 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 996: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl983){
this.setVariableMode(acceptor.VariableModeEnumType.aInternal);
} // If
if (!fl984){
this.setX(0);
} // If
if (!fl985){
this.setY(0);
} // If
if (!fl986){
this.setWidth(0);
} // If
if (!fl987){
this.setHeight(0);
} // If
if (!fl988){
this.setHidden( false);
} // If
if (!fl989){
this.setPinned( false);
} // If
if (!fl990){
this.setImplemented( false);
} // If
if (!fl991){
this.setVerified( false);
} // If
if (!fl992){
this.setNeedsRequirement( true);
} // If
fl995 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Variable";
  endingTag = "</Variable>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Variable\"");
} // If
pw.Write('\n');
if (this.getTypeName() != null){
pw.Write(" Type=\"");
acceptor.unParsePcData(pw, this.getTypeName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefaultValue() != null){
pw.Write(" DefaultValue=\"");
acceptor.unParsePcData(pw, this.getDefaultValue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVariableMode() != 0){
pw.Write(" VariableMode=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_VariableModeEnumType_ToString(this.getVariableMode()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: SubVariables
if (countSubVariables() > 0){
pw.Write("<SubVariables>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubVariables(), false, "<Variable", "</Variable>");
pw.Write("</SubVariables>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubVariables
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSubVariables(); i++) {
  l.Add(getSubVariables(i));
}
}

}
public partial class Rule
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RuleController.alertChange(aLock, this);
}
private  acceptor.RulePriority aPriority;

public  acceptor.RulePriority getPriority() { return aPriority;}

public  void setPriority(acceptor.RulePriority v) {
  aPriority = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getPriority_AsString()
{
  return acceptor.Enum_RulePriority_ToString (aPriority);
}

public  bool setPriority_AsString( string  v)
{
 acceptor.RulePriority  temp = acceptor.StringTo_Enum_RulePriority(v);
if (temp >= 0){
  aPriority = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aConditions;

/// <summary>Part of the list interface for Conditions</summary>
/// <returns>a collection of all the elements in Conditions</returns>
public System.Collections.ArrayList allConditions()
  {
if (aConditions == null){
    setAllConditions( new System.Collections.ArrayList() );
} // If
    return aConditions;
  }

/// <summary>Part of the list interface for Conditions</summary>
/// <returns>a collection of all the elements in Conditions</returns>
private System.Collections.ArrayList getConditions()
  {
    return allConditions();
  }

/// <summary>Part of the list interface for Conditions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Conditions's current content.</param>
public void setAllConditions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aConditions = coll;
    NotifyControllers(null);
  }
public void setAllConditions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aConditions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions</summary>
/// <param name="el">a RuleCondition to add to the collection in 
///           Conditions</param>
/// <seealso cref="appendConditions(System.Collections.IList)"/>
public void appendConditions(RuleCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendConditions(Lock aLock,RuleCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Conditions</summary>
/// <param name="coll">a collection ofRuleConditions to add to the collection in 
///           Conditions</param>
/// <seealso cref="appendConditions(RuleCondition)"/>
public void appendConditions(System.Collections.IList coll)
  {
  __setDirty(true);
  allConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendConditions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions
/// This insertion function inserts a new element in the
/// collection in Conditions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertConditions(int idx, RuleCondition el)
  {
  __setDirty(true);
  allConditions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertConditions(int idx, RuleCondition el,Lock aLock)
  {
  __setDirty(true);
  allConditions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfConditions(IXmlBBase el)
  {
  return ((System.Collections.IList) allConditions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Conditions
/// This deletion function removes an element from the
/// collection in Conditions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteConditions(int idx)
  {
  __setDirty(true);
  allConditions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteConditions(int idx,Lock aLock)
  {
  __setDirty(true);
  allConditions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Conditions
/// This deletion function removes an element from the
/// collection in Conditions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeConditions(IXmlBBase obj)
  {
  int idx = indexOfConditions(obj);
  if (idx >= 0) { deleteConditions(idx);
NotifyControllers(null);
   }
  }

public void removeConditions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfConditions(obj);
  if (idx >= 0) { deleteConditions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Conditions</summary>
/// <returns>the number of elements in Conditions</returns>
public int countConditions()
  {
  return allConditions().Count;
  }

/// <summary>Part of the list interface for Conditions
/// This function returns an element from the
/// collection in Conditions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RuleCondition getConditions(int idx)
{
  return (RuleCondition) ( allConditions()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aHidden;

public  bool getHidden() { return aHidden;}

public  void setHidden(bool v) {
  aHidden = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Rule()
{
Rule obj = this;
aPriority=(0);
aConditions=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aHidden=(false);
aPinned=(false);
}

public void copyTo(Rule other)
{
base.copyTo(other);
other.aPriority = aPriority;
other.aConditions = aConditions;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aHidden = aHidden;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1015;
bool fl1016;
RuleCondition fl1018;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubRules")){
ctxt.skipWhiteSpace();
fl1015 = true ; 
while (fl1015) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1015 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
acceptor.lAcceptPcData(ctxt, 0, '<', XmlBContext.WS_PRESERVE);
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubRules>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Conditions")){
ctxt.skipWhiteSpace();
fl1016 = true ; 
while (fl1016) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1016 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1018 = null;
while(ctxt.lookAheadOpeningTag ("<RuleCondition")) {
fl1018 = acceptor.lAccept_RuleCondition(ctxt, "</RuleCondition>");
appendConditions(fl1018);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Conditions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1029;
bool fl1030;
bool fl1031;
bool fl1032;
bool fl1033;
bool fl1034;
bool fl1035;
bool fl1036;
bool fl1037;
bool fl1038;
bool fl1039;
bool fl1040;
bool fl1041;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1029 = false ; 
fl1030 = false ; 
fl1031 = false ; 
fl1032 = false ; 
fl1033 = false ; 
fl1034 = false ; 
fl1035 = false ; 
fl1036 = false ; 
fl1037 = false ; 
fl1038 = false ; 
fl1039 = false ; 
fl1040 = false ; 
fl1041 = true ; 
while (fl1041) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1031;
} else {
indicator = 1042;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1030;
} else {
indicator = 1042;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 1032;
} else {
indicator = 1042;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 1037;
} else {
indicator = 1042;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("iority=")){
indicator = 1029;
} else {
indicator = 1042;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nned=")){
indicator = 1035;
} else {
indicator = 1042;
} // If
break;
} // Case
default:
indicator = 1042;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 1038;
} else {
indicator = 1042;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1039;
} else {
indicator = 1042;
} // If
break;
} // Case
default:
indicator = 1042;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1036;
} else {
indicator = 1042;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dden=")){
indicator = 1034;
} else {
indicator = 1042;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("ight=")){
indicator = 1033;
} else {
indicator = 1042;
} // If
break;
} // Case
default:
indicator = 1042;
break;
} // Switch
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1040;
} else {
indicator = 1042;
} // If
break;
} // Case
default:
indicator = 1042;
break;
} // Switch
switch (indicator) {
case 1029: {
// Handling attribute Priority
// Also handles alien attributes with prefix Priority
if (fl1029){
ctxt.fail ("Duplicate attribute: Priority");
} // If
fl1029 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPriority(acceptor.lAcceptEnum_RulePriority(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1030: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl1030){
ctxt.fail ("Duplicate attribute: X");
} // If
fl1030 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1031: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl1031){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl1031 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1032: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl1032){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl1032 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1033: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl1033){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl1033 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1034: {
// Handling attribute Hidden
// Also handles alien attributes with prefix Hidden
if (fl1034){
ctxt.fail ("Duplicate attribute: Hidden");
} // If
fl1034 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHidden(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1035: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl1035){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl1035 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1036: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1036){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1036 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1037: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl1037){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl1037 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1038: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl1038){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl1038 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1039: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1039){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1039 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1040: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1040){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1040 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1042: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1030){
this.setX(0);
} // If
if (!fl1031){
this.setY(0);
} // If
if (!fl1032){
this.setWidth(0);
} // If
if (!fl1033){
this.setHeight(0);
} // If
if (!fl1034){
this.setHidden( false);
} // If
if (!fl1035){
this.setPinned( false);
} // If
if (!fl1036){
this.setImplemented( false);
} // If
if (!fl1037){
this.setVerified( false);
} // If
if (!fl1038){
this.setNeedsRequirement( true);
} // If
fl1041 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Rule";
  endingTag = "</Rule>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Rule\"");
} // If
pw.Write('\n');
if (this.getPriority() != 0){
pw.Write(" Priority=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_RulePriority_ToString(this.getPriority()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHidden()){
pw.Write(" Hidden=\"");
acceptor.unParsePcData(pw, this.getHidden());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
pw.Write("<SubRules>");
// Unparsing PcData
pw.Write("</SubRules>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: Conditions
if (countConditions() > 0){
pw.Write("<Conditions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getConditions(), false, "<RuleCondition", "</RuleCondition>");
pw.Write("</Conditions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Conditions
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countConditions(); i++) {
  l.Add(getConditions(i));
}
}

}
public partial class RuleCondition
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RuleConditionController.alertChange(aLock, this);
}
private System.Collections.ArrayList aPreConditions;

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
public System.Collections.ArrayList allPreConditions()
  {
if (aPreConditions == null){
    setAllPreConditions( new System.Collections.ArrayList() );
} // If
    return aPreConditions;
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>a collection of all the elements in PreConditions</returns>
private System.Collections.ArrayList getPreConditions()
  {
    return allPreConditions();
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection of elements which replaces 
///        PreConditions's current content.</param>
public void setAllPreConditions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
    NotifyControllers(null);
  }
public void setAllPreConditions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPreConditions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="el">a PreCondition to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(System.Collections.IList)"/>
public void appendPreConditions(PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendPreConditions(Lock aLock,PreCondition el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPreConditions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for PreConditions</summary>
/// <param name="coll">a collection ofPreConditions to add to the collection in 
///           PreConditions</param>
/// <seealso cref="appendPreConditions(PreCondition)"/>
public void appendPreConditions(System.Collections.IList coll)
  {
  __setDirty(true);
  allPreConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendPreConditions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This insertion function inserts a new element in the
/// collection in PreConditions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertPreConditions(int idx, PreCondition el)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertPreConditions(int idx, PreCondition el,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfPreConditions(IXmlBBase el)
  {
  return ((System.Collections.IList) allPreConditions()).IndexOf (el);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deletePreConditions(int idx)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deletePreConditions(int idx,Lock aLock)
  {
  __setDirty(true);
  allPreConditions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for PreConditions
/// This deletion function removes an element from the
/// collection in PreConditions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removePreConditions(IXmlBBase obj)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(null);
   }
  }

public void removePreConditions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfPreConditions(obj);
  if (idx >= 0) { deletePreConditions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for PreConditions</summary>
/// <returns>the number of elements in PreConditions</returns>
public int countPreConditions()
  {
  return allPreConditions().Count;
  }

/// <summary>Part of the list interface for PreConditions
/// This function returns an element from the
/// collection in PreConditions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public PreCondition getPreConditions(int idx)
{
  return (PreCondition) ( allPreConditions()[idx]);
}

private System.Collections.ArrayList aActions;

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
public System.Collections.ArrayList allActions()
  {
if (aActions == null){
    setAllActions( new System.Collections.ArrayList() );
} // If
    return aActions;
  }

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
private System.Collections.ArrayList getActions()
  {
    return allActions();
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Actions's current content.</param>
public void setAllActions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
    NotifyControllers(null);
  }
public void setAllActions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="el">a Action to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(System.Collections.IList)"/>
public void appendActions(Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendActions(Lock aLock,Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection ofActions to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(Action)"/>
public void appendActions(System.Collections.IList coll)
  {
  __setDirty(true);
  allActions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendActions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allActions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This insertion function inserts a new element in the
/// collection in Actions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertActions(int idx, Action el)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertActions(int idx, Action el,Lock aLock)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfActions(IXmlBBase el)
  {
  return ((System.Collections.IList) allActions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteActions(int idx)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteActions(int idx,Lock aLock)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeActions(IXmlBBase obj)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(null);
   }
  }

public void removeActions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Actions</summary>
/// <returns>the number of elements in Actions</returns>
public int countActions()
  {
  return allActions().Count;
  }

/// <summary>Part of the list interface for Actions
/// This function returns an element from the
/// collection in Actions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Action getActions(int idx)
{
  return (Action) ( allActions()[idx]);
}

private System.Collections.ArrayList aSubRules;

/// <summary>Part of the list interface for SubRules</summary>
/// <returns>a collection of all the elements in SubRules</returns>
public System.Collections.ArrayList allSubRules()
  {
if (aSubRules == null){
    setAllSubRules( new System.Collections.ArrayList() );
} // If
    return aSubRules;
  }

/// <summary>Part of the list interface for SubRules</summary>
/// <returns>a collection of all the elements in SubRules</returns>
private System.Collections.ArrayList getSubRules()
  {
    return allSubRules();
  }

/// <summary>Part of the list interface for SubRules</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubRules's current content.</param>
public void setAllSubRules(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubRules = coll;
    NotifyControllers(null);
  }
public void setAllSubRules(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubRules = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules</summary>
/// <param name="el">a Rule to add to the collection in 
///           SubRules</param>
/// <seealso cref="appendSubRules(System.Collections.IList)"/>
public void appendSubRules(Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubRules(Lock aLock,Rule el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubRules().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubRules</summary>
/// <param name="coll">a collection ofRules to add to the collection in 
///           SubRules</param>
/// <seealso cref="appendSubRules(Rule)"/>
public void appendSubRules(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubRules(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubRules().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules
/// This insertion function inserts a new element in the
/// collection in SubRules</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubRules(int idx, Rule el)
  {
  __setDirty(true);
  allSubRules().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubRules(int idx, Rule el,Lock aLock)
  {
  __setDirty(true);
  allSubRules().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubRules(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubRules()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubRules
/// This deletion function removes an element from the
/// collection in SubRules</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubRules(int idx)
  {
  __setDirty(true);
  allSubRules().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubRules(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubRules().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubRules
/// This deletion function removes an element from the
/// collection in SubRules
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubRules(IXmlBBase obj)
  {
  int idx = indexOfSubRules(obj);
  if (idx >= 0) { deleteSubRules(idx);
NotifyControllers(null);
   }
  }

public void removeSubRules(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubRules(obj);
  if (idx >= 0) { deleteSubRules(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubRules</summary>
/// <returns>the number of elements in SubRules</returns>
public int countSubRules()
  {
  return allSubRules().Count;
  }

/// <summary>Part of the list interface for SubRules
/// This function returns an element from the
/// collection in SubRules based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Rule getSubRules(int idx)
{
  return (Rule) ( allSubRules()[idx]);
}

public RuleCondition()
{
RuleCondition obj = this;
aPreConditions=(null);
aActions=(null);
aSubRules=(null);
}

public void copyTo(RuleCondition other)
{
base.copyTo(other);
other.aPreConditions = aPreConditions;
other.aActions = aActions;
other.aSubRules = aSubRules;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1059;
PreCondition fl1061;
bool fl1072;
Action fl1074;
bool fl1085;
Rule fl1087;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<PreConditions")){
ctxt.skipWhiteSpace();
fl1059 = true ; 
while (fl1059) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1059 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1061 = null;
while(ctxt.lookAheadOpeningTag ("<PreCondition")) {
fl1061 = acceptor.lAccept_PreCondition(ctxt, "</PreCondition>");
appendPreConditions(fl1061);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</PreConditions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Actions")){
ctxt.skipWhiteSpace();
fl1072 = true ; 
while (fl1072) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1072 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1074 = null;
while(ctxt.lookAheadOpeningTag ("<Action")) {
fl1074 = acceptor.lAccept_Action(ctxt, "</Action>");
appendActions(fl1074);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Actions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubRules")){
ctxt.skipWhiteSpace();
fl1085 = true ; 
while (fl1085) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1085 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1087 = null;
while(ctxt.lookAheadOpeningTag ("<Rule")) {
fl1087 = acceptor.lAccept_Rule(ctxt, "</Rule>");
appendSubRules(fl1087);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubRules>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1098;
bool fl1099;
bool fl1100;
bool fl1101;
bool fl1102;
bool fl1103;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1098 = false ; 
fl1099 = false ; 
fl1100 = false ; 
fl1101 = false ; 
fl1102 = false ; 
fl1103 = true ; 
while (fl1103) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 1099;
} else {
indicator = 1104;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 1100;
} else {
indicator = 1104;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1101;
} else {
indicator = 1104;
} // If
break;
} // Case
default:
indicator = 1104;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1098;
} else {
indicator = 1104;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1102;
} else {
indicator = 1104;
} // If
break;
} // Case
default:
indicator = 1104;
break;
} // Switch
switch (indicator) {
case 1098: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1098){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1098 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1099: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl1099){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl1099 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1100: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl1100){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl1100 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1101: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1101){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1101 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1102: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1102){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1102 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1104: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1098){
this.setImplemented( false);
} // If
if (!fl1099){
this.setVerified( false);
} // If
if (!fl1100){
this.setNeedsRequirement( true);
} // If
fl1103 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RuleCondition";
  endingTag = "</RuleCondition>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RuleCondition\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
pw.Write("<PreConditions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getPreConditions(), false, "<PreCondition", "</PreCondition>");
pw.Write("</PreConditions>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<Actions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getActions(), false, "<Action", "</Action>");
pw.Write("</Actions>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
// Testing for empty content: SubRules
if (countSubRules() > 0){
pw.Write("<SubRules>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubRules(), false, "<Rule", "</Rule>");
pw.Write("</SubRules>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubRules
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countPreConditions(); i++) {
  l.Add(getPreConditions(i));
}
for (int i = 0; i < countActions(); i++) {
  l.Add(getActions(i));
}
for (int i = 0; i < countSubRules(); i++) {
  l.Add(getSubRules(i));
}
}

}
public partial class PreCondition
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getCondition().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.PreConditionController.alertChange(aLock, this);
}
private   string  aCondition;

public   string  getCondition() { return aCondition;}

public  void setCondition( string  v) {
  aCondition = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public PreCondition()
{
PreCondition obj = this;
aCondition=(null);
aComment=(null);
}

public void copyTo(PreCondition other)
{
base.copyTo(other);
other.aCondition = aCondition;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1112;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1112 = true ; 
while (fl1112) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1112 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
// Indicator
// Parse PC data
this.setCondition(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1113;
bool fl1114;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1113 = false ; 
fl1114 = true ; 
while (fl1114) { // BeginLoop 
if (ctxt.lookAheadString("Guid=")){
indicator = 1113;
} else {
indicator = 1115;
} // If
switch (indicator) {
case 1113: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1113){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1113 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1115: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1114 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<PreCondition";
  endingTag = "</PreCondition>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"PreCondition\"");
} // If
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing PcData
acceptor.unParsePcData(pw, this.getCondition());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Action
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getExpression().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ActionController.alertChange(aLock, this);
}
private   string  aExpression;

public   string  getExpression() { return aExpression;}

public  void setExpression( string  v) {
  aExpression = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Action()
{
Action obj = this;
aExpression=(null);
aComment=(null);
}

public void copyTo(Action other)
{
base.copyTo(other);
other.aExpression = aExpression;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1117;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1117 = true ; 
while (fl1117) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1117 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
// Indicator
// Parse PC data
this.setExpression(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1118;
bool fl1119;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1118 = false ; 
fl1119 = true ; 
while (fl1119) { // BeginLoop 
if (ctxt.lookAheadString("Guid=")){
indicator = 1118;
} else {
indicator = 1120;
} // If
switch (indicator) {
case 1118: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1118){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1118 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1120: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1119 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Action";
  endingTag = "</Action>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Action\"");
} // If
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing PcData
acceptor.unParsePcData(pw, this.getExpression());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class FrameRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FrameRefController.alertChange(aLock, this);
}
public FrameRef()
{
FrameRef obj = this;
}

public void copyTo(FrameRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1122;
bool fl1123;
bool fl1124;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1122 = false ; 
fl1123 = false ; 
fl1124 = true ; 
while (fl1124) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1122;
} else {
indicator = 1125;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1123;
} else {
indicator = 1125;
} // If
break;
} // Case
default:
indicator = 1125;
break;
} // Switch
switch (indicator) {
case 1122: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1122){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1122 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1123: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1123){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1123 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1125: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1124 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<FrameRef";
  endingTag = "</FrameRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"FrameRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Frame
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getCycleDuration().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FrameController.alertChange(aLock, this);
}
private   string  aCycleDuration;

public   string  getCycleDuration() { return aCycleDuration;}

public  void setCycleDuration( string  v) {
  aCycleDuration = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSubSequences;

/// <summary>Part of the list interface for SubSequences</summary>
/// <returns>a collection of all the elements in SubSequences</returns>
public System.Collections.ArrayList allSubSequences()
  {
if (aSubSequences == null){
    setAllSubSequences( new System.Collections.ArrayList() );
} // If
    return aSubSequences;
  }

/// <summary>Part of the list interface for SubSequences</summary>
/// <returns>a collection of all the elements in SubSequences</returns>
private System.Collections.ArrayList getSubSequences()
  {
    return allSubSequences();
  }

/// <summary>Part of the list interface for SubSequences</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSequences's current content.</param>
public void setAllSubSequences(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSequences = coll;
    NotifyControllers(null);
  }
public void setAllSubSequences(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSequences = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences</summary>
/// <param name="el">a SubSequence to add to the collection in 
///           SubSequences</param>
/// <seealso cref="appendSubSequences(System.Collections.IList)"/>
public void appendSubSequences(SubSequence el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSequences().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSequences(Lock aLock,SubSequence el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSequences().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSequences</summary>
/// <param name="coll">a collection ofSubSequences to add to the collection in 
///           SubSequences</param>
/// <seealso cref="appendSubSequences(SubSequence)"/>
public void appendSubSequences(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSequences().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSequences(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSequences().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences
/// This insertion function inserts a new element in the
/// collection in SubSequences</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSequences(int idx, SubSequence el)
  {
  __setDirty(true);
  allSubSequences().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSequences(int idx, SubSequence el,Lock aLock)
  {
  __setDirty(true);
  allSubSequences().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSequences(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSequences()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSequences
/// This deletion function removes an element from the
/// collection in SubSequences</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSequences(int idx)
  {
  __setDirty(true);
  allSubSequences().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSequences(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSequences().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSequences
/// This deletion function removes an element from the
/// collection in SubSequences
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSequences(IXmlBBase obj)
  {
  int idx = indexOfSubSequences(obj);
  if (idx >= 0) { deleteSubSequences(idx);
NotifyControllers(null);
   }
  }

public void removeSubSequences(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSequences(obj);
  if (idx >= 0) { deleteSubSequences(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSequences</summary>
/// <returns>the number of elements in SubSequences</returns>
public int countSubSequences()
  {
  return allSubSequences().Count;
  }

/// <summary>Part of the list interface for SubSequences
/// This function returns an element from the
/// collection in SubSequences based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SubSequence getSubSequences(int idx)
{
  return (SubSequence) ( allSubSequences()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Frame()
{
Frame obj = this;
aCycleDuration=(null);
aSubSequences=(null);
aComment=(null);
}

public void copyTo(Frame other)
{
base.copyTo(other);
other.aCycleDuration = aCycleDuration;
other.aSubSequences = aSubSequences;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1129;
bool fl1130;
SubSequence fl1132;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1129 = true ; 
while (fl1129) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1129 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubSequences")){
ctxt.skipWhiteSpace();
fl1130 = true ; 
while (fl1130) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1130 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1132 = null;
while(ctxt.lookAheadOpeningTag ("<SubSequence")) {
fl1132 = acceptor.lAccept_SubSequence(ctxt, "</SubSequence>");
appendSubSequences(fl1132);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSequences>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1143;
bool fl1144;
bool fl1145;
bool fl1146;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1143 = false ; 
fl1144 = false ; 
fl1145 = false ; 
fl1146 = true ; 
while (fl1146) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1144;
} else {
indicator = 1147;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1145;
} else {
indicator = 1147;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ycleDuration=")){
indicator = 1143;
} else {
indicator = 1147;
} // If
break;
} // Case
default:
indicator = 1147;
break;
} // Switch
switch (indicator) {
case 1143: {
// Handling attribute CycleDuration
// Also handles alien attributes with prefix CycleDuration
if (fl1143){
ctxt.fail ("Duplicate attribute: CycleDuration");
} // If
fl1143 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCycleDuration((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1144: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1144){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1144 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1145: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1145){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1145 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1147: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1143){
this.setCycleDuration("0.1");
} // If
fl1146 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Frame";
  endingTag = "</Frame>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Frame\"");
} // If
pw.Write('\n');
if (this.getCycleDuration() != null){
pw.Write(" CycleDuration=\"");
acceptor.unParsePcData(pw, this.getCycleDuration());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: SubSequences
if (countSubSequences() > 0){
pw.Write("<SubSequences>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSequences(), false, "<SubSequence", "</SubSequence>");
pw.Write("</SubSequences>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubSequences
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSubSequences(); i++) {
  l.Add(getSubSequences(i));
}
}

}
public partial class SubSequence
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getD_LRBG().CompareTo((String) search) == 0)return true;
if(getLevel().CompareTo((String) search) == 0)return true;
if(getMode().CompareTo((String) search) == 0)return true;
if(getNID_LRBG().CompareTo((String) search) == 0)return true;
if(getQ_DIRLRBG().CompareTo((String) search) == 0)return true;
if(getQ_DIRTRAIN().CompareTo((String) search) == 0)return true;
if(getQ_DLRBG().CompareTo((String) search) == 0)return true;
if(getRBC_ID().CompareTo((String) search) == 0)return true;
if(getRBCPhone().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SubSequenceController.alertChange(aLock, this);
}
private   string  aD_LRBG;

public   string  getD_LRBG() { return aD_LRBG;}

public  void setD_LRBG( string  v) {
  aD_LRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aLevel;

public   string  getLevel() { return aLevel;}

public  void setLevel( string  v) {
  aLevel = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMode;

public   string  getMode() { return aMode;}

public  void setMode( string  v) {
  aMode = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aNID_LRBG;

public   string  getNID_LRBG() { return aNID_LRBG;}

public  void setNID_LRBG( string  v) {
  aNID_LRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aQ_DIRLRBG;

public   string  getQ_DIRLRBG() { return aQ_DIRLRBG;}

public  void setQ_DIRLRBG( string  v) {
  aQ_DIRLRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aQ_DIRTRAIN;

public   string  getQ_DIRTRAIN() { return aQ_DIRTRAIN;}

public  void setQ_DIRTRAIN( string  v) {
  aQ_DIRTRAIN = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aQ_DLRBG;

public   string  getQ_DLRBG() { return aQ_DLRBG;}

public  void setQ_DLRBG( string  v) {
  aQ_DLRBG = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aRBC_ID;

public   string  getRBC_ID() { return aRBC_ID;}

public  void setRBC_ID( string  v) {
  aRBC_ID = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aRBCPhone;

public   string  getRBCPhone() { return aRBCPhone;}

public  void setRBCPhone( string  v) {
  aRBCPhone = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aTestCases;

/// <summary>Part of the list interface for TestCases</summary>
/// <returns>a collection of all the elements in TestCases</returns>
public System.Collections.ArrayList allTestCases()
  {
if (aTestCases == null){
    setAllTestCases( new System.Collections.ArrayList() );
} // If
    return aTestCases;
  }

/// <summary>Part of the list interface for TestCases</summary>
/// <returns>a collection of all the elements in TestCases</returns>
private System.Collections.ArrayList getTestCases()
  {
    return allTestCases();
  }

/// <summary>Part of the list interface for TestCases</summary>
/// <param name="coll">a collection of elements which replaces 
///        TestCases's current content.</param>
public void setAllTestCases(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestCases = coll;
    NotifyControllers(null);
  }
public void setAllTestCases(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTestCases = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases</summary>
/// <param name="el">a TestCase to add to the collection in 
///           TestCases</param>
/// <seealso cref="appendTestCases(System.Collections.IList)"/>
public void appendTestCases(TestCase el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTestCases(Lock aLock,TestCase el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTestCases().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TestCases</summary>
/// <param name="coll">a collection ofTestCases to add to the collection in 
///           TestCases</param>
/// <seealso cref="appendTestCases(TestCase)"/>
public void appendTestCases(System.Collections.IList coll)
  {
  __setDirty(true);
  allTestCases().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTestCases(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTestCases().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases
/// This insertion function inserts a new element in the
/// collection in TestCases</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTestCases(int idx, TestCase el)
  {
  __setDirty(true);
  allTestCases().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTestCases(int idx, TestCase el,Lock aLock)
  {
  __setDirty(true);
  allTestCases().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTestCases(IXmlBBase el)
  {
  return ((System.Collections.IList) allTestCases()).IndexOf (el);
  }

/// <summary>Part of the list interface for TestCases
/// This deletion function removes an element from the
/// collection in TestCases</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTestCases(int idx)
  {
  __setDirty(true);
  allTestCases().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTestCases(int idx,Lock aLock)
  {
  __setDirty(true);
  allTestCases().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TestCases
/// This deletion function removes an element from the
/// collection in TestCases
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTestCases(IXmlBBase obj)
  {
  int idx = indexOfTestCases(obj);
  if (idx >= 0) { deleteTestCases(idx);
NotifyControllers(null);
   }
  }

public void removeTestCases(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTestCases(obj);
  if (idx >= 0) { deleteTestCases(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TestCases</summary>
/// <returns>the number of elements in TestCases</returns>
public int countTestCases()
  {
  return allTestCases().Count;
  }

/// <summary>Part of the list interface for TestCases
/// This function returns an element from the
/// collection in TestCases based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public TestCase getTestCases(int idx)
{
  return (TestCase) ( allTestCases()[idx]);
}

private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aCompleted;

public  bool getCompleted() { return aCompleted;}

public  void setCompleted(bool v) {
  aCompleted = v;
  __setDirty(true);
  NotifyControllers(null);
}


public SubSequence()
{
SubSequence obj = this;
aD_LRBG=(null);
aLevel=(null);
aMode=(null);
aNID_LRBG=(null);
aQ_DIRLRBG=(null);
aQ_DIRTRAIN=(null);
aQ_DLRBG=(null);
aRBC_ID=(null);
aRBCPhone=(null);
aTestCases=(null);
aComment=(null);
aCompleted=(false);
}

public void copyTo(SubSequence other)
{
base.copyTo(other);
other.aD_LRBG = aD_LRBG;
other.aLevel = aLevel;
other.aMode = aMode;
other.aNID_LRBG = aNID_LRBG;
other.aQ_DIRLRBG = aQ_DIRLRBG;
other.aQ_DIRTRAIN = aQ_DIRTRAIN;
other.aQ_DLRBG = aQ_DLRBG;
other.aRBC_ID = aRBC_ID;
other.aRBCPhone = aRBCPhone;
other.aTestCases = aTestCases;
other.aComment = aComment;
other.aCompleted = aCompleted;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1152;
bool fl1153;
TestCase fl1155;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1152 = true ; 
while (fl1152) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1152 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<TestCases")){
ctxt.skipWhiteSpace();
fl1153 = true ; 
while (fl1153) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1153 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1155 = null;
while(ctxt.lookAheadOpeningTag ("<TestCase")) {
fl1155 = acceptor.lAccept_TestCase(ctxt, "</TestCase>");
appendTestCases(fl1155);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</TestCases>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1166;
bool fl1167;
bool fl1168;
bool fl1169;
bool fl1170;
bool fl1171;
bool fl1172;
bool fl1173;
bool fl1174;
bool fl1175;
bool fl1176;
bool fl1177;
bool fl1178;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1166 = false ; 
fl1167 = false ; 
fl1168 = false ; 
fl1169 = false ; 
fl1170 = false ; 
fl1171 = false ; 
fl1172 = false ; 
fl1173 = false ; 
fl1174 = false ; 
fl1175 = false ; 
fl1176 = false ; 
fl1177 = false ; 
fl1178 = true ; 
while (fl1178) { // BeginLoop 
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('B','C')){
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
if (ctxt.lookAhead3('I','D','=')){
indicator = 1173;
} else {
indicator = 1179;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("hone=")){
indicator = 1174;
} else {
indicator = 1179;
} // If
break;
} // Case
default:
indicator = 1179;
break;
} // Switch
} else {
indicator = 1179;
} // If
break;
} // Case
case 'Q':
{
ctxt.advance();
if (ctxt.lookAhead2('_','D')){
switch (ctxt.current()) {
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("RBG=")){
indicator = 1172;
} else {
indicator = 1179;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('R')){
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("RAIN=")){
indicator = 1171;
} else {
indicator = 1179;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("RBG=")){
indicator = 1170;
} else {
indicator = 1179;
} // If
break;
} // Case
default:
indicator = 1179;
break;
} // Switch
} else {
indicator = 1179;
} // If
break;
} // Case
default:
indicator = 1179;
break;
} // Switch
} else {
indicator = 1179;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1176;
} else {
indicator = 1179;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("D_LRBG=")){
indicator = 1169;
} else {
indicator = 1179;
} // If
break;
} // Case
default:
indicator = 1179;
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("ode=")){
indicator = 1168;
} else {
indicator = 1179;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("evel=")){
indicator = 1167;
} else {
indicator = 1179;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1177;
} else {
indicator = 1179;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("_LRBG=")){
indicator = 1166;
} else {
indicator = 1179;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ompleted=")){
indicator = 1175;
} else {
indicator = 1179;
} // If
break;
} // Case
default:
indicator = 1179;
break;
} // Switch
switch (indicator) {
case 1166: {
// Handling attribute D_LRBG
// Also handles alien attributes with prefix D_LRBG
if (fl1166){
ctxt.fail ("Duplicate attribute: D_LRBG");
} // If
fl1166 = true ; 
quoteChar = ctxt.acceptQuote();
this.setD_LRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1167: {
// Handling attribute Level
// Also handles alien attributes with prefix Level
if (fl1167){
ctxt.fail ("Duplicate attribute: Level");
} // If
fl1167 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLevel((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1168: {
// Handling attribute Mode
// Also handles alien attributes with prefix Mode
if (fl1168){
ctxt.fail ("Duplicate attribute: Mode");
} // If
fl1168 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMode((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1169: {
// Handling attribute NID_LRBG
// Also handles alien attributes with prefix NID_LRBG
if (fl1169){
ctxt.fail ("Duplicate attribute: NID_LRBG");
} // If
fl1169 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNID_LRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1170: {
// Handling attribute Q_DIRLRBG
// Also handles alien attributes with prefix Q_DIRLRBG
if (fl1170){
ctxt.fail ("Duplicate attribute: Q_DIRLRBG");
} // If
fl1170 = true ; 
quoteChar = ctxt.acceptQuote();
this.setQ_DIRLRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1171: {
// Handling attribute Q_DIRTRAIN
// Also handles alien attributes with prefix Q_DIRTRAIN
if (fl1171){
ctxt.fail ("Duplicate attribute: Q_DIRTRAIN");
} // If
fl1171 = true ; 
quoteChar = ctxt.acceptQuote();
this.setQ_DIRTRAIN((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1172: {
// Handling attribute Q_DLRBG
// Also handles alien attributes with prefix Q_DLRBG
if (fl1172){
ctxt.fail ("Duplicate attribute: Q_DLRBG");
} // If
fl1172 = true ; 
quoteChar = ctxt.acceptQuote();
this.setQ_DLRBG((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1173: {
// Handling attribute RBC_ID
// Also handles alien attributes with prefix RBC_ID
if (fl1173){
ctxt.fail ("Duplicate attribute: RBC_ID");
} // If
fl1173 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRBC_ID((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1174: {
// Handling attribute RBCPhone
// Also handles alien attributes with prefix RBCPhone
if (fl1174){
ctxt.fail ("Duplicate attribute: RBCPhone");
} // If
fl1174 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRBCPhone((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1175: {
// Handling attribute Completed
// Also handles alien attributes with prefix Completed
if (fl1175){
ctxt.fail ("Duplicate attribute: Completed");
} // If
fl1175 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCompleted(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1176: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1176){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1176 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1177: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1177){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1177 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1179: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1166){
this.setD_LRBG("");
} // If
if (!fl1167){
this.setLevel("");
} // If
if (!fl1168){
this.setMode("");
} // If
if (!fl1169){
this.setNID_LRBG("");
} // If
if (!fl1170){
this.setQ_DIRLRBG("");
} // If
if (!fl1171){
this.setQ_DIRTRAIN("");
} // If
if (!fl1172){
this.setQ_DLRBG("");
} // If
if (!fl1173){
this.setRBC_ID("");
} // If
if (!fl1174){
this.setRBCPhone("");
} // If
if (!fl1175){
this.setCompleted( true);
} // If
fl1178 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SubSequence";
  endingTag = "</SubSequence>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SubSequence\"");
} // If
pw.Write('\n');
if (this.getD_LRBG() != null){
pw.Write(" D_LRBG=\"");
acceptor.unParsePcData(pw, this.getD_LRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getLevel() != null){
pw.Write(" Level=\"");
acceptor.unParsePcData(pw, this.getLevel());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMode() != null){
pw.Write(" Mode=\"");
acceptor.unParsePcData(pw, this.getMode());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getNID_LRBG() != null){
pw.Write(" NID_LRBG=\"");
acceptor.unParsePcData(pw, this.getNID_LRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getQ_DIRLRBG() != null){
pw.Write(" Q_DIRLRBG=\"");
acceptor.unParsePcData(pw, this.getQ_DIRLRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getQ_DIRTRAIN() != null){
pw.Write(" Q_DIRTRAIN=\"");
acceptor.unParsePcData(pw, this.getQ_DIRTRAIN());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getQ_DLRBG() != null){
pw.Write(" Q_DLRBG=\"");
acceptor.unParsePcData(pw, this.getQ_DLRBG());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getRBC_ID() != null){
pw.Write(" RBC_ID=\"");
acceptor.unParsePcData(pw, this.getRBC_ID());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getRBCPhone() != null){
pw.Write(" RBCPhone=\"");
acceptor.unParsePcData(pw, this.getRBCPhone());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getCompleted()){
pw.Write(" Completed=\"");
acceptor.unParsePcData(pw, this.getCompleted());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: TestCases
if (countTestCases() > 0){
pw.Write("<TestCases>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTestCases(), false, "<TestCase", "</TestCase>");
pw.Write("</TestCases>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: TestCases
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countTestCases(); i++) {
  l.Add(getTestCases(i));
}
}

}
public partial class TestCase
: DataDictionary.ReqRelated
{
public  override  bool find(Object search){
if (search is String ) {
if(getObsoleteComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TestCaseController.alertChange(aLock, this);
}
private  int aFeature;

public  int getFeature() { return aFeature;}

public  void setFeature(int v) {
  aFeature = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aCase;

public  int getCase() { return aCase;}

public  void setCase(int v) {
  aCase = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSteps;

/// <summary>Part of the list interface for Steps</summary>
/// <returns>a collection of all the elements in Steps</returns>
public System.Collections.ArrayList allSteps()
  {
if (aSteps == null){
    setAllSteps( new System.Collections.ArrayList() );
} // If
    return aSteps;
  }

/// <summary>Part of the list interface for Steps</summary>
/// <returns>a collection of all the elements in Steps</returns>
private System.Collections.ArrayList getSteps()
  {
    return allSteps();
  }

/// <summary>Part of the list interface for Steps</summary>
/// <param name="coll">a collection of elements which replaces 
///        Steps's current content.</param>
public void setAllSteps(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSteps = coll;
    NotifyControllers(null);
  }
public void setAllSteps(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSteps = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps</summary>
/// <param name="el">a Step to add to the collection in 
///           Steps</param>
/// <seealso cref="appendSteps(System.Collections.IList)"/>
public void appendSteps(Step el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSteps(Lock aLock,Step el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Steps</summary>
/// <param name="coll">a collection ofSteps to add to the collection in 
///           Steps</param>
/// <seealso cref="appendSteps(Step)"/>
public void appendSteps(System.Collections.IList coll)
  {
  __setDirty(true);
  allSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSteps(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps
/// This insertion function inserts a new element in the
/// collection in Steps</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSteps(int idx, Step el)
  {
  __setDirty(true);
  allSteps().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSteps(int idx, Step el,Lock aLock)
  {
  __setDirty(true);
  allSteps().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSteps(IXmlBBase el)
  {
  return ((System.Collections.IList) allSteps()).IndexOf (el);
  }

/// <summary>Part of the list interface for Steps
/// This deletion function removes an element from the
/// collection in Steps</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSteps(int idx)
  {
  __setDirty(true);
  allSteps().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSteps(int idx,Lock aLock)
  {
  __setDirty(true);
  allSteps().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Steps
/// This deletion function removes an element from the
/// collection in Steps
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSteps(IXmlBBase obj)
  {
  int idx = indexOfSteps(obj);
  if (idx >= 0) { deleteSteps(idx);
NotifyControllers(null);
   }
  }

public void removeSteps(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSteps(obj);
  if (idx >= 0) { deleteSteps(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Steps</summary>
/// <returns>the number of elements in Steps</returns>
public int countSteps()
  {
  return allSteps().Count;
  }

/// <summary>Part of the list interface for Steps
/// This function returns an element from the
/// collection in Steps based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Step getSteps(int idx)
{
  return (Step) ( allSteps()[idx]);
}

private   string  aObsoleteComment;

public   string  getObsoleteComment() { return aObsoleteComment;}

public  void setObsoleteComment( string  v) {
  aObsoleteComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public TestCase()
{
TestCase obj = this;
aFeature=(0);
aCase=(0);
aSteps=(null);
aObsoleteComment=(null);
}

public void copyTo(TestCase other)
{
base.copyTo(other);
other.aFeature = aFeature;
other.aCase = aCase;
other.aSteps = aSteps;
other.aObsoleteComment = aObsoleteComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1197;
bool fl1198;
Step fl1200;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1197 = true ; 
while (fl1197) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1197 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setObsoleteComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Steps")){
ctxt.skipWhiteSpace();
fl1198 = true ; 
while (fl1198) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1198 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1200 = null;
while(ctxt.lookAheadOpeningTag ("<Step")) {
fl1200 = acceptor.lAccept_Step(ctxt, "</Step>");
appendSteps(fl1200);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Steps>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1211;
bool fl1212;
bool fl1213;
bool fl1214;
bool fl1215;
bool fl1216;
bool fl1217;
bool fl1218;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1211 = false ; 
fl1212 = false ; 
fl1213 = false ; 
fl1214 = false ; 
fl1215 = false ; 
fl1216 = false ; 
fl1217 = false ; 
fl1218 = true ; 
while (fl1218) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erified=")){
indicator = 1214;
} else {
indicator = 1219;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("edsRequirement=")){
indicator = 1215;
} else {
indicator = 1219;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('m','e','=')){
indicator = 1216;
} else {
indicator = 1219;
} // If
break;
} // Case
default:
indicator = 1219;
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1213;
} else {
indicator = 1219;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1217;
} else {
indicator = 1219;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("eature=")){
indicator = 1211;
} else {
indicator = 1219;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ase=")){
indicator = 1212;
} else {
indicator = 1219;
} // If
break;
} // Case
default:
indicator = 1219;
break;
} // Switch
switch (indicator) {
case 1211: {
// Handling attribute Feature
// Also handles alien attributes with prefix Feature
if (fl1211){
ctxt.fail ("Duplicate attribute: Feature");
} // If
fl1211 = true ; 
quoteChar = ctxt.acceptQuote();
this.setFeature(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1212: {
// Handling attribute Case
// Also handles alien attributes with prefix Case
if (fl1212){
ctxt.fail ("Duplicate attribute: Case");
} // If
fl1212 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCase(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1213: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1213){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1213 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1214: {
// Handling attribute Verified
// Also handles alien attributes with prefix Verified
if (fl1214){
ctxt.fail ("Duplicate attribute: Verified");
} // If
fl1214 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVerified(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1215: {
// Handling attribute NeedsRequirement
// Also handles alien attributes with prefix NeedsRequirement
if (fl1215){
ctxt.fail ("Duplicate attribute: NeedsRequirement");
} // If
fl1215 = true ; 
quoteChar = ctxt.acceptQuote();
this.setNeedsRequirement(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1216: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1216){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1216 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1217: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1217){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1217 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1219: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1211){
this.setFeature(9999);
} // If
if (!fl1212){
this.setCase(9999);
} // If
if (!fl1213){
this.setImplemented( false);
} // If
if (!fl1214){
this.setVerified( false);
} // If
if (!fl1215){
this.setNeedsRequirement( true);
} // If
fl1218 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<TestCase";
  endingTag = "</TestCase>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"TestCase\"");
} // If
pw.Write('\n');
if (this.getFeature() != 9999){
pw.Write(" Feature=\"");
acceptor.unParsePcData(pw, this.getFeature());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getCase() != 9999){
pw.Write(" Case=\"");
acceptor.unParsePcData(pw, this.getCase());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVerified()){
pw.Write(" Verified=\"");
acceptor.unParsePcData(pw, this.getVerified());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getNeedsRequirement()){
pw.Write(" NeedsRequirement=\"");
acceptor.unParsePcData(pw, this.getNeedsRequirement());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: ObsoleteComment
if (this.getObsoleteComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getObsoleteComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: ObsoleteComment
// Unparsing Enclosed
// Testing for empty content: Steps
if (countSteps() > 0){
pw.Write("<Steps>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSteps(), false, "<Step", "</Step>");
pw.Write("</Steps>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Steps
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSteps(); i++) {
  l.Add(getSteps(i));
}
}

}
public partial class Step
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
if(getDescription().CompareTo((String) search) == 0)return true;
if(getObsoleteComment().CompareTo((String) search) == 0)return true;
if(getUserComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.StepController.alertChange(aLock, this);
}
private  int aTCS_Order;

public  int getTCS_Order() { return aTCS_Order;}

public  void setTCS_Order(int v) {
  aTCS_Order = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aDistance;

public  int getDistance() { return aDistance;}

public  void setDistance(int v) {
  aDistance = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDescription;

public   string  getDescription() { return aDescription;}

public  void setDescription( string  v) {
  aDescription = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aObsoleteComment;

public   string  getObsoleteComment() { return aObsoleteComment;}

public  void setObsoleteComment( string  v) {
  aObsoleteComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aUserComment;

public   string  getUserComment() { return aUserComment;}

public  void setUserComment( string  v) {
  aUserComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.ST_IO aIO;

public  acceptor.ST_IO getIO() { return aIO;}

public  void setIO(acceptor.ST_IO v) {
  aIO = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getIO_AsString()
{
  return acceptor.Enum_ST_IO_ToString (aIO);
}

public  bool setIO_AsString( string  v)
{
 acceptor.ST_IO  temp = acceptor.StringTo_Enum_ST_IO(v);
if (temp >= 0){
  aIO = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_INTERFACE aInterface;

public  acceptor.ST_INTERFACE getInterface() { return aInterface;}

public  void setInterface(acceptor.ST_INTERFACE v) {
  aInterface = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getInterface_AsString()
{
  return acceptor.Enum_ST_INTERFACE_ToString (aInterface);
}

public  bool setInterface_AsString( string  v)
{
 acceptor.ST_INTERFACE  temp = acceptor.StringTo_Enum_ST_INTERFACE(v);
if (temp >= 0){
  aInterface = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_LEVEL aLevelIN;

public  acceptor.ST_LEVEL getLevelIN() { return aLevelIN;}

public  void setLevelIN(acceptor.ST_LEVEL v) {
  aLevelIN = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getLevelIN_AsString()
{
  return acceptor.Enum_ST_LEVEL_ToString (aLevelIN);
}

public  bool setLevelIN_AsString( string  v)
{
 acceptor.ST_LEVEL  temp = acceptor.StringTo_Enum_ST_LEVEL(v);
if (temp >= 0){
  aLevelIN = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_LEVEL aLevelOUT;

public  acceptor.ST_LEVEL getLevelOUT() { return aLevelOUT;}

public  void setLevelOUT(acceptor.ST_LEVEL v) {
  aLevelOUT = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getLevelOUT_AsString()
{
  return acceptor.Enum_ST_LEVEL_ToString (aLevelOUT);
}

public  bool setLevelOUT_AsString( string  v)
{
 acceptor.ST_LEVEL  temp = acceptor.StringTo_Enum_ST_LEVEL(v);
if (temp >= 0){
  aLevelOUT = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_MODE aModeIN;

public  acceptor.ST_MODE getModeIN() { return aModeIN;}

public  void setModeIN(acceptor.ST_MODE v) {
  aModeIN = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getModeIN_AsString()
{
  return acceptor.Enum_ST_MODE_ToString (aModeIN);
}

public  bool setModeIN_AsString( string  v)
{
 acceptor.ST_MODE  temp = acceptor.StringTo_Enum_ST_MODE(v);
if (temp >= 0){
  aModeIN = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.ST_MODE aModeOUT;

public  acceptor.ST_MODE getModeOUT() { return aModeOUT;}

public  void setModeOUT(acceptor.ST_MODE v) {
  aModeOUT = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getModeOUT_AsString()
{
  return acceptor.Enum_ST_MODE_ToString (aModeOUT);
}

public  bool setModeOUT_AsString( string  v)
{
 acceptor.ST_MODE  temp = acceptor.StringTo_Enum_ST_MODE(v);
if (temp >= 0){
  aModeOUT = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  bool aTranslationRequired;

public  bool getTranslationRequired() { return aTranslationRequired;}

public  void setTranslationRequired(bool v) {
  aTranslationRequired = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aTranslated;

public  bool getTranslated() { return aTranslated;}

public  void setTranslated(bool v) {
  aTranslated = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSubSteps;

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
public System.Collections.ArrayList allSubSteps()
  {
if (aSubSteps == null){
    setAllSubSteps( new System.Collections.ArrayList() );
} // If
    return aSubSteps;
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
private System.Collections.ArrayList getSubSteps()
  {
    return allSubSteps();
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSteps's current content.</param>
public void setAllSubSteps(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
    NotifyControllers(null);
  }
public void setAllSubSteps(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="el">a SubStep to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(System.Collections.IList)"/>
public void appendSubSteps(SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSteps(Lock aLock,SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection ofSubSteps to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(SubStep)"/>
public void appendSubSteps(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSteps(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This insertion function inserts a new element in the
/// collection in SubSteps</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSteps(int idx, SubStep el)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSteps(int idx, SubStep el,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSteps(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSteps()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSteps(int idx)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSteps(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSteps(IXmlBBase obj)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(null);
   }
  }

public void removeSubSteps(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>the number of elements in SubSteps</returns>
public int countSubSteps()
  {
  return allSubSteps().Count;
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns an element from the
/// collection in SubSteps based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SubStep getSubSteps(int idx)
{
  return (SubStep) ( allSubSteps()[idx]);
}

private System.Collections.ArrayList aMessages;

/// <summary>Part of the list interface for Messages</summary>
/// <returns>a collection of all the elements in Messages</returns>
public System.Collections.ArrayList allMessages()
  {
if (aMessages == null){
    setAllMessages( new System.Collections.ArrayList() );
} // If
    return aMessages;
  }

/// <summary>Part of the list interface for Messages</summary>
/// <returns>a collection of all the elements in Messages</returns>
private System.Collections.ArrayList getMessages()
  {
    return allMessages();
  }

/// <summary>Part of the list interface for Messages</summary>
/// <param name="coll">a collection of elements which replaces 
///        Messages's current content.</param>
public void setAllMessages(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMessages = coll;
    NotifyControllers(null);
  }
public void setAllMessages(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMessages = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages</summary>
/// <param name="el">a DBMessage to add to the collection in 
///           Messages</param>
/// <seealso cref="appendMessages(System.Collections.IList)"/>
public void appendMessages(DBMessage el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMessages().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendMessages(Lock aLock,DBMessage el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMessages().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Messages</summary>
/// <param name="coll">a collection ofDBMessages to add to the collection in 
///           Messages</param>
/// <seealso cref="appendMessages(DBMessage)"/>
public void appendMessages(System.Collections.IList coll)
  {
  __setDirty(true);
  allMessages().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendMessages(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allMessages().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages
/// This insertion function inserts a new element in the
/// collection in Messages</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertMessages(int idx, DBMessage el)
  {
  __setDirty(true);
  allMessages().Insert (idx, el);
NotifyControllers(null);
  }

public void insertMessages(int idx, DBMessage el,Lock aLock)
  {
  __setDirty(true);
  allMessages().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfMessages(IXmlBBase el)
  {
  return ((System.Collections.IList) allMessages()).IndexOf (el);
  }

/// <summary>Part of the list interface for Messages
/// This deletion function removes an element from the
/// collection in Messages</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteMessages(int idx)
  {
  __setDirty(true);
  allMessages().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteMessages(int idx,Lock aLock)
  {
  __setDirty(true);
  allMessages().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Messages
/// This deletion function removes an element from the
/// collection in Messages
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeMessages(IXmlBBase obj)
  {
  int idx = indexOfMessages(obj);
  if (idx >= 0) { deleteMessages(idx);
NotifyControllers(null);
   }
  }

public void removeMessages(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfMessages(obj);
  if (idx >= 0) { deleteMessages(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Messages</summary>
/// <returns>the number of elements in Messages</returns>
public int countMessages()
  {
  return allMessages().Count;
  }

/// <summary>Part of the list interface for Messages
/// This function returns an element from the
/// collection in Messages based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBMessage getMessages(int idx)
{
  return (DBMessage) ( allMessages()[idx]);
}

public Step()
{
Step obj = this;
aTCS_Order=(0);
aDistance=(0);
aDescription=(null);
aObsoleteComment=(null);
aUserComment=(null);
aIO=(0);
aInterface=(0);
aLevelIN=(0);
aLevelOUT=(0);
aModeIN=(0);
aModeOUT=(0);
aTranslationRequired=(false);
aTranslated=(false);
aSubSteps=(null);
aMessages=(null);
}

public void copyTo(Step other)
{
base.copyTo(other);
other.aTCS_Order = aTCS_Order;
other.aDistance = aDistance;
other.aDescription = aDescription;
other.aObsoleteComment = aObsoleteComment;
other.aUserComment = aUserComment;
other.aIO = aIO;
other.aInterface = aInterface;
other.aLevelIN = aLevelIN;
other.aLevelOUT = aLevelOUT;
other.aModeIN = aModeIN;
other.aModeOUT = aModeOUT;
other.aTranslationRequired = aTranslationRequired;
other.aTranslated = aTranslated;
other.aSubSteps = aSubSteps;
other.aMessages = aMessages;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1229;
bool fl1230;
bool fl1231;
bool fl1232;
SubStep fl1234;
bool fl1245;
DBMessage fl1247;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Description")){
ctxt.skipWhiteSpace();
fl1229 = true ; 
while (fl1229) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1229 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setDescription(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Description>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1230 = true ; 
while (fl1230) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1230 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setObsoleteComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<UserComment")){
ctxt.skipWhiteSpace();
fl1231 = true ; 
while (fl1231) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1231 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setUserComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</UserComment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubSteps")){
ctxt.skipWhiteSpace();
fl1232 = true ; 
while (fl1232) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1232 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1234 = null;
while(ctxt.lookAheadOpeningTag ("<SubStep")) {
fl1234 = acceptor.lAccept_SubStep(ctxt, "</SubStep>");
appendSubSteps(fl1234);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSteps>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Messsages")){
ctxt.skipWhiteSpace();
fl1245 = true ; 
while (fl1245) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1245 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1247 = null;
while(ctxt.lookAheadOpeningTag ("<DBMessage")) {
fl1247 = acceptor.lAccept_DBMessage(ctxt, "</DBMessage>");
appendMessages(fl1247);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Messsages>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1258;
bool fl1259;
bool fl1260;
bool fl1261;
bool fl1262;
bool fl1263;
bool fl1264;
bool fl1265;
bool fl1266;
bool fl1267;
bool fl1268;
bool fl1269;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1258 = false ; 
fl1259 = false ; 
fl1260 = false ; 
fl1261 = false ; 
fl1262 = false ; 
fl1263 = false ; 
fl1264 = false ; 
fl1265 = false ; 
fl1266 = false ; 
fl1267 = false ; 
fl1268 = false ; 
fl1269 = true ; 
while (fl1269) { // BeginLoop 
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslat")){
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("onRequired=")){
indicator = 1265;
} else {
indicator = 1270;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 1266;
} else {
indicator = 1270;
} // If
break;
} // Case
default:
indicator = 1270;
break;
} // Switch
} else {
indicator = 1270;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("S_Order=")){
indicator = 1258;
} else {
indicator = 1270;
} // If
break;
} // Case
default:
indicator = 1270;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1267;
} else {
indicator = 1270;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAhead3('o','d','e')){
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead3('U','T','=')){
indicator = 1264;
} else {
indicator = 1270;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('N','=')){
indicator = 1263;
} else {
indicator = 1270;
} // If
break;
} // Case
default:
indicator = 1270;
break;
} // Switch
} else {
indicator = 1270;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAheadString("evel")){
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead3('U','T','=')){
indicator = 1262;
} else {
indicator = 1270;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('N','=')){
indicator = 1261;
} else {
indicator = 1270;
} // If
break;
} // Case
default:
indicator = 1270;
break;
} // Switch
} else {
indicator = 1270;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead2('O','=')){
indicator = 1260;
} else {
indicator = 1270;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1268;
} else {
indicator = 1270;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("istance=")){
indicator = 1259;
} else {
indicator = 1270;
} // If
break;
} // Case
default:
indicator = 1270;
break;
} // Switch
switch (indicator) {
case 1258: {
// Handling attribute TCS_Order
// Also handles alien attributes with prefix TCS_Order
if (fl1258){
ctxt.fail ("Duplicate attribute: TCS_Order");
} // If
fl1258 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTCS_Order(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1259: {
// Handling attribute Distance
// Also handles alien attributes with prefix Distance
if (fl1259){
ctxt.fail ("Duplicate attribute: Distance");
} // If
fl1259 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDistance(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1260: {
// Handling attribute IO
// Also handles alien attributes with prefix IO
if (fl1260){
ctxt.fail ("Duplicate attribute: IO");
} // If
fl1260 = true ; 
quoteChar = ctxt.acceptQuote();
this.setIO(acceptor.lAcceptEnum_ST_IO(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1261: {
// Handling attribute LevelIN
// Also handles alien attributes with prefix LevelIN
if (fl1261){
ctxt.fail ("Duplicate attribute: LevelIN");
} // If
fl1261 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLevelIN(acceptor.lAcceptEnum_ST_LEVEL(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1262: {
// Handling attribute LevelOUT
// Also handles alien attributes with prefix LevelOUT
if (fl1262){
ctxt.fail ("Duplicate attribute: LevelOUT");
} // If
fl1262 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLevelOUT(acceptor.lAcceptEnum_ST_LEVEL(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1263: {
// Handling attribute ModeIN
// Also handles alien attributes with prefix ModeIN
if (fl1263){
ctxt.fail ("Duplicate attribute: ModeIN");
} // If
fl1263 = true ; 
quoteChar = ctxt.acceptQuote();
this.setModeIN(acceptor.lAcceptEnum_ST_MODE(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1264: {
// Handling attribute ModeOUT
// Also handles alien attributes with prefix ModeOUT
if (fl1264){
ctxt.fail ("Duplicate attribute: ModeOUT");
} // If
fl1264 = true ; 
quoteChar = ctxt.acceptQuote();
this.setModeOUT(acceptor.lAcceptEnum_ST_MODE(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1265: {
// Handling attribute TranslationRequired
// Also handles alien attributes with prefix TranslationRequired
if (fl1265){
ctxt.fail ("Duplicate attribute: TranslationRequired");
} // If
fl1265 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTranslationRequired(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1266: {
// Handling attribute Translated
// Also handles alien attributes with prefix Translated
if (fl1266){
ctxt.fail ("Duplicate attribute: Translated");
} // If
fl1266 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTranslated(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1267: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1267){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1267 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1268: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1268){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1268 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1270: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1258){
this.setTCS_Order(0);
} // If
if (!fl1259){
this.setDistance(0);
} // If
if (!fl1260){
this.setIO(acceptor.ST_IO.StIO_NA);
} // If
if (!fl1261){
this.setLevelIN(acceptor.ST_LEVEL.StLevel_NA);
} // If
if (!fl1262){
this.setLevelOUT(acceptor.ST_LEVEL.StLevel_NA);
} // If
if (!fl1263){
this.setModeIN(acceptor.ST_MODE.Mode_NA);
} // If
if (!fl1264){
this.setModeOUT(acceptor.ST_MODE.Mode_NA);
} // If
if (!fl1265){
this.setTranslationRequired( true);
} // If
if (!fl1266){
this.setTranslated( false);
} // If
fl1269 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Step";
  endingTag = "</Step>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Step\"");
} // If
pw.Write('\n');
if (this.getTCS_Order() != 0){
pw.Write(" TCS_Order=\"");
acceptor.unParsePcData(pw, this.getTCS_Order());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDistance() != 0){
pw.Write(" Distance=\"");
acceptor.unParsePcData(pw, this.getDistance());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getIO() != 0){
pw.Write(" IO=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_IO_ToString(this.getIO()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getLevelIN() != 0){
pw.Write(" LevelIN=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_LEVEL_ToString(this.getLevelIN()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getLevelOUT() != 0){
pw.Write(" LevelOUT=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_LEVEL_ToString(this.getLevelOUT()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getModeIN() != 0){
pw.Write(" ModeIN=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_MODE_ToString(this.getModeIN()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getModeOUT() != 0){
pw.Write(" ModeOUT=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ST_MODE_ToString(this.getModeOUT()));
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getTranslationRequired()){
pw.Write(" TranslationRequired=\"");
acceptor.unParsePcData(pw, this.getTranslationRequired());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getTranslated()){
pw.Write(" Translated=\"");
acceptor.unParsePcData(pw, this.getTranslated());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Description
if (this.getDescription() != null){
pw.Write("<Description>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getDescription());
pw.Write("</Description>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Description
// Unparsing Enclosed
// Testing for empty content: ObsoleteComment
if (this.getObsoleteComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getObsoleteComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: ObsoleteComment
// Unparsing Enclosed
// Testing for empty content: UserComment
if (this.getUserComment() != null){
pw.Write("<UserComment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getUserComment());
pw.Write("</UserComment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: UserComment
// Unparsing Enclosed
// Testing for empty content: SubSteps
if (countSubSteps() > 0){
pw.Write("<SubSteps>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSteps(), false, "<SubStep", "</SubStep>");
pw.Write("</SubSteps>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubSteps
// Unparsing Enclosed
// Testing for empty content: Messages
if (countMessages() > 0){
pw.Write("<Messsages>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getMessages(), false, "<DBMessage", "</DBMessage>");
pw.Write("</Messsages>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Messages
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSubSteps(); i++) {
  l.Add(getSubSteps(i));
}
for (int i = 0; i < countMessages(); i++) {
  l.Add(getMessages(i));
}
}

}
public partial class SubStep
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SubStepController.alertChange(aLock, this);
}
private System.Collections.ArrayList aActions;

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
public System.Collections.ArrayList allActions()
  {
if (aActions == null){
    setAllActions( new System.Collections.ArrayList() );
} // If
    return aActions;
  }

/// <summary>Part of the list interface for Actions</summary>
/// <returns>a collection of all the elements in Actions</returns>
private System.Collections.ArrayList getActions()
  {
    return allActions();
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection of elements which replaces 
///        Actions's current content.</param>
public void setAllActions(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
    NotifyControllers(null);
  }
public void setAllActions(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aActions = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions</summary>
/// <param name="el">a Action to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(System.Collections.IList)"/>
public void appendActions(Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendActions(Lock aLock,Action el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allActions().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Actions</summary>
/// <param name="coll">a collection ofActions to add to the collection in 
///           Actions</param>
/// <seealso cref="appendActions(Action)"/>
public void appendActions(System.Collections.IList coll)
  {
  __setDirty(true);
  allActions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendActions(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allActions().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This insertion function inserts a new element in the
/// collection in Actions</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertActions(int idx, Action el)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(null);
  }

public void insertActions(int idx, Action el,Lock aLock)
  {
  __setDirty(true);
  allActions().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfActions(IXmlBBase el)
  {
  return ((System.Collections.IList) allActions()).IndexOf (el);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteActions(int idx)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteActions(int idx,Lock aLock)
  {
  __setDirty(true);
  allActions().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Actions
/// This deletion function removes an element from the
/// collection in Actions
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeActions(IXmlBBase obj)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(null);
   }
  }

public void removeActions(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfActions(obj);
  if (idx >= 0) { deleteActions(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Actions</summary>
/// <returns>the number of elements in Actions</returns>
public int countActions()
  {
  return allActions().Count;
  }

/// <summary>Part of the list interface for Actions
/// This function returns an element from the
/// collection in Actions based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Action getActions(int idx)
{
  return (Action) ( allActions()[idx]);
}

private System.Collections.ArrayList aExpectations;

/// <summary>Part of the list interface for Expectations</summary>
/// <returns>a collection of all the elements in Expectations</returns>
public System.Collections.ArrayList allExpectations()
  {
if (aExpectations == null){
    setAllExpectations( new System.Collections.ArrayList() );
} // If
    return aExpectations;
  }

/// <summary>Part of the list interface for Expectations</summary>
/// <returns>a collection of all the elements in Expectations</returns>
private System.Collections.ArrayList getExpectations()
  {
    return allExpectations();
  }

/// <summary>Part of the list interface for Expectations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Expectations's current content.</param>
public void setAllExpectations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aExpectations = coll;
    NotifyControllers(null);
  }
public void setAllExpectations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aExpectations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations</summary>
/// <param name="el">a Expectation to add to the collection in 
///           Expectations</param>
/// <seealso cref="appendExpectations(System.Collections.IList)"/>
public void appendExpectations(Expectation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allExpectations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendExpectations(Lock aLock,Expectation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allExpectations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Expectations</summary>
/// <param name="coll">a collection ofExpectations to add to the collection in 
///           Expectations</param>
/// <seealso cref="appendExpectations(Expectation)"/>
public void appendExpectations(System.Collections.IList coll)
  {
  __setDirty(true);
  allExpectations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendExpectations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allExpectations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations
/// This insertion function inserts a new element in the
/// collection in Expectations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertExpectations(int idx, Expectation el)
  {
  __setDirty(true);
  allExpectations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertExpectations(int idx, Expectation el,Lock aLock)
  {
  __setDirty(true);
  allExpectations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfExpectations(IXmlBBase el)
  {
  return ((System.Collections.IList) allExpectations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Expectations
/// This deletion function removes an element from the
/// collection in Expectations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteExpectations(int idx)
  {
  __setDirty(true);
  allExpectations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteExpectations(int idx,Lock aLock)
  {
  __setDirty(true);
  allExpectations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Expectations
/// This deletion function removes an element from the
/// collection in Expectations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeExpectations(IXmlBBase obj)
  {
  int idx = indexOfExpectations(obj);
  if (idx >= 0) { deleteExpectations(idx);
NotifyControllers(null);
   }
  }

public void removeExpectations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfExpectations(obj);
  if (idx >= 0) { deleteExpectations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Expectations</summary>
/// <returns>the number of elements in Expectations</returns>
public int countExpectations()
  {
  return allExpectations().Count;
  }

/// <summary>Part of the list interface for Expectations
/// This function returns an element from the
/// collection in Expectations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Expectation getExpectations(int idx)
{
  return (Expectation) ( allExpectations()[idx]);
}

private  bool aSkipEngine;

public  bool getSkipEngine() { return aSkipEngine;}

public  void setSkipEngine(bool v) {
  aSkipEngine = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


public SubStep()
{
SubStep obj = this;
aActions=(null);
aExpectations=(null);
aSkipEngine=(false);
aComment=(null);
}

public void copyTo(SubStep other)
{
base.copyTo(other);
other.aActions = aActions;
other.aExpectations = aExpectations;
other.aSkipEngine = aSkipEngine;
other.aComment = aComment;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1287;
bool fl1288;
Action fl1290;
bool fl1301;
Expectation fl1303;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1287 = true ; 
while (fl1287) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1287 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Actions")){
ctxt.skipWhiteSpace();
fl1288 = true ; 
while (fl1288) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1288 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1290 = null;
while(ctxt.lookAheadOpeningTag ("<Action")) {
fl1290 = acceptor.lAccept_Action(ctxt, "</Action>");
appendActions(fl1290);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Actions>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Expectations")){
ctxt.skipWhiteSpace();
fl1301 = true ; 
while (fl1301) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1301 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1303 = null;
while(ctxt.lookAheadOpeningTag ("<Expectation")) {
fl1303 = acceptor.lAccept_Expectation(ctxt, "</Expectation>");
appendExpectations(fl1303);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Expectations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1314;
bool fl1315;
bool fl1316;
bool fl1317;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1314 = false ; 
fl1315 = false ; 
fl1316 = false ; 
fl1317 = true ; 
while (fl1317) { // BeginLoop 
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
if (ctxt.lookAheadString("kipEngine=")){
indicator = 1314;
} else {
indicator = 1318;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1315;
} else {
indicator = 1318;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1316;
} else {
indicator = 1318;
} // If
break;
} // Case
default:
indicator = 1318;
break;
} // Switch
switch (indicator) {
case 1314: {
// Handling attribute SkipEngine
// Also handles alien attributes with prefix SkipEngine
if (fl1314){
ctxt.fail ("Duplicate attribute: SkipEngine");
} // If
fl1314 = true ; 
quoteChar = ctxt.acceptQuote();
this.setSkipEngine(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1315: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1315){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1315 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1316: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1316){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1316 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1318: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1314){
this.setSkipEngine( false);
} // If
fl1317 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SubStep";
  endingTag = "</SubStep>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SubStep\"");
} // If
pw.Write('\n');
if (this.getSkipEngine()){
pw.Write(" SkipEngine=\"");
acceptor.unParsePcData(pw, this.getSkipEngine());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing Enclosed
// Testing for empty content: Actions
if (countActions() > 0){
pw.Write("<Actions>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getActions(), false, "<Action", "</Action>");
pw.Write("</Actions>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Actions
// Unparsing Enclosed
// Testing for empty content: Expectations
if (countExpectations() > 0){
pw.Write("<Expectations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getExpectations(), false, "<Expectation", "</Expectation>");
pw.Write("</Expectations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Expectations
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countActions(); i++) {
  l.Add(getActions(i));
}
for (int i = 0; i < countExpectations(); i++) {
  l.Add(getExpectations(i));
}
}

}
public partial class Expectation
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
if(getCondition().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ExpectationController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aBlocking;

public  bool getBlocking() { return aBlocking;}

public  void setBlocking(bool v) {
  aBlocking = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.ExpectationKind aKind;

public  acceptor.ExpectationKind getKind() { return aKind;}

public  void setKind(acceptor.ExpectationKind v) {
  aKind = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getKind_AsString()
{
  return acceptor.Enum_ExpectationKind_ToString (aKind);
}

public  bool setKind_AsString( string  v)
{
 acceptor.ExpectationKind  temp = acceptor.StringTo_Enum_ExpectationKind(v);
if (temp >= 0){
  aKind = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  double aDeadLine;

public  double getDeadLine() { return aDeadLine;}

public  void setDeadLine(double v) {
  aDeadLine = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aCondition;

public   string  getCondition() { return aCondition;}

public  void setCondition( string  v) {
  aCondition = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.RulePriority aCyclePhase;

public  acceptor.RulePriority getCyclePhase() { return aCyclePhase;}

public  void setCyclePhase(acceptor.RulePriority v) {
  aCyclePhase = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getCyclePhase_AsString()
{
  return acceptor.Enum_RulePriority_ToString (aCyclePhase);
}

public  bool setCyclePhase_AsString( string  v)
{
 acceptor.RulePriority  temp = acceptor.StringTo_Enum_RulePriority(v);
if (temp >= 0){
  aCyclePhase = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public Expectation()
{
Expectation obj = this;
aValue=(null);
aBlocking=(false);
aKind=(0);
aDeadLine=(0.0);
aCondition=(null);
aComment=(null);
aCyclePhase=(0);
}

public void copyTo(Expectation other)
{
base.copyTo(other);
other.aValue = aValue;
other.aBlocking = aBlocking;
other.aKind = aKind;
other.aDeadLine = aDeadLine;
other.aCondition = aCondition;
other.aComment = aComment;
other.aCyclePhase = aCyclePhase;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1323;
bool fl1324;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1323 = true ; 
while (fl1323) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1323 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Condition")){
ctxt.skipWhiteSpace();
fl1324 = true ; 
while (fl1324) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1324 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setCondition(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Condition>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1325;
bool fl1326;
bool fl1327;
bool fl1328;
bool fl1329;
bool fl1330;
bool fl1331;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1325 = false ; 
fl1326 = false ; 
fl1327 = false ; 
fl1328 = false ; 
fl1329 = false ; 
fl1330 = false ; 
fl1331 = true ; 
while (fl1331) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1329;
} else {
indicator = 1332;
} // If
break;
} // Case
case 'K':
{
ctxt.advance();
if (ctxt.lookAheadString("ind=")){
indicator = 1325;
} else {
indicator = 1332;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1330;
} else {
indicator = 1332;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("eadLine=")){
indicator = 1327;
} else {
indicator = 1332;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("yclePhase=")){
indicator = 1328;
} else {
indicator = 1332;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
if (ctxt.lookAheadString("locking=")){
indicator = 1326;
} else {
indicator = 1332;
} // If
break;
} // Case
default:
indicator = 1332;
break;
} // Switch
switch (indicator) {
case 1325: {
// Handling attribute Kind
// Also handles alien attributes with prefix Kind
if (fl1325){
ctxt.fail ("Duplicate attribute: Kind");
} // If
fl1325 = true ; 
quoteChar = ctxt.acceptQuote();
this.setKind(acceptor.lAcceptEnum_ExpectationKind(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1326: {
// Handling attribute Blocking
// Also handles alien attributes with prefix Blocking
if (fl1326){
ctxt.fail ("Duplicate attribute: Blocking");
} // If
fl1326 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBlocking(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1327: {
// Handling attribute DeadLine
// Also handles alien attributes with prefix DeadLine
if (fl1327){
ctxt.fail ("Duplicate attribute: DeadLine");
} // If
fl1327 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDeadLine(ctxt.fetchDouble());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1328: {
// Handling attribute CyclePhase
// Also handles alien attributes with prefix CyclePhase
if (fl1328){
ctxt.fail ("Duplicate attribute: CyclePhase");
} // If
fl1328 = true ; 
quoteChar = ctxt.acceptQuote();
this.setCyclePhase(acceptor.lAcceptEnum_RulePriority(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1329: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1329){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1329 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1330: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1330){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1330 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1332: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1325){
this.setKind(acceptor.ExpectationKind.aInstantaneous);
} // If
if (!fl1326){
this.setBlocking( true);
} // If
if (!fl1327){
this.setDeadLine(0.0);
} // If
fl1331 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Expectation";
  endingTag = "</Expectation>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Expectation\"");
} // If
pw.Write('\n');
if (this.getKind() != 0){
pw.Write(" Kind=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_ExpectationKind_ToString(this.getKind()));
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getBlocking()){
pw.Write(" Blocking=\"");
acceptor.unParsePcData(pw, this.getBlocking());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDeadLine() != 0){
pw.Write(" DeadLine=\"");
acceptor.unParsePcData(pw, this.getDeadLine());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getCyclePhase() != 0){
pw.Write(" CyclePhase=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_RulePriority_ToString(this.getCyclePhase()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comment
if (this.getComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comment
// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
// Unparsing Enclosed
// Testing for empty content: Condition
if (this.getCondition() != null){
pw.Write("<Condition>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getCondition());
pw.Write("</Condition>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Condition
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class DBMessage
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DBMessageController.alertChange(aLock, this);
}
private  int aMessageOrder;

public  int getMessageOrder() { return aMessageOrder;}

public  void setMessageOrder(int v) {
  aMessageOrder = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.DBMessageType aMessageType;

public  acceptor.DBMessageType getMessageType() { return aMessageType;}

public  void setMessageType(acceptor.DBMessageType v) {
  aMessageType = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMessageType_AsString()
{
  return acceptor.Enum_DBMessageType_ToString (aMessageType);
}

public  bool setMessageType_AsString( string  v)
{
 acceptor.DBMessageType  temp = acceptor.StringTo_Enum_DBMessageType(v);
if (temp >= 0){
  aMessageType = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aFields;

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
public System.Collections.ArrayList allFields()
  {
if (aFields == null){
    setAllFields( new System.Collections.ArrayList() );
} // If
    return aFields;
  }

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
private System.Collections.ArrayList getFields()
  {
    return allFields();
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection of elements which replaces 
///        Fields's current content.</param>
public void setAllFields(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
    NotifyControllers(null);
  }
public void setAllFields(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="el">a DBField to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(System.Collections.IList)"/>
public void appendFields(DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFields(Lock aLock,DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection ofDBFields to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(DBField)"/>
public void appendFields(System.Collections.IList coll)
  {
  __setDirty(true);
  allFields().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFields(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFields().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This insertion function inserts a new element in the
/// collection in Fields</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFields(int idx, DBField el)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFields(int idx, DBField el,Lock aLock)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFields(IXmlBBase el)
  {
  return ((System.Collections.IList) allFields()).IndexOf (el);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFields(int idx)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFields(int idx,Lock aLock)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFields(IXmlBBase obj)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(null);
   }
  }

public void removeFields(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Fields</summary>
/// <returns>the number of elements in Fields</returns>
public int countFields()
  {
  return allFields().Count;
  }

/// <summary>Part of the list interface for Fields
/// This function returns an element from the
/// collection in Fields based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBField getFields(int idx)
{
  return (DBField) ( allFields()[idx]);
}

private System.Collections.ArrayList aPackets;

/// <summary>Part of the list interface for Packets</summary>
/// <returns>a collection of all the elements in Packets</returns>
public System.Collections.ArrayList allPackets()
  {
if (aPackets == null){
    setAllPackets( new System.Collections.ArrayList() );
} // If
    return aPackets;
  }

/// <summary>Part of the list interface for Packets</summary>
/// <returns>a collection of all the elements in Packets</returns>
private System.Collections.ArrayList getPackets()
  {
    return allPackets();
  }

/// <summary>Part of the list interface for Packets</summary>
/// <param name="coll">a collection of elements which replaces 
///        Packets's current content.</param>
public void setAllPackets(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPackets = coll;
    NotifyControllers(null);
  }
public void setAllPackets(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aPackets = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets</summary>
/// <param name="el">a DBPacket to add to the collection in 
///           Packets</param>
/// <seealso cref="appendPackets(System.Collections.IList)"/>
public void appendPackets(DBPacket el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPackets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendPackets(Lock aLock,DBPacket el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allPackets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Packets</summary>
/// <param name="coll">a collection ofDBPackets to add to the collection in 
///           Packets</param>
/// <seealso cref="appendPackets(DBPacket)"/>
public void appendPackets(System.Collections.IList coll)
  {
  __setDirty(true);
  allPackets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendPackets(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allPackets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets
/// This insertion function inserts a new element in the
/// collection in Packets</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertPackets(int idx, DBPacket el)
  {
  __setDirty(true);
  allPackets().Insert (idx, el);
NotifyControllers(null);
  }

public void insertPackets(int idx, DBPacket el,Lock aLock)
  {
  __setDirty(true);
  allPackets().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfPackets(IXmlBBase el)
  {
  return ((System.Collections.IList) allPackets()).IndexOf (el);
  }

/// <summary>Part of the list interface for Packets
/// This deletion function removes an element from the
/// collection in Packets</summary>
/// <param name="idx">the index of the element to remove</param>
public void deletePackets(int idx)
  {
  __setDirty(true);
  allPackets().RemoveAt(idx);
NotifyControllers(null);
  }

public void deletePackets(int idx,Lock aLock)
  {
  __setDirty(true);
  allPackets().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Packets
/// This deletion function removes an element from the
/// collection in Packets
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removePackets(IXmlBBase obj)
  {
  int idx = indexOfPackets(obj);
  if (idx >= 0) { deletePackets(idx);
NotifyControllers(null);
   }
  }

public void removePackets(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfPackets(obj);
  if (idx >= 0) { deletePackets(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Packets</summary>
/// <returns>the number of elements in Packets</returns>
public int countPackets()
  {
  return allPackets().Count;
  }

/// <summary>Part of the list interface for Packets
/// This function returns an element from the
/// collection in Packets based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBPacket getPackets(int idx)
{
  return (DBPacket) ( allPackets()[idx]);
}

public DBMessage()
{
DBMessage obj = this;
aMessageOrder=(0);
aMessageType=(0);
aFields=(null);
aPackets=(null);
}

public void copyTo(DBMessage other)
{
base.copyTo(other);
other.aMessageOrder = aMessageOrder;
other.aMessageType = aMessageType;
other.aFields = aFields;
other.aPackets = aPackets;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1340;
DBField fl1342;
bool fl1353;
DBPacket fl1355;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Fields")){
ctxt.skipWhiteSpace();
fl1340 = true ; 
while (fl1340) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1340 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1342 = null;
while(ctxt.lookAheadOpeningTag ("<DBField")) {
fl1342 = acceptor.lAccept_DBField(ctxt, "</DBField>");
appendFields(fl1342);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Fields>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Packets")){
ctxt.skipWhiteSpace();
fl1353 = true ; 
while (fl1353) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1353 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1355 = null;
while(ctxt.lookAheadOpeningTag ("<DBPacket")) {
fl1355 = acceptor.lAccept_DBPacket(ctxt, "</DBPacket>");
appendPackets(fl1355);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Packets>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1366;
bool fl1367;
bool fl1368;
bool fl1369;
bool fl1370;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1366 = false ; 
fl1367 = false ; 
fl1368 = false ; 
fl1369 = false ; 
fl1370 = true ; 
while (fl1370) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1368;
} else {
indicator = 1371;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("essage")){
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 1367;
} else {
indicator = 1371;
} // If
break;
} // Case
case 'O':
{
ctxt.advance();
if (ctxt.lookAheadString("rder=")){
indicator = 1366;
} else {
indicator = 1371;
} // If
break;
} // Case
default:
indicator = 1371;
break;
} // Switch
} else {
indicator = 1371;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1369;
} else {
indicator = 1371;
} // If
break;
} // Case
default:
indicator = 1371;
break;
} // Switch
switch (indicator) {
case 1366: {
// Handling attribute MessageOrder
// Also handles alien attributes with prefix MessageOrder
if (fl1366){
ctxt.fail ("Duplicate attribute: MessageOrder");
} // If
fl1366 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMessageOrder(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1367: {
// Handling attribute MessageType
// Also handles alien attributes with prefix MessageType
if (fl1367){
ctxt.fail ("Duplicate attribute: MessageType");
} // If
fl1367 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMessageType(acceptor.lAcceptEnum_DBMessageType(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1368: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1368){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1368 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1369: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1369){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1369 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1371: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1366){
this.setMessageOrder(0);
} // If
if (!fl1367){
this.setMessageType(acceptor.DBMessageType.aEUROBALISE);
} // If
fl1370 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<DBMessage";
  endingTag = "</DBMessage>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"DBMessage\"");
} // If
pw.Write('\n');
if (this.getMessageOrder() != 0){
pw.Write(" MessageOrder=\"");
acceptor.unParsePcData(pw, this.getMessageOrder());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMessageType() != 0){
pw.Write(" MessageType=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_DBMessageType_ToString(this.getMessageType()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Fields
if (countFields() > 0){
pw.Write("<Fields>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFields(), false, "<DBField", "</DBField>");
pw.Write("</Fields>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Fields
// Unparsing Enclosed
// Testing for empty content: Packets
if (countPackets() > 0){
pw.Write("<Packets>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getPackets(), false, "<DBPacket", "</DBPacket>");
pw.Write("</Packets>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Packets
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFields(); i++) {
  l.Add(getFields(i));
}
for (int i = 0; i < countPackets(); i++) {
  l.Add(getPackets(i));
}
}

}
public partial class DBPacket
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DBPacketController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFields;

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
public System.Collections.ArrayList allFields()
  {
if (aFields == null){
    setAllFields( new System.Collections.ArrayList() );
} // If
    return aFields;
  }

/// <summary>Part of the list interface for Fields</summary>
/// <returns>a collection of all the elements in Fields</returns>
private System.Collections.ArrayList getFields()
  {
    return allFields();
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection of elements which replaces 
///        Fields's current content.</param>
public void setAllFields(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
    NotifyControllers(null);
  }
public void setAllFields(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFields = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields</summary>
/// <param name="el">a DBField to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(System.Collections.IList)"/>
public void appendFields(DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFields(Lock aLock,DBField el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFields().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Fields</summary>
/// <param name="coll">a collection ofDBFields to add to the collection in 
///           Fields</param>
/// <seealso cref="appendFields(DBField)"/>
public void appendFields(System.Collections.IList coll)
  {
  __setDirty(true);
  allFields().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFields(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFields().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This insertion function inserts a new element in the
/// collection in Fields</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFields(int idx, DBField el)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFields(int idx, DBField el,Lock aLock)
  {
  __setDirty(true);
  allFields().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFields(IXmlBBase el)
  {
  return ((System.Collections.IList) allFields()).IndexOf (el);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFields(int idx)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFields(int idx,Lock aLock)
  {
  __setDirty(true);
  allFields().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Fields
/// This deletion function removes an element from the
/// collection in Fields
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFields(IXmlBBase obj)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(null);
   }
  }

public void removeFields(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFields(obj);
  if (idx >= 0) { deleteFields(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Fields</summary>
/// <returns>the number of elements in Fields</returns>
public int countFields()
  {
  return allFields().Count;
  }

/// <summary>Part of the list interface for Fields
/// This function returns an element from the
/// collection in Fields based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public DBField getFields(int idx)
{
  return (DBField) ( allFields()[idx]);
}

public DBPacket()
{
DBPacket obj = this;
aFields=(null);
}

public void copyTo(DBPacket other)
{
base.copyTo(other);
other.aFields = aFields;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1378;
DBField fl1380;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Fields")){
ctxt.skipWhiteSpace();
fl1378 = true ; 
while (fl1378) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1378 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1380 = null;
while(ctxt.lookAheadOpeningTag ("<DBField")) {
fl1380 = acceptor.lAccept_DBField(ctxt, "</DBField>");
appendFields(fl1380);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Fields>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1391;
bool fl1392;
bool fl1393;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1391 = false ; 
fl1392 = false ; 
fl1393 = true ; 
while (fl1393) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1391;
} else {
indicator = 1394;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1392;
} else {
indicator = 1394;
} // If
break;
} // Case
default:
indicator = 1394;
break;
} // Switch
switch (indicator) {
case 1391: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1391){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1391 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1392: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1392){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1392 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1394: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1393 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<DBPacket";
  endingTag = "</DBPacket>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"DBPacket\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Fields
if (countFields() > 0){
pw.Write("<Fields>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFields(), false, "<DBField", "</DBField>");
pw.Write("</Fields>");
// No formula father defined
pw.Write('\n');
} // If
// After Testing for empty content: Fields
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFields(); i++) {
  l.Add(getFields(i));
}
}

}
public partial class DBField
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getVariable().CompareTo((String) search) == 0)return true;
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.DBFieldController.alertChange(aLock, this);
}
private   string  aVariable;

public   string  getVariable() { return aVariable;}

public  void setVariable( string  v) {
  aVariable = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public DBField()
{
DBField obj = this;
aVariable=(null);
aValue=(null);
}

public void copyTo(DBField other)
{
base.copyTo(other);
other.aVariable = aVariable;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1398;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Variable")){
ctxt.skipWhiteSpace();
fl1398 = true ; 
while (fl1398) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1398 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setVariable(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Variable>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1399;
bool fl1400;
bool fl1401;
bool fl1402;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1399 = false ; 
fl1400 = false ; 
fl1401 = false ; 
fl1402 = true ; 
while (fl1402) { // BeginLoop 
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue=")){
indicator = 1399;
} else {
indicator = 1403;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1400;
} else {
indicator = 1403;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1401;
} else {
indicator = 1403;
} // If
break;
} // Case
default:
indicator = 1403;
break;
} // Switch
switch (indicator) {
case 1399: {
// Handling attribute Value
// Also handles alien attributes with prefix Value
if (fl1399){
ctxt.fail ("Duplicate attribute: Value");
} // If
fl1399 = true ; 
quoteChar = ctxt.acceptQuote();
this.setValue((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1400: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1400){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1400 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1401: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1401){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1401 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1403: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1399){
this.setValue("");
} // If
fl1402 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<DBField";
  endingTag = "</DBField>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"DBField\"");
} // If
pw.Write('\n');
if (this.getValue() != null){
pw.Write(" Value=\"");
acceptor.unParsePcData(pw, this.getValue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Variable
if (this.getVariable() != null){
pw.Write("<Variable>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getVariable());
pw.Write("</Variable>");
// No formula father defined
pw.Write('\n');
} // If
// After Testing for empty content: Variable
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class TranslationDictionary
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TranslationDictionaryController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a Folder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(Folder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, Folder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, Folder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Folder getFolders(int idx)
{
  return (Folder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aTranslations;

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
public System.Collections.ArrayList allTranslations()
  {
if (aTranslations == null){
    setAllTranslations( new System.Collections.ArrayList() );
} // If
    return aTranslations;
  }

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
private System.Collections.ArrayList getTranslations()
  {
    return allTranslations();
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Translations's current content.</param>
public void setAllTranslations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
    NotifyControllers(null);
  }
public void setAllTranslations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="el">a Translation to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(System.Collections.IList)"/>
public void appendTranslations(Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTranslations(Lock aLock,Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection ofTranslations to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(Translation)"/>
public void appendTranslations(System.Collections.IList coll)
  {
  __setDirty(true);
  allTranslations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTranslations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTranslations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This insertion function inserts a new element in the
/// collection in Translations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTranslations(int idx, Translation el)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTranslations(int idx, Translation el,Lock aLock)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTranslations(IXmlBBase el)
  {
  return ((System.Collections.IList) allTranslations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTranslations(int idx)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTranslations(int idx,Lock aLock)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTranslations(IXmlBBase obj)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(null);
   }
  }

public void removeTranslations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Translations</summary>
/// <returns>the number of elements in Translations</returns>
public int countTranslations()
  {
  return allTranslations().Count;
  }

/// <summary>Part of the list interface for Translations
/// This function returns an element from the
/// collection in Translations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Translation getTranslations(int idx)
{
  return (Translation) ( allTranslations()[idx]);
}

public TranslationDictionary()
{
TranslationDictionary obj = this;
aFolders=(null);
aTranslations=(null);
}

public void copyTo(TranslationDictionary other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aTranslations = aTranslations;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1408;
Folder fl1410;
bool fl1421;
Translation fl1423;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1408 = true ; 
while (fl1408) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1408 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1410 = null;
while(ctxt.lookAheadOpeningTag ("<Folder")) {
fl1410 = acceptor.lAccept_Folder(ctxt, "</Folder>");
appendFolders(fl1410);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Translations")){
ctxt.skipWhiteSpace();
fl1421 = true ; 
while (fl1421) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1421 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1423 = null;
while(ctxt.lookAheadOpeningTag ("<Translation")) {
fl1423 = acceptor.lAccept_Translation(ctxt, "</Translation>");
appendTranslations(fl1423);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Translations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1434;
bool fl1435;
bool fl1436;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1434 = false ; 
fl1435 = false ; 
fl1436 = true ; 
while (fl1436) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1434;
} else {
indicator = 1437;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1435;
} else {
indicator = 1437;
} // If
break;
} // Case
default:
indicator = 1437;
break;
} // Switch
switch (indicator) {
case 1434: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1434){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1434 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1435: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1435){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1435 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1437: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1436 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<TranslationDictionary";
  endingTag = "</TranslationDictionary>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"TranslationDictionary\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<Folder", "</Folder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Translations
if (countTranslations() > 0){
pw.Write("<Translations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTranslations(), false, "<Translation", "</Translation>");
pw.Write("</Translations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Translations
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countTranslations(); i++) {
  l.Add(getTranslations(i));
}
}

}
public partial class Folder
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.FolderController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a Folder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,Folder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(Folder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, Folder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, Folder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Folder getFolders(int idx)
{
  return (Folder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aTranslations;

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
public System.Collections.ArrayList allTranslations()
  {
if (aTranslations == null){
    setAllTranslations( new System.Collections.ArrayList() );
} // If
    return aTranslations;
  }

/// <summary>Part of the list interface for Translations</summary>
/// <returns>a collection of all the elements in Translations</returns>
private System.Collections.ArrayList getTranslations()
  {
    return allTranslations();
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection of elements which replaces 
///        Translations's current content.</param>
public void setAllTranslations(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
    NotifyControllers(null);
  }
public void setAllTranslations(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTranslations = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations</summary>
/// <param name="el">a Translation to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(System.Collections.IList)"/>
public void appendTranslations(Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTranslations(Lock aLock,Translation el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTranslations().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Translations</summary>
/// <param name="coll">a collection ofTranslations to add to the collection in 
///           Translations</param>
/// <seealso cref="appendTranslations(Translation)"/>
public void appendTranslations(System.Collections.IList coll)
  {
  __setDirty(true);
  allTranslations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTranslations(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTranslations().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This insertion function inserts a new element in the
/// collection in Translations</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTranslations(int idx, Translation el)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTranslations(int idx, Translation el,Lock aLock)
  {
  __setDirty(true);
  allTranslations().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTranslations(IXmlBBase el)
  {
  return ((System.Collections.IList) allTranslations()).IndexOf (el);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTranslations(int idx)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTranslations(int idx,Lock aLock)
  {
  __setDirty(true);
  allTranslations().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Translations
/// This deletion function removes an element from the
/// collection in Translations
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTranslations(IXmlBBase obj)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(null);
   }
  }

public void removeTranslations(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTranslations(obj);
  if (idx >= 0) { deleteTranslations(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Translations</summary>
/// <returns>the number of elements in Translations</returns>
public int countTranslations()
  {
  return allTranslations().Count;
  }

/// <summary>Part of the list interface for Translations
/// This function returns an element from the
/// collection in Translations based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Translation getTranslations(int idx)
{
  return (Translation) ( allTranslations()[idx]);
}

public Folder()
{
Folder obj = this;
aFolders=(null);
aTranslations=(null);
}

public void copyTo(Folder other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aTranslations = aTranslations;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1441;
Folder fl1443;
bool fl1454;
Translation fl1456;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1441 = true ; 
while (fl1441) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1441 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1443 = null;
while(ctxt.lookAheadOpeningTag ("<Folder")) {
fl1443 = acceptor.lAccept_Folder(ctxt, "</Folder>");
appendFolders(fl1443);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Translations")){
ctxt.skipWhiteSpace();
fl1454 = true ; 
while (fl1454) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1454 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1456 = null;
while(ctxt.lookAheadOpeningTag ("<Translation")) {
fl1456 = acceptor.lAccept_Translation(ctxt, "</Translation>");
appendTranslations(fl1456);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Translations>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1467;
bool fl1468;
bool fl1469;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1467 = false ; 
fl1468 = false ; 
fl1469 = true ; 
while (fl1469) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1467;
} else {
indicator = 1470;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1468;
} else {
indicator = 1470;
} // If
break;
} // Case
default:
indicator = 1470;
break;
} // Switch
switch (indicator) {
case 1467: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1467){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1467 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1468: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1468){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1468 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1470: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1469 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Folder";
  endingTag = "</Folder>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Folder\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<Folder", "</Folder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Translations
if (countTranslations() > 0){
pw.Write("<Translations>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTranslations(), false, "<Translation", "</Translation>");
pw.Write("</Translations>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Translations
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countTranslations(); i++) {
  l.Add(getTranslations(i));
}
}

}
public partial class Translation
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
if(getObsoleteComment().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TranslationController.alertChange(aLock, this);
}
private System.Collections.ArrayList aSourceTexts;

/// <summary>Part of the list interface for SourceTexts</summary>
/// <returns>a collection of all the elements in SourceTexts</returns>
public System.Collections.ArrayList allSourceTexts()
  {
if (aSourceTexts == null){
    setAllSourceTexts( new System.Collections.ArrayList() );
} // If
    return aSourceTexts;
  }

/// <summary>Part of the list interface for SourceTexts</summary>
/// <returns>a collection of all the elements in SourceTexts</returns>
private System.Collections.ArrayList getSourceTexts()
  {
    return allSourceTexts();
  }

/// <summary>Part of the list interface for SourceTexts</summary>
/// <param name="coll">a collection of elements which replaces 
///        SourceTexts's current content.</param>
public void setAllSourceTexts(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSourceTexts = coll;
    NotifyControllers(null);
  }
public void setAllSourceTexts(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSourceTexts = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts</summary>
/// <param name="el">a SourceText to add to the collection in 
///           SourceTexts</param>
/// <seealso cref="appendSourceTexts(System.Collections.IList)"/>
public void appendSourceTexts(SourceText el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSourceTexts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSourceTexts(Lock aLock,SourceText el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSourceTexts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SourceTexts</summary>
/// <param name="coll">a collection ofSourceTexts to add to the collection in 
///           SourceTexts</param>
/// <seealso cref="appendSourceTexts(SourceText)"/>
public void appendSourceTexts(System.Collections.IList coll)
  {
  __setDirty(true);
  allSourceTexts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSourceTexts(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSourceTexts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts
/// This insertion function inserts a new element in the
/// collection in SourceTexts</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSourceTexts(int idx, SourceText el)
  {
  __setDirty(true);
  allSourceTexts().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSourceTexts(int idx, SourceText el,Lock aLock)
  {
  __setDirty(true);
  allSourceTexts().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSourceTexts(IXmlBBase el)
  {
  return ((System.Collections.IList) allSourceTexts()).IndexOf (el);
  }

/// <summary>Part of the list interface for SourceTexts
/// This deletion function removes an element from the
/// collection in SourceTexts</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSourceTexts(int idx)
  {
  __setDirty(true);
  allSourceTexts().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSourceTexts(int idx,Lock aLock)
  {
  __setDirty(true);
  allSourceTexts().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SourceTexts
/// This deletion function removes an element from the
/// collection in SourceTexts
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSourceTexts(IXmlBBase obj)
  {
  int idx = indexOfSourceTexts(obj);
  if (idx >= 0) { deleteSourceTexts(idx);
NotifyControllers(null);
   }
  }

public void removeSourceTexts(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSourceTexts(obj);
  if (idx >= 0) { deleteSourceTexts(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SourceTexts</summary>
/// <returns>the number of elements in SourceTexts</returns>
public int countSourceTexts()
  {
  return allSourceTexts().Count;
  }

/// <summary>Part of the list interface for SourceTexts
/// This function returns an element from the
/// collection in SourceTexts based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SourceText getSourceTexts(int idx)
{
  return (SourceText) ( allSourceTexts()[idx]);
}

private   string  aObsoleteComment;

public   string  getObsoleteComment() { return aObsoleteComment;}

public  void setObsoleteComment( string  v) {
  aObsoleteComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aImplemented;

public  bool getImplemented() { return aImplemented;}

public  void setImplemented(bool v) {
  aImplemented = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aSubSteps;

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
public System.Collections.ArrayList allSubSteps()
  {
if (aSubSteps == null){
    setAllSubSteps( new System.Collections.ArrayList() );
} // If
    return aSubSteps;
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>a collection of all the elements in SubSteps</returns>
private System.Collections.ArrayList getSubSteps()
  {
    return allSubSteps();
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSteps's current content.</param>
public void setAllSubSteps(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
    NotifyControllers(null);
  }
public void setAllSubSteps(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSteps = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="el">a SubStep to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(System.Collections.IList)"/>
public void appendSubSteps(SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSteps(Lock aLock,SubStep el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSteps().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSteps</summary>
/// <param name="coll">a collection ofSubSteps to add to the collection in 
///           SubSteps</param>
/// <seealso cref="appendSubSteps(SubStep)"/>
public void appendSubSteps(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSteps(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This insertion function inserts a new element in the
/// collection in SubSteps</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSteps(int idx, SubStep el)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSteps(int idx, SubStep el,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSteps(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSteps()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSteps(int idx)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSteps(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSteps().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSteps
/// This deletion function removes an element from the
/// collection in SubSteps
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSteps(IXmlBBase obj)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(null);
   }
  }

public void removeSubSteps(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSteps(obj);
  if (idx >= 0) { deleteSubSteps(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSteps</summary>
/// <returns>the number of elements in SubSteps</returns>
public int countSubSteps()
  {
  return allSubSteps().Count;
  }

/// <summary>Part of the list interface for SubSteps
/// This function returns an element from the
/// collection in SubSteps based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SubStep getSubSteps(int idx)
{
  return (SubStep) ( allSubSteps()[idx]);
}

public Translation()
{
Translation obj = this;
aSourceTexts=(null);
aObsoleteComment=(null);
aImplemented=(false);
aSubSteps=(null);
}

public void copyTo(Translation other)
{
base.copyTo(other);
other.aSourceTexts = aSourceTexts;
other.aObsoleteComment = aObsoleteComment;
other.aImplemented = aImplemented;
other.aSubSteps = aSubSteps;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1474;
SourceText fl1476;
bool fl1487;
SubStep fl1489;
bool fl1500;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SourceTexts")){
ctxt.skipWhiteSpace();
fl1474 = true ; 
while (fl1474) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1474 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1476 = null;
while(ctxt.lookAheadOpeningTag ("<SourceText")) {
fl1476 = acceptor.lAccept_SourceText(ctxt, "</SourceText>");
appendSourceTexts(fl1476);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SourceTexts>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<SubSteps")){
ctxt.skipWhiteSpace();
fl1487 = true ; 
while (fl1487) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1487 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1489 = null;
while(ctxt.lookAheadOpeningTag ("<SubStep")) {
fl1489 = acceptor.lAccept_SubStep(ctxt, "</SubStep>");
appendSubSteps(fl1489);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSteps>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comment")){
ctxt.skipWhiteSpace();
fl1500 = true ; 
while (fl1500) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1500 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setObsoleteComment(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comment>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1501;
bool fl1502;
bool fl1503;
bool fl1504;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1501 = false ; 
fl1502 = false ; 
fl1503 = false ; 
fl1504 = true ; 
while (fl1504) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1502;
} else {
indicator = 1505;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented=")){
indicator = 1501;
} else {
indicator = 1505;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1503;
} else {
indicator = 1505;
} // If
break;
} // Case
default:
indicator = 1505;
break;
} // Switch
switch (indicator) {
case 1501: {
// Handling attribute Implemented
// Also handles alien attributes with prefix Implemented
if (fl1501){
ctxt.fail ("Duplicate attribute: Implemented");
} // If
fl1501 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplemented(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1502: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1502){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1502 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1503: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1503){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1503 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1505: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1501){
this.setImplemented( false);
} // If
fl1504 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Translation";
  endingTag = "</Translation>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Translation\"");
} // If
pw.Write('\n');
if (this.getImplemented()){
pw.Write(" Implemented=\"");
acceptor.unParsePcData(pw, this.getImplemented());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: SourceTexts
if (countSourceTexts() > 0){
pw.Write("<SourceTexts>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSourceTexts(), false, "<SourceText", "</SourceText>");
pw.Write("</SourceTexts>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SourceTexts
// Unparsing Enclosed
// Testing for empty content: SubSteps
if (countSubSteps() > 0){
pw.Write("<SubSteps>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSteps(), false, "<SubStep", "</SubStep>");
pw.Write("</SubSteps>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: SubSteps
// Unparsing Enclosed
// Testing for empty content: ObsoleteComment
if (this.getObsoleteComment() != null){
pw.Write("<Comment>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getObsoleteComment());
pw.Write("</Comment>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: ObsoleteComment
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countSourceTexts(); i++) {
  l.Add(getSourceTexts(i));
}
for (int i = 0; i < countSubSteps(); i++) {
  l.Add(getSubSteps(i));
}
}

}
public partial class SourceText
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SourceTextController.alertChange(aLock, this);
}
private System.Collections.ArrayList aComments;

/// <summary>Part of the list interface for Comments</summary>
/// <returns>a collection of all the elements in Comments</returns>
public System.Collections.ArrayList allComments()
  {
if (aComments == null){
    setAllComments( new System.Collections.ArrayList() );
} // If
    return aComments;
  }

/// <summary>Part of the list interface for Comments</summary>
/// <returns>a collection of all the elements in Comments</returns>
private System.Collections.ArrayList getComments()
  {
    return allComments();
  }

/// <summary>Part of the list interface for Comments</summary>
/// <param name="coll">a collection of elements which replaces 
///        Comments's current content.</param>
public void setAllComments(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aComments = coll;
    NotifyControllers(null);
  }
public void setAllComments(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aComments = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Comments</summary>
/// <param name="el">a SourceTextComment to add to the collection in 
///           Comments</param>
/// <seealso cref="appendComments(System.Collections.IList)"/>
public void appendComments(SourceTextComment el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allComments().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendComments(Lock aLock,SourceTextComment el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allComments().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Comments</summary>
/// <param name="coll">a collection ofSourceTextComments to add to the collection in 
///           Comments</param>
/// <seealso cref="appendComments(SourceTextComment)"/>
public void appendComments(System.Collections.IList coll)
  {
  __setDirty(true);
  allComments().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendComments(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allComments().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Comments
/// This insertion function inserts a new element in the
/// collection in Comments</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertComments(int idx, SourceTextComment el)
  {
  __setDirty(true);
  allComments().Insert (idx, el);
NotifyControllers(null);
  }

public void insertComments(int idx, SourceTextComment el,Lock aLock)
  {
  __setDirty(true);
  allComments().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Comments
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfComments(IXmlBBase el)
  {
  return ((System.Collections.IList) allComments()).IndexOf (el);
  }

/// <summary>Part of the list interface for Comments
/// This deletion function removes an element from the
/// collection in Comments</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteComments(int idx)
  {
  __setDirty(true);
  allComments().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteComments(int idx,Lock aLock)
  {
  __setDirty(true);
  allComments().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Comments
/// This deletion function removes an element from the
/// collection in Comments
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeComments(IXmlBBase obj)
  {
  int idx = indexOfComments(obj);
  if (idx >= 0) { deleteComments(idx);
NotifyControllers(null);
   }
  }

public void removeComments(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfComments(obj);
  if (idx >= 0) { deleteComments(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Comments</summary>
/// <returns>the number of elements in Comments</returns>
public int countComments()
  {
  return allComments().Count;
  }

/// <summary>Part of the list interface for Comments
/// This function returns an element from the
/// collection in Comments based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public SourceTextComment getComments(int idx)
{
  return (SourceTextComment) ( allComments()[idx]);
}

public SourceText()
{
SourceText obj = this;
aComments=(null);
}

public void copyTo(SourceText other)
{
base.copyTo(other);
other.aComments = aComments;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1510;
SourceTextComment fl1512;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Comments")){
ctxt.skipWhiteSpace();
fl1510 = true ; 
while (fl1510) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1510 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1512 = null;
while(ctxt.lookAheadOpeningTag ("<SourceTextComment")) {
fl1512 = acceptor.lAccept_SourceTextComment(ctxt, "</SourceTextComment>");
appendComments(fl1512);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Comments>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1523;
bool fl1524;
bool fl1525;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1523 = false ; 
fl1524 = false ; 
fl1525 = true ; 
while (fl1525) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1523;
} else {
indicator = 1526;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1524;
} else {
indicator = 1526;
} // If
break;
} // Case
default:
indicator = 1526;
break;
} // Switch
switch (indicator) {
case 1523: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1523){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1523 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1524: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1524){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1524 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1526: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1525 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SourceText";
  endingTag = "</SourceText>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SourceText\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Comments
if (countComments() > 0){
pw.Write("<Comments>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getComments(), false, "<SourceTextComment", "</SourceTextComment>");
pw.Write("</Comments>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Comments
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countComments(); i++) {
  l.Add(getComments(i));
}
}

}
public partial class SourceTextComment
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SourceTextCommentController.alertChange(aLock, this);
}
public SourceTextComment()
{
SourceTextComment obj = this;
}

public void copyTo(SourceTextComment other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1530;
bool fl1531;
bool fl1532;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1530 = false ; 
fl1531 = false ; 
fl1532 = true ; 
while (fl1532) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1530;
} else {
indicator = 1533;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1531;
} else {
indicator = 1533;
} // If
break;
} // Case
default:
indicator = 1533;
break;
} // Switch
switch (indicator) {
case 1530: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1530){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1530 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1531: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1531){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1531 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1533: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1532 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<SourceTextComment";
  endingTag = "</SourceTextComment>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"SourceTextComment\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class ShortcutDictionary
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ShortcutDictionaryController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a ShortcutFolder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofShortcutFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(ShortcutFolder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, ShortcutFolder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, ShortcutFolder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ShortcutFolder getFolders(int idx)
{
  return (ShortcutFolder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aShortcuts;

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
public System.Collections.ArrayList allShortcuts()
  {
if (aShortcuts == null){
    setAllShortcuts( new System.Collections.ArrayList() );
} // If
    return aShortcuts;
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
private System.Collections.ArrayList getShortcuts()
  {
    return allShortcuts();
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection of elements which replaces 
///        Shortcuts's current content.</param>
public void setAllShortcuts(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
    NotifyControllers(null);
  }
public void setAllShortcuts(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="el">a Shortcut to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(System.Collections.IList)"/>
public void appendShortcuts(Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendShortcuts(Lock aLock,Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection ofShortcuts to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(Shortcut)"/>
public void appendShortcuts(System.Collections.IList coll)
  {
  __setDirty(true);
  allShortcuts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendShortcuts(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This insertion function inserts a new element in the
/// collection in Shortcuts</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertShortcuts(int idx, Shortcut el)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(null);
  }

public void insertShortcuts(int idx, Shortcut el,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfShortcuts(IXmlBBase el)
  {
  return ((System.Collections.IList) allShortcuts()).IndexOf (el);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteShortcuts(int idx)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteShortcuts(int idx,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeShortcuts(IXmlBBase obj)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(null);
   }
  }

public void removeShortcuts(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>the number of elements in Shortcuts</returns>
public int countShortcuts()
  {
  return allShortcuts().Count;
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns an element from the
/// collection in Shortcuts based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Shortcut getShortcuts(int idx)
{
  return (Shortcut) ( allShortcuts()[idx]);
}

public ShortcutDictionary()
{
ShortcutDictionary obj = this;
aFolders=(null);
aShortcuts=(null);
}

public void copyTo(ShortcutDictionary other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aShortcuts = aShortcuts;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1537;
ShortcutFolder fl1539;
bool fl1550;
Shortcut fl1552;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1537 = true ; 
while (fl1537) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1537 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1539 = null;
while(ctxt.lookAheadOpeningTag ("<ShortcutFolder")) {
fl1539 = acceptor.lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
appendFolders(fl1539);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Shortcuts")){
ctxt.skipWhiteSpace();
fl1550 = true ; 
while (fl1550) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1550 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1552 = null;
while(ctxt.lookAheadOpeningTag ("<Shortcut")) {
fl1552 = acceptor.lAccept_Shortcut(ctxt, "</Shortcut>");
appendShortcuts(fl1552);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Shortcuts>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1563;
bool fl1564;
bool fl1565;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1563 = false ; 
fl1564 = false ; 
fl1565 = true ; 
while (fl1565) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1563;
} else {
indicator = 1566;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1564;
} else {
indicator = 1566;
} // If
break;
} // Case
default:
indicator = 1566;
break;
} // Switch
switch (indicator) {
case 1563: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1563){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1563 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1564: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1564){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1564 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1566: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1565 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ShortcutDictionary";
  endingTag = "</ShortcutDictionary>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ShortcutDictionary\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<ShortcutFolder", "</ShortcutFolder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Shortcuts
if (countShortcuts() > 0){
pw.Write("<Shortcuts>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getShortcuts(), false, "<Shortcut", "</Shortcut>");
pw.Write("</Shortcuts>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Shortcuts
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countShortcuts(); i++) {
  l.Add(getShortcuts(i));
}
}

}
public partial class ShortcutFolder
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ShortcutFolderController.alertChange(aLock, this);
}
private System.Collections.ArrayList aFolders;

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
public System.Collections.ArrayList allFolders()
  {
if (aFolders == null){
    setAllFolders( new System.Collections.ArrayList() );
} // If
    return aFolders;
  }

/// <summary>Part of the list interface for Folders</summary>
/// <returns>a collection of all the elements in Folders</returns>
private System.Collections.ArrayList getFolders()
  {
    return allFolders();
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection of elements which replaces 
///        Folders's current content.</param>
public void setAllFolders(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
    NotifyControllers(null);
  }
public void setAllFolders(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aFolders = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders</summary>
/// <param name="el">a ShortcutFolder to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(System.Collections.IList)"/>
public void appendFolders(ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendFolders(Lock aLock,ShortcutFolder el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allFolders().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Folders</summary>
/// <param name="coll">a collection ofShortcutFolders to add to the collection in 
///           Folders</param>
/// <seealso cref="appendFolders(ShortcutFolder)"/>
public void appendFolders(System.Collections.IList coll)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendFolders(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allFolders().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This insertion function inserts a new element in the
/// collection in Folders</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertFolders(int idx, ShortcutFolder el)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(null);
  }

public void insertFolders(int idx, ShortcutFolder el,Lock aLock)
  {
  __setDirty(true);
  allFolders().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfFolders(IXmlBBase el)
  {
  return ((System.Collections.IList) allFolders()).IndexOf (el);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteFolders(int idx)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteFolders(int idx,Lock aLock)
  {
  __setDirty(true);
  allFolders().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Folders
/// This deletion function removes an element from the
/// collection in Folders
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeFolders(IXmlBBase obj)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(null);
   }
  }

public void removeFolders(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfFolders(obj);
  if (idx >= 0) { deleteFolders(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Folders</summary>
/// <returns>the number of elements in Folders</returns>
public int countFolders()
  {
  return allFolders().Count;
  }

/// <summary>Part of the list interface for Folders
/// This function returns an element from the
/// collection in Folders based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ShortcutFolder getFolders(int idx)
{
  return (ShortcutFolder) ( allFolders()[idx]);
}

private System.Collections.ArrayList aShortcuts;

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
public System.Collections.ArrayList allShortcuts()
  {
if (aShortcuts == null){
    setAllShortcuts( new System.Collections.ArrayList() );
} // If
    return aShortcuts;
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>a collection of all the elements in Shortcuts</returns>
private System.Collections.ArrayList getShortcuts()
  {
    return allShortcuts();
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection of elements which replaces 
///        Shortcuts's current content.</param>
public void setAllShortcuts(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
    NotifyControllers(null);
  }
public void setAllShortcuts(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aShortcuts = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="el">a Shortcut to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(System.Collections.IList)"/>
public void appendShortcuts(Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendShortcuts(Lock aLock,Shortcut el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allShortcuts().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Shortcuts</summary>
/// <param name="coll">a collection ofShortcuts to add to the collection in 
///           Shortcuts</param>
/// <seealso cref="appendShortcuts(Shortcut)"/>
public void appendShortcuts(System.Collections.IList coll)
  {
  __setDirty(true);
  allShortcuts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendShortcuts(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This insertion function inserts a new element in the
/// collection in Shortcuts</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertShortcuts(int idx, Shortcut el)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(null);
  }

public void insertShortcuts(int idx, Shortcut el,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfShortcuts(IXmlBBase el)
  {
  return ((System.Collections.IList) allShortcuts()).IndexOf (el);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteShortcuts(int idx)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteShortcuts(int idx,Lock aLock)
  {
  __setDirty(true);
  allShortcuts().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Shortcuts
/// This deletion function removes an element from the
/// collection in Shortcuts
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeShortcuts(IXmlBBase obj)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(null);
   }
  }

public void removeShortcuts(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfShortcuts(obj);
  if (idx >= 0) { deleteShortcuts(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Shortcuts</summary>
/// <returns>the number of elements in Shortcuts</returns>
public int countShortcuts()
  {
  return allShortcuts().Count;
  }

/// <summary>Part of the list interface for Shortcuts
/// This function returns an element from the
/// collection in Shortcuts based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Shortcut getShortcuts(int idx)
{
  return (Shortcut) ( allShortcuts()[idx]);
}

public ShortcutFolder()
{
ShortcutFolder obj = this;
aFolders=(null);
aShortcuts=(null);
}

public void copyTo(ShortcutFolder other)
{
base.copyTo(other);
other.aFolders = aFolders;
other.aShortcuts = aShortcuts;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1570;
ShortcutFolder fl1572;
bool fl1583;
Shortcut fl1585;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Folders")){
ctxt.skipWhiteSpace();
fl1570 = true ; 
while (fl1570) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1570 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1572 = null;
while(ctxt.lookAheadOpeningTag ("<ShortcutFolder")) {
fl1572 = acceptor.lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
appendFolders(fl1572);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Folders>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Shortcuts")){
ctxt.skipWhiteSpace();
fl1583 = true ; 
while (fl1583) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1583 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1585 = null;
while(ctxt.lookAheadOpeningTag ("<Shortcut")) {
fl1585 = acceptor.lAccept_Shortcut(ctxt, "</Shortcut>");
appendShortcuts(fl1585);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Shortcuts>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1596;
bool fl1597;
bool fl1598;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1596 = false ; 
fl1597 = false ; 
fl1598 = true ; 
while (fl1598) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1596;
} else {
indicator = 1599;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1597;
} else {
indicator = 1599;
} // If
break;
} // Case
default:
indicator = 1599;
break;
} // Switch
switch (indicator) {
case 1596: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1596){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1596 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1597: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1597){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1597 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1599: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1598 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ShortcutFolder";
  endingTag = "</ShortcutFolder>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ShortcutFolder\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: Folders
if (countFolders() > 0){
pw.Write("<Folders>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getFolders(), false, "<ShortcutFolder", "</ShortcutFolder>");
pw.Write("</Folders>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Folders
// Unparsing Enclosed
// Testing for empty content: Shortcuts
if (countShortcuts() > 0){
pw.Write("<Shortcuts>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getShortcuts(), false, "<Shortcut", "</Shortcut>");
pw.Write("</Shortcuts>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Shortcuts
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countFolders(); i++) {
  l.Add(getFolders(i));
}
for (int i = 0; i < countShortcuts(); i++) {
  l.Add(getShortcuts(i));
}
}

}
public partial class Shortcut
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getShortcutName().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ShortcutController.alertChange(aLock, this);
}
private   string  aShortcutName;

public   string  getShortcutName() { return aShortcutName;}

public  void setShortcutName( string  v) {
  aShortcutName = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Shortcut()
{
Shortcut obj = this;
aShortcutName=(null);
}

public void copyTo(Shortcut other)
{
base.copyTo(other);
other.aShortcutName = aShortcutName;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1603;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<ShortcutName")){
ctxt.skipWhiteSpace();
fl1603 = true ; 
while (fl1603) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1603 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setShortcutName(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</ShortcutName>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1604;
bool fl1605;
bool fl1606;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1604 = false ; 
fl1605 = false ; 
fl1606 = true ; 
while (fl1606) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1604;
} else {
indicator = 1607;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1605;
} else {
indicator = 1607;
} // If
break;
} // Case
default:
indicator = 1607;
break;
} // Switch
switch (indicator) {
case 1604: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1604){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1604 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1605: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1605){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1605 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1607: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1606 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Shortcut";
  endingTag = "</Shortcut>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Shortcut\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
// Testing for empty content: ShortcutName
if (this.getShortcutName() != null){
pw.Write("<ShortcutName>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getShortcutName());
pw.Write("</ShortcutName>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: ShortcutName
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class RequirementSet
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RequirementSetController.alertChange(aLock, this);
}
private System.Collections.ArrayList aDependancies;

/// <summary>Part of the list interface for Dependancies</summary>
/// <returns>a collection of all the elements in Dependancies</returns>
public System.Collections.ArrayList allDependancies()
  {
if (aDependancies == null){
    setAllDependancies( new System.Collections.ArrayList() );
} // If
    return aDependancies;
  }

/// <summary>Part of the list interface for Dependancies</summary>
/// <returns>a collection of all the elements in Dependancies</returns>
private System.Collections.ArrayList getDependancies()
  {
    return allDependancies();
  }

/// <summary>Part of the list interface for Dependancies</summary>
/// <param name="coll">a collection of elements which replaces 
///        Dependancies's current content.</param>
public void setAllDependancies(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aDependancies = coll;
    NotifyControllers(null);
  }
public void setAllDependancies(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aDependancies = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Dependancies</summary>
/// <param name="el">a RequirementSetDependancy to add to the collection in 
///           Dependancies</param>
/// <seealso cref="appendDependancies(System.Collections.IList)"/>
public void appendDependancies(RequirementSetDependancy el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allDependancies().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendDependancies(Lock aLock,RequirementSetDependancy el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allDependancies().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Dependancies</summary>
/// <param name="coll">a collection ofRequirementSetDependancys to add to the collection in 
///           Dependancies</param>
/// <seealso cref="appendDependancies(RequirementSetDependancy)"/>
public void appendDependancies(System.Collections.IList coll)
  {
  __setDirty(true);
  allDependancies().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendDependancies(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allDependancies().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Dependancies
/// This insertion function inserts a new element in the
/// collection in Dependancies</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertDependancies(int idx, RequirementSetDependancy el)
  {
  __setDirty(true);
  allDependancies().Insert (idx, el);
NotifyControllers(null);
  }

public void insertDependancies(int idx, RequirementSetDependancy el,Lock aLock)
  {
  __setDirty(true);
  allDependancies().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Dependancies
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfDependancies(IXmlBBase el)
  {
  return ((System.Collections.IList) allDependancies()).IndexOf (el);
  }

/// <summary>Part of the list interface for Dependancies
/// This deletion function removes an element from the
/// collection in Dependancies</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteDependancies(int idx)
  {
  __setDirty(true);
  allDependancies().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteDependancies(int idx,Lock aLock)
  {
  __setDirty(true);
  allDependancies().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Dependancies
/// This deletion function removes an element from the
/// collection in Dependancies
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeDependancies(IXmlBBase obj)
  {
  int idx = indexOfDependancies(obj);
  if (idx >= 0) { deleteDependancies(idx);
NotifyControllers(null);
   }
  }

public void removeDependancies(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfDependancies(obj);
  if (idx >= 0) { deleteDependancies(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Dependancies</summary>
/// <returns>the number of elements in Dependancies</returns>
public int countDependancies()
  {
  return allDependancies().Count;
  }

/// <summary>Part of the list interface for Dependancies
/// This function returns an element from the
/// collection in Dependancies based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RequirementSetDependancy getDependancies(int idx)
{
  return (RequirementSetDependancy) ( allDependancies()[idx]);
}

private System.Collections.ArrayList aSubSets;

/// <summary>Part of the list interface for SubSets</summary>
/// <returns>a collection of all the elements in SubSets</returns>
public System.Collections.ArrayList allSubSets()
  {
if (aSubSets == null){
    setAllSubSets( new System.Collections.ArrayList() );
} // If
    return aSubSets;
  }

/// <summary>Part of the list interface for SubSets</summary>
/// <returns>a collection of all the elements in SubSets</returns>
private System.Collections.ArrayList getSubSets()
  {
    return allSubSets();
  }

/// <summary>Part of the list interface for SubSets</summary>
/// <param name="coll">a collection of elements which replaces 
///        SubSets's current content.</param>
public void setAllSubSets(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSets = coll;
    NotifyControllers(null);
  }
public void setAllSubSets(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSubSets = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSets</summary>
/// <param name="el">a RequirementSet to add to the collection in 
///           SubSets</param>
/// <seealso cref="appendSubSets(System.Collections.IList)"/>
public void appendSubSets(RequirementSet el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSubSets(Lock aLock,RequirementSet el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSubSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for SubSets</summary>
/// <param name="coll">a collection ofRequirementSets to add to the collection in 
///           SubSets</param>
/// <seealso cref="appendSubSets(RequirementSet)"/>
public void appendSubSets(System.Collections.IList coll)
  {
  __setDirty(true);
  allSubSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSubSets(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSubSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSets
/// This insertion function inserts a new element in the
/// collection in SubSets</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSubSets(int idx, RequirementSet el)
  {
  __setDirty(true);
  allSubSets().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSubSets(int idx, RequirementSet el,Lock aLock)
  {
  __setDirty(true);
  allSubSets().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSets
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSubSets(IXmlBBase el)
  {
  return ((System.Collections.IList) allSubSets()).IndexOf (el);
  }

/// <summary>Part of the list interface for SubSets
/// This deletion function removes an element from the
/// collection in SubSets</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSubSets(int idx)
  {
  __setDirty(true);
  allSubSets().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSubSets(int idx,Lock aLock)
  {
  __setDirty(true);
  allSubSets().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for SubSets
/// This deletion function removes an element from the
/// collection in SubSets
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSubSets(IXmlBBase obj)
  {
  int idx = indexOfSubSets(obj);
  if (idx >= 0) { deleteSubSets(idx);
NotifyControllers(null);
   }
  }

public void removeSubSets(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSubSets(obj);
  if (idx >= 0) { deleteSubSets(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for SubSets</summary>
/// <returns>the number of elements in SubSets</returns>
public int countSubSets()
  {
  return allSubSets().Count;
  }

/// <summary>Part of the list interface for SubSets
/// This function returns an element from the
/// collection in SubSets based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RequirementSet getSubSets(int idx)
{
  return (RequirementSet) ( allSubSets()[idx]);
}

private  int aWidth;

public  int getWidth() { return aWidth;}

public  void setWidth(int v) {
  aWidth = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aHeight;

public  int getHeight() { return aHeight;}

public  void setHeight(int v) {
  aHeight = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aX;

public  int getX() { return aX;}

public  void setX(int v) {
  aX = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aY;

public  int getY() { return aY;}

public  void setY(int v) {
  aY = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aRecursiveSelection;

public  bool getRecursiveSelection() { return aRecursiveSelection;}

public  void setRecursiveSelection(bool v) {
  aRecursiveSelection = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.SPEC_IMPLEMENTED_ENUM aObsoleteRequirementsStatus;

public  acceptor.SPEC_IMPLEMENTED_ENUM getObsoleteRequirementsStatus() { return aObsoleteRequirementsStatus;}

public  void setObsoleteRequirementsStatus(acceptor.SPEC_IMPLEMENTED_ENUM v) {
  aObsoleteRequirementsStatus = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getObsoleteRequirementsStatus_AsString()
{
  return acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString (aObsoleteRequirementsStatus);
}

public  bool setObsoleteRequirementsStatus_AsString( string  v)
{
 acceptor.SPEC_IMPLEMENTED_ENUM  temp = acceptor.StringTo_Enum_SPEC_IMPLEMENTED_ENUM(v);
if (temp >= 0){
  aObsoleteRequirementsStatus = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  bool aDefault;

public  bool getDefault() { return aDefault;}

public  void setDefault(bool v) {
  aDefault = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aPinned;

public  bool getPinned() { return aPinned;}

public  void setPinned(bool v) {
  aPinned = v;
  __setDirty(true);
  NotifyControllers(null);
}


public RequirementSet()
{
RequirementSet obj = this;
aDependancies=(null);
aSubSets=(null);
aWidth=(0);
aHeight=(0);
aX=(0);
aY=(0);
aRecursiveSelection=(false);
aObsoleteRequirementsStatus=(0);
aDefault=(false);
aPinned=(false);
}

public void copyTo(RequirementSet other)
{
base.copyTo(other);
other.aDependancies = aDependancies;
other.aSubSets = aSubSets;
other.aWidth = aWidth;
other.aHeight = aHeight;
other.aX = aX;
other.aY = aY;
other.aRecursiveSelection = aRecursiveSelection;
other.aObsoleteRequirementsStatus = aObsoleteRequirementsStatus;
other.aDefault = aDefault;
other.aPinned = aPinned;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1611;
RequirementSetDependancy fl1613;
bool fl1624;
RequirementSet fl1626;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<Dependancies");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl1611 = true ; 
while (fl1611) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1611 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1613 = null;
while(ctxt.lookAheadOpeningTag ("<RequirementSetDependancy")) {
fl1613 = acceptor.lAccept_RequirementSetDependancy(ctxt, "</RequirementSetDependancy>");
appendDependancies(fl1613);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Dependancies>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<SubSets");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl1624 = true ; 
while (fl1624) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1624 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1626 = null;
while(ctxt.lookAheadOpeningTag ("<RequirementSet")) {
fl1626 = acceptor.lAccept_RequirementSet(ctxt, "</RequirementSet>");
appendSubSets(fl1626);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</SubSets>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1637;
bool fl1638;
bool fl1639;
bool fl1640;
bool fl1641;
bool fl1642;
bool fl1643;
bool fl1644;
bool fl1645;
bool fl1646;
bool fl1647;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1637 = false ; 
fl1638 = false ; 
fl1639 = false ; 
fl1640 = false ; 
fl1641 = false ; 
fl1642 = false ; 
fl1643 = false ; 
fl1644 = false ; 
fl1645 = false ; 
fl1646 = false ; 
fl1647 = true ; 
while (fl1647) { // BeginLoop 
switch (ctxt.current()) {
case 'Y':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1638;
} else {
indicator = 1648;
} // If
break;
} // Case
case 'X':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1637;
} else {
indicator = 1648;
} // If
break;
} // Case
case 'W':
{
ctxt.advance();
if (ctxt.lookAheadString("idth=")){
indicator = 1639;
} else {
indicator = 1648;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead1('e')){
switch (ctxt.current()) {
case 'q':
{
ctxt.advance();
if (ctxt.lookAheadString("uirementsStatus=")){
indicator = 1642;
} else {
indicator = 1648;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("ursiveSelection=")){
indicator = 1641;
} else {
indicator = 1648;
} // If
break;
} // Case
default:
indicator = 1648;
break;
} // Switch
} else {
indicator = 1648;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("inned=")){
indicator = 1644;
} else {
indicator = 1648;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1645;
} else {
indicator = 1648;
} // If
break;
} // Case
case 'H':
{
ctxt.advance();
if (ctxt.lookAheadString("eight=")){
indicator = 1640;
} else {
indicator = 1648;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1646;
} else {
indicator = 1648;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("efault=")){
indicator = 1643;
} else {
indicator = 1648;
} // If
break;
} // Case
default:
indicator = 1648;
break;
} // Switch
switch (indicator) {
case 1637: {
// Handling attribute X
// Also handles alien attributes with prefix X
if (fl1637){
ctxt.fail ("Duplicate attribute: X");
} // If
fl1637 = true ; 
quoteChar = ctxt.acceptQuote();
this.setX(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1638: {
// Handling attribute Y
// Also handles alien attributes with prefix Y
if (fl1638){
ctxt.fail ("Duplicate attribute: Y");
} // If
fl1638 = true ; 
quoteChar = ctxt.acceptQuote();
this.setY(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1639: {
// Handling attribute Width
// Also handles alien attributes with prefix Width
if (fl1639){
ctxt.fail ("Duplicate attribute: Width");
} // If
fl1639 = true ; 
quoteChar = ctxt.acceptQuote();
this.setWidth(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1640: {
// Handling attribute Height
// Also handles alien attributes with prefix Height
if (fl1640){
ctxt.fail ("Duplicate attribute: Height");
} // If
fl1640 = true ; 
quoteChar = ctxt.acceptQuote();
this.setHeight(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1641: {
// Handling attribute RecursiveSelection
// Also handles alien attributes with prefix RecursiveSelection
if (fl1641){
ctxt.fail ("Duplicate attribute: RecursiveSelection");
} // If
fl1641 = true ; 
quoteChar = ctxt.acceptQuote();
this.setRecursiveSelection(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1642: {
// Handling attribute RequirementsStatus
// Also handles alien attributes with prefix RequirementsStatus
if (fl1642){
ctxt.fail ("Duplicate attribute: RequirementsStatus");
} // If
fl1642 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteRequirementsStatus(acceptor.lAcceptEnum_SPEC_IMPLEMENTED_ENUM(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1643: {
// Handling attribute Default
// Also handles alien attributes with prefix Default
if (fl1643){
ctxt.fail ("Duplicate attribute: Default");
} // If
fl1643 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDefault(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1644: {
// Handling attribute Pinned
// Also handles alien attributes with prefix Pinned
if (fl1644){
ctxt.fail ("Duplicate attribute: Pinned");
} // If
fl1644 = true ; 
quoteChar = ctxt.acceptQuote();
this.setPinned(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1645: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1645){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1645 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1646: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1646){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1646 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1648: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1637){
this.setX(0);
} // If
if (!fl1638){
this.setY(0);
} // If
if (!fl1639){
this.setWidth(0);
} // If
if (!fl1640){
this.setHeight(0);
} // If
if (!fl1641){
this.setRecursiveSelection( false);
} // If
if (!fl1643){
this.setDefault( false);
} // If
if (!fl1644){
this.setPinned( false);
} // If
fl1647 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RequirementSet";
  endingTag = "</RequirementSet>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RequirementSet\"");
} // If
pw.Write('\n');
if (this.getX() != 0){
pw.Write(" X=\"");
acceptor.unParsePcData(pw, this.getX());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getY() != 0){
pw.Write(" Y=\"");
acceptor.unParsePcData(pw, this.getY());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getWidth() != 0){
pw.Write(" Width=\"");
acceptor.unParsePcData(pw, this.getWidth());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getHeight() != 0){
pw.Write(" Height=\"");
acceptor.unParsePcData(pw, this.getHeight());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getRecursiveSelection()){
pw.Write(" RecursiveSelection=\"");
acceptor.unParsePcData(pw, this.getRecursiveSelection());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteRequirementsStatus() != 0){
pw.Write(" RequirementsStatus=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString(this.getObsoleteRequirementsStatus()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getDefault()){
pw.Write(" Default=\"");
acceptor.unParsePcData(pw, this.getDefault());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getPinned()){
pw.Write(" Pinned=\"");
acceptor.unParsePcData(pw, this.getPinned());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Enclosed
pw.Write("<Dependancies>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getDependancies(), false, "<RequirementSetDependancy", "</RequirementSetDependancy>");
pw.Write("</Dependancies>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<SubSets>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSubSets(), false, "<RequirementSet", "</RequirementSet>");
pw.Write("</SubSets>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countDependancies(); i++) {
  l.Add(getDependancies(i));
}
for (int i = 0; i < countSubSets(); i++) {
  l.Add(getSubSets(i));
}
}

}
public partial class RequirementSetDependancy
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getTarget().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RequirementSetDependancyController.alertChange(aLock, this);
}
private   string  aTarget;

public   string  getTarget() { return aTarget;}

public  void setTarget( string  v) {
  aTarget = v;
  __setDirty(true);
  NotifyControllers(null);
}


public RequirementSetDependancy()
{
RequirementSetDependancy obj = this;
aTarget=(null);
}

public void copyTo(RequirementSetDependancy other)
{
base.copyTo(other);
other.aTarget = aTarget;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1661;
bool fl1662;
bool fl1663;
bool fl1664;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1661 = false ; 
fl1662 = false ; 
fl1663 = false ; 
fl1664 = true ; 
while (fl1664) { // BeginLoop 
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("arget=")){
indicator = 1661;
} else {
indicator = 1665;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1662;
} else {
indicator = 1665;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1663;
} else {
indicator = 1665;
} // If
break;
} // Case
default:
indicator = 1665;
break;
} // Switch
switch (indicator) {
case 1661: {
// Handling attribute Target
// Also handles alien attributes with prefix Target
if (fl1661){
ctxt.fail ("Duplicate attribute: Target");
} // If
fl1661 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTarget((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1662: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1662){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1662 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1663: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1663){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1663 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1665: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1661){
ctxt.fail ("Mandatory attribute missing: Target in RequirementSetDependancy");
} // If
fl1664 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RequirementSetDependancy";
  endingTag = "</RequirementSetDependancy>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RequirementSetDependancy\"");
} // If
pw.Write('\n');
pw.Write(" Target=\"");
acceptor.unParsePcData(pw, this.getTarget());
pw.Write('"');
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Specification
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getVersion().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.SpecificationController.alertChange(aLock, this);
}
private   string  aVersion;

public   string  getVersion() { return aVersion;}

public  void setVersion( string  v) {
  aVersion = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aChapters;

/// <summary>Part of the list interface for Chapters</summary>
/// <returns>a collection of all the elements in Chapters</returns>
public System.Collections.ArrayList allChapters()
  {
if (aChapters == null){
    setAllChapters( new System.Collections.ArrayList() );
} // If
    return aChapters;
  }

/// <summary>Part of the list interface for Chapters</summary>
/// <returns>a collection of all the elements in Chapters</returns>
private System.Collections.ArrayList getChapters()
  {
    return allChapters();
  }

/// <summary>Part of the list interface for Chapters</summary>
/// <param name="coll">a collection of elements which replaces 
///        Chapters's current content.</param>
public void setAllChapters(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapters = coll;
    NotifyControllers(null);
  }
public void setAllChapters(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapters = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters</summary>
/// <param name="el">a Chapter to add to the collection in 
///           Chapters</param>
/// <seealso cref="appendChapters(System.Collections.IList)"/>
public void appendChapters(Chapter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendChapters(Lock aLock,Chapter el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapters().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Chapters</summary>
/// <param name="coll">a collection ofChapters to add to the collection in 
///           Chapters</param>
/// <seealso cref="appendChapters(Chapter)"/>
public void appendChapters(System.Collections.IList coll)
  {
  __setDirty(true);
  allChapters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendChapters(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allChapters().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters
/// This insertion function inserts a new element in the
/// collection in Chapters</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertChapters(int idx, Chapter el)
  {
  __setDirty(true);
  allChapters().Insert (idx, el);
NotifyControllers(null);
  }

public void insertChapters(int idx, Chapter el,Lock aLock)
  {
  __setDirty(true);
  allChapters().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfChapters(IXmlBBase el)
  {
  return ((System.Collections.IList) allChapters()).IndexOf (el);
  }

/// <summary>Part of the list interface for Chapters
/// This deletion function removes an element from the
/// collection in Chapters</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteChapters(int idx)
  {
  __setDirty(true);
  allChapters().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteChapters(int idx,Lock aLock)
  {
  __setDirty(true);
  allChapters().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Chapters
/// This deletion function removes an element from the
/// collection in Chapters
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeChapters(IXmlBBase obj)
  {
  int idx = indexOfChapters(obj);
  if (idx >= 0) { deleteChapters(idx);
NotifyControllers(null);
   }
  }

public void removeChapters(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfChapters(obj);
  if (idx >= 0) { deleteChapters(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Chapters</summary>
/// <returns>the number of elements in Chapters</returns>
public int countChapters()
  {
  return allChapters().Count;
  }

/// <summary>Part of the list interface for Chapters
/// This function returns an element from the
/// collection in Chapters based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Chapter getChapters(int idx)
{
  return (Chapter) ( allChapters()[idx]);
}

private System.Collections.ArrayList aChapterRefs;

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <returns>a collection of all the elements in ChapterRefs</returns>
public System.Collections.ArrayList allChapterRefs()
  {
if (aChapterRefs == null){
    setAllChapterRefs( new System.Collections.ArrayList() );
} // If
    return aChapterRefs;
  }

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <returns>a collection of all the elements in ChapterRefs</returns>
private System.Collections.ArrayList getChapterRefs()
  {
    return allChapterRefs();
  }

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <param name="coll">a collection of elements which replaces 
///        ChapterRefs's current content.</param>
public void setAllChapterRefs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapterRefs = coll;
    NotifyControllers(null);
  }
public void setAllChapterRefs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aChapterRefs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <param name="el">a ChapterRef to add to the collection in 
///           ChapterRefs</param>
/// <seealso cref="appendChapterRefs(System.Collections.IList)"/>
public void appendChapterRefs(ChapterRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapterRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendChapterRefs(Lock aLock,ChapterRef el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allChapterRefs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for ChapterRefs</summary>
/// <param name="coll">a collection ofChapterRefs to add to the collection in 
///           ChapterRefs</param>
/// <seealso cref="appendChapterRefs(ChapterRef)"/>
public void appendChapterRefs(System.Collections.IList coll)
  {
  __setDirty(true);
  allChapterRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendChapterRefs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allChapterRefs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This insertion function inserts a new element in the
/// collection in ChapterRefs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertChapterRefs(int idx, ChapterRef el)
  {
  __setDirty(true);
  allChapterRefs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertChapterRefs(int idx, ChapterRef el,Lock aLock)
  {
  __setDirty(true);
  allChapterRefs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfChapterRefs(IXmlBBase el)
  {
  return ((System.Collections.IList) allChapterRefs()).IndexOf (el);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This deletion function removes an element from the
/// collection in ChapterRefs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteChapterRefs(int idx)
  {
  __setDirty(true);
  allChapterRefs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteChapterRefs(int idx,Lock aLock)
  {
  __setDirty(true);
  allChapterRefs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for ChapterRefs
/// This deletion function removes an element from the
/// collection in ChapterRefs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeChapterRefs(IXmlBBase obj)
  {
  int idx = indexOfChapterRefs(obj);
  if (idx >= 0) { deleteChapterRefs(idx);
NotifyControllers(null);
   }
  }

public void removeChapterRefs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfChapterRefs(obj);
  if (idx >= 0) { deleteChapterRefs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for ChapterRefs</summary>
/// <returns>the number of elements in ChapterRefs</returns>
public int countChapterRefs()
  {
  return allChapterRefs().Count;
  }

/// <summary>Part of the list interface for ChapterRefs
/// This function returns an element from the
/// collection in ChapterRefs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public ChapterRef getChapterRefs(int idx)
{
  return (ChapterRef) ( allChapterRefs()[idx]);
}

public Specification()
{
Specification obj = this;
aVersion=(null);
aChapters=(null);
aChapterRefs=(null);
}

public void copyTo(Specification other)
{
base.copyTo(other);
other.aVersion = aVersion;
other.aChapters = aChapters;
other.aChapterRefs = aChapterRefs;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
Chapter fl1671;
ChapterRef fl1683;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl1671 = null;
while(ctxt.lookAheadOpeningTag ("<Chapter")) {
fl1671 = acceptor.lAccept_Chapter(ctxt, "</Chapter>");
appendChapters(fl1671);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl1683 = null;
while(ctxt.lookAheadOpeningTag ("<ChapterRef")) {
fl1683 = acceptor.lAccept_ChapterRef(ctxt, "</ChapterRef>");
appendChapterRefs(fl1683);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1694;
bool fl1695;
bool fl1696;
bool fl1697;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1694 = false ; 
fl1695 = false ; 
fl1696 = false ; 
fl1697 = true ; 
while (fl1697) { // BeginLoop 
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
if (ctxt.lookAheadString("ersion=")){
indicator = 1694;
} else {
indicator = 1698;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1695;
} else {
indicator = 1698;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1696;
} else {
indicator = 1698;
} // If
break;
} // Case
default:
indicator = 1698;
break;
} // Switch
switch (indicator) {
case 1694: {
// Handling attribute version
// Also handles alien attributes with prefix version
if (fl1694){
ctxt.fail ("Duplicate attribute: version");
} // If
fl1694 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVersion((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1695: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1695){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1695 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1696: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1696){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1696 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1698: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1697 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Specification";
  endingTag = "</Specification>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Specification\"");
} // If
pw.Write('\n');
if (this.getVersion() != null){
pw.Write(" version=\"");
acceptor.unParsePcData(pw, this.getVersion());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getChapters(), false, "<Chapter", "</Chapter>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getChapterRefs(), false, "<ChapterRef", "</ChapterRef>");
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countChapters(); i++) {
  l.Add(getChapters(i));
}
for (int i = 0; i < countChapterRefs(); i++) {
  l.Add(getChapterRefs(i));
}
}

}
public partial class ChapterRef
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ChapterRefController.alertChange(aLock, this);
}
public ChapterRef()
{
ChapterRef obj = this;
}

public void copyTo(ChapterRef other)
{
base.copyTo(other);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1703;
bool fl1704;
bool fl1705;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1703 = false ; 
fl1704 = false ; 
fl1705 = true ; 
while (fl1705) { // BeginLoop 
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1703;
} else {
indicator = 1706;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1704;
} else {
indicator = 1706;
} // If
break;
} // Case
default:
indicator = 1706;
break;
} // Switch
switch (indicator) {
case 1703: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1703){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1703 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1704: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1704){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1704 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1706: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1705 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ChapterRef";
  endingTag = "</ChapterRef>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ChapterRef\"");
} // If
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Chapter
: DataDictionary.Namable
{
public  override  bool find(Object search){
if (search is String ) {
if(getId().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ChapterController.alertChange(aLock, this);
}
private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aParagraphs;

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
public System.Collections.ArrayList allParagraphs()
  {
if (aParagraphs == null){
    setAllParagraphs( new System.Collections.ArrayList() );
} // If
    return aParagraphs;
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
private System.Collections.ArrayList getParagraphs()
  {
    return allParagraphs();
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection of elements which replaces 
///        Paragraphs's current content.</param>
public void setAllParagraphs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
    NotifyControllers(null);
  }
public void setAllParagraphs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="el">a Paragraph to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(System.Collections.IList)"/>
public void appendParagraphs(Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParagraphs(Lock aLock,Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection ofParagraphs to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(Paragraph)"/>
public void appendParagraphs(System.Collections.IList coll)
  {
  __setDirty(true);
  allParagraphs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParagraphs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This insertion function inserts a new element in the
/// collection in Paragraphs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParagraphs(int idx, Paragraph el)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParagraphs(int idx, Paragraph el,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParagraphs(IXmlBBase el)
  {
  return ((System.Collections.IList) allParagraphs()).IndexOf (el);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParagraphs(int idx)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParagraphs(int idx,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParagraphs(IXmlBBase obj)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(null);
   }
  }

public void removeParagraphs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>the number of elements in Paragraphs</returns>
public int countParagraphs()
  {
  return allParagraphs().Count;
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns an element from the
/// collection in Paragraphs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Paragraph getParagraphs(int idx)
{
  return (Paragraph) ( allParagraphs()[idx]);
}

private System.Collections.ArrayList aTypeSpecs;

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
public System.Collections.ArrayList allTypeSpecs()
  {
if (aTypeSpecs == null){
    setAllTypeSpecs( new System.Collections.ArrayList() );
} // If
    return aTypeSpecs;
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
private System.Collections.ArrayList getTypeSpecs()
  {
    return allTypeSpecs();
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection of elements which replaces 
///        TypeSpecs's current content.</param>
public void setAllTypeSpecs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
    NotifyControllers(null);
  }
public void setAllTypeSpecs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="el">a TypeSpec to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(System.Collections.IList)"/>
public void appendTypeSpecs(TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTypeSpecs(Lock aLock,TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection ofTypeSpecs to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(TypeSpec)"/>
public void appendTypeSpecs(System.Collections.IList coll)
  {
  __setDirty(true);
  allTypeSpecs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTypeSpecs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This insertion function inserts a new element in the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTypeSpecs(int idx, TypeSpec el)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTypeSpecs(int idx, TypeSpec el,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTypeSpecs(IXmlBBase el)
  {
  return ((System.Collections.IList) allTypeSpecs()).IndexOf (el);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTypeSpecs(int idx)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTypeSpecs(int idx,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTypeSpecs(IXmlBBase obj)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(null);
   }
  }

public void removeTypeSpecs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>the number of elements in TypeSpecs</returns>
public int countTypeSpecs()
  {
  return allTypeSpecs().Count;
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns an element from the
/// collection in TypeSpecs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public TypeSpec getTypeSpecs(int idx)
{
  return (TypeSpec) ( allTypeSpecs()[idx]);
}

public Chapter()
{
Chapter obj = this;
aId=(null);
aParagraphs=(null);
aTypeSpecs=(null);
}

public void copyTo(Chapter other)
{
base.copyTo(other);
other.aId = aId;
other.aParagraphs = aParagraphs;
other.aTypeSpecs = aTypeSpecs;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
Paragraph fl1711;
TypeSpec fl1723;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Repeat
ctxt.skipWhiteSpace();
fl1711 = null;
while(ctxt.lookAheadOpeningTag ("<Paragraph")) {
fl1711 = acceptor.lAccept_Paragraph(ctxt, "</Paragraph>");
appendParagraphs(fl1711);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
// Repeat
ctxt.skipWhiteSpace();
fl1723 = null;
while(ctxt.lookAheadOpeningTag ("<TypeSpec")) {
fl1723 = acceptor.lAccept_TypeSpec(ctxt, null);
appendTypeSpecs(fl1723);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1734;
bool fl1735;
bool fl1736;
bool fl1737;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1734 = false ; 
fl1735 = false ; 
fl1736 = false ; 
fl1737 = true ; 
while (fl1737) { // BeginLoop 
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 1734;
} else {
indicator = 1738;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1735;
} else {
indicator = 1738;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1736;
} else {
indicator = 1738;
} // If
break;
} // Case
default:
indicator = 1738;
break;
} // Switch
switch (indicator) {
case 1734: {
// Handling attribute id
// Also handles alien attributes with prefix id
if (fl1734){
ctxt.fail ("Duplicate attribute: id");
} // If
fl1734 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1735: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1735){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1735 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1736: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1736){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1736 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1738: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1734){
ctxt.fail ("Mandatory attribute missing: id in Chapter");
} // If
fl1737 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Chapter";
  endingTag = "</Chapter>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Chapter\"");
} // If
pw.Write('\n');
pw.Write(" id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParagraphs(), false, "<Paragraph", "</Paragraph>");
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTypeSpecs(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countParagraphs(); i++) {
  l.Add(getParagraphs(i));
}
for (int i = 0; i < countTypeSpecs(); i++) {
  l.Add(getTypeSpecs(i));
}
}

}
public partial class Paragraph
: DataDictionary.ReferencesParagraph
{
public  override  bool find(Object search){
if (search is String ) {
if(getId().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
if(getText().CompareTo((String) search) == 0)return true;
if(getVersion().CompareTo((String) search) == 0)return true;
if(getObsoleteFunctionalBlockName().CompareTo((String) search) == 0)return true;
if(getObsoleteGuid().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ParagraphController.alertChange(aLock, this);
}
private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.Paragraph_type aType;

public  acceptor.Paragraph_type getType() { return aType;}

public  void setType(acceptor.Paragraph_type v) {
  aType = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getType_AsString()
{
  return acceptor.Enum_Paragraph_type_ToString (aType);
}

public  bool setType_AsString( string  v)
{
 acceptor.Paragraph_type  temp = acceptor.StringTo_Enum_Paragraph_type(v);
if (temp >= 0){
  aType = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.Paragraph_scope aObsoleteScope;

public  acceptor.Paragraph_scope getObsoleteScope() { return aObsoleteScope;}

public  void setObsoleteScope(acceptor.Paragraph_scope v) {
  aObsoleteScope = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getObsoleteScope_AsString()
{
  return acceptor.Enum_Paragraph_scope_ToString (aObsoleteScope);
}

public  bool setObsoleteScope_AsString( string  v)
{
 acceptor.Paragraph_scope  temp = acceptor.StringTo_Enum_Paragraph_scope(v);
if (temp >= 0){
  aObsoleteScope = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  bool aObsoleteScopeOnBoard;

public  bool getObsoleteScopeOnBoard() { return aObsoleteScopeOnBoard;}

public  void setObsoleteScopeOnBoard(bool v) {
  aObsoleteScopeOnBoard = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aObsoleteScopeTrackside;

public  bool getObsoleteScopeTrackside() { return aObsoleteScopeTrackside;}

public  void setObsoleteScopeTrackside(bool v) {
  aObsoleteScopeTrackside = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aObsoleteScopeRollingStock;

public  bool getObsoleteScopeRollingStock() { return aObsoleteScopeRollingStock;}

public  void setObsoleteScopeRollingStock(bool v) {
  aObsoleteScopeRollingStock = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aOptional;

public  bool getOptional() { return aOptional;}

public  void setOptional(bool v) {
  aOptional = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aTypeSpecs;

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
public System.Collections.ArrayList allTypeSpecs()
  {
if (aTypeSpecs == null){
    setAllTypeSpecs( new System.Collections.ArrayList() );
} // If
    return aTypeSpecs;
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>a collection of all the elements in TypeSpecs</returns>
private System.Collections.ArrayList getTypeSpecs()
  {
    return allTypeSpecs();
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection of elements which replaces 
///        TypeSpecs's current content.</param>
public void setAllTypeSpecs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
    NotifyControllers(null);
  }
public void setAllTypeSpecs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aTypeSpecs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="el">a TypeSpec to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(System.Collections.IList)"/>
public void appendTypeSpecs(TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendTypeSpecs(Lock aLock,TypeSpec el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allTypeSpecs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for TypeSpecs</summary>
/// <param name="coll">a collection ofTypeSpecs to add to the collection in 
///           TypeSpecs</param>
/// <seealso cref="appendTypeSpecs(TypeSpec)"/>
public void appendTypeSpecs(System.Collections.IList coll)
  {
  __setDirty(true);
  allTypeSpecs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendTypeSpecs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This insertion function inserts a new element in the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertTypeSpecs(int idx, TypeSpec el)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertTypeSpecs(int idx, TypeSpec el,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfTypeSpecs(IXmlBBase el)
  {
  return ((System.Collections.IList) allTypeSpecs()).IndexOf (el);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteTypeSpecs(int idx)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteTypeSpecs(int idx,Lock aLock)
  {
  __setDirty(true);
  allTypeSpecs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for TypeSpecs
/// This deletion function removes an element from the
/// collection in TypeSpecs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeTypeSpecs(IXmlBBase obj)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(null);
   }
  }

public void removeTypeSpecs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfTypeSpecs(obj);
  if (idx >= 0) { deleteTypeSpecs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for TypeSpecs</summary>
/// <returns>the number of elements in TypeSpecs</returns>
public int countTypeSpecs()
  {
  return allTypeSpecs().Count;
  }

/// <summary>Part of the list interface for TypeSpecs
/// This function returns an element from the
/// collection in TypeSpecs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public TypeSpec getTypeSpecs(int idx)
{
  return (TypeSpec) ( allTypeSpecs()[idx]);
}

private   string  aText;

public   string  getText() { return aText;}

public  void setText( string  v) {
  aText = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aVersion;

public   string  getVersion() { return aVersion;}

public  void setVersion( string  v) {
  aVersion = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aReviewed;

public  bool getReviewed() { return aReviewed;}

public  void setReviewed(bool v) {
  aReviewed = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.SPEC_IMPLEMENTED_ENUM aImplementationStatus;

public  acceptor.SPEC_IMPLEMENTED_ENUM getImplementationStatus() { return aImplementationStatus;}

public  void setImplementationStatus(acceptor.SPEC_IMPLEMENTED_ENUM v) {
  aImplementationStatus = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getImplementationStatus_AsString()
{
  return acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString (aImplementationStatus);
}

public  bool setImplementationStatus_AsString( string  v)
{
 acceptor.SPEC_IMPLEMENTED_ENUM  temp = acceptor.StringTo_Enum_SPEC_IMPLEMENTED_ENUM(v);
if (temp >= 0){
  aImplementationStatus = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private System.Collections.ArrayList aParagraphs;

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
public System.Collections.ArrayList allParagraphs()
  {
if (aParagraphs == null){
    setAllParagraphs( new System.Collections.ArrayList() );
} // If
    return aParagraphs;
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>a collection of all the elements in Paragraphs</returns>
private System.Collections.ArrayList getParagraphs()
  {
    return allParagraphs();
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection of elements which replaces 
///        Paragraphs's current content.</param>
public void setAllParagraphs(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
    NotifyControllers(null);
  }
public void setAllParagraphs(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aParagraphs = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="el">a Paragraph to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(System.Collections.IList)"/>
public void appendParagraphs(Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendParagraphs(Lock aLock,Paragraph el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allParagraphs().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Paragraphs</summary>
/// <param name="coll">a collection ofParagraphs to add to the collection in 
///           Paragraphs</param>
/// <seealso cref="appendParagraphs(Paragraph)"/>
public void appendParagraphs(System.Collections.IList coll)
  {
  __setDirty(true);
  allParagraphs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendParagraphs(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This insertion function inserts a new element in the
/// collection in Paragraphs</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertParagraphs(int idx, Paragraph el)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(null);
  }

public void insertParagraphs(int idx, Paragraph el,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfParagraphs(IXmlBBase el)
  {
  return ((System.Collections.IList) allParagraphs()).IndexOf (el);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteParagraphs(int idx)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteParagraphs(int idx,Lock aLock)
  {
  __setDirty(true);
  allParagraphs().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Paragraphs
/// This deletion function removes an element from the
/// collection in Paragraphs
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeParagraphs(IXmlBBase obj)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(null);
   }
  }

public void removeParagraphs(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfParagraphs(obj);
  if (idx >= 0) { deleteParagraphs(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Paragraphs</summary>
/// <returns>the number of elements in Paragraphs</returns>
public int countParagraphs()
  {
  return allParagraphs().Count;
  }

/// <summary>Part of the list interface for Paragraphs
/// This function returns an element from the
/// collection in Paragraphs based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public Paragraph getParagraphs(int idx)
{
  return (Paragraph) ( allParagraphs()[idx]);
}

private  ParagraphRevision aRevision;

public  ParagraphRevision getRevision() { return aRevision;}

public  void setRevision(ParagraphRevision v) {
  aRevision = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  Message aMessage;

public  Message getMessage() { return aMessage;}

public  void setMessage(Message v) {
  aMessage = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aMoreInfoRequired;

public  bool getMoreInfoRequired() { return aMoreInfoRequired;}

public  void setMoreInfoRequired(bool v) {
  aMoreInfoRequired = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aSpecIssue;

public  bool getSpecIssue() { return aSpecIssue;}

public  void setSpecIssue(bool v) {
  aSpecIssue = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aObsoleteFunctionalBlock;

public  bool getObsoleteFunctionalBlock() { return aObsoleteFunctionalBlock;}

public  void setObsoleteFunctionalBlock(bool v) {
  aObsoleteFunctionalBlock = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aObsoleteFunctionalBlockName;

public   string  getObsoleteFunctionalBlockName() { return aObsoleteFunctionalBlockName;}

public  void setObsoleteFunctionalBlockName( string  v) {
  aObsoleteFunctionalBlockName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aRequirementSets;

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>a collection of all the elements in RequirementSets</returns>
public System.Collections.ArrayList allRequirementSets()
  {
if (aRequirementSets == null){
    setAllRequirementSets( new System.Collections.ArrayList() );
} // If
    return aRequirementSets;
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>a collection of all the elements in RequirementSets</returns>
private System.Collections.ArrayList getRequirementSets()
  {
    return allRequirementSets();
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="coll">a collection of elements which replaces 
///        RequirementSets's current content.</param>
public void setAllRequirementSets(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirementSets = coll;
    NotifyControllers(null);
  }
public void setAllRequirementSets(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aRequirementSets = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="el">a RequirementSetReference to add to the collection in 
///           RequirementSets</param>
/// <seealso cref="appendRequirementSets(System.Collections.IList)"/>
public void appendRequirementSets(RequirementSetReference el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirementSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendRequirementSets(Lock aLock,RequirementSetReference el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allRequirementSets().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for RequirementSets</summary>
/// <param name="coll">a collection ofRequirementSetReferences to add to the collection in 
///           RequirementSets</param>
/// <seealso cref="appendRequirementSets(RequirementSetReference)"/>
public void appendRequirementSets(System.Collections.IList coll)
  {
  __setDirty(true);
  allRequirementSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendRequirementSets(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This insertion function inserts a new element in the
/// collection in RequirementSets</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertRequirementSets(int idx, RequirementSetReference el)
  {
  __setDirty(true);
  allRequirementSets().Insert (idx, el);
NotifyControllers(null);
  }

public void insertRequirementSets(int idx, RequirementSetReference el,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfRequirementSets(IXmlBBase el)
  {
  return ((System.Collections.IList) allRequirementSets()).IndexOf (el);
  }

/// <summary>Part of the list interface for RequirementSets
/// This deletion function removes an element from the
/// collection in RequirementSets</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteRequirementSets(int idx)
  {
  __setDirty(true);
  allRequirementSets().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteRequirementSets(int idx,Lock aLock)
  {
  __setDirty(true);
  allRequirementSets().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for RequirementSets
/// This deletion function removes an element from the
/// collection in RequirementSets
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeRequirementSets(IXmlBBase obj)
  {
  int idx = indexOfRequirementSets(obj);
  if (idx >= 0) { deleteRequirementSets(idx);
NotifyControllers(null);
   }
  }

public void removeRequirementSets(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfRequirementSets(obj);
  if (idx >= 0) { deleteRequirementSets(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for RequirementSets</summary>
/// <returns>the number of elements in RequirementSets</returns>
public int countRequirementSets()
  {
  return allRequirementSets().Count;
  }

/// <summary>Part of the list interface for RequirementSets
/// This function returns an element from the
/// collection in RequirementSets based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public RequirementSetReference getRequirementSets(int idx)
{
  return (RequirementSetReference) ( allRequirementSets()[idx]);
}

private   string  aObsoleteGuid;

public   string  getObsoleteGuid() { return aObsoleteGuid;}

public  void setObsoleteGuid( string  v) {
  aObsoleteGuid = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  bool aTested;

public  bool getTested() { return aTested;}

public  void setTested(bool v) {
  aTested = v;
  __setDirty(true);
  NotifyControllers(null);
}


public Paragraph()
{
Paragraph obj = this;
aId=(null);
aType=(0);
aObsoleteScope=(0);
aObsoleteScopeOnBoard=(false);
aObsoleteScopeTrackside=(false);
aObsoleteScopeRollingStock=(false);
aBl=(null);
aOptional=(false);
aTypeSpecs=(null);
aText=(null);
aVersion=(null);
aReviewed=(false);
aImplementationStatus=(0);
aParagraphs=(null);
aRevision=(null);
aMessage=(null);
aMoreInfoRequired=(false);
aSpecIssue=(false);
aObsoleteFunctionalBlock=(false);
aObsoleteFunctionalBlockName=(null);
aRequirementSets=(null);
aObsoleteGuid=(null);
aTested=(false);
}

public void copyTo(Paragraph other)
{
base.copyTo(other);
other.aId = aId;
other.aType = aType;
other.aObsoleteScope = aObsoleteScope;
other.aObsoleteScopeOnBoard = aObsoleteScopeOnBoard;
other.aObsoleteScopeTrackside = aObsoleteScopeTrackside;
other.aObsoleteScopeRollingStock = aObsoleteScopeRollingStock;
other.aBl = aBl;
other.aOptional = aOptional;
other.aTypeSpecs = aTypeSpecs;
other.aText = aText;
other.aVersion = aVersion;
other.aReviewed = aReviewed;
other.aImplementationStatus = aImplementationStatus;
other.aParagraphs = aParagraphs;
other.aRevision = aRevision;
other.aMessage = aMessage;
other.aMoreInfoRequired = aMoreInfoRequired;
other.aSpecIssue = aSpecIssue;
other.aObsoleteFunctionalBlock = aObsoleteFunctionalBlock;
other.aObsoleteFunctionalBlockName = aObsoleteFunctionalBlockName;
other.aRequirementSets = aRequirementSets;
other.aObsoleteGuid = aObsoleteGuid;
other.aTested = aTested;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1743;
Paragraph fl1745;
TypeSpec fl1757;
bool fl1768;
RequirementSetReference fl1770;

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Indicator
// Parse PC data
this.setText(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
// Element Ref : Message
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<Message")){
// Parsing sub element
this.setMessage(acceptor.lAccept_Message(ctxt,null));
setSon(this.getMessage());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Element Ref : ParagraphRevision
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<ParagraphRevision")){
// Parsing sub element
this.setRevision(acceptor.lAccept_ParagraphRevision(ctxt,"</ParagraphRevision>"));
setSon(this.getRevision());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Sub")){
ctxt.skipWhiteSpace();
fl1743 = true ; 
while (fl1743) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1743 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1745 = null;
while(ctxt.lookAheadOpeningTag ("<Paragraph")) {
fl1745 = acceptor.lAccept_Paragraph(ctxt, "</Paragraph>");
appendParagraphs(fl1745);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Sub>");
} // If
} // If
// End enclosed
// Repeat
ctxt.skipWhiteSpace();
fl1757 = null;
while(ctxt.lookAheadOpeningTag ("<TypeSpec")) {
fl1757 = acceptor.lAccept_TypeSpec(ctxt, null);
appendTypeSpecs(fl1757);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<RequirementSets")){
ctxt.skipWhiteSpace();
fl1768 = true ; 
while (fl1768) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1768 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Repeat
ctxt.skipWhiteSpace();
fl1770 = null;
while(ctxt.lookAheadOpeningTag ("<RequirementSetReference")) {
fl1770 = acceptor.lAccept_RequirementSetReference(ctxt, "</RequirementSetReference>");
appendRequirementSets(fl1770);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
ctxt.acceptString ("</RequirementSets>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1781;
bool fl1782;
bool fl1783;
bool fl1784;
bool fl1785;
bool fl1786;
bool fl1787;
bool fl1788;
bool fl1789;
bool fl1790;
bool fl1791;
bool fl1792;
bool fl1793;
bool fl1794;
bool fl1795;
bool fl1796;
bool fl1797;
bool fl1798;
bool fl1799;
bool fl1800;
bool fl1801;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1781 = false ; 
fl1782 = false ; 
fl1783 = false ; 
fl1784 = false ; 
fl1785 = false ; 
fl1786 = false ; 
fl1787 = false ; 
fl1788 = false ; 
fl1789 = false ; 
fl1790 = false ; 
fl1791 = false ; 
fl1792 = false ; 
fl1793 = false ; 
fl1794 = false ; 
fl1795 = false ; 
fl1796 = false ; 
fl1797 = false ; 
fl1798 = false ; 
fl1799 = false ; 
fl1800 = false ; 
fl1801 = true ; 
while (fl1801) { // BeginLoop 
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
if (ctxt.lookAheadString("ersion=")){
indicator = 1791;
} else {
indicator = 1802;
} // If
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'y':
{
ctxt.advance();
if (ctxt.lookAhead3('p','e','=')){
indicator = 1783;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ackside=")){
indicator = 1797;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("sted=")){
indicator = 1790;
} else {
indicator = 1802;
} // If
break;
} // Case
default:
indicator = 1802;
break;
} // Switch
break;
} // Case
case 's':
{
ctxt.advance();
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAheadString("atus=")){
indicator = 1789;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("ecIssue=")){
indicator = 1793;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("ope=")){
indicator = 1784;
} else {
indicator = 1802;
} // If
break;
} // Case
default:
indicator = 1802;
break;
} // Switch
break;
} // Case
case 'r':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("llinkstock=")){
indicator = 1798;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("viewed=")){
indicator = 1788;
} else {
indicator = 1802;
} // If
break;
} // Case
default:
indicator = 1802;
break;
} // Switch
break;
} // Case
case 'o':
{
ctxt.advance();
switch (ctxt.current()) {
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("tional=")){
indicator = 1786;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("board=")){
indicator = 1796;
} else {
indicator = 1802;
} // If
break;
} // Case
default:
indicator = 1802;
break;
} // Switch
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1787;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("foRequired=")){
indicator = 1792;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'd':
{
ctxt.advance();
if (ctxt.lookAhead1('=')){
indicator = 1781;
} else {
indicator = 1802;
} // If
break;
} // Case
default:
indicator = 1802;
break;
} // Switch
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1782;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'f':
{
ctxt.advance();
if (ctxt.lookAheadString("unctionalBlock")){
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1795;
} else {
indicator = 1802;
} // If
break;
} // Case
case '=':
{
ctxt.advance();
indicator = 1794;
break;
} // Case
default:
indicator = 1802;
break;
} // Switch
} else {
indicator = 1802;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1785;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1799;
} else {
indicator = 1802;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1800;
} else {
indicator = 1802;
} // If
break;
} // Case
default:
indicator = 1802;
break;
} // Switch
switch (indicator) {
case 1781: {
// Handling attribute id
// Also handles alien attributes with prefix id
if (fl1781){
ctxt.fail ("Duplicate attribute: id");
} // If
fl1781 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1782: {
// Handling attribute guid
// Also handles alien attributes with prefix guid
if (fl1782){
ctxt.fail ("Duplicate attribute: guid");
} // If
fl1782 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1783: {
// Handling attribute type
// Also handles alien attributes with prefix type
if (fl1783){
ctxt.fail ("Duplicate attribute: type");
} // If
fl1783 = true ; 
quoteChar = ctxt.acceptQuote();
this.setType(acceptor.lAcceptEnum_Paragraph_type(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1784: {
// Handling attribute scope
// Also handles alien attributes with prefix scope
if (fl1784){
ctxt.fail ("Duplicate attribute: scope");
} // If
fl1784 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteScope(acceptor.lAcceptEnum_Paragraph_scope(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1785: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1785){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1785 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1786: {
// Handling attribute optional
// Also handles alien attributes with prefix optional
if (fl1786){
ctxt.fail ("Duplicate attribute: optional");
} // If
fl1786 = true ; 
quoteChar = ctxt.acceptQuote();
this.setOptional(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1787: {
// Handling attribute name
// Also handles alien attributes with prefix name
if (fl1787){
ctxt.fail ("Duplicate attribute: name");
} // If
fl1787 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1788: {
// Handling attribute reviewed
// Also handles alien attributes with prefix reviewed
if (fl1788){
ctxt.fail ("Duplicate attribute: reviewed");
} // If
fl1788 = true ; 
quoteChar = ctxt.acceptQuote();
this.setReviewed(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1789: {
// Handling attribute status
// Also handles alien attributes with prefix status
if (fl1789){
ctxt.fail ("Duplicate attribute: status");
} // If
fl1789 = true ; 
quoteChar = ctxt.acceptQuote();
this.setImplementationStatus(acceptor.lAcceptEnum_SPEC_IMPLEMENTED_ENUM(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1790: {
// Handling attribute tested
// Also handles alien attributes with prefix tested
if (fl1790){
ctxt.fail ("Duplicate attribute: tested");
} // If
fl1790 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTested(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1791: {
// Handling attribute version
// Also handles alien attributes with prefix version
if (fl1791){
ctxt.fail ("Duplicate attribute: version");
} // If
fl1791 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVersion((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1792: {
// Handling attribute infoRequired
// Also handles alien attributes with prefix infoRequired
if (fl1792){
ctxt.fail ("Duplicate attribute: infoRequired");
} // If
fl1792 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMoreInfoRequired(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1793: {
// Handling attribute specIssue
// Also handles alien attributes with prefix specIssue
if (fl1793){
ctxt.fail ("Duplicate attribute: specIssue");
} // If
fl1793 = true ; 
quoteChar = ctxt.acceptQuote();
this.setSpecIssue(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1794: {
// Handling attribute functionalBlock
// Also handles alien attributes with prefix functionalBlock
if (fl1794){
ctxt.fail ("Duplicate attribute: functionalBlock");
} // If
fl1794 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteFunctionalBlock(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1795: {
// Handling attribute functionalBlockName
// Also handles alien attributes with prefix functionalBlockName
if (fl1795){
ctxt.fail ("Duplicate attribute: functionalBlockName");
} // If
fl1795 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteFunctionalBlockName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1796: {
// Handling attribute onboard
// Also handles alien attributes with prefix onboard
if (fl1796){
ctxt.fail ("Duplicate attribute: onboard");
} // If
fl1796 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteScopeOnBoard(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1797: {
// Handling attribute trackside
// Also handles alien attributes with prefix trackside
if (fl1797){
ctxt.fail ("Duplicate attribute: trackside");
} // If
fl1797 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteScopeTrackside(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1798: {
// Handling attribute rollinkstock
// Also handles alien attributes with prefix rollinkstock
if (fl1798){
ctxt.fail ("Duplicate attribute: rollinkstock");
} // If
fl1798 = true ; 
quoteChar = ctxt.acceptQuote();
this.setObsoleteScopeRollingStock(acceptor.lAcceptBoolean(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1799: {
// Handling attribute Name
// Also handles alien attributes with prefix Name
if (fl1799){
ctxt.fail ("Duplicate attribute: Name");
} // If
fl1799 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1800: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1800){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1800 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1802: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1781){
ctxt.fail ("Mandatory attribute missing: id in Paragraph");
} // If
if (!fl1782){
this.setObsoleteGuid("");
} // If
if (!fl1783){
this.setType(acceptor.Paragraph_type.aREQUIREMENT);
} // If
if (!fl1784){
this.setObsoleteScope(acceptor.Paragraph_scope.aOBU_AND_TRACK);
} // If
if (!fl1785){
this.setBl("");
} // If
if (!fl1786){
this.setOptional( true);
} // If
if (!fl1787){
this.setName("");
} // If
if (!fl1788){
this.setReviewed( false);
} // If
if (!fl1789){
this.setImplementationStatus(acceptor.SPEC_IMPLEMENTED_ENUM.Impl_NA);
} // If
if (!fl1790){
this.setTested( false);
} // If
if (!fl1791){
this.setVersion("3.0.0");
} // If
if (!fl1792){
this.setMoreInfoRequired( false);
} // If
if (!fl1793){
this.setSpecIssue( false);
} // If
if (!fl1794){
this.setObsoleteFunctionalBlock( false);
} // If
if (!fl1795){
this.setObsoleteFunctionalBlockName("");
} // If
if (!fl1796){
this.setObsoleteScopeOnBoard( false);
} // If
if (!fl1797){
this.setObsoleteScopeTrackside( false);
} // If
if (!fl1798){
this.setObsoleteScopeRollingStock( false);
} // If
fl1801 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<Paragraph";
  endingTag = "</Paragraph>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"Paragraph\"");
} // If
pw.Write('\n');
pw.Write(" id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
if (this.getObsoleteGuid() != null){
pw.Write(" guid=\"");
acceptor.unParsePcData(pw, this.getObsoleteGuid());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getType() != 0){
pw.Write(" type=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_Paragraph_type_ToString(this.getType()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteScope() != 0){
pw.Write(" scope=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_Paragraph_scope_ToString(this.getObsoleteScope()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
if (!this.getOptional()){
pw.Write(" optional=\"");
acceptor.unParsePcData(pw, this.getOptional());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getReviewed()){
pw.Write(" reviewed=\"");
acceptor.unParsePcData(pw, this.getReviewed());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getImplementationStatus() != 0){
pw.Write(" status=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_SPEC_IMPLEMENTED_ENUM_ToString(this.getImplementationStatus()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getTested()){
pw.Write(" tested=\"");
acceptor.unParsePcData(pw, this.getTested());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getVersion() != null){
pw.Write(" version=\"");
acceptor.unParsePcData(pw, this.getVersion());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMoreInfoRequired()){
pw.Write(" infoRequired=\"");
acceptor.unParsePcData(pw, this.getMoreInfoRequired());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getSpecIssue()){
pw.Write(" specIssue=\"");
acceptor.unParsePcData(pw, this.getSpecIssue());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteFunctionalBlock()){
pw.Write(" functionalBlock=\"");
acceptor.unParsePcData(pw, this.getObsoleteFunctionalBlock());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteFunctionalBlockName() != null){
pw.Write(" functionalBlockName=\"");
acceptor.unParsePcData(pw, this.getObsoleteFunctionalBlockName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteScopeOnBoard()){
pw.Write(" onboard=\"");
acceptor.unParsePcData(pw, this.getObsoleteScopeOnBoard());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteScopeTrackside()){
pw.Write(" trackside=\"");
acceptor.unParsePcData(pw, this.getObsoleteScopeTrackside());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getObsoleteScopeRollingStock()){
pw.Write(" rollinkstock=\"");
acceptor.unParsePcData(pw, this.getObsoleteScopeRollingStock());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getName() != null){
pw.Write(" Name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing PcData
acceptor.unParsePcData(pw, this.getText());
// Unparsing ElementRef
if (this.getMessage() != null){
unParse(pw, this.getMessage(), false, null, null);
} // If
// Unparsing ElementRef
if (this.getRevision() != null){
unParse(pw, this.getRevision(),false,"<ParagraphRevision","</ParagraphRevision>");
} // If
// Unparsing Enclosed
// Testing for empty content: Paragraphs
if (countParagraphs() > 0){
pw.Write("<Sub>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getParagraphs(), false, "<Paragraph", "</Paragraph>");
pw.Write("</Sub>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Paragraphs
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getTypeSpecs(), false, null, null);
// Unparsing Enclosed
// Testing for empty content: RequirementSets
if (countRequirementSets() > 0){
pw.Write("<RequirementSets>");
pw.Write('\n');
// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getRequirementSets(), false, "<RequirementSetReference", "</RequirementSetReference>");
pw.Write("</RequirementSets>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: RequirementSets
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
for (int i = 0; i < countTypeSpecs(); i++) {
  l.Add(getTypeSpecs(i));
}
for (int i = 0; i < countParagraphs(); i++) {
  l.Add(getParagraphs(i));
}
l.Add(this.getRevision());
l.Add(this.getMessage());
for (int i = 0; i < countRequirementSets(); i++) {
  l.Add(getRequirementSets(i));
}
}

}
public partial class RequirementSetReference
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getTarget().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.RequirementSetReferenceController.alertChange(aLock, this);
}
private   string  aTarget;

public   string  getTarget() { return aTarget;}

public  void setTarget( string  v) {
  aTarget = v;
  __setDirty(true);
  NotifyControllers(null);
}


public RequirementSetReference()
{
RequirementSetReference obj = this;
aTarget=(null);
}

public void copyTo(RequirementSetReference other)
{
base.copyTo(other);
other.aTarget = aTarget;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1830;
bool fl1831;
bool fl1832;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1830 = false ; 
fl1831 = false ; 
fl1832 = true ; 
while (fl1832) { // BeginLoop 
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("efId=")){
indicator = 1830;
} else {
indicator = 1833;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1831;
} else {
indicator = 1833;
} // If
break;
} // Case
default:
indicator = 1833;
break;
} // Switch
switch (indicator) {
case 1830: {
// Handling attribute RefId
// Also handles alien attributes with prefix RefId
if (fl1830){
ctxt.fail ("Duplicate attribute: RefId");
} // If
fl1830 = true ; 
quoteChar = ctxt.acceptQuote();
this.setTarget((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1831: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1831){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1831 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1833: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1830){
ctxt.fail ("Mandatory attribute missing: RefId in RequirementSetReference");
} // If
fl1832 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<RequirementSetReference";
  endingTag = "</RequirementSetReference>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"RequirementSetReference\"");
} // If
pw.Write('\n');
pw.Write(" RefId=\"");
acceptor.unParsePcData(pw, this.getTarget());
pw.Write('"');
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class Message
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getDescription().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.MessageController.alertChange(aLock, this);
}
private   string  aDescription;

public   string  getDescription() { return aDescription;}

public  void setDescription( string  v) {
  aDescription = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.Message_media aMedia;

public  acceptor.Message_media getMedia() { return aMedia;}

public  void setMedia(acceptor.Message_media v) {
  aMedia = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMedia_AsString()
{
  return acceptor.Enum_Message_media_ToString (aMedia);
}

public  bool setMedia_AsString( string  v)
{
 acceptor.Message_media  temp = acceptor.StringTo_Enum_Message_media(v);
if (temp >= 0){
  aMedia = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aMsgVariables;

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
public System.Collections.ArrayList allMsgVariables()
  {
if (aMsgVariables == null){
    setAllMsgVariables( new System.Collections.ArrayList() );
} // If
    return aMsgVariables;
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
private System.Collections.ArrayList getMsgVariables()
  {
    return allMsgVariables();
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection of elements which replaces 
///        MsgVariables's current content.</param>
public void setAllMsgVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
    NotifyControllers(null);
  }
public void setAllMsgVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="el">a MsgVariable to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(System.Collections.IList)"/>
public void appendMsgVariables(MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendMsgVariables(Lock aLock,MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection ofMsgVariables to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(MsgVariable)"/>
public void appendMsgVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allMsgVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendMsgVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This insertion function inserts a new element in the
/// collection in MsgVariables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertMsgVariables(int idx, MsgVariable el)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertMsgVariables(int idx, MsgVariable el,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfMsgVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allMsgVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteMsgVariables(int idx)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteMsgVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeMsgVariables(IXmlBBase obj)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(null);
   }
  }

public void removeMsgVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>the number of elements in MsgVariables</returns>
public int countMsgVariables()
  {
  return allMsgVariables().Count;
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns an element from the
/// collection in MsgVariables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public MsgVariable getMsgVariables(int idx)
{
  return (MsgVariable) ( allMsgVariables()[idx]);
}

public Message()
{
Message obj = this;
aDescription=(null);
aMedia=(0);
aBl=(null);
aMsgVariables=(null);
}

public void copyTo(Message other)
{
other.aDescription = aDescription;
other.aMedia = aMedia;
other.aBl = aBl;
other.aMsgVariables = aMsgVariables;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
MsgVariable fl1838;

ctxt.skipWhiteSpace();
// Repeat
ctxt.skipWhiteSpace();
fl1838 = null;
while(ctxt.lookAheadOpeningTag ("<MsgVariable")) {
fl1838 = acceptor.lAccept_MsgVariable(ctxt, null);
appendMsgVariables(fl1838);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1849;
bool fl1850;
bool fl1851;
bool fl1852;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1849 = false ; 
fl1850 = false ; 
fl1851 = false ; 
fl1852 = true ; 
while (fl1852) { // BeginLoop 
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("edia=")){
indicator = 1850;
} else {
indicator = 1853;
} // If
break;
} // Case
case 'd':
{
ctxt.advance();
if (ctxt.lookAheadString("escription=")){
indicator = 1849;
} else {
indicator = 1853;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1851;
} else {
indicator = 1853;
} // If
break;
} // Case
default:
indicator = 1853;
break;
} // Switch
switch (indicator) {
case 1849: {
// Handling attribute description
// Also handles alien attributes with prefix description
if (fl1849){
ctxt.fail ("Duplicate attribute: description");
} // If
fl1849 = true ; 
quoteChar = ctxt.acceptQuote();
this.setDescription((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1850: {
// Handling attribute media
// Also handles alien attributes with prefix media
if (fl1850){
ctxt.fail ("Duplicate attribute: media");
} // If
fl1850 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMedia(acceptor.lAcceptEnum_Message_media(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1851: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1851){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1851 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1853: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1849){
ctxt.fail ("Mandatory attribute missing: description in Message");
} // If
if (!fl1850){
ctxt.fail ("Mandatory attribute missing: media in Message");
} // If
fl1852 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</Message>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<Message");
if (typeId){
pw.Write(" xsi:type=\"Message\"");
} // If
pw.Write('\n');
pw.Write(" description=\"");
acceptor.unParsePcData(pw, this.getDescription());
pw.Write('"');
pw.Write('\n');
pw.Write(" media=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_Message_media_ToString(this.getMedia()));
pw.Write('"');
pw.Write('\n');
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</Message>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getMsgVariables(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
for (int i = 0; i < countMsgVariables(); i++) {
  l.Add(getMsgVariables(i));
}
}

}
public partial class MsgVariable
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getName().CompareTo((String) search) == 0)return true;
if(getLength().CompareTo((String) search) == 0)return true;
if(getComment().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.MsgVariableController.alertChange(aLock, this);
}
private   string  aName;

public   string  getName() { return aName;}

public  void setName( string  v) {
  aName = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aLength;

public   string  getLength() { return aLength;}

public  void setLength( string  v) {
  aLength = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aComment;

public   string  getComment() { return aComment;}

public  void setComment( string  v) {
  aComment = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private System.Collections.ArrayList aMsgVariables;

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
public System.Collections.ArrayList allMsgVariables()
  {
if (aMsgVariables == null){
    setAllMsgVariables( new System.Collections.ArrayList() );
} // If
    return aMsgVariables;
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>a collection of all the elements in MsgVariables</returns>
private System.Collections.ArrayList getMsgVariables()
  {
    return allMsgVariables();
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection of elements which replaces 
///        MsgVariables's current content.</param>
public void setAllMsgVariables(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
    NotifyControllers(null);
  }
public void setAllMsgVariables(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aMsgVariables = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="el">a MsgVariable to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(System.Collections.IList)"/>
public void appendMsgVariables(MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendMsgVariables(Lock aLock,MsgVariable el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allMsgVariables().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for MsgVariables</summary>
/// <param name="coll">a collection ofMsgVariables to add to the collection in 
///           MsgVariables</param>
/// <seealso cref="appendMsgVariables(MsgVariable)"/>
public void appendMsgVariables(System.Collections.IList coll)
  {
  __setDirty(true);
  allMsgVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendMsgVariables(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This insertion function inserts a new element in the
/// collection in MsgVariables</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertMsgVariables(int idx, MsgVariable el)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(null);
  }

public void insertMsgVariables(int idx, MsgVariable el,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfMsgVariables(IXmlBBase el)
  {
  return ((System.Collections.IList) allMsgVariables()).IndexOf (el);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteMsgVariables(int idx)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteMsgVariables(int idx,Lock aLock)
  {
  __setDirty(true);
  allMsgVariables().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for MsgVariables
/// This deletion function removes an element from the
/// collection in MsgVariables
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeMsgVariables(IXmlBBase obj)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(null);
   }
  }

public void removeMsgVariables(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfMsgVariables(obj);
  if (idx >= 0) { deleteMsgVariables(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for MsgVariables</summary>
/// <returns>the number of elements in MsgVariables</returns>
public int countMsgVariables()
  {
  return allMsgVariables().Count;
  }

/// <summary>Part of the list interface for MsgVariables
/// This function returns an element from the
/// collection in MsgVariables based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public MsgVariable getMsgVariables(int idx)
{
  return (MsgVariable) ( allMsgVariables()[idx]);
}

public MsgVariable()
{
MsgVariable obj = this;
aName=(null);
aLength=(null);
aComment=(null);
aBl=(null);
aMsgVariables=(null);
}

public void copyTo(MsgVariable other)
{
other.aName = aName;
other.aLength = aLength;
other.aComment = aComment;
other.aBl = aBl;
other.aMsgVariables = aMsgVariables;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
MsgVariable fl1859;

ctxt.skipWhiteSpace();
// Repeat
ctxt.skipWhiteSpace();
fl1859 = null;
while(ctxt.lookAheadOpeningTag ("<MsgVariable")) {
fl1859 = acceptor.lAccept_MsgVariable(ctxt, null);
appendMsgVariables(fl1859);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1870;
bool fl1871;
bool fl1872;
bool fl1873;
bool fl1874;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1870 = false ; 
fl1871 = false ; 
fl1872 = false ; 
fl1873 = false ; 
fl1874 = true ; 
while (fl1874) { // BeginLoop 
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
if (ctxt.lookAheadString("ame=")){
indicator = 1870;
} else {
indicator = 1875;
} // If
break;
} // Case
case 'l':
{
ctxt.advance();
if (ctxt.lookAheadString("ength=")){
indicator = 1871;
} else {
indicator = 1875;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("omment=")){
indicator = 1872;
} else {
indicator = 1875;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1873;
} else {
indicator = 1875;
} // If
break;
} // Case
default:
indicator = 1875;
break;
} // Switch
switch (indicator) {
case 1870: {
// Handling attribute name
// Also handles alien attributes with prefix name
if (fl1870){
ctxt.fail ("Duplicate attribute: name");
} // If
fl1870 = true ; 
quoteChar = ctxt.acceptQuote();
this.setName((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1871: {
// Handling attribute length
// Also handles alien attributes with prefix length
if (fl1871){
ctxt.fail ("Duplicate attribute: length");
} // If
fl1871 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLength((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1872: {
// Handling attribute comment
// Also handles alien attributes with prefix comment
if (fl1872){
ctxt.fail ("Duplicate attribute: comment");
} // If
fl1872 = true ; 
quoteChar = ctxt.acceptQuote();
this.setComment((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1873: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1873){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1873 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1875: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1870){
ctxt.fail ("Mandatory attribute missing: name in MsgVariable");
} // If
if (!fl1872){
ctxt.fail ("Mandatory attribute missing: comment in MsgVariable");
} // If
fl1874 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</MsgVariable>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<MsgVariable");
if (typeId){
pw.Write(" xsi:type=\"MsgVariable\"");
} // If
pw.Write('\n');
pw.Write(" name=\"");
acceptor.unParsePcData(pw, this.getName());
pw.Write('"');
pw.Write('\n');
if (this.getLength() != null){
pw.Write(" length=\"");
acceptor.unParsePcData(pw, this.getLength());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write(" comment=\"");
acceptor.unParsePcData(pw, this.getComment());
pw.Write('"');
pw.Write('\n');
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</MsgVariable>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getMsgVariables(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
for (int i = 0; i < countMsgVariables(); i++) {
  l.Add(getMsgVariables(i));
}
}

}
public partial class TypeSpec
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getMinimum_value().CompareTo((String) search) == 0)return true;
if(getMaximum_value().CompareTo((String) search) == 0)return true;
if(getResolution_formula().CompareTo((String) search) == 0)return true;
if(getId().CompareTo((String) search) == 0)return true;
if(getBl().CompareTo((String) search) == 0)return true;
if(getDescription().CompareTo((String) search) == 0)return true;
if(getShort_description().CompareTo((String) search) == 0)return true;
if(getReference().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.TypeSpecController.alertChange(aLock, this);
}
private  int aLength;

public  int getLength() { return aLength;}

public  void setLength(int v) {
  aLength = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMinimum_value;

public   string  getMinimum_value() { return aMinimum_value;}

public  void setMinimum_value( string  v) {
  aMinimum_value = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aMaximum_value;

public   string  getMaximum_value() { return aMaximum_value;}

public  void setMaximum_value( string  v) {
  aMaximum_value = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aResolution_formula;

public   string  getResolution_formula() { return aResolution_formula;}

public  void setResolution_formula( string  v) {
  aResolution_formula = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aId;

public   string  getId() { return aId;}

public  void setId( string  v) {
  aId = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.TypeSpec_ertms_type aErtms_type;

public  acceptor.TypeSpec_ertms_type getErtms_type() { return aErtms_type;}

public  void setErtms_type(acceptor.TypeSpec_ertms_type v) {
  aErtms_type = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getErtms_type_AsString()
{
  return acceptor.Enum_TypeSpec_ertms_type_ToString (aErtms_type);
}

public  bool setErtms_type_AsString( string  v)
{
 acceptor.TypeSpec_ertms_type  temp = acceptor.StringTo_Enum_TypeSpec_ertms_type(v);
if (temp >= 0){
  aErtms_type = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  Values aValues;

public  Values getValues() { return aValues;}

public  void setValues(Values v) {
  aValues = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  char_value aChar_value;

public  char_value getChar_value() { return aChar_value;}

public  void setChar_value(char_value v) {
  aChar_value = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aDescription;

public   string  getDescription() { return aDescription;}

public  void setDescription( string  v) {
  aDescription = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aShort_description;

public   string  getShort_description() { return aShort_description;}

public  void setShort_description( string  v) {
  aShort_description = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aReference;

public   string  getReference() { return aReference;}

public  void setReference( string  v) {
  aReference = v;
  __setDirty(true);
  NotifyControllers(null);
}


public TypeSpec()
{
TypeSpec obj = this;
aLength=(0);
aMinimum_value=(null);
aMaximum_value=(null);
aResolution_formula=(null);
aId=(null);
aErtms_type=(0);
aBl=(null);
aValues=(null);
aChar_value=(null);
aDescription=(null);
aShort_description=(null);
aReference=(null);
}

public void copyTo(TypeSpec other)
{
other.aLength = aLength;
other.aMinimum_value = aMinimum_value;
other.aMaximum_value = aMaximum_value;
other.aResolution_formula = aResolution_formula;
other.aId = aId;
other.aErtms_type = aErtms_type;
other.aBl = aBl;
other.aValues = aValues;
other.aChar_value = aChar_value;
other.aDescription = aDescription;
other.aShort_description = aShort_description;
other.aReference = aReference;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1881;
bool fl1882;
bool fl1883;
int fl1886;

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<short-description")){
ctxt.skipWhiteSpace();
fl1881 = true ; 
while (fl1881) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1881 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setShort_description(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</short-description>");
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<Description")){
ctxt.skipWhiteSpace();
fl1882 = true ; 
while (fl1882) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1882 = false ; 
} // If
} // While
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
// Indicator
// Parse PC data
this.setDescription(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</Description>");
} // If
} // If
// End enclosed
ctxt.skipWhiteSpace();
// Optional Enclosed
if (ctxt.lookAheadOpeningTag("<reference")){
ctxt.skipWhiteSpace();
fl1883 = true ; 
while (fl1883) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1883 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setReference(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</reference>");
} // If
// End enclosed
// Disjunct
ctxt.skipWhiteSpace();
// Nullable formula
fl1886 = ctxt.getPtr();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
switch (ctxt.current()) {
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("har-value")){
indicator = 1885;
} else {
ctxt.moveBack(1);
indicator = 1887;
} // If
break;
} // Case
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alues")){
indicator = 1884;
} else {
ctxt.moveBack(1);
indicator = 1887;
} // If
break;
} // Case
default:
indicator = 1887;
break;
} // Switch
break;
} // Case
default:
indicator = 1887;
break;
} // Switch
switch (indicator) {
// Dispatch Lablel
case 1884: {
ctxt.moveBack(7);
// Element Ref : Values
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<Values")){
// Parsing sub element
this.setValues(acceptor.lAccept_Values(ctxt,null));
setSon(this.getValues());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Dispatch Lablel
case 1885: {
ctxt.moveBack(11);
// Element Ref : char-value
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<char-value")){
// Parsing sub element
this.setChar_value(acceptor.lAccept_char_value(ctxt,null));
setSon(this.getChar_value());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Optional of PCdata
case 1887: {
ctxt.setPtr(fl1886);
// Doing nothing, optional disj
break;
} // End of dispatch label
} // Dispatch
// End Disjunct
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1892;
bool fl1893;
bool fl1894;
bool fl1895;
bool fl1896;
bool fl1897;
bool fl1898;
bool fl1899;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1892 = false ; 
fl1893 = false ; 
fl1894 = false ; 
fl1895 = false ; 
fl1896 = false ; 
fl1897 = false ; 
fl1898 = false ; 
fl1899 = true ; 
while (fl1899) { // BeginLoop 
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("esolution_formula=")){
indicator = 1895;
} else {
indicator = 1900;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("nimum_value=")){
indicator = 1893;
} else {
indicator = 1900;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("ximum_value=")){
indicator = 1894;
} else {
indicator = 1900;
} // If
break;
} // Case
default:
indicator = 1900;
break;
} // Switch
break;
} // Case
case 'l':
{
ctxt.advance();
if (ctxt.lookAheadString("ength=")){
indicator = 1892;
} else {
indicator = 1900;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAhead2('d','=')){
indicator = 1896;
} else {
indicator = 1900;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("rtms-type=")){
indicator = 1897;
} else {
indicator = 1900;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1898;
} else {
indicator = 1900;
} // If
break;
} // Case
default:
indicator = 1900;
break;
} // Switch
switch (indicator) {
case 1892: {
// Handling attribute length
// Also handles alien attributes with prefix length
if (fl1892){
ctxt.fail ("Duplicate attribute: length");
} // If
fl1892 = true ; 
quoteChar = ctxt.acceptQuote();
this.setLength(ctxt.fetchInteger());
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1893: {
// Handling attribute minimum_value
// Also handles alien attributes with prefix minimum_value
if (fl1893){
ctxt.fail ("Duplicate attribute: minimum_value");
} // If
fl1893 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMinimum_value((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1894: {
// Handling attribute maximum_value
// Also handles alien attributes with prefix maximum_value
if (fl1894){
ctxt.fail ("Duplicate attribute: maximum_value");
} // If
fl1894 = true ; 
quoteChar = ctxt.acceptQuote();
this.setMaximum_value((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1895: {
// Handling attribute resolution_formula
// Also handles alien attributes with prefix resolution_formula
if (fl1895){
ctxt.fail ("Duplicate attribute: resolution_formula");
} // If
fl1895 = true ; 
quoteChar = ctxt.acceptQuote();
this.setResolution_formula((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1896: {
// Handling attribute id
// Also handles alien attributes with prefix id
if (fl1896){
ctxt.fail ("Duplicate attribute: id");
} // If
fl1896 = true ; 
quoteChar = ctxt.acceptQuote();
this.setId((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1897: {
// Handling attribute ertms-type
// Also handles alien attributes with prefix ertms-type
if (fl1897){
ctxt.fail ("Duplicate attribute: ertms-type");
} // If
fl1897 = true ; 
quoteChar = ctxt.acceptQuote();
this.setErtms_type(acceptor.lAcceptEnum_TypeSpec_ertms_type(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1898: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1898){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1898 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1900: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1892){
ctxt.fail ("Mandatory attribute missing: length in TypeSpec");
} // If
fl1899 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</TypeSpec>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<TypeSpec");
if (typeId){
pw.Write(" xsi:type=\"TypeSpec\"");
} // If
pw.Write('\n');
pw.Write(" length=\"");
acceptor.unParsePcData(pw, this.getLength());
pw.Write('"');
pw.Write('\n');
if (this.getMinimum_value() != null){
pw.Write(" minimum_value=\"");
acceptor.unParsePcData(pw, this.getMinimum_value());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getMaximum_value() != null){
pw.Write(" maximum_value=\"");
acceptor.unParsePcData(pw, this.getMaximum_value());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getResolution_formula() != null){
pw.Write(" resolution_formula=\"");
acceptor.unParsePcData(pw, this.getResolution_formula());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getId() != null){
pw.Write(" id=\"");
acceptor.unParsePcData(pw, this.getId());
pw.Write('"');
pw.Write('\n');
} // If
if (this.getErtms_type() != 0){
pw.Write(" ertms-type=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_TypeSpec_ertms_type_ToString(this.getErtms_type()));
pw.Write('"');
pw.Write('\n');
} // If
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</TypeSpec>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Enclosed
// Testing for empty content: Short-description
if (this.getShort_description() != null){
pw.Write("<short-description>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getShort_description());
pw.Write("</short-description>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Short-description
// Unparsing Enclosed
// Testing for empty content: Description
if (this.getDescription() != null){
pw.Write("<Description>");
// Unparsing PcData
if (this.getDescription() != null){
acceptor.unParsePcData(pw, this.getDescription());
} // If
pw.Write("</Description>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Description
// Unparsing Enclosed
// Testing for empty content: Reference
if (this.getReference() != null){
pw.Write("<reference>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getReference());
pw.Write("</reference>");
// Father is not a mixed
pw.Write('\n');
} // If
// After Testing for empty content: Reference
// Unparsing Disjunct
if (this.getValues() != null){
// Unparsing ElementRef
if (this.getValues() != null){
unParse(pw, this.getValues(), false, null, null);
} // If
} else {
if (this.getChar_value() != null){
// Unparsing ElementRef
if (this.getChar_value() != null){
unParse(pw, this.getChar_value(), false, null, null);
} // If
} // If
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
l.Add(this.getValues());
l.Add(this.getChar_value());
}

}
public partial class Values
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ValuesController.alertChange(aLock, this);
}
private  resolution_formula aResolution_formula_1;

public  resolution_formula getResolution_formula_1() { return aResolution_formula_1;}

public  void setResolution_formula_1(resolution_formula v) {
  aResolution_formula_1 = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  special_or_reserved_values aSpecial_or_reserved_values;

public  special_or_reserved_values getSpecial_or_reserved_values() { return aSpecial_or_reserved_values;}

public  void setSpecial_or_reserved_values(special_or_reserved_values v) {
  aSpecial_or_reserved_values = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  special_or_reserved_value aSpecial_or_reserved_value;

public  special_or_reserved_value getSpecial_or_reserved_value() { return aSpecial_or_reserved_value;}

public  void setSpecial_or_reserved_value(special_or_reserved_value v) {
  aSpecial_or_reserved_value = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


public Values()
{
Values obj = this;
aResolution_formula_1=(null);
aSpecial_or_reserved_values=(null);
aSpecial_or_reserved_value=(null);
}

public void copyTo(Values other)
{
other.aResolution_formula_1 = aResolution_formula_1;
other.aSpecial_or_reserved_values = aSpecial_or_reserved_values;
other.aSpecial_or_reserved_value = aSpecial_or_reserved_value;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
int fl1912;

ctxt.skipWhiteSpace();
// Element Ref : resolution-formula
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<resolution-formula")){
// Parsing sub element
this.setResolution_formula_1(acceptor.lAccept_resolution_formula(ctxt,null));
setSon(this.getResolution_formula_1());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Disjunct
ctxt.skipWhiteSpace();
// Nullable formula
fl1912 = ctxt.getPtr();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
if (ctxt.lookAheadString("special-or-reserved-value")){
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
indicator = 1910;
break;
} // Case
default:
indicator = 1911;
break;
} // Switch
} else {
ctxt.moveBack(1);
indicator = 1913;
} // If
break;
} // Case
default:
indicator = 1913;
break;
} // Switch
switch (indicator) {
// Dispatch Lablel
case 1910: {
ctxt.moveBack(27);
// Element Ref : special-or-reserved-values
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<special-or-reserved-values")){
// Parsing sub element
this.setSpecial_or_reserved_values(acceptor.lAccept_special_or_reserved_values(ctxt,null));
setSon(this.getSpecial_or_reserved_values());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Dispatch Lablel
case 1911: {
ctxt.moveBack(26);
// Element Ref : special-or-reserved-value
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<special-or-reserved-value")){
// Parsing sub element
this.setSpecial_or_reserved_value(acceptor.lAccept_special_or_reserved_value(ctxt,null));
setSon(this.getSpecial_or_reserved_value());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Optional of PCdata
case 1913: {
ctxt.setPtr(fl1912);
// Doing nothing, optional disj
break;
} // End of dispatch label
} // Dispatch
// End Disjunct
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1917;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1917 = true ; 
while (fl1917) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1917 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</Values>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<Values");
if (typeId){
pw.Write(" xsi:type=\"Values\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</Values>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing ElementRef
if (this.getResolution_formula_1() != null){
unParse(pw, this.getResolution_formula_1(), false, null, null);
} // If
// Unparsing Disjunct
if (this.getSpecial_or_reserved_values() != null){
// Unparsing ElementRef
if (this.getSpecial_or_reserved_values() != null){
unParse(pw, this.getSpecial_or_reserved_values(), false, null, null);
} // If
} else {
if (this.getSpecial_or_reserved_value() != null){
// Unparsing ElementRef
if (this.getSpecial_or_reserved_value() != null){
unParse(pw, this.getSpecial_or_reserved_value(), false, null, null);
} // If
} // If
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
l.Add(this.getResolution_formula_1());
l.Add(this.getSpecial_or_reserved_values());
l.Add(this.getSpecial_or_reserved_value());
}

}
public partial class special_or_reserved_values
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.special_or_reserved_valuesController.alertChange(aLock, this);
}
private System.Collections.ArrayList aSpecial_or_reserved_values;

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <returns>a collection of all the elements in Special_or_reserved_values</returns>
public System.Collections.ArrayList allSpecial_or_reserved_values()
  {
if (aSpecial_or_reserved_values == null){
    setAllSpecial_or_reserved_values( new System.Collections.ArrayList() );
} // If
    return aSpecial_or_reserved_values;
  }

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <returns>a collection of all the elements in Special_or_reserved_values</returns>
private System.Collections.ArrayList getSpecial_or_reserved_values()
  {
    return allSpecial_or_reserved_values();
  }

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <param name="coll">a collection of elements which replaces 
///        Special_or_reserved_values's current content.</param>
public void setAllSpecial_or_reserved_values(System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecial_or_reserved_values = coll;
    NotifyControllers(null);
  }
public void setAllSpecial_or_reserved_values(Lock aLock,System.Collections.ArrayList coll)
  {
  __setDirty(true);
    aSpecial_or_reserved_values = coll;
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <param name="el">a special_or_reserved_value to add to the collection in 
///           Special_or_reserved_values</param>
/// <seealso cref="appendSpecial_or_reserved_values(System.Collections.IList)"/>
public void appendSpecial_or_reserved_values(special_or_reserved_value el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecial_or_reserved_values().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(null);
  }

public void appendSpecial_or_reserved_values(Lock aLock,special_or_reserved_value el)
  {
  __setDirty(true);
  el.__setDirty(true);
  allSpecial_or_reserved_values().Add(el);
  acceptor.connectSon (this, el);
NotifyControllers(aLock);
  }
/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <param name="coll">a collection ofspecial_or_reserved_values to add to the collection in 
///           Special_or_reserved_values</param>
/// <seealso cref="appendSpecial_or_reserved_values(special_or_reserved_value)"/>
public void appendSpecial_or_reserved_values(System.Collections.IList coll)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(null);
  }

public void appendSpecial_or_reserved_values(System.Collections.IList coll,Lock aLock)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().XmlBAddRange(coll);
  acceptor.connectSons (this, coll);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This insertion function inserts a new element in the
/// collection in Special_or_reserved_values</summary>
/// <param name="idx">the index where the insertion must take place</param>
/// <param name="el">the element to insert</param>
public void insertSpecial_or_reserved_values(int idx, special_or_reserved_value el)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().Insert (idx, el);
NotifyControllers(null);
  }

public void insertSpecial_or_reserved_values(int idx, special_or_reserved_value el,Lock aLock)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().Insert (idx, el);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This function returns the index of an element in
/// the collection.</summary>
/// <param name="el">the object to look for</param>
/// <returns>the index where it is found, or -1 if it is not.</returns>
public int indexOfSpecial_or_reserved_values(IXmlBBase el)
  {
  return ((System.Collections.IList) allSpecial_or_reserved_values()).IndexOf (el);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This deletion function removes an element from the
/// collection in Special_or_reserved_values</summary>
/// <param name="idx">the index of the element to remove</param>
public void deleteSpecial_or_reserved_values(int idx)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().RemoveAt(idx);
NotifyControllers(null);
  }

public void deleteSpecial_or_reserved_values(int idx,Lock aLock)
  {
  __setDirty(true);
  allSpecial_or_reserved_values().RemoveAt(idx);
NotifyControllers(aLock);
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This deletion function removes an element from the
/// collection in Special_or_reserved_values
/// If the object given in parameter is not found in the
/// the collection, this function does nothing.</summary>
/// <param name="obj">the object to remove</param>
public void removeSpecial_or_reserved_values(IXmlBBase obj)
  {
  int idx = indexOfSpecial_or_reserved_values(obj);
  if (idx >= 0) { deleteSpecial_or_reserved_values(idx);
NotifyControllers(null);
   }
  }

public void removeSpecial_or_reserved_values(IXmlBBase obj,Lock aLock)
  {
  int idx = indexOfSpecial_or_reserved_values(obj);
  if (idx >= 0) { deleteSpecial_or_reserved_values(idx);
NotifyControllers(aLock);
  }}

/// <summary>Part of the list interface for Special_or_reserved_values</summary>
/// <returns>the number of elements in Special_or_reserved_values</returns>
public int countSpecial_or_reserved_values()
  {
  return allSpecial_or_reserved_values().Count;
  }

/// <summary>Part of the list interface for Special_or_reserved_values
/// This function returns an element from the
/// collection in Special_or_reserved_values based on an index.</summary>
/// <param name="idx">the index of the element to extract</param>
/// <returns>the extracted element</returns>
public special_or_reserved_value getSpecial_or_reserved_values(int idx)
{
  return (special_or_reserved_value) ( allSpecial_or_reserved_values()[idx]);
}

public special_or_reserved_values()
{
special_or_reserved_values obj = this;
aSpecial_or_reserved_values=(null);
}

public void copyTo(special_or_reserved_values other)
{
other.aSpecial_or_reserved_values = aSpecial_or_reserved_values;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
special_or_reserved_value fl1919;

ctxt.skipWhiteSpace();
// Repeat
ctxt.skipWhiteSpace();
fl1919 = null;
while(ctxt.lookAheadOpeningTag ("<special-or-reserved-value")) {
fl1919 = acceptor.lAccept_special_or_reserved_value(ctxt, null);
appendSpecial_or_reserved_values(fl1919);
ctxt.skipWhiteSpace();
} // -- monomorphic Loop
if (fl1919 == null){
ctxt.fail ("At least one element expected in repetition");
} // If
// EndRepeat
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1930;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1930 = true ; 
while (fl1930) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1930 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</special-or-reserved-values>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<special-or-reserved-values");
if (typeId){
pw.Write(" xsi:type=\"special-or-reserved-values\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</special-or-reserved-values>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Repeat
// Unparsing repetition
unParse(pw, this.getSpecial_or_reserved_values(), false, null, null);
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
for (int i = 0; i < countSpecial_or_reserved_values(); i++) {
  l.Add(getSpecial_or_reserved_values(i));
}
}

}
public partial class special_or_reserved_value
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.special_or_reserved_valueController.alertChange(aLock, this);
}
private  mask aMask;

public  mask getMask() { return aMask;}

public  void setMask(mask v) {
  aMask = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  match aMatch;

public  match getMatch() { return aMatch;}

public  void setMatch(match v) {
  aMatch = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  match_range aMatch_range;

public  match_range getMatch_range() { return aMatch_range;}

public  void setMatch_range(match_range v) {
  aMatch_range = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  meaning aMeaning;

public  meaning getMeaning() { return aMeaning;}

public  void setMeaning(meaning v) {
  aMeaning = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


private  value aValue;

public  value getValue() { return aValue;}

public  void setValue(value v) {
  aValue = v;
  if ( v != null ) { 
    v.setFather(this);
  }
  __setDirty(true);
  NotifyControllers(null);
}


public special_or_reserved_value()
{
special_or_reserved_value obj = this;
aMask=(null);
aMatch=(null);
aMatch_range=(null);
aMeaning=(null);
aValue=(null);
}

public void copyTo(special_or_reserved_value other)
{
other.aMask = aMask;
other.aMatch = aMatch;
other.aMatch_range = aMatch_range;
other.aMeaning = aMeaning;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
int fl1933;

ctxt.skipWhiteSpace();
// Element Ref : mask
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<mask")){
// Parsing sub element
this.setMask(acceptor.lAccept_mask(ctxt,null));
setSon(this.getMask());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Disjunct
ctxt.skipWhiteSpace();
// Nullable formula
fl1933 = ctxt.getPtr();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
if (ctxt.lookAheadString("match")){
switch (ctxt.current()) {
case '-':
{
ctxt.advance();
if (ctxt.lookAheadString("range")){
indicator = 1932;
} else {
ctxt.moveBack(1);
indicator = 1931;
} // If
break;
} // Case
default:
indicator = 1931;
break;
} // Switch
} else {
ctxt.moveBack(1);
indicator = 1934;
} // If
break;
} // Case
default:
indicator = 1934;
break;
} // Switch
switch (indicator) {
// Dispatch Lablel
case 1931: {
ctxt.moveBack(6);
// Element Ref : match
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<match")){
// Parsing sub element
this.setMatch(acceptor.lAccept_match(ctxt,null));
setSon(this.getMatch());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Dispatch Lablel
case 1932: {
ctxt.moveBack(12);
// Element Ref : match-range
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<match-range")){
// Parsing sub element
this.setMatch_range(acceptor.lAccept_match_range(ctxt,null));
setSon(this.getMatch_range());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Optional of PCdata
case 1934: {
ctxt.setPtr(fl1933);
// Doing nothing, optional disj
break;
} // End of dispatch label
} // Dispatch
// End Disjunct
// Element Ref : meaning
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<meaning")){
// Parsing sub element
this.setMeaning(acceptor.lAccept_meaning(ctxt,null));
setSon(this.getMeaning());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
// Element Ref : value
ctxt.skipWhiteSpace();
// If optional...
if (ctxt.lookAheadOpeningTag("<value")){
// Parsing sub element
this.setValue(acceptor.lAccept_value(ctxt,null));
setSon(this.getValue());
// Endif optional...
} // If
ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1938;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1938 = true ; 
while (fl1938) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1938 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</special-or-reserved-value>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<special-or-reserved-value");
if (typeId){
pw.Write(" xsi:type=\"special-or-reserved-value\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</special-or-reserved-value>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing ElementRef
if (this.getMask() != null){
unParse(pw, this.getMask(), false, null, null);
} // If
// Unparsing Disjunct
if (this.getMatch() != null){
// Unparsing ElementRef
if (this.getMatch() != null){
unParse(pw, this.getMatch(), false, null, null);
} // If
} else {
if (this.getMatch_range() != null){
// Unparsing ElementRef
if (this.getMatch_range() != null){
unParse(pw, this.getMatch_range(), false, null, null);
} // If
} // If
} // If
// Unparsing ElementRef
if (this.getMeaning() != null){
unParse(pw, this.getMeaning(), false, null, null);
} // If
// Unparsing ElementRef
if (this.getValue() != null){
unParse(pw, this.getValue(), false, null, null);
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
l.Add(this.getMask());
l.Add(this.getMatch());
l.Add(this.getMatch_range());
l.Add(this.getMeaning());
l.Add(this.getValue());
}

}
public partial class mask
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.maskController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public mask()
{
mask obj = this;
aValue=(null);
}

public void copyTo(mask other)
{
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1939;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1939 = true ; 
while (fl1939) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1939 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</mask>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<mask");
if (typeId){
pw.Write(" xsi:type=\"mask\"");
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</mask>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class match
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.matchController.alertChange(aLock, this);
}
private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public match()
{
match obj = this;
aValue=(null);
}

public void copyTo(match other)
{
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1940;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1940 = true ; 
while (fl1940) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1940 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</match>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<match");
if (typeId){
pw.Write(" xsi:type=\"match\"");
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</match>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class meaning
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getBl().CompareTo((String) search) == 0)return true;
if(getValue().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.meaningController.alertChange(aLock, this);
}
private  acceptor.meaning_type aType;

public  acceptor.meaning_type getType() { return aType;}

public  void setType(acceptor.meaning_type v) {
  aType = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getType_AsString()
{
  return acceptor.Enum_meaning_type_ToString (aType);
}

public  bool setType_AsString( string  v)
{
 acceptor.meaning_type  temp = acceptor.StringTo_Enum_meaning_type(v);
if (temp >= 0){
  aType = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private   string  aBl;

public   string  getBl() { return aBl;}

public  void setBl( string  v) {
  aBl = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aValue;

public   string  getValue() { return aValue;}

public  void setValue( string  v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public meaning()
{
meaning obj = this;
aType=(0);
aBl=(null);
aValue=(null);
}

public void copyTo(meaning other)
{
other.aType = aType;
other.aBl = aBl;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
// Parse PC data
this.setValue(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1941;
bool fl1942;
bool fl1943;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1941 = false ; 
fl1942 = false ; 
fl1943 = true ; 
while (fl1943) { // BeginLoop 
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAheadString("ype=")){
indicator = 1941;
} else {
indicator = 1944;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
if (ctxt.lookAhead2('l','=')){
indicator = 1942;
} else {
indicator = 1944;
} // If
break;
} // Case
default:
indicator = 1944;
break;
} // Switch
switch (indicator) {
case 1941: {
// Handling attribute type
// Also handles alien attributes with prefix type
if (fl1941){
ctxt.fail ("Duplicate attribute: type");
} // If
fl1941 = true ; 
quoteChar = ctxt.acceptQuote();
this.setType(acceptor.lAcceptEnum_meaning_type(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1942: {
// Handling attribute bl
// Also handles alien attributes with prefix bl
if (fl1942){
ctxt.fail ("Duplicate attribute: bl");
} // If
fl1942 = true ; 
quoteChar = ctxt.acceptQuote();
this.setBl((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1944: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1941){
ctxt.fail ("Mandatory attribute missing: type in meaning");
} // If
fl1943 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</meaning>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<meaning");
if (typeId){
pw.Write(" xsi:type=\"meaning\"");
} // If
pw.Write('\n');
pw.Write(" type=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_meaning_type_ToString(this.getType()));
pw.Write('"');
pw.Write('\n');
if (this.getBl() != null){
pw.Write(" bl=\"");
acceptor.unParsePcData(pw, this.getBl());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</meaning>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
if (this.getValue() != null){
acceptor.unParsePcData(pw, this.getValue());
} // If
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class match_range
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getMinimum().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.match_rangeController.alertChange(aLock, this);
}
private   string  aMinimum;

public   string  getMinimum() { return aMinimum;}

public  void setMinimum( string  v) {
  aMinimum = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  acceptor.maximum_Value aMaximum;

public  acceptor.maximum_Value getMaximum() { return aMaximum;}

public  void setMaximum(acceptor.maximum_Value v) {
  aMaximum = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getMaximum_AsString()
{
  return acceptor.Enum_maximum_Value_ToString (aMaximum);
}

public  bool setMaximum_AsString( string  v)
{
 acceptor.maximum_Value  temp = acceptor.StringTo_Enum_maximum_Value(v);
if (temp >= 0){
  aMaximum = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public match_range()
{
match_range obj = this;
aMinimum=(null);
aMaximum=(0);
}

public void copyTo(match_range other)
{
other.aMinimum = aMinimum;
other.aMaximum = aMaximum;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219
bool fl1948;
bool fl1949;

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<minimum");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl1948 = true ; 
while (fl1948) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1948 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
// Parse PC data
this.setMinimum(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</minimum>");
// End enclosed
ctxt.skipWhiteSpace();
// Enclosed
ctxt.acceptString ("<maximum");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
ctxt.skipWhiteSpace();
fl1949 = true ; 
while (fl1949) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1949 = false ; 
} // If
} // While
ctxt.accept('>');
// Indicator
ctxt.skipWhiteSpace();
// Parse PC data
this.setMaximum(acceptor.lAcceptEnum_maximum_Value(ctxt));
// Regexp
ctxt.skipWhiteSpace();
ctxt.acceptString ("</maximum>");
// End enclosed
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1950;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
fl1950 = true ; 
while (fl1950) { // BeginLoop 
ctxt.skipWhiteSpace();
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1950 = false ; 
} // If
} // While
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</match-range>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<match-range");
if (typeId){
pw.Write(" xsi:type=\"match-range\"");
} // If
pw.Write('>');
pw.Write('\n');
unParseBody(pw);
pw.Write("</match-range>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing Enclosed
pw.Write("<minimum>");
// Unparsing PcData
acceptor.unParsePcData(pw, this.getMinimum());
pw.Write("</minimum>");
// Father is not a mixed
pw.Write('\n');
// Unparsing Enclosed
pw.Write("<maximum>");
// Unparsing PcData
acceptor.unParsePcData(pw,
  acceptor.Enum_maximum_Value_ToString(this.getMaximum()));
pw.Write("</maximum>");
// Father is not a mixed
pw.Write('\n');
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class resolution_formula
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.resolution_formulaController.alertChange(aLock, this);
}
private  acceptor.resolution_formula_units aUnits;

public  acceptor.resolution_formula_units getUnits() { return aUnits;}

public  void setUnits(acceptor.resolution_formula_units v) {
  aUnits = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getUnits_AsString()
{
  return acceptor.Enum_resolution_formula_units_ToString (aUnits);
}

public  bool setUnits_AsString( string  v)
{
 acceptor.resolution_formula_units  temp = acceptor.StringTo_Enum_resolution_formula_units(v);
if (temp >= 0){
  aUnits = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

private  acceptor.resolution_formula_Value aValue;

public  acceptor.resolution_formula_Value getValue() { return aValue;}

public  void setValue(acceptor.resolution_formula_Value v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public  string   getValue_AsString()
{
  return acceptor.Enum_resolution_formula_Value_ToString (aValue);
}

public  bool setValue_AsString( string  v)
{
 acceptor.resolution_formula_Value  temp = acceptor.StringTo_Enum_resolution_formula_Value(v);
if (temp >= 0){
  aValue = temp;
  __setDirty(true);
  NotifyControllers(null);
  return true;
} // If
return false;
}

public resolution_formula()
{
resolution_formula obj = this;
aUnits=(0);
aValue=(0);
}

public void copyTo(resolution_formula other)
{
other.aUnits = aUnits;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
ctxt.skipWhiteSpace();
// Parse PC data
this.setValue(acceptor.lAcceptEnum_resolution_formula_Value(ctxt));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1951;
bool fl1952;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1951 = false ; 
fl1952 = true ; 
while (fl1952) { // BeginLoop 
if (ctxt.lookAheadString("units=")){
indicator = 1951;
} else {
indicator = 1953;
} // If
switch (indicator) {
case 1951: {
// Handling attribute units
// Also handles alien attributes with prefix units
if (fl1951){
ctxt.fail ("Duplicate attribute: units");
} // If
fl1951 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUnits(acceptor.lAcceptEnum_resolution_formula_units(ctxt));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1953: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
fl1952 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</resolution-formula>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<resolution-formula");
if (typeId){
pw.Write(" xsi:type=\"resolution-formula\"");
} // If
pw.Write('\n');
if (this.getUnits() != 0){
pw.Write(" units=\"");
acceptor.unParsePcData(pw,
  acceptor.Enum_resolution_formula_units_ToString(this.getUnits()));
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write("</resolution-formula>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw,
  acceptor.Enum_resolution_formula_Value_ToString(this.getValue()));
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class value
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getUnits().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.valueController.alertChange(aLock, this);
}
private   string  aUnits;

public   string  getUnits() { return aUnits;}

public  void setUnits( string  v) {
  aUnits = v;
  __setDirty(true);
  NotifyControllers(null);
}


private  int aValue;

public  int getValue() { return aValue;}

public  void setValue(int v) {
  aValue = v;
  __setDirty(true);
  NotifyControllers(null);
}


public value()
{
value obj = this;
aUnits=(null);
aValue=(0);
}

public void copyTo(value other)
{
other.aUnits = aUnits;
other.aValue = aValue;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

// Indicator
ctxt.skipWhiteSpace();
// Parse PC data
this.setValue(ctxt.fetchInteger());
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1955;
bool fl1956;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1955 = false ; 
fl1956 = true ; 
while (fl1956) { // BeginLoop 
if (ctxt.lookAheadString("units=")){
indicator = 1955;
} else {
indicator = 1957;
} // If
switch (indicator) {
case 1955: {
// Handling attribute units
// Also handles alien attributes with prefix units
if (fl1955){
ctxt.fail ("Duplicate attribute: units");
} // If
fl1955 = true ; 
quoteChar = ctxt.acceptQuote();
this.setUnits((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1957: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1955){
ctxt.fail ("Mandatory attribute missing: units in value");
} // If
fl1956 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</value>");
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<value");
if (typeId){
pw.Write(" xsi:type=\"value\"");
} // If
pw.Write('\n');
pw.Write(" units=\"");
acceptor.unParsePcData(pw, this.getUnits());
pw.Write('"');
pw.Write('\n');
pw.Write('>');
unParseBody(pw);
pw.Write("</value>");
pw.Write('\n');
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

// Unparsing PcData
acceptor.unParsePcData(pw, this.getValue());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class char_value
: XmlBBase
{
public  override  bool find(Object search){
if (search is String ) {
if(getEncoding().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.char_valueController.alertChange(aLock, this);
}
private   string  aEncoding;

public   string  getEncoding() { return aEncoding;}

public  void setEncoding( string  v) {
  aEncoding = v;
  __setDirty(true);
  NotifyControllers(null);
}


public char_value()
{
char_value obj = this;
aEncoding=(null);
}

public void copyTo(char_value other)
{
other.aEncoding = aEncoding;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1959;
bool fl1960;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1959 = false ; 
fl1960 = true ; 
while (fl1960) { // BeginLoop 
if (ctxt.lookAheadString("encoding=")){
indicator = 1959;
} else {
indicator = 1961;
} // If
switch (indicator) {
case 1959: {
// Handling attribute encoding
// Also handles alien attributes with prefix encoding
if (fl1959){
ctxt.fail ("Duplicate attribute: encoding");
} // If
fl1959 = true ; 
quoteChar = ctxt.acceptQuote();
this.setEncoding((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1961: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1959){
ctxt.fail ("Mandatory attribute missing: encoding in char-value");
} // If
fl1960 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
if (ctxt.current() == '/'){
ctxt.advance();
ctxt.accept('>');
} else {
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString ("</char-value>");
// If formula empty
} // If
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

pw.Write("<char-value");
if (typeId){
pw.Write(" xsi:type=\"char-value\"");
} // If
pw.Write('\n');
pw.Write(" encoding=\"");
acceptor.unParsePcData(pw, this.getEncoding());
pw.Write('"');
pw.Write('\n');
pw.Write("/>");
pw.Write('\n');
unParseBody(pw);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
}

}
public partial class ParagraphRevision
: ModelElement
{
public  override  bool find(Object search){
if (search is String ) {
if(getText().CompareTo((String) search) == 0)return true;
if(getVersion().CompareTo((String) search) == 0)return true;
}
return false;
}

public  override  void NotifyControllers(Lock aLock){
	base.NotifyControllers(aLock);
	ControllersManager.ParagraphRevisionController.alertChange(aLock, this);
}
private   string  aText;

public   string  getText() { return aText;}

public  void setText( string  v) {
  aText = v;
  __setDirty(true);
  NotifyControllers(null);
}


private   string  aVersion;

public   string  getVersion() { return aVersion;}

public  void setVersion( string  v) {
  aVersion = v;
  __setDirty(true);
  NotifyControllers(null);
}


public ParagraphRevision()
{
ParagraphRevision obj = this;
aText=(null);
aVersion=(null);
}

public void copyTo(ParagraphRevision other)
{
base.copyTo(other);
other.aText = aText;
other.aVersion = aVersion;
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void parseBody(XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
int indicator=0;
char quoteChar;
 string  tempStr;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
base.parseBody(ctxt);
// Indicator
// Parse PC data
this.setText(acceptor.lAcceptPcData(ctxt, -1, '<',XmlBContext.WS_PRESERVE));
// Regexp
ctxt.skipWhiteSpace();
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  void parse(XmlBContext ctxt,  string  endingTag)

{
#pragma warning disable 0168, 0219
int indicator = 0;
char quoteChar;
 string  tempStr = null;
bool fl1963;
bool fl1964;
bool fl1965;
#pragma warning restore 0168, 0219

ctxt.skipWhiteSpace();
{
// Accept Attributes
fl1963 = false ; 
fl1964 = false ; 
fl1965 = true ; 
while (fl1965) { // BeginLoop 
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
if (ctxt.lookAheadString("ersion=")){
indicator = 1963;
} else {
indicator = 1966;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("uid=")){
indicator = 1964;
} else {
indicator = 1966;
} // If
break;
} // Case
default:
indicator = 1966;
break;
} // Switch
switch (indicator) {
case 1963: {
// Handling attribute version
// Also handles alien attributes with prefix version
if (fl1963){
ctxt.fail ("Duplicate attribute: version");
} // If
fl1963 = true ; 
quoteChar = ctxt.acceptQuote();
this.setVersion((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
case 1964: {
// Handling attribute Guid
// Also handles alien attributes with prefix Guid
if (fl1964){
ctxt.fail ("Duplicate attribute: Guid");
} // If
fl1964 = true ; 
quoteChar = ctxt.acceptQuote();
this.setGuid((acceptor.lAcceptPcData(ctxt,-1, quoteChar, XmlBContext.WS_PRESERVE)));
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
break;
} // End of dispatch label
// Final default label
case 1966: {
// Taking ignorable attributes into account
if (ctxt.isAlNum()){
ctxt.skipTill ('=');
ctxt.advance();
ctxt.skipWhiteSpace();
quoteChar = ctxt.acceptQuote();
ctxt.skipTill (quoteChar);
ctxt.accept(quoteChar);
ctxt.skipWhiteSpace();
} else {
if (!fl1963){
ctxt.fail ("Mandatory attribute missing: version in ParagraphRevision");
} // If
fl1965 = false ; 
} // If
break;
} // End of dispatch label
} // Dispatch
} // While
}
ctxt.skipWhiteSpace();
ctxt.accept('>');
parseBody(ctxt);
ctxt.acceptString(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override  public  void unParse(TextWriter pw,
                    bool typeId,
                     string  headingTag,
                     string  endingTag)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219
if (headingTag == null) {
  headingTag = "<ParagraphRevision";
  endingTag = "</ParagraphRevision>";
}

pw.Write(headingTag);
if (typeId){
pw.Write(" xsi:type=\"ParagraphRevision\"");
} // If
pw.Write('\n');
pw.Write(" version=\"");
acceptor.unParsePcData(pw, this.getVersion());
pw.Write('"');
pw.Write('\n');
if (this.getGuid() != null){
pw.Write(" Guid=\"");
acceptor.unParsePcData(pw, this.getGuid());
pw.Write('"');
pw.Write('\n');
} // If
pw.Write('>');
unParseBody(pw);
pw.Write(endingTag);
}

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
 override public void unParseBody(TextWriter pw)
{
#pragma warning disable 0168, 0219
int i;
#pragma warning restore 0168, 0219

base.unParseBody(pw);
// Unparsing PcData
acceptor.unParsePcData(pw, this.getText());
}
public  override  void dispatch(XmlBBaseVisitor v)
{
  ((Visitor)v).visit(this);
}

public  override  void dispatch(XmlBBaseVisitor v, bool visitSubNodes)
{
  ((Visitor)v).visit(this, visitSubNodes);
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override void subElements(ArrayList l)
{
 base.subElements(l);
}

}
public partial class ControllersManager
{
//BaseModelElement  BaseModelElement
public static Controller<BaseModelElement, IListener<BaseModelElement>> BaseModelElementController = new Controller<BaseModelElement, IListener<BaseModelElement>>();
//Namable  Namable
public static Controller<Namable, IListener<Namable>> NamableController = new Controller<Namable, IListener<Namable>>();
//ReferencesParagraph  ReferencesParagraph
public static Controller<ReferencesParagraph, IListener<ReferencesParagraph>> ReferencesParagraphController = new Controller<ReferencesParagraph, IListener<ReferencesParagraph>>();
//ReqRelated  ReqRelated
public static Controller<ReqRelated, IListener<ReqRelated>> ReqRelatedController = new Controller<ReqRelated, IListener<ReqRelated>>();
//Dictionary  Dictionary
public static Controller<Dictionary, IListener<Dictionary>> DictionaryController = new Controller<Dictionary, IListener<Dictionary>>();
//RuleDisabling  RuleDisabling
public static Controller<RuleDisabling, IListener<RuleDisabling>> RuleDisablingController = new Controller<RuleDisabling, IListener<RuleDisabling>>();
//NameSpaceRef  NameSpaceRef
public static Controller<NameSpaceRef, IListener<NameSpaceRef>> NameSpaceRefController = new Controller<NameSpaceRef, IListener<NameSpaceRef>>();
//NameSpace  NameSpace
public static Controller<NameSpace, IListener<NameSpace>> NameSpaceController = new Controller<NameSpace, IListener<NameSpace>>();
//ReqRef  ReqRef
public static Controller<ReqRef, IListener<ReqRef>> ReqRefController = new Controller<ReqRef, IListener<ReqRef>>();
//Type  Type
public static Controller<Type, IListener<Type>> TypeController = new Controller<Type, IListener<Type>>();
//Enum  Enum
public static Controller<Enum, IListener<Enum>> EnumController = new Controller<Enum, IListener<Enum>>();
//EnumValue  EnumValue
public static Controller<EnumValue, IListener<EnumValue>> EnumValueController = new Controller<EnumValue, IListener<EnumValue>>();
//Range  Range
public static Controller<Range, IListener<Range>> RangeController = new Controller<Range, IListener<Range>>();
//Structure  Structure
public static Controller<Structure, IListener<Structure>> StructureController = new Controller<Structure, IListener<Structure>>();
//StructureRef  StructureRef
public static Controller<StructureRef, IListener<StructureRef>> StructureRefController = new Controller<StructureRef, IListener<StructureRef>>();
//StructureElement  StructureElement
public static Controller<StructureElement, IListener<StructureElement>> StructureElementController = new Controller<StructureElement, IListener<StructureElement>>();
//Collection  Collection
public static Controller<Collection, IListener<Collection>> CollectionController = new Controller<Collection, IListener<Collection>>();
//Function  Function
public static Controller<Function, IListener<Function>> FunctionController = new Controller<Function, IListener<Function>>();
//Parameter  Parameter
public static Controller<Parameter, IListener<Parameter>> ParameterController = new Controller<Parameter, IListener<Parameter>>();
//Case  Case
public static Controller<Case, IListener<Case>> CaseController = new Controller<Case, IListener<Case>>();
//Procedure  Procedure
public static Controller<Procedure, IListener<Procedure>> ProcedureController = new Controller<Procedure, IListener<Procedure>>();
//StateMachine  StateMachine
public static Controller<StateMachine, IListener<StateMachine>> StateMachineController = new Controller<StateMachine, IListener<StateMachine>>();
//State  State
public static Controller<State, IListener<State>> StateController = new Controller<State, IListener<State>>();
//Variable  Variable
public static Controller<Variable, IListener<Variable>> VariableController = new Controller<Variable, IListener<Variable>>();
//Rule  Rule
public static Controller<Rule, IListener<Rule>> RuleController = new Controller<Rule, IListener<Rule>>();
//RuleCondition  RuleCondition
public static Controller<RuleCondition, IListener<RuleCondition>> RuleConditionController = new Controller<RuleCondition, IListener<RuleCondition>>();
//PreCondition  PreCondition
public static Controller<PreCondition, IListener<PreCondition>> PreConditionController = new Controller<PreCondition, IListener<PreCondition>>();
//Action  Action
public static Controller<Action, IListener<Action>> ActionController = new Controller<Action, IListener<Action>>();
//FrameRef  FrameRef
public static Controller<FrameRef, IListener<FrameRef>> FrameRefController = new Controller<FrameRef, IListener<FrameRef>>();
//Frame  Frame
public static Controller<Frame, IListener<Frame>> FrameController = new Controller<Frame, IListener<Frame>>();
//SubSequence  SubSequence
public static Controller<SubSequence, IListener<SubSequence>> SubSequenceController = new Controller<SubSequence, IListener<SubSequence>>();
//TestCase  TestCase
public static Controller<TestCase, IListener<TestCase>> TestCaseController = new Controller<TestCase, IListener<TestCase>>();
//Step  Step
public static Controller<Step, IListener<Step>> StepController = new Controller<Step, IListener<Step>>();
//SubStep  SubStep
public static Controller<SubStep, IListener<SubStep>> SubStepController = new Controller<SubStep, IListener<SubStep>>();
//Expectation  Expectation
public static Controller<Expectation, IListener<Expectation>> ExpectationController = new Controller<Expectation, IListener<Expectation>>();
//DBMessage  DBMessage
public static Controller<DBMessage, IListener<DBMessage>> DBMessageController = new Controller<DBMessage, IListener<DBMessage>>();
//DBPacket  DBPacket
public static Controller<DBPacket, IListener<DBPacket>> DBPacketController = new Controller<DBPacket, IListener<DBPacket>>();
//DBField  DBField
public static Controller<DBField, IListener<DBField>> DBFieldController = new Controller<DBField, IListener<DBField>>();
//TranslationDictionary  TranslationDictionary
public static Controller<TranslationDictionary, IListener<TranslationDictionary>> TranslationDictionaryController = new Controller<TranslationDictionary, IListener<TranslationDictionary>>();
//Folder  Folder
public static Controller<Folder, IListener<Folder>> FolderController = new Controller<Folder, IListener<Folder>>();
//Translation  Translation
public static Controller<Translation, IListener<Translation>> TranslationController = new Controller<Translation, IListener<Translation>>();
//SourceText  SourceText
public static Controller<SourceText, IListener<SourceText>> SourceTextController = new Controller<SourceText, IListener<SourceText>>();
//SourceTextComment  SourceTextComment
public static Controller<SourceTextComment, IListener<SourceTextComment>> SourceTextCommentController = new Controller<SourceTextComment, IListener<SourceTextComment>>();
//ShortcutDictionary  ShortcutDictionary
public static Controller<ShortcutDictionary, IListener<ShortcutDictionary>> ShortcutDictionaryController = new Controller<ShortcutDictionary, IListener<ShortcutDictionary>>();
//ShortcutFolder  ShortcutFolder
public static Controller<ShortcutFolder, IListener<ShortcutFolder>> ShortcutFolderController = new Controller<ShortcutFolder, IListener<ShortcutFolder>>();
//Shortcut  Shortcut
public static Controller<Shortcut, IListener<Shortcut>> ShortcutController = new Controller<Shortcut, IListener<Shortcut>>();
//RequirementSet  RequirementSet
public static Controller<RequirementSet, IListener<RequirementSet>> RequirementSetController = new Controller<RequirementSet, IListener<RequirementSet>>();
//RequirementSetDependancy  RequirementSetDependancy
public static Controller<RequirementSetDependancy, IListener<RequirementSetDependancy>> RequirementSetDependancyController = new Controller<RequirementSetDependancy, IListener<RequirementSetDependancy>>();
//Specification  Specification
public static Controller<Specification, IListener<Specification>> SpecificationController = new Controller<Specification, IListener<Specification>>();
//ChapterRef  ChapterRef
public static Controller<ChapterRef, IListener<ChapterRef>> ChapterRefController = new Controller<ChapterRef, IListener<ChapterRef>>();
//Chapter  Chapter
public static Controller<Chapter, IListener<Chapter>> ChapterController = new Controller<Chapter, IListener<Chapter>>();
//Paragraph  Paragraph
public static Controller<Paragraph, IListener<Paragraph>> ParagraphController = new Controller<Paragraph, IListener<Paragraph>>();
//RequirementSetReference  RequirementSetReference
public static Controller<RequirementSetReference, IListener<RequirementSetReference>> RequirementSetReferenceController = new Controller<RequirementSetReference, IListener<RequirementSetReference>>();
//Message  Message
public static Controller<Message, IListener<Message>> MessageController = new Controller<Message, IListener<Message>>();
//MsgVariable  MsgVariable
public static Controller<MsgVariable, IListener<MsgVariable>> MsgVariableController = new Controller<MsgVariable, IListener<MsgVariable>>();
//TypeSpec  TypeSpec
public static Controller<TypeSpec, IListener<TypeSpec>> TypeSpecController = new Controller<TypeSpec, IListener<TypeSpec>>();
//Values  Values
public static Controller<Values, IListener<Values>> ValuesController = new Controller<Values, IListener<Values>>();
//special-or-reserved-values  special_or_reserved_values
public static Controller<special_or_reserved_values, IListener<special_or_reserved_values>> special_or_reserved_valuesController = new Controller<special_or_reserved_values, IListener<special_or_reserved_values>>();
//special-or-reserved-value  special_or_reserved_value
public static Controller<special_or_reserved_value, IListener<special_or_reserved_value>> special_or_reserved_valueController = new Controller<special_or_reserved_value, IListener<special_or_reserved_value>>();
//mask  mask
public static Controller<mask, IListener<mask>> maskController = new Controller<mask, IListener<mask>>();
//match  match
public static Controller<match, IListener<match>> matchController = new Controller<match, IListener<match>>();
//meaning  meaning
public static Controller<meaning, IListener<meaning>> meaningController = new Controller<meaning, IListener<meaning>>();
//match-range  match_range
public static Controller<match_range, IListener<match_range>> match_rangeController = new Controller<match_range, IListener<match_range>>();
//resolution-formula  resolution_formula
public static Controller<resolution_formula, IListener<resolution_formula>> resolution_formulaController = new Controller<resolution_formula, IListener<resolution_formula>>();
//value  value
public static Controller<value, IListener<value>> valueController = new Controller<value, IListener<value>>();
//char-value  char_value
public static Controller<char_value, IListener<char_value>> char_valueController = new Controller<char_value, IListener<char_value>>();
//ParagraphRevision  ParagraphRevision
public static Controller<ParagraphRevision, IListener<ParagraphRevision>> ParagraphRevisionController = new Controller<ParagraphRevision, IListener<ParagraphRevision>>();
public static void ActivateAllNotifications(){
BaseModelElementController.ActivateNotification();
NamableController.ActivateNotification();
ReferencesParagraphController.ActivateNotification();
ReqRelatedController.ActivateNotification();
DictionaryController.ActivateNotification();
RuleDisablingController.ActivateNotification();
NameSpaceRefController.ActivateNotification();
NameSpaceController.ActivateNotification();
ReqRefController.ActivateNotification();
TypeController.ActivateNotification();
EnumController.ActivateNotification();
EnumValueController.ActivateNotification();
RangeController.ActivateNotification();
StructureController.ActivateNotification();
StructureRefController.ActivateNotification();
StructureElementController.ActivateNotification();
CollectionController.ActivateNotification();
FunctionController.ActivateNotification();
ParameterController.ActivateNotification();
CaseController.ActivateNotification();
ProcedureController.ActivateNotification();
StateMachineController.ActivateNotification();
StateController.ActivateNotification();
VariableController.ActivateNotification();
RuleController.ActivateNotification();
RuleConditionController.ActivateNotification();
PreConditionController.ActivateNotification();
ActionController.ActivateNotification();
FrameRefController.ActivateNotification();
FrameController.ActivateNotification();
SubSequenceController.ActivateNotification();
TestCaseController.ActivateNotification();
StepController.ActivateNotification();
SubStepController.ActivateNotification();
ExpectationController.ActivateNotification();
DBMessageController.ActivateNotification();
DBPacketController.ActivateNotification();
DBFieldController.ActivateNotification();
TranslationDictionaryController.ActivateNotification();
FolderController.ActivateNotification();
TranslationController.ActivateNotification();
SourceTextController.ActivateNotification();
SourceTextCommentController.ActivateNotification();
ShortcutDictionaryController.ActivateNotification();
ShortcutFolderController.ActivateNotification();
ShortcutController.ActivateNotification();
RequirementSetController.ActivateNotification();
RequirementSetDependancyController.ActivateNotification();
SpecificationController.ActivateNotification();
ChapterRefController.ActivateNotification();
ChapterController.ActivateNotification();
ParagraphController.ActivateNotification();
RequirementSetReferenceController.ActivateNotification();
MessageController.ActivateNotification();
MsgVariableController.ActivateNotification();
TypeSpecController.ActivateNotification();
ValuesController.ActivateNotification();
special_or_reserved_valuesController.ActivateNotification();
special_or_reserved_valueController.ActivateNotification();
maskController.ActivateNotification();
matchController.ActivateNotification();
meaningController.ActivateNotification();
match_rangeController.ActivateNotification();
resolution_formulaController.ActivateNotification();
valueController.ActivateNotification();
char_valueController.ActivateNotification();
ParagraphRevisionController.ActivateNotification();
}
public static void DesactivateAllNotifications(){
BaseModelElementController.DesactivateNotification();
NamableController.DesactivateNotification();
ReferencesParagraphController.DesactivateNotification();
ReqRelatedController.DesactivateNotification();
DictionaryController.DesactivateNotification();
RuleDisablingController.DesactivateNotification();
NameSpaceRefController.DesactivateNotification();
NameSpaceController.DesactivateNotification();
ReqRefController.DesactivateNotification();
TypeController.DesactivateNotification();
EnumController.DesactivateNotification();
EnumValueController.DesactivateNotification();
RangeController.DesactivateNotification();
StructureController.DesactivateNotification();
StructureRefController.DesactivateNotification();
StructureElementController.DesactivateNotification();
CollectionController.DesactivateNotification();
FunctionController.DesactivateNotification();
ParameterController.DesactivateNotification();
CaseController.DesactivateNotification();
ProcedureController.DesactivateNotification();
StateMachineController.DesactivateNotification();
StateController.DesactivateNotification();
VariableController.DesactivateNotification();
RuleController.DesactivateNotification();
RuleConditionController.DesactivateNotification();
PreConditionController.DesactivateNotification();
ActionController.DesactivateNotification();
FrameRefController.DesactivateNotification();
FrameController.DesactivateNotification();
SubSequenceController.DesactivateNotification();
TestCaseController.DesactivateNotification();
StepController.DesactivateNotification();
SubStepController.DesactivateNotification();
ExpectationController.DesactivateNotification();
DBMessageController.DesactivateNotification();
DBPacketController.DesactivateNotification();
DBFieldController.DesactivateNotification();
TranslationDictionaryController.DesactivateNotification();
FolderController.DesactivateNotification();
TranslationController.DesactivateNotification();
SourceTextController.DesactivateNotification();
SourceTextCommentController.DesactivateNotification();
ShortcutDictionaryController.DesactivateNotification();
ShortcutFolderController.DesactivateNotification();
ShortcutController.DesactivateNotification();
RequirementSetController.DesactivateNotification();
RequirementSetDependancyController.DesactivateNotification();
SpecificationController.DesactivateNotification();
ChapterRefController.DesactivateNotification();
ChapterController.DesactivateNotification();
ParagraphController.DesactivateNotification();
RequirementSetReferenceController.DesactivateNotification();
MessageController.DesactivateNotification();
MsgVariableController.DesactivateNotification();
TypeSpecController.DesactivateNotification();
ValuesController.DesactivateNotification();
special_or_reserved_valuesController.DesactivateNotification();
special_or_reserved_valueController.DesactivateNotification();
maskController.DesactivateNotification();
matchController.DesactivateNotification();
meaningController.DesactivateNotification();
match_rangeController.DesactivateNotification();
resolution_formulaController.DesactivateNotification();
valueController.DesactivateNotification();
char_valueController.DesactivateNotification();
ParagraphRevisionController.DesactivateNotification();
}
}
public partial class acceptor
: XmlBBaseAcceptor
{

public enum Paragraph_type {
     defaultParagraph_type,
     aTITLE,
     aDEFINITION,
     aNOTE,
     aDELETED,
     aREQUIREMENT,
     aTABLE_HEADER,
     aPROBLEM
};

public enum Paragraph_scope {
     defaultParagraph_scope,
     aOBU_AND_TRACK,
     aTRACK,
     aOBU,
     aROLLING_STOCK,
     aFLAGS
};

public enum Message_media {
     defaultMessage_media,
     aBalise_RBC,
     aAny,
     aRBC,
     aBalise,
     aBalise_loop_RIU,
     aLoop,
     aBalise_RBC_RIU,
     aAny_,
     aRIU,
     aRBC_RIU,
     aBalise_loop
};

public enum TypeSpec_ertms_type {
     defaultTypeSpec_ertms_type,
     adistance,
     agradient,
     alength,
     amiscellaneous,
     aclass_number,
     aidentity_number,
     aqualifier,
     atime_or_date,
     aspeed,
     atext
};

public enum meaning_type {
     defaultmeaning_type,
     ainvalid,
     aenum,
     aunknown,
     ainfinite
};

public enum maximum_Value {
     defaultmaximum_Value,
     a11,
     a15,
     a127,
     a1022,
     a255,
     aC_7,
     a1_55,
     a126,
     aE,
     a254,
     a125
};

public enum resolution_formula_units {
     defaultresolution_formula_units,
     m_s2,
     q_scale,
     percent,
     abyte,
     abit,
     text_string_element,
     m,
     A,
     s,
     ms,
     km_h
};

public enum resolution_formula_Value {
     defaultresolution_formula_Value,
     a0_05,
     aC_1,
     a10,
     a0_02,
     aintegers,
     aNumbers,
     aBinary_Coded_Decimal,
     aNumber,
     aBitset,
     aC_5
};

public enum VariableModeEnumType {
     defaultVariableModeEnumType,
     aIncoming,
     aOutgoing,
     aInternal,
     aInOut,
     aConstant
};

public enum MessageEnumType {
     defaultMessageEnumType,
     aEurobalise,
     aEuroloop,
     aValidatedTrainData,
     aRequestForShunting,
     aMARequest,
     aTrainPositionReport,
     aRequestToShortenMAIsGranted,
     aRequestToShortenMAIsRejected,
     aAcknowledgement,
     aAcknowledgementOfEmergencyStop,
     aTrackAheadFreeGranted,
     aEndOfMission,
     aRadioInFillRequest,
     aTrain_NoCompatibleVersionSupported,
     aTrain_InitiationOfACommunicationSession,
     aTrain_TerminationOfACommunicationSession,
     aSoMPositionReport,
     aTrain_SessionEstablished,
     aSRAuthorization,
     aMovementAuthority,
     aRecognitionOfExitFromTripMode,
     aAcknowledgementOfTrainData,
     aRequestToShortenMA,
     aConditionalEmergencyStop,
     aUnconditionalEmergencyStop,
     aRevocationOfEmergencyStop,
     aGeneralMessage,
     aSHRefused,
     aSHAuthorized,
     aRBCRIUSystemVersion,
     aMAWithShiftedLocationReference,
     aTrackAheadFreeRequest,
     aInFillMA,
     aTrack_InitiationOfACommunicationSession,
     aAcknowledgementOfTerminationOfACommunicationSession,
     aTrainRejected,
     aTrainAccepted,
     aSomPositionReportConfirmedByRBC,
     aAssignmentOfCoordinateSystem
};

public enum MessageDirectionEnumType {
     defaultMessageDirectionEnumType,
     aTrainToTrack,
     aTrackToTrain
};

public enum SPEC_IMPLEMENTED_ENUM {
     defaultSPEC_IMPLEMENTED_ENUM,
     Impl_NA,
     Impl_Implemented,
     Impl_NotImplementable,
     Impl_NewRevisionAvailable
};

public enum ST_IO {
     defaultST_IO,
     StIO_NA,
     StIO_In,
     StIO_Out
};

public enum ST_INTERFACE {
     defaultST_INTERFACE,
     StInterface_NA,
     StInterface_DMI,
     StInterface_RTM,
     StInterface_JRU,
     StInterface_TIU
};

public enum ST_LEVEL {
     defaultST_LEVEL,
     StLevel_NA,
     StLevel_L0,
     StLevel_L1,
     StLevel_LSTM,
     StLevel_L2,
     StLevel_L3
};

public enum ST_MODE {
     defaultST_MODE,
     Mode_NA,
     Mode_IS,
     Mode_NP,
     Mode_SF,
     Mode_SL,
     Mode_SB,
     Mode_SH,
     Mode_FS,
     Mode_UF,
     Mode_SR,
     Mode_OS,
     Mode_TR,
     Mode_PT,
     Mode_NL,
     Mode_SN,
     Mode_RE,
     Mode_LS,
     Mode_PSH
};

public enum RulePriority {
     defaultRulePriority,
     aVerification,
     aUpdateINTERNAL,
     aProcessing,
     aUpdateOUT,
     aCleanUp
};

public enum PrecisionEnum {
     defaultPrecisionEnum,
     aIntegerPrecision,
     aDoublePrecision
};

public enum DBMessageType {
     defaultDBMessageType,
     aEUROBALISE,
     aEUROLOOP,
     aEURORADIO
};

public enum ExpectationKind {
     defaultExpectationKind,
     aInstantaneous,
     aContinuous
};

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Paragraph_type lAcceptEnum_Paragraph_type (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  Paragraph_type res = Paragraph_type.defaultParagraph_type;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
ctxt.accept3('T','L','E');
res = Paragraph_type.aTITLE;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("BLE_HEADER");
res = Paragraph_type.aTABLE_HEADER;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1973)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("EQUIREMENT")){
res = Paragraph_type.aREQUIREMENT;
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("ROBLEM")){
res = Paragraph_type.aPROBLEM;
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead3('O','T','E')){
res = Paragraph_type.aNOTE;
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAhead1('E')){
switch (ctxt.current()) {
case 'L':
{
ctxt.advance();
ctxt.acceptString ("ETED");
res = Paragraph_type.aDELETED;
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.acceptString ("INITION");
res = Paragraph_type.aDEFINITION;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1980)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Paragraph_type.aREQUIREMENT;
} // If
break;
} // Case
default:
res = Paragraph_type.aREQUIREMENT;
break;
} // Switch
return res;
}

public static  string  Enum_Paragraph_type_ToString (Paragraph_type v)
{
switch (v) {
 case Paragraph_type.aTITLE: return "TITLE";
 case Paragraph_type.aDEFINITION: return "DEFINITION";
 case Paragraph_type.aNOTE: return "NOTE";
 case Paragraph_type.aDELETED: return "DELETED";
 case Paragraph_type.aREQUIREMENT: return "REQUIREMENT";
 case Paragraph_type.aTABLE_HEADER: return "TABLE_HEADER";
 case Paragraph_type.aPROBLEM: return "PROBLEM";
} return "";
}

public static Paragraph_type StringTo_Enum_Paragraph_type( string  str)
{
if (str.Equals("TITLE")){
  return Paragraph_type.aTITLE;
} // If
if (str.Equals("DEFINITION")){
  return Paragraph_type.aDEFINITION;
} // If
if (str.Equals("NOTE")){
  return Paragraph_type.aNOTE;
} // If
if (str.Equals("DELETED")){
  return Paragraph_type.aDELETED;
} // If
if (str.Equals("REQUIREMENT")){
  return Paragraph_type.aREQUIREMENT;
} // If
if (str.Equals("TABLE_HEADER")){
  return Paragraph_type.aTABLE_HEADER;
} // If
if (str.Equals("PROBLEM")){
  return Paragraph_type.aPROBLEM;
} // If
return Paragraph_type.defaultParagraph_type;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Paragraph_scope lAcceptEnum_Paragraph_scope (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  Paragraph_scope res = Paragraph_scope.defaultParagraph_scope;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("RACK")){
res = Paragraph_scope.aTRACK;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("OLLING_STOCK")){
res = Paragraph_scope.aROLLING_STOCK;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead2('B','U')){
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
if (ctxt.lookAheadString("AND_TRACK")){
res = Paragraph_scope.aOBU_AND_TRACK;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU;
} // If
break;
} // Case
default:
res = Paragraph_scope.aOBU;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("LAGS")){
res = Paragraph_scope.aFLAGS;
} else {
ctxt.moveBack(1);
res = Paragraph_scope.aOBU_AND_TRACK;
} // If
break;
} // Case
default:
res = Paragraph_scope.aOBU_AND_TRACK;
break;
} // Switch
return res;
}

public static  string  Enum_Paragraph_scope_ToString (Paragraph_scope v)
{
switch (v) {
 case Paragraph_scope.aOBU_AND_TRACK: return "OBU_AND_TRACK";
 case Paragraph_scope.aTRACK: return "TRACK";
 case Paragraph_scope.aOBU: return "OBU";
 case Paragraph_scope.aROLLING_STOCK: return "ROLLING_STOCK";
 case Paragraph_scope.aFLAGS: return "FLAGS";
} return "";
}

public static Paragraph_scope StringTo_Enum_Paragraph_scope( string  str)
{
if (str.Equals("OBU_AND_TRACK")){
  return Paragraph_scope.aOBU_AND_TRACK;
} // If
if (str.Equals("TRACK")){
  return Paragraph_scope.aTRACK;
} // If
if (str.Equals("OBU")){
  return Paragraph_scope.aOBU;
} // If
if (str.Equals("ROLLING_STOCK")){
  return Paragraph_scope.aROLLING_STOCK;
} // If
if (str.Equals("FLAGS")){
  return Paragraph_scope.aFLAGS;
} // If
return Paragraph_scope.defaultParagraph_scope;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Message_media lAcceptEnum_Message_media (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  Message_media res = Message_media.defaultMessage_media;
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
ctxt.accept('U');
res = Message_media.aRIU;
break;
} // Case
case 'B':
{
ctxt.advance();
ctxt.accept('C');
switch (ctxt.current()) {
case ',':
{
ctxt.advance();
if (ctxt.lookAheadString(" RIU")){
res = Message_media.aRBC_RIU;
} else {
ctxt.moveBack(1);
res = Message_media.aRBC;
} // If
break;
} // Case
default:
res = Message_media.aRBC;
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1990)");
break;
} // Switch
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAhead3('o','o','p')){
res = Message_media.aLoop;
} else {
ctxt.moveBack(1);
res = Message_media.aAny_;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
if (ctxt.lookAheadString("alise")){
switch (ctxt.current()) {
case ',':
{
ctxt.advance();
if (ctxt.lookAhead1(' ')){
switch (ctxt.current()) {
case 'l':
{
ctxt.advance();
ctxt.acceptString ("oop, RIU");
res = Message_media.aBalise_loop_RIU;
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.accept2('B','C');
switch (ctxt.current()) {
case ',':
{
ctxt.advance();
if (ctxt.lookAheadString(" RIU")){
res = Message_media.aBalise_RBC_RIU;
} else {
ctxt.moveBack(1);
res = Message_media.aBalise_RBC;
} // If
break;
} // Case
default:
res = Message_media.aBalise_RBC;
break;
} // Switch
break;
} // Case
case 'L':
{
ctxt.advance();
ctxt.accept3('o','o','p');
res = Message_media.aBalise_loop;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (1998)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Message_media.aBalise;
} // If
break;
} // Case
default:
res = Message_media.aBalise;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Message_media.aAny_;
} // If
break;
} // Case
case 'A':
{
ctxt.advance();
if (ctxt.lookAhead2('n','y')){
switch (ctxt.current()) {
case ' ':
{
ctxt.advance();
res = Message_media.aAny_;
break;
} // Case
default:
res = Message_media.aAny;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = Message_media.aAny_;
} // If
break;
} // Case
default:
res = Message_media.aAny_;
break;
} // Switch
return res;
}

public static  string  Enum_Message_media_ToString (Message_media v)
{
switch (v) {
 case Message_media.aBalise_RBC: return "Balise, RBC";
 case Message_media.aAny: return "Any";
 case Message_media.aRBC: return "RBC";
 case Message_media.aBalise: return "Balise";
 case Message_media.aBalise_loop_RIU: return "Balise, loop, RIU";
 case Message_media.aLoop: return "Loop";
 case Message_media.aBalise_RBC_RIU: return "Balise, RBC, RIU";
 case Message_media.aAny_: return "Any ";
 case Message_media.aRIU: return "RIU";
 case Message_media.aRBC_RIU: return "RBC, RIU";
 case Message_media.aBalise_loop: return "Balise, Loop";
} return "";
}

public static Message_media StringTo_Enum_Message_media( string  str)
{
if (str.Equals("Balise, RBC")){
  return Message_media.aBalise_RBC;
} // If
if (str.Equals("Any")){
  return Message_media.aAny;
} // If
if (str.Equals("RBC")){
  return Message_media.aRBC;
} // If
if (str.Equals("Balise")){
  return Message_media.aBalise;
} // If
if (str.Equals("Balise, loop, RIU")){
  return Message_media.aBalise_loop_RIU;
} // If
if (str.Equals("Loop")){
  return Message_media.aLoop;
} // If
if (str.Equals("Balise, RBC, RIU")){
  return Message_media.aBalise_RBC_RIU;
} // If
if (str.Equals("Any ")){
  return Message_media.aAny_;
} // If
if (str.Equals("RIU")){
  return Message_media.aRIU;
} // If
if (str.Equals("RBC, RIU")){
  return Message_media.aRBC_RIU;
} // If
if (str.Equals("Balise, Loop")){
  return Message_media.aBalise_loop;
} // If
return Message_media.defaultMessage_media;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TypeSpec_ertms_type lAcceptEnum_TypeSpec_ertms_type (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  TypeSpec_ertms_type res = TypeSpec_ertms_type.defaultTypeSpec_ertms_type;
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.acceptString ("me-or-date");
res = TypeSpec_ertms_type.atime_or_date;
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.accept2('x','t');
res = TypeSpec_ertms_type.atext;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2004)");
break;
} // Switch
break;
} // Case
case 's':
{
ctxt.advance();
if (ctxt.lookAheadString("peed")){
res = TypeSpec_ertms_type.aspeed;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'q':
{
ctxt.advance();
if (ctxt.lookAheadString("ualifier")){
res = TypeSpec_ertms_type.aqualifier;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("iscellaneous")){
res = TypeSpec_ertms_type.amiscellaneous;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'l':
{
ctxt.advance();
if (ctxt.lookAheadString("ength")){
res = TypeSpec_ertms_type.alength;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("dentity-number")){
res = TypeSpec_ertms_type.aidentity_number;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("radient")){
res = TypeSpec_ertms_type.agradient;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'd':
{
ctxt.advance();
if (ctxt.lookAheadString("istance")){
res = TypeSpec_ertms_type.adistance;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'c':
{
ctxt.advance();
if (ctxt.lookAheadString("lass-number")){
res = TypeSpec_ertms_type.aclass_number;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_TypeSpec_ertms_type_ToString (TypeSpec_ertms_type v)
{
switch (v) {
 case TypeSpec_ertms_type.adistance: return "distance";
 case TypeSpec_ertms_type.agradient: return "gradient";
 case TypeSpec_ertms_type.alength: return "length";
 case TypeSpec_ertms_type.amiscellaneous: return "miscellaneous";
 case TypeSpec_ertms_type.aclass_number: return "class-number";
 case TypeSpec_ertms_type.aidentity_number: return "identity-number";
 case TypeSpec_ertms_type.aqualifier: return "qualifier";
 case TypeSpec_ertms_type.atime_or_date: return "time-or-date";
 case TypeSpec_ertms_type.aspeed: return "speed";
 case TypeSpec_ertms_type.atext: return "text";
} return "";
}

public static TypeSpec_ertms_type StringTo_Enum_TypeSpec_ertms_type( string  str)
{
if (str.Equals("distance")){
  return TypeSpec_ertms_type.adistance;
} // If
if (str.Equals("gradient")){
  return TypeSpec_ertms_type.agradient;
} // If
if (str.Equals("length")){
  return TypeSpec_ertms_type.alength;
} // If
if (str.Equals("miscellaneous")){
  return TypeSpec_ertms_type.amiscellaneous;
} // If
if (str.Equals("class-number")){
  return TypeSpec_ertms_type.aclass_number;
} // If
if (str.Equals("identity-number")){
  return TypeSpec_ertms_type.aidentity_number;
} // If
if (str.Equals("qualifier")){
  return TypeSpec_ertms_type.aqualifier;
} // If
if (str.Equals("time-or-date")){
  return TypeSpec_ertms_type.atime_or_date;
} // If
if (str.Equals("speed")){
  return TypeSpec_ertms_type.aspeed;
} // If
if (str.Equals("text")){
  return TypeSpec_ertms_type.atext;
} // If
return TypeSpec_ertms_type.defaultTypeSpec_ertms_type;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static meaning_type lAcceptEnum_meaning_type (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  meaning_type res = meaning_type.defaultmeaning_type;
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("nknown")){
res = meaning_type.aunknown;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'i':
{
ctxt.advance();
if (ctxt.lookAhead1('n')){
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
ctxt.acceptString ("alid");
res = meaning_type.ainvalid;
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.acceptString ("inite");
res = meaning_type.ainfinite;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2017)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
res = meaning_type.aenum;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_meaning_type_ToString (meaning_type v)
{
switch (v) {
 case meaning_type.ainvalid: return "invalid";
 case meaning_type.aenum: return "enum";
 case meaning_type.aunknown: return "unknown";
 case meaning_type.ainfinite: return "infinite";
} return "";
}

public static meaning_type StringTo_Enum_meaning_type( string  str)
{
if (str.Equals("invalid")){
  return meaning_type.ainvalid;
} // If
if (str.Equals("enum")){
  return meaning_type.aenum;
} // If
if (str.Equals("unknown")){
  return meaning_type.aunknown;
} // If
if (str.Equals("infinite")){
  return meaning_type.ainfinite;
} // If
return meaning_type.defaultmeaning_type;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static maximum_Value lAcceptEnum_maximum_Value (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  maximum_Value res = maximum_Value.defaultmaximum_Value;
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
res = maximum_Value.aE;
break;
} // Case
case '7':
{
ctxt.advance();
res = maximum_Value.aC_7;
break;
} // Case
case '2':
{
ctxt.advance();
if (ctxt.lookAhead1('5')){
switch (ctxt.current()) {
case '5':
{
ctxt.advance();
res = maximum_Value.a255;
break;
} // Case
case '4':
{
ctxt.advance();
res = maximum_Value.a254;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2024)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case '1':
{
ctxt.advance();
switch (ctxt.current()) {
case '5':
{
ctxt.advance();
res = maximum_Value.a15;
break;
} // Case
case '2':
{
ctxt.advance();
switch (ctxt.current()) {
case '7':
{
ctxt.advance();
res = maximum_Value.a127;
break;
} // Case
case '6':
{
ctxt.advance();
res = maximum_Value.a126;
break;
} // Case
case '5':
{
ctxt.advance();
res = maximum_Value.a125;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2031)");
break;
} // Switch
break;
} // Case
case '1':
{
ctxt.advance();
res = maximum_Value.a11;
break;
} // Case
case '0':
{
ctxt.advance();
ctxt.accept2('2','2');
res = maximum_Value.a1022;
break;
} // Case
case '.':
{
ctxt.advance();
ctxt.accept2('5','5');
res = maximum_Value.a1_55;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2035)");
break;
} // Switch
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_maximum_Value_ToString (maximum_Value v)
{
switch (v) {
 case maximum_Value.a11: return "11";
 case maximum_Value.a15: return "15";
 case maximum_Value.a127: return "127";
 case maximum_Value.a1022: return "1022";
 case maximum_Value.a255: return "255";
 case maximum_Value.aC_7: return "7";
 case maximum_Value.a1_55: return "1.55";
 case maximum_Value.a126: return "126";
 case maximum_Value.aE: return "E";
 case maximum_Value.a254: return "254";
 case maximum_Value.a125: return "125";
} return "";
}

public static maximum_Value StringTo_Enum_maximum_Value( string  str)
{
if (str.Equals("11")){
  return maximum_Value.a11;
} // If
if (str.Equals("15")){
  return maximum_Value.a15;
} // If
if (str.Equals("127")){
  return maximum_Value.a127;
} // If
if (str.Equals("1022")){
  return maximum_Value.a1022;
} // If
if (str.Equals("255")){
  return maximum_Value.a255;
} // If
if (str.Equals("7")){
  return maximum_Value.aC_7;
} // If
if (str.Equals("1.55")){
  return maximum_Value.a1_55;
} // If
if (str.Equals("126")){
  return maximum_Value.a126;
} // If
if (str.Equals("E")){
  return maximum_Value.aE;
} // If
if (str.Equals("254")){
  return maximum_Value.a254;
} // If
if (str.Equals("125")){
  return maximum_Value.a125;
} // If
return maximum_Value.defaultmaximum_Value;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static resolution_formula_units lAcceptEnum_resolution_formula_units (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  resolution_formula_units res = resolution_formula_units.defaultresolution_formula_units;
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAheadString("ext-string-element")){
res = resolution_formula_units.text_string_element;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 's':
{
ctxt.advance();
res = resolution_formula_units.s;
break;
} // Case
case 'q':
{
ctxt.advance();
if (ctxt.lookAheadString("_scale")){
res = resolution_formula_units.q_scale;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'm':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
res = resolution_formula_units.ms;
break;
} // Case
case '/':
{
ctxt.advance();
if (ctxt.lookAhead2('s','2')){
res = resolution_formula_units.m_s2;
} else {
ctxt.moveBack(1);
res = resolution_formula_units.m;
} // If
break;
} // Case
default:
res = resolution_formula_units.m;
break;
} // Switch
break;
} // Case
case 'k':
{
ctxt.advance();
if (ctxt.lookAhead3('m','/','h')){
res = resolution_formula_units.km_h;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'b':
{
ctxt.advance();
switch (ctxt.current()) {
case 'y':
{
ctxt.advance();
ctxt.accept2('t','e');
res = resolution_formula_units.abyte;
break;
} // Case
case 'i':
{
ctxt.advance();
ctxt.accept('t');
res = resolution_formula_units.abit;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2046)");
break;
} // Switch
break;
} // Case
case 'A':
{
ctxt.advance();
res = resolution_formula_units.A;
break;
} // Case
case '%':
{
ctxt.advance();
res = resolution_formula_units.percent;
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_resolution_formula_units_ToString (resolution_formula_units v)
{
switch (v) {
 case resolution_formula_units.m_s2: return "m/s2";
 case resolution_formula_units.q_scale: return "q_scale";
 case resolution_formula_units.percent: return "%";
 case resolution_formula_units.abyte: return "byte";
 case resolution_formula_units.abit: return "bit";
 case resolution_formula_units.text_string_element: return "text-string-element";
 case resolution_formula_units.m: return "m";
 case resolution_formula_units.A: return "A";
 case resolution_formula_units.s: return "s";
 case resolution_formula_units.ms: return "ms";
 case resolution_formula_units.km_h: return "km/h";
} return "";
}

public static resolution_formula_units StringTo_Enum_resolution_formula_units( string  str)
{
if (str.Equals("m/s2")){
  return resolution_formula_units.m_s2;
} // If
if (str.Equals("q_scale")){
  return resolution_formula_units.q_scale;
} // If
if (str.Equals("%")){
  return resolution_formula_units.percent;
} // If
if (str.Equals("byte")){
  return resolution_formula_units.abyte;
} // If
if (str.Equals("bit")){
  return resolution_formula_units.abit;
} // If
if (str.Equals("text-string-element")){
  return resolution_formula_units.text_string_element;
} // If
if (str.Equals("m")){
  return resolution_formula_units.m;
} // If
if (str.Equals("A")){
  return resolution_formula_units.A;
} // If
if (str.Equals("s")){
  return resolution_formula_units.s;
} // If
if (str.Equals("ms")){
  return resolution_formula_units.ms;
} // If
if (str.Equals("km/h")){
  return resolution_formula_units.km_h;
} // If
return resolution_formula_units.defaultresolution_formula_units;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static resolution_formula_Value lAcceptEnum_resolution_formula_Value (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  resolution_formula_Value res = resolution_formula_Value.defaultresolution_formula_Value;
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("ntegers")){
res = resolution_formula_Value.aintegers;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("umber")){
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
res = resolution_formula_Value.aNumbers;
break;
} // Case
default:
res = resolution_formula_Value.aNumber;
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
if (ctxt.lookAhead1('i')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
ctxt.accept3('s','e','t');
res = resolution_formula_Value.aBitset;
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.acceptString ("ary Coded Decimal");
res = resolution_formula_Value.aBinary_Coded_Decimal;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2055)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case '5':
{
ctxt.advance();
res = resolution_formula_Value.aC_5;
break;
} // Case
case '1':
{
ctxt.advance();
switch (ctxt.current()) {
case '0':
{
ctxt.advance();
res = resolution_formula_Value.a10;
break;
} // Case
default:
res = resolution_formula_Value.aC_1;
break;
} // Switch
break;
} // Case
case '0':
{
ctxt.advance();
if (ctxt.lookAhead2('.','0')){
switch (ctxt.current()) {
case '5':
{
ctxt.advance();
res = resolution_formula_Value.a0_05;
break;
} // Case
case '2':
{
ctxt.advance();
res = resolution_formula_Value.a0_02;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2062)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_resolution_formula_Value_ToString (resolution_formula_Value v)
{
switch (v) {
 case resolution_formula_Value.a0_05: return "0.05";
 case resolution_formula_Value.aC_1: return "1";
 case resolution_formula_Value.a10: return "10";
 case resolution_formula_Value.a0_02: return "0.02";
 case resolution_formula_Value.aintegers: return "integers";
 case resolution_formula_Value.aNumbers: return "Numbers";
 case resolution_formula_Value.aBinary_Coded_Decimal: return "Binary Coded Decimal";
 case resolution_formula_Value.aNumber: return "Number";
 case resolution_formula_Value.aBitset: return "Bitset";
 case resolution_formula_Value.aC_5: return "5";
} return "";
}

public static resolution_formula_Value StringTo_Enum_resolution_formula_Value( string  str)
{
if (str.Equals("0.05")){
  return resolution_formula_Value.a0_05;
} // If
if (str.Equals("1")){
  return resolution_formula_Value.aC_1;
} // If
if (str.Equals("10")){
  return resolution_formula_Value.a10;
} // If
if (str.Equals("0.02")){
  return resolution_formula_Value.a0_02;
} // If
if (str.Equals("integers")){
  return resolution_formula_Value.aintegers;
} // If
if (str.Equals("Numbers")){
  return resolution_formula_Value.aNumbers;
} // If
if (str.Equals("Binary Coded Decimal")){
  return resolution_formula_Value.aBinary_Coded_Decimal;
} // If
if (str.Equals("Number")){
  return resolution_formula_Value.aNumber;
} // If
if (str.Equals("Bitset")){
  return resolution_formula_Value.aBitset;
} // If
if (str.Equals("5")){
  return resolution_formula_Value.aC_5;
} // If
return resolution_formula_Value.defaultresolution_formula_Value;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static VariableModeEnumType lAcceptEnum_VariableModeEnumType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  VariableModeEnumType res = VariableModeEnumType.defaultVariableModeEnumType;
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAheadString("utgoing")){
res = VariableModeEnumType.aOutgoing;
} else {
ctxt.moveBack(1);
res = VariableModeEnumType.aInternal;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('n')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
ctxt.acceptString ("ernal");
res = VariableModeEnumType.aInternal;
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("oming");
res = VariableModeEnumType.aIncoming;
break;
} // Case
case 'O':
{
ctxt.advance();
ctxt.accept2('u','t');
res = VariableModeEnumType.aInOut;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2068)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = VariableModeEnumType.aInternal;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("onstant")){
res = VariableModeEnumType.aConstant;
} else {
ctxt.moveBack(1);
res = VariableModeEnumType.aInternal;
} // If
break;
} // Case
default:
res = VariableModeEnumType.aInternal;
break;
} // Switch
return res;
}

public static  string  Enum_VariableModeEnumType_ToString (VariableModeEnumType v)
{
switch (v) {
 case VariableModeEnumType.aIncoming: return "Incoming";
 case VariableModeEnumType.aOutgoing: return "Outgoing";
 case VariableModeEnumType.aInternal: return "Internal";
 case VariableModeEnumType.aInOut: return "InOut";
 case VariableModeEnumType.aConstant: return "Constant";
} return "";
}

public static VariableModeEnumType StringTo_Enum_VariableModeEnumType( string  str)
{
if (str.Equals("Incoming")){
  return VariableModeEnumType.aIncoming;
} // If
if (str.Equals("Outgoing")){
  return VariableModeEnumType.aOutgoing;
} // If
if (str.Equals("Internal")){
  return VariableModeEnumType.aInternal;
} // If
if (str.Equals("InOut")){
  return VariableModeEnumType.aInOut;
} // If
if (str.Equals("Constant")){
  return VariableModeEnumType.aConstant;
} // If
return VariableModeEnumType.defaultVariableModeEnumType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static MessageEnumType lAcceptEnum_MessageEnumType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  MessageEnumType res = MessageEnumType.defaultMessageEnumType;
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alidatedTrainData")){
res = MessageEnumType.aValidatedTrainData;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("nconditionalEmergencyStop")){
res = MessageEnumType.aUnconditionalEmergencyStop;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.accept('n');
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
ctxt.acceptString ("erminationOfACommunicationSession");
res = MessageEnumType.aTrain_TerminationOfACommunicationSession;
break;
} // Case
case 'S':
{
ctxt.advance();
ctxt.acceptString ("essionEstablished");
res = MessageEnumType.aTrain_SessionEstablished;
break;
} // Case
case 'N':
{
ctxt.advance();
ctxt.acceptString ("oCompatibleVersionSupported");
res = MessageEnumType.aTrain_NoCompatibleVersionSupported;
break;
} // Case
case 'I':
{
ctxt.advance();
ctxt.acceptString ("nitiationOfACommunicationSession");
res = MessageEnumType.aTrain_InitiationOfACommunicationSession;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2079)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.acceptString ("ejected");
res = MessageEnumType.aTrainRejected;
break;
} // Case
case 'P':
{
ctxt.advance();
ctxt.acceptString ("ositionReport");
res = MessageEnumType.aTrainPositionReport;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("ccepted");
res = MessageEnumType.aTrainAccepted;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2083)");
break;
} // Switch
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.accept('k');
switch (ctxt.current()) {
case '_':
{
ctxt.advance();
ctxt.acceptString ("InitiationOfACommunicationSession");
res = MessageEnumType.aTrack_InitiationOfACommunicationSession;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("headFree");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("equest");
res = MessageEnumType.aTrackAheadFreeRequest;
break;
} // Case
case 'G':
{
ctxt.advance();
ctxt.acceptString ("ranted");
res = MessageEnumType.aTrackAheadFreeGranted;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2089)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2090)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2091)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
ctxt.acceptString ("PositionReportConfirmedByRBC");
res = MessageEnumType.aSomPositionReportConfirmedByRBC;
break;
} // Case
case 'M':
{
ctxt.advance();
ctxt.acceptString ("PositionReport");
res = MessageEnumType.aSoMPositionReport;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2096)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.acceptString ("Authorization");
res = MessageEnumType.aSRAuthorization;
break;
} // Case
case 'H':
{
ctxt.advance();
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("efused");
res = MessageEnumType.aSHRefused;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("uthorized");
res = MessageEnumType.aSHAuthorized;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2101)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2102)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
switch (ctxt.current()) {
case 'v':
{
ctxt.advance();
ctxt.acceptString ("ocationOfEmergencyStop");
res = MessageEnumType.aRevocationOfEmergencyStop;
break;
} // Case
case 'q':
{
ctxt.advance();
ctxt.acceptString ("uest");
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
ctxt.acceptString ("oShortenMA");
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('s')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("ejected");
res = MessageEnumType.aRequestToShortenMAIsRejected;
break;
} // Case
case 'G':
{
ctxt.advance();
ctxt.acceptString ("ranted");
res = MessageEnumType.aRequestToShortenMAIsGranted;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2111)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = MessageEnumType.aRequestToShortenMA;
} // If
break;
} // Case
default:
res = MessageEnumType.aRequestToShortenMA;
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.acceptString ("orShunting");
res = MessageEnumType.aRequestForShunting;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2113)");
break;
} // Switch
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("ognitionOfExitFromTripMode");
res = MessageEnumType.aRecognitionOfExitFromTripMode;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2115)");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.acceptString ("dioInFillRequest");
res = MessageEnumType.aRadioInFillRequest;
break;
} // Case
case 'B':
{
ctxt.advance();
ctxt.acceptString ("CRIUSystemVersion");
res = MessageEnumType.aRBCRIUSystemVersion;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2118)");
break;
} // Switch
break;
} // Case
case 'M':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("vementAuthority");
res = MessageEnumType.aMovementAuthority;
break;
} // Case
case 'A':
{
ctxt.advance();
switch (ctxt.current()) {
case 'W':
{
ctxt.advance();
ctxt.acceptString ("ithShiftedLocationReference");
res = MessageEnumType.aMAWithShiftedLocationReference;
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.acceptString ("equest");
res = MessageEnumType.aMARequest;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2124)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2125)");
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("nFillMA")){
res = MessageEnumType.aInFillMA;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'G':
{
ctxt.advance();
if (ctxt.lookAheadString("eneralMessage")){
res = MessageEnumType.aGeneralMessage;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.accept2('r','o');
switch (ctxt.current()) {
case 'l':
{
ctxt.advance();
ctxt.accept3('o','o','p');
res = MessageEnumType.aEuroloop;
break;
} // Case
case 'b':
{
ctxt.advance();
ctxt.acceptString ("alise");
res = MessageEnumType.aEurobalise;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2132)");
break;
} // Switch
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.acceptString ("dOfMission");
res = MessageEnumType.aEndOfMission;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2134)");
break;
} // Switch
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("onditionalEmergencyStop")){
res = MessageEnumType.aConditionalEmergencyStop;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'A':
{
ctxt.advance();
switch (ctxt.current()) {
case 's':
{
ctxt.advance();
ctxt.acceptString ("signmentOfCoordinateSystem");
res = MessageEnumType.aAssignmentOfCoordinateSystem;
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("knowledgement");
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead1('f')){
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.acceptString ("ainData");
res = MessageEnumType.aAcknowledgementOfTrainData;
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("rminationOfACommunicationSession");
res = MessageEnumType.aAcknowledgementOfTerminationOfACommunicationSession;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2143)");
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
ctxt.acceptString ("mergencyStop");
res = MessageEnumType.aAcknowledgementOfEmergencyStop;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2145)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = MessageEnumType.aAcknowledgement;
} // If
break;
} // Case
default:
res = MessageEnumType.aAcknowledgement;
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2146)");
break;
} // Switch
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_MessageEnumType_ToString (MessageEnumType v)
{
switch (v) {
 case MessageEnumType.aEurobalise: return "Eurobalise";
 case MessageEnumType.aEuroloop: return "Euroloop";
 case MessageEnumType.aValidatedTrainData: return "ValidatedTrainData";
 case MessageEnumType.aRequestForShunting: return "RequestForShunting";
 case MessageEnumType.aMARequest: return "MARequest";
 case MessageEnumType.aTrainPositionReport: return "TrainPositionReport";
 case MessageEnumType.aRequestToShortenMAIsGranted: return "RequestToShortenMAIsGranted";
 case MessageEnumType.aRequestToShortenMAIsRejected: return "RequestToShortenMAIsRejected";
 case MessageEnumType.aAcknowledgement: return "Acknowledgement";
 case MessageEnumType.aAcknowledgementOfEmergencyStop: return "AcknowledgementOfEmergencyStop";
 case MessageEnumType.aTrackAheadFreeGranted: return "TrackAheadFreeGranted";
 case MessageEnumType.aEndOfMission: return "EndOfMission";
 case MessageEnumType.aRadioInFillRequest: return "RadioInFillRequest";
 case MessageEnumType.aTrain_NoCompatibleVersionSupported: return "Train_NoCompatibleVersionSupported";
 case MessageEnumType.aTrain_InitiationOfACommunicationSession: return "Train_InitiationOfACommunicationSession";
 case MessageEnumType.aTrain_TerminationOfACommunicationSession: return "Train_TerminationOfACommunicationSession";
 case MessageEnumType.aSoMPositionReport: return "SoMPositionReport";
 case MessageEnumType.aTrain_SessionEstablished: return "Train_SessionEstablished";
 case MessageEnumType.aSRAuthorization: return "SRAuthorization";
 case MessageEnumType.aMovementAuthority: return "MovementAuthority";
 case MessageEnumType.aRecognitionOfExitFromTripMode: return "RecognitionOfExitFromTripMode";
 case MessageEnumType.aAcknowledgementOfTrainData: return "AcknowledgementOfTrainData";
 case MessageEnumType.aRequestToShortenMA: return "RequestToShortenMA";
 case MessageEnumType.aConditionalEmergencyStop: return "ConditionalEmergencyStop";
 case MessageEnumType.aUnconditionalEmergencyStop: return "UnconditionalEmergencyStop";
 case MessageEnumType.aRevocationOfEmergencyStop: return "RevocationOfEmergencyStop";
 case MessageEnumType.aGeneralMessage: return "GeneralMessage";
 case MessageEnumType.aSHRefused: return "SHRefused";
 case MessageEnumType.aSHAuthorized: return "SHAuthorized";
 case MessageEnumType.aRBCRIUSystemVersion: return "RBCRIUSystemVersion";
 case MessageEnumType.aMAWithShiftedLocationReference: return "MAWithShiftedLocationReference";
 case MessageEnumType.aTrackAheadFreeRequest: return "TrackAheadFreeRequest";
 case MessageEnumType.aInFillMA: return "InFillMA";
 case MessageEnumType.aTrack_InitiationOfACommunicationSession: return "Track_InitiationOfACommunicationSession";
 case MessageEnumType.aAcknowledgementOfTerminationOfACommunicationSession: return "AcknowledgementOfTerminationOfACommunicationSession";
 case MessageEnumType.aTrainRejected: return "TrainRejected";
 case MessageEnumType.aTrainAccepted: return "TrainAccepted";
 case MessageEnumType.aSomPositionReportConfirmedByRBC: return "SomPositionReportConfirmedByRBC";
 case MessageEnumType.aAssignmentOfCoordinateSystem: return "AssignmentOfCoordinateSystem";
} return "";
}

public static MessageEnumType StringTo_Enum_MessageEnumType( string  str)
{
if (str.Equals("Eurobalise")){
  return MessageEnumType.aEurobalise;
} // If
if (str.Equals("Euroloop")){
  return MessageEnumType.aEuroloop;
} // If
if (str.Equals("ValidatedTrainData")){
  return MessageEnumType.aValidatedTrainData;
} // If
if (str.Equals("RequestForShunting")){
  return MessageEnumType.aRequestForShunting;
} // If
if (str.Equals("MARequest")){
  return MessageEnumType.aMARequest;
} // If
if (str.Equals("TrainPositionReport")){
  return MessageEnumType.aTrainPositionReport;
} // If
if (str.Equals("RequestToShortenMAIsGranted")){
  return MessageEnumType.aRequestToShortenMAIsGranted;
} // If
if (str.Equals("RequestToShortenMAIsRejected")){
  return MessageEnumType.aRequestToShortenMAIsRejected;
} // If
if (str.Equals("Acknowledgement")){
  return MessageEnumType.aAcknowledgement;
} // If
if (str.Equals("AcknowledgementOfEmergencyStop")){
  return MessageEnumType.aAcknowledgementOfEmergencyStop;
} // If
if (str.Equals("TrackAheadFreeGranted")){
  return MessageEnumType.aTrackAheadFreeGranted;
} // If
if (str.Equals("EndOfMission")){
  return MessageEnumType.aEndOfMission;
} // If
if (str.Equals("RadioInFillRequest")){
  return MessageEnumType.aRadioInFillRequest;
} // If
if (str.Equals("Train_NoCompatibleVersionSupported")){
  return MessageEnumType.aTrain_NoCompatibleVersionSupported;
} // If
if (str.Equals("Train_InitiationOfACommunicationSession")){
  return MessageEnumType.aTrain_InitiationOfACommunicationSession;
} // If
if (str.Equals("Train_TerminationOfACommunicationSession")){
  return MessageEnumType.aTrain_TerminationOfACommunicationSession;
} // If
if (str.Equals("SoMPositionReport")){
  return MessageEnumType.aSoMPositionReport;
} // If
if (str.Equals("Train_SessionEstablished")){
  return MessageEnumType.aTrain_SessionEstablished;
} // If
if (str.Equals("SRAuthorization")){
  return MessageEnumType.aSRAuthorization;
} // If
if (str.Equals("MovementAuthority")){
  return MessageEnumType.aMovementAuthority;
} // If
if (str.Equals("RecognitionOfExitFromTripMode")){
  return MessageEnumType.aRecognitionOfExitFromTripMode;
} // If
if (str.Equals("AcknowledgementOfTrainData")){
  return MessageEnumType.aAcknowledgementOfTrainData;
} // If
if (str.Equals("RequestToShortenMA")){
  return MessageEnumType.aRequestToShortenMA;
} // If
if (str.Equals("ConditionalEmergencyStop")){
  return MessageEnumType.aConditionalEmergencyStop;
} // If
if (str.Equals("UnconditionalEmergencyStop")){
  return MessageEnumType.aUnconditionalEmergencyStop;
} // If
if (str.Equals("RevocationOfEmergencyStop")){
  return MessageEnumType.aRevocationOfEmergencyStop;
} // If
if (str.Equals("GeneralMessage")){
  return MessageEnumType.aGeneralMessage;
} // If
if (str.Equals("SHRefused")){
  return MessageEnumType.aSHRefused;
} // If
if (str.Equals("SHAuthorized")){
  return MessageEnumType.aSHAuthorized;
} // If
if (str.Equals("RBCRIUSystemVersion")){
  return MessageEnumType.aRBCRIUSystemVersion;
} // If
if (str.Equals("MAWithShiftedLocationReference")){
  return MessageEnumType.aMAWithShiftedLocationReference;
} // If
if (str.Equals("TrackAheadFreeRequest")){
  return MessageEnumType.aTrackAheadFreeRequest;
} // If
if (str.Equals("InFillMA")){
  return MessageEnumType.aInFillMA;
} // If
if (str.Equals("Track_InitiationOfACommunicationSession")){
  return MessageEnumType.aTrack_InitiationOfACommunicationSession;
} // If
if (str.Equals("AcknowledgementOfTerminationOfACommunicationSession")){
  return MessageEnumType.aAcknowledgementOfTerminationOfACommunicationSession;
} // If
if (str.Equals("TrainRejected")){
  return MessageEnumType.aTrainRejected;
} // If
if (str.Equals("TrainAccepted")){
  return MessageEnumType.aTrainAccepted;
} // If
if (str.Equals("SomPositionReportConfirmedByRBC")){
  return MessageEnumType.aSomPositionReportConfirmedByRBC;
} // If
if (str.Equals("AssignmentOfCoordinateSystem")){
  return MessageEnumType.aAssignmentOfCoordinateSystem;
} // If
return MessageEnumType.defaultMessageEnumType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static MessageDirectionEnumType lAcceptEnum_MessageDirectionEnumType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  MessageDirectionEnumType res = MessageDirectionEnumType.defaultMessageDirectionEnumType;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.acceptString ("nToTrack");
res = MessageDirectionEnumType.aTrainToTrack;
break;
} // Case
case 'c':
{
ctxt.advance();
ctxt.acceptString ("kToTrain");
res = MessageDirectionEnumType.aTrackToTrain;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2150)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_MessageDirectionEnumType_ToString (MessageDirectionEnumType v)
{
switch (v) {
 case MessageDirectionEnumType.aTrainToTrack: return "TrainToTrack";
 case MessageDirectionEnumType.aTrackToTrain: return "TrackToTrain";
} return "";
}

public static MessageDirectionEnumType StringTo_Enum_MessageDirectionEnumType( string  str)
{
if (str.Equals("TrainToTrack")){
  return MessageDirectionEnumType.aTrainToTrack;
} // If
if (str.Equals("TrackToTrain")){
  return MessageDirectionEnumType.aTrackToTrain;
} // If
return MessageDirectionEnumType.defaultMessageDirectionEnumType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SPEC_IMPLEMENTED_ENUM lAcceptEnum_SPEC_IMPLEMENTED_ENUM (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  SPEC_IMPLEMENTED_ENUM res = SPEC_IMPLEMENTED_ENUM.defaultSPEC_IMPLEMENTED_ENUM;
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("tImplementable");
res = SPEC_IMPLEMENTED_ENUM.Impl_NotImplementable;
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("wRevisionAvailable");
res = SPEC_IMPLEMENTED_ENUM.Impl_NewRevisionAvailable;
break;
} // Case
case 'A':
{
ctxt.advance();
res = SPEC_IMPLEMENTED_ENUM.Impl_NA;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2155)");
break;
} // Switch
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("mplemented")){
res = SPEC_IMPLEMENTED_ENUM.Impl_Implemented;
} else {
ctxt.moveBack(1);
res = SPEC_IMPLEMENTED_ENUM.Impl_NA;
} // If
break;
} // Case
default:
res = SPEC_IMPLEMENTED_ENUM.Impl_NA;
break;
} // Switch
return res;
}

public static  string  Enum_SPEC_IMPLEMENTED_ENUM_ToString (SPEC_IMPLEMENTED_ENUM v)
{
switch (v) {
 case SPEC_IMPLEMENTED_ENUM.Impl_NA: return "NA";
 case SPEC_IMPLEMENTED_ENUM.Impl_Implemented: return "Implemented";
 case SPEC_IMPLEMENTED_ENUM.Impl_NotImplementable: return "NotImplementable";
 case SPEC_IMPLEMENTED_ENUM.Impl_NewRevisionAvailable: return "NewRevisionAvailable";
} return "";
}

public static SPEC_IMPLEMENTED_ENUM StringTo_Enum_SPEC_IMPLEMENTED_ENUM( string  str)
{
if (str.Equals("NA")){
  return SPEC_IMPLEMENTED_ENUM.Impl_NA;
} // If
if (str.Equals("Implemented")){
  return SPEC_IMPLEMENTED_ENUM.Impl_Implemented;
} // If
if (str.Equals("NotImplementable")){
  return SPEC_IMPLEMENTED_ENUM.Impl_NotImplementable;
} // If
if (str.Equals("NewRevisionAvailable")){
  return SPEC_IMPLEMENTED_ENUM.Impl_NewRevisionAvailable;
} // If
return SPEC_IMPLEMENTED_ENUM.defaultSPEC_IMPLEMENTED_ENUM;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_IO lAcceptEnum_ST_IO (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_IO res = ST_IO.defaultST_IO;
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead2('u','t')){
res = ST_IO.StIO_Out;
} else {
ctxt.moveBack(1);
res = ST_IO.StIO_NA;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead1('A')){
res = ST_IO.StIO_NA;
} else {
ctxt.moveBack(1);
res = ST_IO.StIO_NA;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('n')){
res = ST_IO.StIO_In;
} else {
ctxt.moveBack(1);
res = ST_IO.StIO_NA;
} // If
break;
} // Case
default:
res = ST_IO.StIO_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_IO_ToString (ST_IO v)
{
switch (v) {
 case ST_IO.StIO_NA: return "NA";
 case ST_IO.StIO_In: return "In";
 case ST_IO.StIO_Out: return "Out";
} return "";
}

public static ST_IO StringTo_Enum_ST_IO( string  str)
{
if (str.Equals("NA")){
  return ST_IO.StIO_NA;
} // If
if (str.Equals("In")){
  return ST_IO.StIO_In;
} // If
if (str.Equals("Out")){
  return ST_IO.StIO_Out;
} // If
return ST_IO.defaultST_IO;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_INTERFACE lAcceptEnum_ST_INTERFACE (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_INTERFACE res = ST_INTERFACE.defaultST_INTERFACE;
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead2('I','U')){
res = ST_INTERFACE.StInterface_TIU;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('T','M')){
res = ST_INTERFACE.StInterface_RTM;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead1('A')){
res = ST_INTERFACE.StInterface_NA;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'J':
{
ctxt.advance();
if (ctxt.lookAhead2('R','U')){
res = ST_INTERFACE.StInterface_JRU;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAhead2('M','I')){
res = ST_INTERFACE.StInterface_DMI;
} else {
ctxt.moveBack(1);
res = ST_INTERFACE.StInterface_NA;
} // If
break;
} // Case
default:
res = ST_INTERFACE.StInterface_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_INTERFACE_ToString (ST_INTERFACE v)
{
switch (v) {
 case ST_INTERFACE.StInterface_NA: return "NA";
 case ST_INTERFACE.StInterface_DMI: return "DMI";
 case ST_INTERFACE.StInterface_RTM: return "RTM";
 case ST_INTERFACE.StInterface_JRU: return "JRU";
 case ST_INTERFACE.StInterface_TIU: return "TIU";
} return "";
}

public static ST_INTERFACE StringTo_Enum_ST_INTERFACE( string  str)
{
if (str.Equals("NA")){
  return ST_INTERFACE.StInterface_NA;
} // If
if (str.Equals("DMI")){
  return ST_INTERFACE.StInterface_DMI;
} // If
if (str.Equals("RTM")){
  return ST_INTERFACE.StInterface_RTM;
} // If
if (str.Equals("JRU")){
  return ST_INTERFACE.StInterface_JRU;
} // If
if (str.Equals("TIU")){
  return ST_INTERFACE.StInterface_TIU;
} // If
return ST_INTERFACE.defaultST_INTERFACE;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_LEVEL lAcceptEnum_ST_LEVEL (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_LEVEL res = ST_LEVEL.defaultST_LEVEL;
switch (ctxt.current()) {
case 'N':
{
ctxt.advance();
if (ctxt.lookAhead1('A')){
res = ST_LEVEL.StLevel_NA;
} else {
ctxt.moveBack(1);
res = ST_LEVEL.StLevel_NA;
} // If
break;
} // Case
case 'L':
{
ctxt.advance();
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
ctxt.accept2('T','M');
res = ST_LEVEL.StLevel_LSTM;
break;
} // Case
case '3':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L3;
break;
} // Case
case '2':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L2;
break;
} // Case
case '1':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L1;
break;
} // Case
case '0':
{
ctxt.advance();
res = ST_LEVEL.StLevel_L0;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2172)");
break;
} // Switch
break;
} // Case
default:
res = ST_LEVEL.StLevel_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_LEVEL_ToString (ST_LEVEL v)
{
switch (v) {
 case ST_LEVEL.StLevel_NA: return "NA";
 case ST_LEVEL.StLevel_L0: return "L0";
 case ST_LEVEL.StLevel_L1: return "L1";
 case ST_LEVEL.StLevel_LSTM: return "LSTM";
 case ST_LEVEL.StLevel_L2: return "L2";
 case ST_LEVEL.StLevel_L3: return "L3";
} return "";
}

public static ST_LEVEL StringTo_Enum_ST_LEVEL( string  str)
{
if (str.Equals("NA")){
  return ST_LEVEL.StLevel_NA;
} // If
if (str.Equals("L0")){
  return ST_LEVEL.StLevel_L0;
} // If
if (str.Equals("L1")){
  return ST_LEVEL.StLevel_L1;
} // If
if (str.Equals("LSTM")){
  return ST_LEVEL.StLevel_LSTM;
} // If
if (str.Equals("L2")){
  return ST_LEVEL.StLevel_L2;
} // If
if (str.Equals("L3")){
  return ST_LEVEL.StLevel_L3;
} // If
return ST_LEVEL.defaultST_LEVEL;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ST_MODE lAcceptEnum_ST_MODE (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ST_MODE res = ST_MODE.defaultST_MODE;
switch (ctxt.current()) {
case 'U':
{
ctxt.advance();
if (ctxt.lookAhead1('F')){
res = ST_MODE.Mode_UF;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAhead1('R')){
res = ST_MODE.Mode_TR;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
res = ST_MODE.Mode_SR;
break;
} // Case
case 'N':
{
ctxt.advance();
res = ST_MODE.Mode_SN;
break;
} // Case
case 'L':
{
ctxt.advance();
res = ST_MODE.Mode_SL;
break;
} // Case
case 'H':
{
ctxt.advance();
res = ST_MODE.Mode_SH;
break;
} // Case
case 'F':
{
ctxt.advance();
res = ST_MODE.Mode_SF;
break;
} // Case
case 'B':
{
ctxt.advance();
res = ST_MODE.Mode_SB;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2182)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead1('E')){
res = ST_MODE.Mode_RE;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'T':
{
ctxt.advance();
res = ST_MODE.Mode_PT;
break;
} // Case
case 'S':
{
ctxt.advance();
ctxt.accept('H');
res = ST_MODE.Mode_PSH;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2187)");
break;
} // Switch
break;
} // Case
case 'O':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_OS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
res = ST_MODE.Mode_NP;
break;
} // Case
case 'L':
{
ctxt.advance();
res = ST_MODE.Mode_NL;
break;
} // Case
case 'A':
{
ctxt.advance();
res = ST_MODE.Mode_NA;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2193)");
break;
} // Switch
break;
} // Case
case 'L':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_LS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'I':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_IS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = ST_MODE.Mode_FS;
} else {
ctxt.moveBack(1);
res = ST_MODE.Mode_NA;
} // If
break;
} // Case
default:
res = ST_MODE.Mode_NA;
break;
} // Switch
return res;
}

public static  string  Enum_ST_MODE_ToString (ST_MODE v)
{
switch (v) {
 case ST_MODE.Mode_NA: return "NA";
 case ST_MODE.Mode_IS: return "IS";
 case ST_MODE.Mode_NP: return "NP";
 case ST_MODE.Mode_SF: return "SF";
 case ST_MODE.Mode_SL: return "SL";
 case ST_MODE.Mode_SB: return "SB";
 case ST_MODE.Mode_SH: return "SH";
 case ST_MODE.Mode_FS: return "FS";
 case ST_MODE.Mode_UF: return "UF";
 case ST_MODE.Mode_SR: return "SR";
 case ST_MODE.Mode_OS: return "OS";
 case ST_MODE.Mode_TR: return "TR";
 case ST_MODE.Mode_PT: return "PT";
 case ST_MODE.Mode_NL: return "NL";
 case ST_MODE.Mode_SN: return "SN";
 case ST_MODE.Mode_RE: return "RE";
 case ST_MODE.Mode_LS: return "LS";
 case ST_MODE.Mode_PSH: return "PSH";
} return "";
}

public static ST_MODE StringTo_Enum_ST_MODE( string  str)
{
if (str.Equals("NA")){
  return ST_MODE.Mode_NA;
} // If
if (str.Equals("IS")){
  return ST_MODE.Mode_IS;
} // If
if (str.Equals("NP")){
  return ST_MODE.Mode_NP;
} // If
if (str.Equals("SF")){
  return ST_MODE.Mode_SF;
} // If
if (str.Equals("SL")){
  return ST_MODE.Mode_SL;
} // If
if (str.Equals("SB")){
  return ST_MODE.Mode_SB;
} // If
if (str.Equals("SH")){
  return ST_MODE.Mode_SH;
} // If
if (str.Equals("FS")){
  return ST_MODE.Mode_FS;
} // If
if (str.Equals("UF")){
  return ST_MODE.Mode_UF;
} // If
if (str.Equals("SR")){
  return ST_MODE.Mode_SR;
} // If
if (str.Equals("OS")){
  return ST_MODE.Mode_OS;
} // If
if (str.Equals("TR")){
  return ST_MODE.Mode_TR;
} // If
if (str.Equals("PT")){
  return ST_MODE.Mode_PT;
} // If
if (str.Equals("NL")){
  return ST_MODE.Mode_NL;
} // If
if (str.Equals("SN")){
  return ST_MODE.Mode_SN;
} // If
if (str.Equals("RE")){
  return ST_MODE.Mode_RE;
} // If
if (str.Equals("LS")){
  return ST_MODE.Mode_LS;
} // If
if (str.Equals("PSH")){
  return ST_MODE.Mode_PSH;
} // If
return ST_MODE.defaultST_MODE;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RulePriority lAcceptEnum_RulePriority (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  RulePriority res = RulePriority.defaultRulePriority;
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("erification")){
res = RulePriority.aVerification;
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
case 'U':
{
ctxt.advance();
if (ctxt.lookAheadString("pdate")){
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
ctxt.accept2('U','T');
res = RulePriority.aUpdateOUT;
break;
} // Case
case 'I':
{
ctxt.advance();
ctxt.acceptString ("NTERNAL");
res = RulePriority.aUpdateINTERNAL;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2201)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("rocessing")){
res = RulePriority.aProcessing;
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("leanUp")){
res = RulePriority.aCleanUp;
} else {
ctxt.moveBack(1);
res = RulePriority.aProcessing;
} // If
break;
} // Case
default:
res = RulePriority.aProcessing;
break;
} // Switch
return res;
}

public static  string  Enum_RulePriority_ToString (RulePriority v)
{
switch (v) {
 case RulePriority.aVerification: return "Verification";
 case RulePriority.aUpdateINTERNAL: return "UpdateINTERNAL";
 case RulePriority.aProcessing: return "Processing";
 case RulePriority.aUpdateOUT: return "UpdateOUT";
 case RulePriority.aCleanUp: return "CleanUp";
} return "";
}

public static RulePriority StringTo_Enum_RulePriority( string  str)
{
if (str.Equals("Verification")){
  return RulePriority.aVerification;
} // If
if (str.Equals("UpdateINTERNAL")){
  return RulePriority.aUpdateINTERNAL;
} // If
if (str.Equals("Processing")){
  return RulePriority.aProcessing;
} // If
if (str.Equals("UpdateOUT")){
  return RulePriority.aUpdateOUT;
} // If
if (str.Equals("CleanUp")){
  return RulePriority.aCleanUp;
} // If
return RulePriority.defaultRulePriority;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static PrecisionEnum lAcceptEnum_PrecisionEnum (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  PrecisionEnum res = PrecisionEnum.defaultPrecisionEnum;
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("ntegerPrecision")){
res = PrecisionEnum.aIntegerPrecision;
} else {
ctxt.moveBack(1);
res = PrecisionEnum.aIntegerPrecision;
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("oublePrecision")){
res = PrecisionEnum.aDoublePrecision;
} else {
ctxt.moveBack(1);
res = PrecisionEnum.aIntegerPrecision;
} // If
break;
} // Case
default:
res = PrecisionEnum.aIntegerPrecision;
break;
} // Switch
return res;
}

public static  string  Enum_PrecisionEnum_ToString (PrecisionEnum v)
{
switch (v) {
 case PrecisionEnum.aIntegerPrecision: return "IntegerPrecision";
 case PrecisionEnum.aDoublePrecision: return "DoublePrecision";
} return "";
}

public static PrecisionEnum StringTo_Enum_PrecisionEnum( string  str)
{
if (str.Equals("IntegerPrecision")){
  return PrecisionEnum.aIntegerPrecision;
} // If
if (str.Equals("DoublePrecision")){
  return PrecisionEnum.aDoublePrecision;
} // If
return PrecisionEnum.defaultPrecisionEnum;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBMessageType lAcceptEnum_DBMessageType (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  DBMessageType res = DBMessageType.defaultDBMessageType;
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('U','R','O')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
ctxt.acceptString ("ADIO");
res = DBMessageType.aEURORADIO;
break;
} // Case
case 'L':
{
ctxt.advance();
ctxt.accept3('O','O','P');
res = DBMessageType.aEUROLOOP;
break;
} // Case
case 'B':
{
ctxt.advance();
ctxt.acceptString ("ALISE");
res = DBMessageType.aEUROBALISE;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2210)");
break;
} // Switch
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_DBMessageType_ToString (DBMessageType v)
{
switch (v) {
 case DBMessageType.aEUROBALISE: return "EUROBALISE";
 case DBMessageType.aEUROLOOP: return "EUROLOOP";
 case DBMessageType.aEURORADIO: return "EURORADIO";
} return "";
}

public static DBMessageType StringTo_Enum_DBMessageType( string  str)
{
if (str.Equals("EUROBALISE")){
  return DBMessageType.aEUROBALISE;
} // If
if (str.Equals("EUROLOOP")){
  return DBMessageType.aEUROLOOP;
} // If
if (str.Equals("EURORADIO")){
  return DBMessageType.aEURORADIO;
} // If
return DBMessageType.defaultDBMessageType;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ExpectationKind lAcceptEnum_ExpectationKind (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator=0;
#pragma warning restore 0168, 0219
  ExpectationKind res = ExpectationKind.defaultExpectationKind;
switch (ctxt.current()) {
case 'I':
{
ctxt.advance();
if (ctxt.lookAheadString("nstantaneous")){
res = ExpectationKind.aInstantaneous;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ontinuous")){
res = ExpectationKind.aContinuous;
} else {
ctxt.moveBack(1);
res = 0;
} // If
break;
} // Case
default:
res = 0;
break;
} // Switch
return res;
}

public static  string  Enum_ExpectationKind_ToString (ExpectationKind v)
{
switch (v) {
 case ExpectationKind.aInstantaneous: return "Instantaneous";
 case ExpectationKind.aContinuous: return "Continuous";
} return "";
}

public static ExpectationKind StringTo_Enum_ExpectationKind( string  str)
{
if (str.Equals("Instantaneous")){
  return ExpectationKind.aInstantaneous;
} // If
if (str.Equals("Continuous")){
  return ExpectationKind.aContinuous;
} // If
return ExpectationKind.defaultExpectationKind;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static bool lAcceptBoolean (XmlBContext ctxt)

{
#pragma warning disable 0168, 0219
  int indicator = 0;
#pragma warning restore 0168, 0219
  bool res = false;
switch (ctxt.current()) {
case 'y':
{
ctxt.advance();
switch (ctxt.current()) {
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('s')){
res = true;
} else {
res = true;
} // If
break;
} // Case
default:
res = true;
break;
} // Switch
break;
} // Case
case 't':
{
ctxt.advance();
ctxt.accept3('r','u','e');
res = true;
break;
} // Case
case 'o':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
res = true;
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.accept('f');
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2219)");
break;
} // Switch
break;
} // Case
case 'n':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
res = false;
break;
} // Case
default:
res = false;
break;
} // Switch
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.acceptString ("alse");
res = false;
break;
} // Case
case 'Y':
{
ctxt.advance();
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead1('S')){
res = true;
} else {
res = true;
} // If
break;
} // Case
default:
res = true;
break;
} // Switch
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.accept2('u','e');
res = true;
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.accept2('U','E');
res = true;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2228)");
break;
} // Switch
break;
} // Case
case 'O':
{
ctxt.advance();
switch (ctxt.current()) {
case 'n':
{
ctxt.advance();
res = true;
break;
} // Case
case 'f':
{
ctxt.advance();
ctxt.accept('f');
res = false;
break;
} // Case
case 'N':
{
ctxt.advance();
res = true;
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.accept('F');
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2234)");
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
switch (ctxt.current()) {
case 'O':
{
ctxt.advance();
res = false;
break;
} // Case
default:
res = false;
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'a':
{
ctxt.advance();
ctxt.accept3('l','s','e');
res = false;
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.accept3('L','S','E');
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2240)");
break;
} // Switch
break;
} // Case
case '1':
{
ctxt.advance();
res = true;
break;
} // Case
case '0':
{
ctxt.advance();
res = false;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2243)");
break;
} // Switch
return res;
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static BaseModelElement lAccept_Poly_BaseModelElement (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    BaseModelElement res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslation")){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_TranslationDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("stCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('b','S')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAhead2('e','p')){
ctxt.accept(quoteChar);
res = lAccept_SubStep(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("quence")){
ctxt.accept(quoteChar);
res = lAccept_SubSequence(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_StructureRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('p')){
ctxt.accept(quoteChar);
res = lAccept_Step(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("ecification")){
ctxt.accept(quoteChar);
res = lAccept_Specification(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("urceText")){
switch (ctxt.current()) {
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("omment")){
ctxt.accept(quoteChar);
res = lAccept_SourceTextComment(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("ortcut")){
switch (ctxt.current()) {
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("older")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutFolder(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('q')){
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("irementSet")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("eference")){
ctxt.accept(quoteChar);
res = lAccept_RequirementSetReference(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ependancy")){
ctxt.accept(quoteChar);
res = lAccept_RequirementSetDependancy(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_ReqRef(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("cedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("Condition")){
ctxt.accept(quoteChar);
res = lAccept_PreCondition(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("eter")){
ctxt.accept(quoteChar);
res = lAccept_Parameter(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("raph")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("evision")){
ctxt.accept(quoteChar);
res = lAccept_ParagraphRevision(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ameSpace")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_NameSpaceRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("nction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'r':
{
ctxt.advance();
if (ctxt.lookAhead3('a','m','e')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_FrameRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("lder")){
ctxt.accept(quoteChar);
res = lAccept_Folder(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
if (ctxt.lookAheadString("pectation")){
ctxt.accept(quoteChar);
res = lAccept_Expectation(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAhead2('u','m')){
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue")){
ctxt.accept(quoteChar);
res = lAccept_EnumValue(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'D':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
if (ctxt.lookAheadString("ctionary")){
ctxt.accept(quoteChar);
res = lAccept_Dictionary(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'B':
{
ctxt.advance();
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("acket")){
ctxt.accept(quoteChar);
res = lAccept_DBPacket(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("essage")){
ctxt.accept(quoteChar);
res = lAccept_DBMessage(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("ield")){
ctxt.accept(quoteChar);
res = lAccept_DBField(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'C':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("llection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("apter")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_ChapterRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('s','e')){
ctxt.accept(quoteChar);
res = lAccept_Case(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'A':
{
ctxt.advance();
if (ctxt.lookAheadString("ction")){
ctxt.accept(quoteChar);
res = lAccept_Action(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Namable lAccept_Poly_Namable (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    Namable res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslation")){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_TranslationDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("stCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('b','S')){
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
if (ctxt.lookAhead2('e','p')){
ctxt.accept(quoteChar);
res = lAccept_SubStep(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("quence")){
ctxt.accept(quoteChar);
res = lAccept_SubSequence(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_StructureRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('p')){
ctxt.accept(quoteChar);
res = lAccept_Step(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'p':
{
ctxt.advance();
if (ctxt.lookAheadString("ecification")){
ctxt.accept(quoteChar);
res = lAccept_Specification(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("urceText")){
switch (ctxt.current()) {
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("omment")){
ctxt.accept(quoteChar);
res = lAccept_SourceTextComment(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_SourceText(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("ortcut")){
switch (ctxt.current()) {
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("older")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutFolder(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
ctxt.accept(quoteChar);
res = lAccept_ShortcutDictionary(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Shortcut(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("quirementSet")){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ependancy")){
ctxt.accept(quoteChar);
res = lAccept_RequirementSetDependancy(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_RequirementSet(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ocedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('r','a')){
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
if (ctxt.lookAheadString("eter")){
ctxt.accept(quoteChar);
res = lAccept_Parameter(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'g':
{
ctxt.advance();
if (ctxt.lookAheadString("raph")){
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
if (ctxt.lookAheadString("ameSpace")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_NameSpaceRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_NameSpace(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAheadString("nction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'r':
{
ctxt.advance();
if (ctxt.lookAhead3('a','m','e')){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_FrameRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Frame(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("lder")){
ctxt.accept(quoteChar);
res = lAccept_Folder(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
if (ctxt.lookAheadString("pectation")){
ctxt.accept(quoteChar);
res = lAccept_Expectation(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'n':
{
ctxt.advance();
if (ctxt.lookAhead2('u','m')){
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue")){
ctxt.accept(quoteChar);
res = lAccept_EnumValue(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAhead1('B')){
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("acket")){
ctxt.accept(quoteChar);
res = lAccept_DBPacket(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("essage")){
ctxt.accept(quoteChar);
res = lAccept_DBMessage(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("ield")){
ctxt.accept(quoteChar);
res = lAccept_DBField(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
if (ctxt.lookAheadString("llection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'h':
{
ctxt.advance();
if (ctxt.lookAheadString("apter")){
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
ctxt.accept(quoteChar);
res = lAccept_ChapterRef(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Chapter(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('s','e')){
ctxt.accept(quoteChar);
res = lAccept_Case(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ReferencesParagraph lAccept_Poly_ReferencesParagraph (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    ReferencesParagraph res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("anslation")){
ctxt.accept(quoteChar);
res = lAccept_Translation(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAheadString("stCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
if (ctxt.lookAhead1('t')){
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'e':
{
ctxt.advance();
if (ctxt.lookAhead1('p')){
ctxt.accept(quoteChar);
res = lAccept_Step(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ocedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("ragraph")){
ctxt.accept(quoteChar);
res = lAccept_Paragraph(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("unction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ollection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ReqRelated lAccept_Poly_ReqRelated (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    ReqRelated res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("ariable")){
ctxt.accept(quoteChar);
res = lAccept_Variable(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'T':
{
ctxt.advance();
if (ctxt.lookAheadString("estCase")){
ctxt.accept(quoteChar);
res = lAccept_TestCase(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'S':
{
ctxt.advance();
if (ctxt.lookAhead1('t')){
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
switch (ctxt.current()) {
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
ctxt.accept(quoteChar);
res = lAccept_StructureElement(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead2('t','e')){
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_State(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
if (ctxt.lookAhead2('l','e')){
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
ctxt.accept(quoteChar);
res = lAccept_RuleDisabling(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
ctxt.accept(quoteChar);
res = lAccept_RuleCondition(ctxt, endingTag);
} else {
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
} // If
break;
} // Case
default:
ctxt.accept(quoteChar);
res = lAccept_Rule(ctxt, endingTag);
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAhead3('n','g','e')){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
if (ctxt.lookAheadString("rocedure")){
ctxt.accept(quoteChar);
res = lAccept_Procedure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("unction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ollection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Dictionary lAccept_Dictionary (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Dictionary>";
  Dictionary res = aFactory.createDictionary();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RuleDisabling lAccept_RuleDisabling (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RuleDisabling>";
  RuleDisabling res = aFactory.createRuleDisabling();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static NameSpaceRef lAccept_NameSpaceRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</NameSpaceRef>";
  NameSpaceRef res = aFactory.createNameSpaceRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static NameSpace lAccept_NameSpace (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</NameSpace>";
  NameSpace res = aFactory.createNameSpace();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ReqRef lAccept_ReqRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ReqRef>";
  ReqRef res = aFactory.createReqRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Type lAccept_Poly_Type (XmlBContext ctxt, 
                          string  endingTag)

  {
    char quoteChar;
    Type res = null;
ctxt.skipWhiteSpace();
ctxt.acceptString ("xsi:type=");
quoteChar = ctxt.acceptQuote();
switch (ctxt.current()) {
case 'S':
{
ctxt.advance();
if (ctxt.lookAhead1('t')){
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
if (ctxt.lookAheadString("ucture")){
ctxt.accept(quoteChar);
res = lAccept_Structure(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'a':
{
ctxt.advance();
if (ctxt.lookAheadString("teMachine")){
ctxt.accept(quoteChar);
res = lAccept_StateMachine(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
} else {
res = null;
} // If
break;
} // Case
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("ange")){
ctxt.accept(quoteChar);
res = lAccept_Range(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("unction")){
ctxt.accept(quoteChar);
res = lAccept_Function(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAhead3('n','u','m')){
ctxt.accept(quoteChar);
res = lAccept_Enum(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ollection")){
ctxt.accept(quoteChar);
res = lAccept_Collection(ctxt, endingTag);
} else {
res = null;
} // If
break;
} // Case
default:
res = null;
break;
} // Switch
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Enum lAccept_Enum (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Enum>";
  Enum res = aFactory.createEnum();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static EnumValue lAccept_EnumValue (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</EnumValue>";
  EnumValue res = aFactory.createEnumValue();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Range lAccept_Range (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Range>";
  Range res = aFactory.createRange();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Structure lAccept_Structure (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Structure>";
  Structure res = aFactory.createStructure();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static StructureRef lAccept_StructureRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</StructureRef>";
  StructureRef res = aFactory.createStructureRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static StructureElement lAccept_StructureElement (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</StructureElement>";
  StructureElement res = aFactory.createStructureElement();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Collection lAccept_Collection (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Collection>";
  Collection res = aFactory.createCollection();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Function lAccept_Function (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Function>";
  Function res = aFactory.createFunction();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Parameter lAccept_Parameter (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Parameter>";
  Parameter res = aFactory.createParameter();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Case lAccept_Case (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Case>";
  Case res = aFactory.createCase();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Procedure lAccept_Procedure (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Procedure>";
  Procedure res = aFactory.createProcedure();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static StateMachine lAccept_StateMachine (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</StateMachine>";
  StateMachine res = aFactory.createStateMachine();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static State lAccept_State (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</State>";
  State res = aFactory.createState();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Variable lAccept_Variable (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Variable>";
  Variable res = aFactory.createVariable();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Rule lAccept_Rule (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Rule>";
  Rule res = aFactory.createRule();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RuleCondition lAccept_RuleCondition (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RuleCondition>";
  RuleCondition res = aFactory.createRuleCondition();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static PreCondition lAccept_PreCondition (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</PreCondition>";
  PreCondition res = aFactory.createPreCondition();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Action lAccept_Action (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Action>";
  Action res = aFactory.createAction();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static FrameRef lAccept_FrameRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</FrameRef>";
  FrameRef res = aFactory.createFrameRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Frame lAccept_Frame (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Frame>";
  Frame res = aFactory.createFrame();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SubSequence lAccept_SubSequence (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SubSequence>";
  SubSequence res = aFactory.createSubSequence();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TestCase lAccept_TestCase (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</TestCase>";
  TestCase res = aFactory.createTestCase();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Step lAccept_Step (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Step>";
  Step res = aFactory.createStep();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SubStep lAccept_SubStep (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SubStep>";
  SubStep res = aFactory.createSubStep();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Expectation lAccept_Expectation (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Expectation>";
  Expectation res = aFactory.createExpectation();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBMessage lAccept_DBMessage (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</DBMessage>";
  DBMessage res = aFactory.createDBMessage();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBPacket lAccept_DBPacket (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</DBPacket>";
  DBPacket res = aFactory.createDBPacket();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static DBField lAccept_DBField (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</DBField>";
  DBField res = aFactory.createDBField();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TranslationDictionary lAccept_TranslationDictionary (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</TranslationDictionary>";
  TranslationDictionary res = aFactory.createTranslationDictionary();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Folder lAccept_Folder (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Folder>";
  Folder res = aFactory.createFolder();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Translation lAccept_Translation (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Translation>";
  Translation res = aFactory.createTranslation();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SourceText lAccept_SourceText (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SourceText>";
  SourceText res = aFactory.createSourceText();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static SourceTextComment lAccept_SourceTextComment (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</SourceTextComment>";
  SourceTextComment res = aFactory.createSourceTextComment();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ShortcutDictionary lAccept_ShortcutDictionary (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ShortcutDictionary>";
  ShortcutDictionary res = aFactory.createShortcutDictionary();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ShortcutFolder lAccept_ShortcutFolder (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ShortcutFolder>";
  ShortcutFolder res = aFactory.createShortcutFolder();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Shortcut lAccept_Shortcut (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Shortcut>";
  Shortcut res = aFactory.createShortcut();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RequirementSet lAccept_RequirementSet (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RequirementSet>";
  RequirementSet res = aFactory.createRequirementSet();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RequirementSetDependancy lAccept_RequirementSetDependancy (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RequirementSetDependancy>";
  RequirementSetDependancy res = aFactory.createRequirementSetDependancy();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Specification lAccept_Specification (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Specification>";
  Specification res = aFactory.createSpecification();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ChapterRef lAccept_ChapterRef (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ChapterRef>";
  ChapterRef res = aFactory.createChapterRef();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Chapter lAccept_Chapter (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Chapter>";
  Chapter res = aFactory.createChapter();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Paragraph lAccept_Paragraph (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</Paragraph>";
  Paragraph res = aFactory.createParagraph();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static RequirementSetReference lAccept_RequirementSetReference (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</RequirementSetReference>";
  RequirementSetReference res = aFactory.createRequirementSetReference();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Message lAccept_Message (XmlBContext ctxt, 
                          string  endingTag)

  {
  Message res = aFactory.createMessage();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static MsgVariable lAccept_MsgVariable (XmlBContext ctxt, 
                          string  endingTag)

  {
  MsgVariable res = aFactory.createMsgVariable();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static TypeSpec lAccept_TypeSpec (XmlBContext ctxt, 
                          string  endingTag)

  {
  TypeSpec res = aFactory.createTypeSpec();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static Values lAccept_Values (XmlBContext ctxt, 
                          string  endingTag)

  {
  Values res = aFactory.createValues();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static special_or_reserved_values lAccept_special_or_reserved_values (XmlBContext ctxt, 
                          string  endingTag)

  {
  special_or_reserved_values res = aFactory.createspecial_or_reserved_values();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static special_or_reserved_value lAccept_special_or_reserved_value (XmlBContext ctxt, 
                          string  endingTag)

  {
  special_or_reserved_value res = aFactory.createspecial_or_reserved_value();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static mask lAccept_mask (XmlBContext ctxt, 
                          string  endingTag)

  {
  mask res = aFactory.createmask();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static match lAccept_match (XmlBContext ctxt, 
                          string  endingTag)

  {
  match res = aFactory.creatematch();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static meaning lAccept_meaning (XmlBContext ctxt, 
                          string  endingTag)

  {
  meaning res = aFactory.createmeaning();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static match_range lAccept_match_range (XmlBContext ctxt, 
                          string  endingTag)

  {
  match_range res = aFactory.creatematch_range();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static resolution_formula lAccept_resolution_formula (XmlBContext ctxt, 
                          string  endingTag)

  {
  resolution_formula res = aFactory.createresolution_formula();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static value lAccept_value (XmlBContext ctxt, 
                          string  endingTag)

  {
  value res = aFactory.createvalue();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static char_value lAccept_char_value (XmlBContext ctxt, 
                          string  endingTag)

  {
  char_value res = aFactory.createchar_value();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static ParagraphRevision lAccept_ParagraphRevision (XmlBContext ctxt, 
                          string  endingTag)

  {
if (endingTag == null) endingTag = "</ParagraphRevision>";
  ParagraphRevision res = aFactory.createParagraphRevision();
  res.parse(ctxt, endingTag);
  return res;
  }

/// <summary>Utility function which parse an entity character 
/// as defined in the XMLBooster configuration.</summary>
/// <param name="ctxt">the context from which the data must be parsed</param>
static char lAcceptPcDataChr(XmlBContext ctxt)

{
    char c = (char)0;
    int indicator=0;
switch (ctxt.current()) {
case 'q':
{
ctxt.advance();
ctxt.acceptString ("uot;");
indicator = 2409;
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.acceptString ("bsp;");
indicator = 2408;
break;
} // Case
case 'l':
{
ctxt.advance();
ctxt.accept2('t',';');
indicator = 2406;
break;
} // Case
case 'g':
{
ctxt.advance();
ctxt.accept2('t',';');
indicator = 2407;
break;
} // Case
case 'a':
{
ctxt.advance();
switch (ctxt.current()) {
case 'p':
{
ctxt.advance();
ctxt.accept3('o','s',';');
indicator = 2410;
break;
} // Case
case 'm':
{
ctxt.advance();
ctxt.accept2('p',';');
indicator = 2405;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2418)");
break;
} // Switch
break;
} // Case
case '#':
{
ctxt.advance();
ctxt.accept('x');
indicator = 2411;
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2420)");
break;
} // Switch
switch (indicator) {
case 2405: {
c = XMLB_AMPERSAND;
break;
} // End of dispatch label
case 2406: {
c = XMLB_LESS;
break;
} // End of dispatch label
case 2407: {
c = XMLB_GREATER;
break;
} // End of dispatch label
case 2408: {
c = XMLB_NBSP;
break;
} // End of dispatch label
case 2409: {
c = XMLB_QUOT;
break;
} // End of dispatch label
case 2410: {
c = XMLB_APOS;
break;
} // End of dispatch label
case 2411: {
c = (char) ctxt.acceptHexa();
ctxt.accept(';');
break;
} // End of dispatch label
} // Dispatch
return c;
}
/// <summary>Utility function which parse a PCDATA component 
/// from a context. It takes the entities defined in the
/// in the configuration into account.</summary>
/// <param name="ctxt">the context from which the data must be 
///        parsed</param>
/// <param name="maxLen">the maximal number of characters that 
///        can be read.</param>
/// <param name="closingCh">a character on which parsing must stop
///        in addition to the standard &lt; character.</param>
/// <param name="wsMode">indicates PRESERVE (default), REPLACE or COLLAPSE.</param>
public static  string  lAcceptPcData(XmlBContext ctxt, 
                                   int maxLen,
                                   char closingCh,
                                   int wsMode)

 {
    char ch;
    char lastch = '.';
    System.Text.StringBuilder buff;
     string  res;

  buff = new System.Text.StringBuilder();
  bool go_on = true;
  while (go_on) 
{
  go_on = false;
  while ((ctxt.current() != '<') && (ctxt.current() != closingCh)) // while 1 
{
    ch = ctxt.current();
ctxt.advance();
if (ch == '&'){
ch = lAcceptPcDataChr(ctxt);
} else {
if (wsMode >= WS_REPLACE){
if (ch == '\t' || ch == '\n' || ch == '\r'){
ch = ' ';
} // If
if (wsMode == WS_COLLAPSE){
if ((ch == ' ') && ((lastch == ' ') || (buff.Length == 0))){
ch = (char)0;
} else {
lastch = ch;
} // If
} else {
lastch = ch;
} // If
} // If
} // If
if (ch != '\0'){
buff.Append (ch);
} // If
}
// end while
if (ctxt.current() == '<'){
if (ctxt.lookAheadString("<![CDATA[")){
     string  cdata = ctxt.acceptUntil("]]>", true);
    buff.Append (cdata);
    go_on = true;
} else {
if (ctxt.lookAhead2('<','?')){
ctxt.skipTill ('?');
ctxt.accept2('?','>');
go_on = true;
} else {
} // If
} // If
} // If
}
if (wsMode == WS_COLLAPSE && lastch == ' ' && buff. Length > 0){
res = buff.ToString (0, buff.Length -1);
} else {
res = buff.ToString();
} // If
if ((maxLen > 0) && (res.Length > maxLen)){
ctxt.recoverableFail ("Maximum length exceeded");
} // If
return res;
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  private static bool requiresEscape (char a)
  {
    switch (a)
    {
      case XMLB_AMPERSAND:
      case XMLB_LESS:
      case XMLB_GREATER:
      case XMLB_QUOT:
      case XMLB_APOS:
        return true;
      default: break;
    }
    return false;
  }
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  private static bool requiresEscape ( string  a)
  {
    for (int i=0; i < a.Length; i++)
    {
      if (requiresEscape(a[i]))
        return true;
    }
    return false	;
  }
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw,  string  a)
    {
      bool escaped = false;
      
      if (a == null)
      {
          return;
      }
      escaped = requiresEscape (a);
      if (! escaped)
        pw.Write (a);
      else
      {
        char c;
        for (int i = 0; i < a.Length; i++)
        {
          c = a[i];
          switch (c)
            {
              case XMLB_AMPERSAND:
                  pw.Write("&amp;"); 
                  break;
              case XMLB_LESS:
                  pw.Write("&lt;"); 
                  break;
              case XMLB_GREATER:
                  pw.Write("&gt;"); 
                  break;
              case XMLB_QUOT:
                  pw.Write("&quot;"); 
                  break;
              case XMLB_APOS:
                  pw.Write("&apos;"); 
                  break;
               default: 
                   pw.Write(c);
                   break;
            }
        }
      }
    }
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, bool flag)
    {
      if (flag)
        pw.Write ("TRUE");
       else
        pw.Write("FALSE");
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, object obj)
    {
      if (obj != null)
        unParsePcData (pw, obj.ToString());
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, int val)
    {
      pw.Write (val);
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, long val)
    {
      pw.Write (val);
    }

/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
  public static void unParsePcData (TextWriter pw, double val)
    {
      XmlBConverter conv;
      conv = getConverter();
      if(conv != null)
        pw.Write(conv.doubleToString(val));
       else
        pw.Write (val);
    }



private static Factory aFactory;
/// <summary>Sets the factory to introduce an indirection level
/// so that the user can externally define derived classes
/// to be used in place of the XMLBooster-generated 
/// classes.</summary>
public static void setFactory (Factory f) { aFactory = f; }

/// <returns>the currently active factory.</returns>
public static Factory getFactory () { return aFactory; }
static private acceptor theOne = null;
static public acceptor getUnique()
{
  if (theOne == null) { theOne = new acceptor(); }
  return theOne;
}

static public void setUnique(acceptor acc)
{
  theOne = acc;
}


/// <summary>Top level function to parse an Dictionary from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Dictionary acceptDictionary(XmlBContext ctxt)

  {
Dictionary res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Dictionary");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Dictionary(ctxt, "</Dictionary>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RuleDisabling from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RuleDisabling acceptRuleDisabling(XmlBContext ctxt)

  {
RuleDisabling res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RuleDisabling");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RuleDisabling(ctxt, "</RuleDisabling>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an NameSpace from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static NameSpace acceptNameSpace(XmlBContext ctxt)

  {
NameSpace res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<NameSpace");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_NameSpace(ctxt, "</NameSpace>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ReqRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ReqRef acceptReqRef(XmlBContext ctxt)

  {
ReqRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ReqRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ReqRef(ctxt, "</ReqRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Enum from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Enum acceptEnum(XmlBContext ctxt)

  {
Enum res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Enum");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Enum(ctxt, "</Enum>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an EnumValue from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static EnumValue acceptEnumValue(XmlBContext ctxt)

  {
EnumValue res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<EnumValue");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_EnumValue(ctxt, "</EnumValue>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Range from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Range acceptRange(XmlBContext ctxt)

  {
Range res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Range");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Range(ctxt, "</Range>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Structure from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Structure acceptStructure(XmlBContext ctxt)

  {
Structure res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Structure");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Structure(ctxt, "</Structure>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an StructureElement from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static StructureElement acceptStructureElement(XmlBContext ctxt)

  {
StructureElement res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<StructureElement");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_StructureElement(ctxt, "</StructureElement>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Collection from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Collection acceptCollection(XmlBContext ctxt)

  {
Collection res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Collection");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Collection(ctxt, "</Collection>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Function from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Function acceptFunction(XmlBContext ctxt)

  {
Function res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Function");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Function(ctxt, "</Function>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Parameter from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Parameter acceptParameter(XmlBContext ctxt)

  {
Parameter res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Parameter");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Parameter(ctxt, "</Parameter>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Case from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Case acceptCase(XmlBContext ctxt)

  {
Case res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Case");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Case(ctxt, "</Case>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Procedure from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Procedure acceptProcedure(XmlBContext ctxt)

  {
Procedure res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Procedure");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Procedure(ctxt, "</Procedure>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an StateMachine from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static StateMachine acceptStateMachine(XmlBContext ctxt)

  {
StateMachine res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<StateMachine");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_StateMachine(ctxt, "</StateMachine>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an State from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static State acceptState(XmlBContext ctxt)

  {
State res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<State");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_State(ctxt, "</State>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Variable from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Variable acceptVariable(XmlBContext ctxt)

  {
Variable res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Variable");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Variable(ctxt, "</Variable>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Rule from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Rule acceptRule(XmlBContext ctxt)

  {
Rule res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Rule");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Rule(ctxt, "</Rule>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RuleCondition from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RuleCondition acceptRuleCondition(XmlBContext ctxt)

  {
RuleCondition res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RuleCondition");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RuleCondition(ctxt, "</RuleCondition>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an PreCondition from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static PreCondition acceptPreCondition(XmlBContext ctxt)

  {
PreCondition res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<PreCondition");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_PreCondition(ctxt, "</PreCondition>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Action from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Action acceptAction(XmlBContext ctxt)

  {
Action res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Action");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Action(ctxt, "</Action>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Frame from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Frame acceptFrame(XmlBContext ctxt)

  {
Frame res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Frame");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Frame(ctxt, "</Frame>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SubSequence from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SubSequence acceptSubSequence(XmlBContext ctxt)

  {
SubSequence res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SubSequence");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SubSequence(ctxt, "</SubSequence>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an TestCase from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static TestCase acceptTestCase(XmlBContext ctxt)

  {
TestCase res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<TestCase");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_TestCase(ctxt, "</TestCase>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Step from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Step acceptStep(XmlBContext ctxt)

  {
Step res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Step");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Step(ctxt, "</Step>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SubStep from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SubStep acceptSubStep(XmlBContext ctxt)

  {
SubStep res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SubStep");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SubStep(ctxt, "</SubStep>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Expectation from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Expectation acceptExpectation(XmlBContext ctxt)

  {
Expectation res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Expectation");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Expectation(ctxt, "</Expectation>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an DBMessage from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static DBMessage acceptDBMessage(XmlBContext ctxt)

  {
DBMessage res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<DBMessage");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_DBMessage(ctxt, "</DBMessage>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an DBPacket from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static DBPacket acceptDBPacket(XmlBContext ctxt)

  {
DBPacket res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<DBPacket");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_DBPacket(ctxt, "</DBPacket>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an DBField from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static DBField acceptDBField(XmlBContext ctxt)

  {
DBField res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<DBField");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_DBField(ctxt, "</DBField>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an TranslationDictionary from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static TranslationDictionary acceptTranslationDictionary(XmlBContext ctxt)

  {
TranslationDictionary res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<TranslationDictionary");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_TranslationDictionary(ctxt, "</TranslationDictionary>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Folder from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Folder acceptFolder(XmlBContext ctxt)

  {
Folder res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Folder");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Folder(ctxt, "</Folder>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Translation from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Translation acceptTranslation(XmlBContext ctxt)

  {
Translation res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Translation");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Translation(ctxt, "</Translation>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SourceText from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SourceText acceptSourceText(XmlBContext ctxt)

  {
SourceText res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SourceText");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SourceText(ctxt, "</SourceText>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an SourceTextComment from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static SourceTextComment acceptSourceTextComment(XmlBContext ctxt)

  {
SourceTextComment res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<SourceTextComment");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_SourceTextComment(ctxt, "</SourceTextComment>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ShortcutDictionary from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ShortcutDictionary acceptShortcutDictionary(XmlBContext ctxt)

  {
ShortcutDictionary res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ShortcutDictionary");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ShortcutDictionary(ctxt, "</ShortcutDictionary>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ShortcutFolder from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ShortcutFolder acceptShortcutFolder(XmlBContext ctxt)

  {
ShortcutFolder res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ShortcutFolder");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Shortcut from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Shortcut acceptShortcut(XmlBContext ctxt)

  {
Shortcut res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Shortcut");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Shortcut(ctxt, "</Shortcut>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RequirementSet from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RequirementSet acceptRequirementSet(XmlBContext ctxt)

  {
RequirementSet res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RequirementSet");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RequirementSet(ctxt, "</RequirementSet>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RequirementSetDependancy from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RequirementSetDependancy acceptRequirementSetDependancy(XmlBContext ctxt)

  {
RequirementSetDependancy res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RequirementSetDependancy");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RequirementSetDependancy(ctxt, "</RequirementSetDependancy>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Specification from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Specification acceptSpecification(XmlBContext ctxt)

  {
Specification res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Specification");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Specification(ctxt, "</Specification>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Chapter from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Chapter acceptChapter(XmlBContext ctxt)

  {
Chapter res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Chapter");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Chapter(ctxt, "</Chapter>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an Paragraph from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static Paragraph acceptParagraph(XmlBContext ctxt)

  {
Paragraph res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<Paragraph");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_Paragraph(ctxt, "</Paragraph>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an RequirementSetReference from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static RequirementSetReference acceptRequirementSetReference(XmlBContext ctxt)

  {
RequirementSetReference res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<RequirementSetReference");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_RequirementSetReference(ctxt, "</RequirementSetReference>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ParagraphRevision from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ParagraphRevision acceptParagraphRevision(XmlBContext ctxt)

  {
ParagraphRevision res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ParagraphRevision");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ParagraphRevision(ctxt, "</ParagraphRevision>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an NameSpaceRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static NameSpaceRef acceptNameSpaceRef(XmlBContext ctxt)

  {
NameSpaceRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<NameSpaceRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an StructureRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static StructureRef acceptStructureRef(XmlBContext ctxt)

  {
StructureRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<StructureRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_StructureRef(ctxt, "</StructureRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an FrameRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static FrameRef acceptFrameRef(XmlBContext ctxt)

  {
FrameRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<FrameRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_FrameRef(ctxt, "</FrameRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

/// <summary>Top level function to parse an ChapterRef from 
/// a context. This kind of function is only made
/// available for elements marked as MAIN in the 
/// metadefinition</summary>
/// <seealso cref="accept"/>
public static ChapterRef acceptChapterRef(XmlBContext ctxt)

  {
ChapterRef res;
ctxt.skipWhiteSpace();
try {
ctxt.acceptString ("<ChapterRef");
if (ctxt.isAlNum()){
ctxt.fail ("White space expected after TAG");
} // If
  res = lAccept_ChapterRef(ctxt, "</ChapterRef>");
 } catch (XmlBRecoveryException e) {
  throw new XmlBException("Unexpected recovery exception: " +
     e.ToString());
}
  ctxt.close();
if (ctxt.errCount() > 0){
res = null;
throw new XmlBException (ctxt.errorMessage());
} // If
  return res;
  }

public static IXmlBBase accept(XmlBContext ctxt)

{
  IXmlBBase res = null;
ctxt.skipWhiteSpace();
switch (ctxt.current()) {
case '<':
{
ctxt.advance();
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
ctxt.acceptString ("ariable");
  res =  lAccept_Variable(ctxt, "</Variable>");
break;
} // Case
case 'T':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.acceptString ("anslation");
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
  res =  lAccept_TranslationDictionary(ctxt, "</TranslationDictionary>");
} else {
  res =  lAccept_Translation(ctxt, "</Translation>");
} // If
break;
} // Case
default:
  res =  lAccept_Translation(ctxt, "</Translation>");
break;
} // Switch
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("stCase");
  res =  lAccept_TestCase(ctxt, "</TestCase>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2428)");
break;
} // Switch
break;
} // Case
case 'S':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.accept2('b','S');
switch (ctxt.current()) {
case 't':
{
ctxt.advance();
ctxt.accept2('e','p');
  res =  lAccept_SubStep(ctxt, "</SubStep>");
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("quence");
  res =  lAccept_SubSequence(ctxt, "</SubSequence>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2433)");
break;
} // Switch
break;
} // Case
case 't':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
ctxt.acceptString ("ucture");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_StructureRef(ctxt, "</StructureRef>");
} else {
  res =  lAccept_Structure(ctxt, "</Structure>");
} // If
break;
} // Case
case 'E':
{
ctxt.advance();
if (ctxt.lookAheadString("lement")){
  res =  lAccept_StructureElement(ctxt, "</StructureElement>");
} else {
  res =  lAccept_Structure(ctxt, "</Structure>");
} // If
break;
} // Case
default:
  res =  lAccept_Structure(ctxt, "</Structure>");
break;
} // Switch
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.accept('p');
  res =  lAccept_Step(ctxt, "</Step>");
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept2('t','e');
switch (ctxt.current()) {
case 'M':
{
ctxt.advance();
if (ctxt.lookAheadString("achine")){
  res =  lAccept_StateMachine(ctxt, "</StateMachine>");
} else {
  res =  lAccept_State(ctxt, "</State>");
} // If
break;
} // Case
default:
  res =  lAccept_State(ctxt, "</State>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2441)");
break;
} // Switch
break;
} // Case
case 'p':
{
ctxt.advance();
ctxt.acceptString ("ecification");
  res =  lAccept_Specification(ctxt, "</Specification>");
break;
} // Case
case 'o':
{
ctxt.advance();
ctxt.acceptString ("urceText");
switch (ctxt.current()) {
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("omment")){
  res =  lAccept_SourceTextComment(ctxt, "</SourceTextComment>");
} else {
  res =  lAccept_SourceText(ctxt, "</SourceText>");
} // If
break;
} // Case
default:
  res =  lAccept_SourceText(ctxt, "</SourceText>");
break;
} // Switch
break;
} // Case
case 'h':
{
ctxt.advance();
ctxt.acceptString ("ortcut");
switch (ctxt.current()) {
case 'F':
{
ctxt.advance();
if (ctxt.lookAheadString("older")){
  res =  lAccept_ShortcutFolder(ctxt, "</ShortcutFolder>");
} else {
  res =  lAccept_Shortcut(ctxt, "</Shortcut>");
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ictionary")){
  res =  lAccept_ShortcutDictionary(ctxt, "</ShortcutDictionary>");
} else {
  res =  lAccept_Shortcut(ctxt, "</Shortcut>");
} // If
break;
} // Case
default:
  res =  lAccept_Shortcut(ctxt, "</Shortcut>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2448)");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.accept2('l','e');
switch (ctxt.current()) {
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("isabling")){
  res =  lAccept_RuleDisabling(ctxt, "</RuleDisabling>");
} else {
  res =  lAccept_Rule(ctxt, "</Rule>");
} // If
break;
} // Case
case 'C':
{
ctxt.advance();
if (ctxt.lookAheadString("ondition")){
  res =  lAccept_RuleCondition(ctxt, "</RuleCondition>");
} else {
  res =  lAccept_Rule(ctxt, "</Rule>");
} // If
break;
} // Case
default:
  res =  lAccept_Rule(ctxt, "</Rule>");
break;
} // Switch
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.accept('q');
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.acceptString ("irementSet");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("eference")){
  res =  lAccept_RequirementSetReference(ctxt, "</RequirementSetReference>");
} else {
  res =  lAccept_RequirementSet(ctxt, "</RequirementSet>");
} // If
break;
} // Case
case 'D':
{
ctxt.advance();
if (ctxt.lookAheadString("ependancy")){
  res =  lAccept_RequirementSetDependancy(ctxt, "</RequirementSetDependancy>");
} else {
  res =  lAccept_RequirementSet(ctxt, "</RequirementSet>");
} // If
break;
} // Case
default:
  res =  lAccept_RequirementSet(ctxt, "</RequirementSet>");
break;
} // Switch
break;
} // Case
case 'R':
{
ctxt.advance();
ctxt.accept2('e','f');
  res =  lAccept_ReqRef(ctxt, "</ReqRef>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2458)");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept3('n','g','e');
  res =  lAccept_Range(ctxt, "</Range>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2460)");
break;
} // Switch
break;
} // Case
case 'P':
{
ctxt.advance();
switch (ctxt.current()) {
case 'r':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("cedure");
  res =  lAccept_Procedure(ctxt, "</Procedure>");
break;
} // Case
case 'e':
{
ctxt.advance();
ctxt.acceptString ("Condition");
  res =  lAccept_PreCondition(ctxt, "</PreCondition>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2465)");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept2('r','a');
switch (ctxt.current()) {
case 'm':
{
ctxt.advance();
ctxt.acceptString ("eter");
  res =  lAccept_Parameter(ctxt, "</Parameter>");
break;
} // Case
case 'g':
{
ctxt.advance();
ctxt.acceptString ("raph");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAheadString("evision")){
  res =  lAccept_ParagraphRevision(ctxt, "</ParagraphRevision>");
} else {
  res =  lAccept_Paragraph(ctxt, "</Paragraph>");
} // If
break;
} // Case
default:
  res =  lAccept_Paragraph(ctxt, "</Paragraph>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2470)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2471)");
break;
} // Switch
break;
} // Case
case 'N':
{
ctxt.advance();
ctxt.acceptString ("ameSpace");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_NameSpaceRef(ctxt, "</NameSpaceRef>");
} else {
  res =  lAccept_NameSpace(ctxt, "</NameSpace>");
} // If
break;
} // Case
default:
  res =  lAccept_NameSpace(ctxt, "</NameSpace>");
break;
} // Switch
break;
} // Case
case 'F':
{
ctxt.advance();
switch (ctxt.current()) {
case 'u':
{
ctxt.advance();
ctxt.acceptString ("nction");
  res =  lAccept_Function(ctxt, "</Function>");
break;
} // Case
case 'r':
{
ctxt.advance();
ctxt.accept3('a','m','e');
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_FrameRef(ctxt, "</FrameRef>");
} else {
  res =  lAccept_Frame(ctxt, "</Frame>");
} // If
break;
} // Case
default:
  res =  lAccept_Frame(ctxt, "</Frame>");
break;
} // Switch
break;
} // Case
case 'o':
{
ctxt.advance();
ctxt.acceptString ("lder");
  res =  lAccept_Folder(ctxt, "</Folder>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2479)");
break;
} // Switch
break;
} // Case
case 'E':
{
ctxt.advance();
switch (ctxt.current()) {
case 'x':
{
ctxt.advance();
ctxt.acceptString ("pectation");
  res =  lAccept_Expectation(ctxt, "</Expectation>");
break;
} // Case
case 'n':
{
ctxt.advance();
ctxt.accept2('u','m');
switch (ctxt.current()) {
case 'V':
{
ctxt.advance();
if (ctxt.lookAheadString("alue")){
  res =  lAccept_EnumValue(ctxt, "</EnumValue>");
} else {
  res =  lAccept_Enum(ctxt, "</Enum>");
} // If
break;
} // Case
default:
  res =  lAccept_Enum(ctxt, "</Enum>");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2484)");
break;
} // Switch
break;
} // Case
case 'D':
{
ctxt.advance();
switch (ctxt.current()) {
case 'i':
{
ctxt.advance();
ctxt.acceptString ("ctionary");
  res =  lAccept_Dictionary(ctxt, "</Dictionary>");
break;
} // Case
case 'B':
{
ctxt.advance();
switch (ctxt.current()) {
case 'P':
{
ctxt.advance();
ctxt.acceptString ("acket");
  res =  lAccept_DBPacket(ctxt, "</DBPacket>");
break;
} // Case
case 'M':
{
ctxt.advance();
ctxt.acceptString ("essage");
  res =  lAccept_DBMessage(ctxt, "</DBMessage>");
break;
} // Case
case 'F':
{
ctxt.advance();
ctxt.acceptString ("ield");
  res =  lAccept_DBField(ctxt, "</DBField>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2491)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2492)");
break;
} // Switch
break;
} // Case
case 'C':
{
ctxt.advance();
switch (ctxt.current()) {
case 'o':
{
ctxt.advance();
ctxt.acceptString ("llection");
  res =  lAccept_Collection(ctxt, "</Collection>");
break;
} // Case
case 'h':
{
ctxt.advance();
ctxt.acceptString ("apter");
switch (ctxt.current()) {
case 'R':
{
ctxt.advance();
if (ctxt.lookAhead2('e','f')){
  res =  lAccept_ChapterRef(ctxt, "</ChapterRef>");
} else {
  res =  lAccept_Chapter(ctxt, "</Chapter>");
} // If
break;
} // Case
default:
  res =  lAccept_Chapter(ctxt, "</Chapter>");
break;
} // Switch
break;
} // Case
case 'a':
{
ctxt.advance();
ctxt.accept2('s','e');
  res =  lAccept_Case(ctxt, "</Case>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2498)");
break;
} // Switch
break;
} // Case
case 'A':
{
ctxt.advance();
ctxt.acceptString ("ction");
  res =  lAccept_Action(ctxt, "</Action>");
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2500)");
break;
} // Switch
break;
} // Case
default:
ctxt.recoverableFail ("Other character expected (2501)");
break;
} // Switch
return res;
}


/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override bool genericUnParse(TextWriter pw, IXmlBBase obj)
{
  ((XmlBBase ) obj).unParse(pw, false);
  return true;
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public static IXmlBBase[] subElements(IXmlBBase obj)
{
  return ((XmlBBase ) obj).subElements();
}
/// <remarks>This method is used by XMLBooster-generated code
/// internally. Please refrain from using it, as it
/// might produce unexpected results, and might change
/// or even disappear in the future.</remarks>
public  override  IXmlBBase[] genericSubElements(IXmlBBase obj)
{
  return ((XmlBBase ) obj).subElements();
}
public  override IXmlBBase genericAccept (XmlBContext ctxt)

  {
    return accept(ctxt);
  }
}
public abstract partial class Factory
{
public abstract Dictionary createDictionary();
public abstract RuleDisabling createRuleDisabling();
public abstract NameSpaceRef createNameSpaceRef();
public abstract NameSpace createNameSpace();
public abstract ReqRef createReqRef();
public abstract Enum createEnum();
public abstract EnumValue createEnumValue();
public abstract Range createRange();
public abstract Structure createStructure();
public abstract StructureRef createStructureRef();
public abstract StructureElement createStructureElement();
public abstract Collection createCollection();
public abstract Function createFunction();
public abstract Parameter createParameter();
public abstract Case createCase();
public abstract Procedure createProcedure();
public abstract StateMachine createStateMachine();
public abstract State createState();
public abstract Variable createVariable();
public abstract Rule createRule();
public abstract RuleCondition createRuleCondition();
public abstract PreCondition createPreCondition();
public abstract Action createAction();
public abstract FrameRef createFrameRef();
public abstract Frame createFrame();
public abstract SubSequence createSubSequence();
public abstract TestCase createTestCase();
public abstract Step createStep();
public abstract SubStep createSubStep();
public abstract Expectation createExpectation();
public abstract DBMessage createDBMessage();
public abstract DBPacket createDBPacket();
public abstract DBField createDBField();
public abstract TranslationDictionary createTranslationDictionary();
public abstract Folder createFolder();
public abstract Translation createTranslation();
public abstract SourceText createSourceText();
public abstract SourceTextComment createSourceTextComment();
public abstract ShortcutDictionary createShortcutDictionary();
public abstract ShortcutFolder createShortcutFolder();
public abstract Shortcut createShortcut();
public abstract RequirementSet createRequirementSet();
public abstract RequirementSetDependancy createRequirementSetDependancy();
public abstract Specification createSpecification();
public abstract ChapterRef createChapterRef();
public abstract Chapter createChapter();
public abstract Paragraph createParagraph();
public abstract RequirementSetReference createRequirementSetReference();
public abstract Message createMessage();
public abstract MsgVariable createMsgVariable();
public abstract TypeSpec createTypeSpec();
public abstract Values createValues();
public abstract special_or_reserved_values createspecial_or_reserved_values();
public abstract special_or_reserved_value createspecial_or_reserved_value();
public abstract mask createmask();
public abstract match creatematch();
public abstract meaning createmeaning();
public abstract match_range creatematch_range();
public abstract resolution_formula createresolution_formula();
public abstract value createvalue();
public abstract char_value createchar_value();
public abstract ParagraphRevision createParagraphRevision();
}

public partial class TestParser
{
public static void main( string [] args)
  {
   XmlBTester tester = new  XmlBTester();
   tester.performTest (acceptor.getUnique(), args);
  }
}

public partial class Visitor
: XmlBBaseVisitor
{
public virtual void visit(BaseModelElement obj)
{
  visit(obj, true);
}

public virtual void visit(BaseModelElement obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Namable obj)
{
  visit(obj, true);
}

public virtual void visit(Namable obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ReferencesParagraph obj)
{
  visit(obj, true);
}

public virtual void visit(ReferencesParagraph obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ReqRelated obj)
{
  visit(obj, true);
}

public virtual void visit(ReqRelated obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Dictionary obj)
{
  visit(obj, true);
}

public virtual void visit(Dictionary obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RuleDisabling obj)
{
  visit(obj, true);
}

public virtual void visit(RuleDisabling obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(NameSpaceRef obj)
{
  visit(obj, true);
}

public virtual void visit(NameSpaceRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(NameSpace obj)
{
  visit(obj, true);
}

public virtual void visit(NameSpace obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ReqRef obj)
{
  visit(obj, true);
}

public virtual void visit(ReqRef obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Type obj)
{
  visit(obj, true);
}

public virtual void visit(Type obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Enum obj)
{
  visit(obj, true);
}

public virtual void visit(Enum obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(EnumValue obj)
{
  visit(obj, true);
}

public virtual void visit(EnumValue obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Range obj)
{
  visit(obj, true);
}

public virtual void visit(Range obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Structure obj)
{
  visit(obj, true);
}

public virtual void visit(Structure obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(StructureRef obj)
{
  visit(obj, true);
}

public virtual void visit(StructureRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(StructureElement obj)
{
  visit(obj, true);
}

public virtual void visit(StructureElement obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Collection obj)
{
  visit(obj, true);
}

public virtual void visit(Collection obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Function obj)
{
  visit(obj, true);
}

public virtual void visit(Function obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Parameter obj)
{
  visit(obj, true);
}

public virtual void visit(Parameter obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Case obj)
{
  visit(obj, true);
}

public virtual void visit(Case obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Procedure obj)
{
  visit(obj, true);
}

public virtual void visit(Procedure obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(StateMachine obj)
{
  visit(obj, true);
}

public virtual void visit(StateMachine obj, bool visitSubNodes)
{
visit ((Type) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(State obj)
{
  visit(obj, true);
}

public virtual void visit(State obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Variable obj)
{
  visit(obj, true);
}

public virtual void visit(Variable obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Rule obj)
{
  visit(obj, true);
}

public virtual void visit(Rule obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RuleCondition obj)
{
  visit(obj, true);
}

public virtual void visit(RuleCondition obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(PreCondition obj)
{
  visit(obj, true);
}

public virtual void visit(PreCondition obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Action obj)
{
  visit(obj, true);
}

public virtual void visit(Action obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(FrameRef obj)
{
  visit(obj, true);
}

public virtual void visit(FrameRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Frame obj)
{
  visit(obj, true);
}

public virtual void visit(Frame obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SubSequence obj)
{
  visit(obj, true);
}

public virtual void visit(SubSequence obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(TestCase obj)
{
  visit(obj, true);
}

public virtual void visit(TestCase obj, bool visitSubNodes)
{
visit ((ReqRelated) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Step obj)
{
  visit(obj, true);
}

public virtual void visit(Step obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SubStep obj)
{
  visit(obj, true);
}

public virtual void visit(SubStep obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Expectation obj)
{
  visit(obj, true);
}

public virtual void visit(Expectation obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(DBMessage obj)
{
  visit(obj, true);
}

public virtual void visit(DBMessage obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(DBPacket obj)
{
  visit(obj, true);
}

public virtual void visit(DBPacket obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(DBField obj)
{
  visit(obj, true);
}

public virtual void visit(DBField obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(TranslationDictionary obj)
{
  visit(obj, true);
}

public virtual void visit(TranslationDictionary obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Folder obj)
{
  visit(obj, true);
}

public virtual void visit(Folder obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Translation obj)
{
  visit(obj, true);
}

public virtual void visit(Translation obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SourceText obj)
{
  visit(obj, true);
}

public virtual void visit(SourceText obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(SourceTextComment obj)
{
  visit(obj, true);
}

public virtual void visit(SourceTextComment obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ShortcutDictionary obj)
{
  visit(obj, true);
}

public virtual void visit(ShortcutDictionary obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ShortcutFolder obj)
{
  visit(obj, true);
}

public virtual void visit(ShortcutFolder obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Shortcut obj)
{
  visit(obj, true);
}

public virtual void visit(Shortcut obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RequirementSet obj)
{
  visit(obj, true);
}

public virtual void visit(RequirementSet obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RequirementSetDependancy obj)
{
  visit(obj, true);
}

public virtual void visit(RequirementSetDependancy obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Specification obj)
{
  visit(obj, true);
}

public virtual void visit(Specification obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ChapterRef obj)
{
  visit(obj, true);
}

public virtual void visit(ChapterRef obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Chapter obj)
{
  visit(obj, true);
}

public virtual void visit(Chapter obj, bool visitSubNodes)
{
visit ((Namable) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Paragraph obj)
{
  visit(obj, true);
}

public virtual void visit(Paragraph obj, bool visitSubNodes)
{
visit ((ReferencesParagraph) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(RequirementSetReference obj)
{
  visit(obj, true);
}

public virtual void visit(RequirementSetReference obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Message obj)
{
  visit(obj, true);
}

public virtual void visit(Message obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(MsgVariable obj)
{
  visit(obj, true);
}

public virtual void visit(MsgVariable obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(TypeSpec obj)
{
  visit(obj, true);
}

public virtual void visit(TypeSpec obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(Values obj)
{
  visit(obj, true);
}

public virtual void visit(Values obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(special_or_reserved_values obj)
{
  visit(obj, true);
}

public virtual void visit(special_or_reserved_values obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(special_or_reserved_value obj)
{
  visit(obj, true);
}

public virtual void visit(special_or_reserved_value obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(mask obj)
{
  visit(obj, true);
}

public virtual void visit(mask obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(match obj)
{
  visit(obj, true);
}

public virtual void visit(match obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(meaning obj)
{
  visit(obj, true);
}

public virtual void visit(meaning obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(match_range obj)
{
  visit(obj, true);
}

public virtual void visit(match_range obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(resolution_formula obj)
{
  visit(obj, true);
}

public virtual void visit(resolution_formula obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(value obj)
{
  visit(obj, true);
}

public virtual void visit(value obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(char_value obj)
{
  visit(obj, true);
}

public virtual void visit(char_value obj, bool visitSubNodes)
{
visit ((IXmlBBase)obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public virtual void visit(ParagraphRevision obj)
{
  visit(obj, true);
}

public virtual void visit(ParagraphRevision obj, bool visitSubNodes)
{
visit ((BaseModelElement) obj, false);
if (visitSubNodes){
IXmlBBase[] Subs  = acceptor.subElements((IXmlBBase)obj);
if (Subs != null){
for (int i=0; i<Subs.Length; i++) {
  dispatch(Subs[i], true);
} // If
} // If
}
}

public  override  void dispatch(IXmlBBase obj)
{
  dispatch (obj, true);
}

public  override  void dispatch(IXmlBBase obj, bool visitSubNodes)
{
if (obj == null){
return;
} // If
((XmlBBase)obj).dispatch(this, visitSubNodes);
} // End of dispatch methods

}
}
