<NameSpace
 Name="BTM"
>
<NameSpaces>
<NameSpaceRef
 Name="Linking"
>
</NameSpaceRef></NameSpaces>
<Structures>
<Structure
 Implemented="TRUE"
 Name="BaliseGroup"
>
<ReqRef
 Id="3.6.1.3"
>
</ReqRef><Comment> Represents the information about the Last Relevant Balise Group.</Comment>
<StructureElement
 TypeName="Position"
 Default=""
 Mode="Internal"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="Position"
>
<Comment>Position of the LRBG.</Comment>
</StructureElement><StructureElement
 TypeName="Messages.NID_LRBG"
 Default=""
 Mode="Internal"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="NID"
>
<Comment>The identity number of the LRBG.</Comment>
</StructureElement><StructureElement
 TypeName="Default.Orientation"
 Default="Orientation.Unknown"
 Mode="Internal"
 Implemented="TRUE"
 Name="Orientation"
>
<ReqRef
 Id="3.4.2.1.1"
>
</ReqRef><ReqRef
 Id="3.4.2.1.2"
>
</ReqRef><ReqRef
 Id="3.4.2.2.2"
>
</ReqRef><Comment>Indicates of the orientation of the LRBG can be determined.</Comment>
</StructureElement></Structure><Structure
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="Position"
>
<Comment>Saves the information provided by the odometry at the moment where a balise group is passed. Used to compute the position, over and under reading amount relative to that balise group.</Comment>
<StructureElement
 TypeName="Default.BaseTypes.Distance"
 Default="0.0"
 Mode="Internal"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="Position"
>
</StructureElement><StructureElement
 TypeName="Default.BaseTypes.Length"
 Default="0.0"
 Mode="Internal"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="UnderReadingAmountOdo"
>
</StructureElement><StructureElement
 TypeName="Default.BaseTypes.Length"
 Default="0.0"
 Mode="Internal"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="OverReadingAmountOdo"
>
</StructureElement></Structure></Structures>
<Collections>
<Collection
 TypeName="BaliseGroup"
 MaxSize="8"
 Default="[]"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="BaliseGroups"
>
<Comment>Represents the list of last received LRBGs.</Comment>
</Collection><Collection
 TypeName="Messages.EUROBALISE.Message"
 MaxSize="8"
 Default="[]"
 Implemented="TRUE"
 Name="BaliseGroupMessages"
>
<ReqRef
 Id="3.4.1.1"
>
</ReqRef><Comment></Comment>
</Collection></Collections>
<Functions>
<Function
 Type="Default.BaseTypes.Length"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="BGLocationAccuracy"
>
<ReqRef
 Id="3.6.4.2.3"
>
</ReqRef><ReqRef
 Id="3.6.4.2.b"
>
</ReqRef><ReqRef
 Id="Entry 3.A3.2.1.23"
>
</ReqRef><Comment></Comment>
<Cases>
<Case
 Name="LinkingAvailable"
>
<PreConditions>
<PreCondition>Available ( Linking.CurrentLinking() )</PreCondition></PreConditions>
<Expression>Linking.CurrentLinking().LocationAccuracy</Expression>
</Case><Case
 Name="NationalValuesAvailable"
>
<PreConditions>
<PreCondition>Kernel.NationalValues.ApplicableNationalValues.DataState == DataState.Valid</PreCondition></PreConditions>
<Expression>Default.BaseTypes.Length(Kernel.NationalValues.ApplicableNationalValues.Value.DefaultLocationAccuracyOfABaliseGroup)</Expression>
</Case><Case
 Name="DefaultValue"
>
<Expression>Default.BaseTypes.Length(Kernel.NationalValues.DefaultValues.DefaultLocationAccuracyOfABaliseGroup)</Expression>
</Case></Cases>
</Function><Function
 Type="Default.BaseTypes.Distance"
 Name="TravelledDistanceFromLRBG"
>
<ReqRef
 Id="3.6.4.3.a"
>
</ReqRef><ReqRef
 Id="3.6.4.3.b"
>
</ReqRef><Comment></Comment>
<Cases>
<Case
 Name="LinkingAvailable"
>
<PreConditions>
<PreCondition>Available ( Linking.CurrentLinking )</PreCondition></PreConditions>
<Expression>0.0</Expression>
</Case><Case
 Name="LinkingNotAvailable"
>
<Expression>Odometry.NominalDistance - LRBG.Position.Position</Expression>
</Case></Cases>
</Function><Function
 Type="BaliseGroup"
 Implemented="TRUE"
 Name="FartherLRBG"
>
<ReqRef
 Id="3.6.5.1.2.i"
>
<Comment></Comment>
</ReqRef><Comment>Provides the previous LRBG, if any.</Comment>
<Cases>
<Case
 Name="Value"
>
<Expression>REDUCE PreviousLRBGs 
  USING SelectFartherBG ( X , RESULT )
  INITIAL_VALUE EMPTY</Expression>
</Case></Cases>
</Function><Function
 Type="Default.BaseTypes.Distance"
 Implemented="TRUE"
 Name="DistanceFromLRBG"
>
<ReqRef
 Id="3.6.4.4.a"
>
</ReqRef><Comment>Current position, relative to the LRBG.</Comment>
<Cases>
<Case
 Name="Value"
>
<Expression>Odometry.NominalDistance - BTM.LRBG.Position.Position</Expression>
</Case></Cases>
</Function><Function
 Type="BaliseGroup"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="SelectFartherBG"
>
<Comment>Selects the balise group which is the nearer between the two balise groups provided</Comment>
<Parameters>
<Parameter
 Type="BaliseGroup"
 Name="bg1"
>
</Parameter><Parameter
 Type="BaliseGroup"
 Name="bg2"
>
</Parameter></Parameters>
<Cases>
<Case
 Name="Unknown train orientation"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Unknown</PreCondition></PreConditions>
<Expression>EMPTY</Expression>
</Case><Case
 Name="Empty bg1"
>
<PreConditions>
<PreCondition>NOT Available ( bg1 )</PreCondition></PreConditions>
<Expression>bg2</Expression>
</Case><Case
 Name="Empty bg2"
>
<PreConditions>
<PreCondition>NOT Available ( bg2 )</PreCondition></PreConditions>
<Expression>bg1</Expression>
</Case><Case
 Name="Nominal and bg1.Position &lt;= bg2.Position"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Nominal</PreCondition><PreCondition>bg1.Position.Position &lt;= bg2.Position.Position</PreCondition></PreConditions>
<Expression>bg1</Expression>
</Case><Case
 Name="Nominal and bg1.Position &gt; bg2.Position"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Nominal</PreCondition><PreCondition>bg1.Position.Position &gt; bg2.Position.Position</PreCondition></PreConditions>
<Expression>bg2</Expression>
</Case><Case
 Name="Reverse and bg1.Position &lt;= bg2.Position"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Reverse</PreCondition><PreCondition>bg1.Position.Position &lt;= bg2.Position.Position</PreCondition></PreConditions>
<Expression>bg2</Expression>
</Case><Case
 Name="Reverse and bg1.Position &gt; bg2.Position"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Reverse</PreCondition><PreCondition>bg1.Position.Position &gt; bg2.Position.Position</PreCondition></PreConditions>
<Expression>bg1</Expression>
</Case></Cases>
</Function><Function
 Type="BaliseGroup"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="SelectNearerBG"
>
<Comment>Selects the balise group which is the nearer between the two balise groups provided</Comment>
<Parameters>
<Parameter
 Type="BaliseGroup"
 Name="bg1"
>
</Parameter><Parameter
 Type="BaliseGroup"
 Name="bg2"
>
</Parameter></Parameters>
<Cases>
<Case
 Name="Unknown train orientation"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Unknown</PreCondition></PreConditions>
<Expression>EMPTY</Expression>
</Case><Case
 Name="Empty bg1"
>
<PreConditions>
<PreCondition>NOT Available ( bg1 )</PreCondition></PreConditions>
<Expression>bg2</Expression>
</Case><Case
 Name="Empty bg2"
>
<PreConditions>
<PreCondition>NOT Available ( bg2 )</PreCondition></PreConditions>
<Expression>bg1</Expression>
</Case><Case
 Name="Nominal and bg1.Position &gt; bg2.Position"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Nominal</PreCondition><PreCondition>bg1.Position.Position &gt; bg2.Position.Position</PreCondition></PreConditions>
<Expression>bg1</Expression>
</Case><Case
 Name="Nominal and bg1.Position &lt;= bg2.Position"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Nominal</PreCondition><PreCondition>bg1.Position.Position &lt;= bg2.Position.Position</PreCondition></PreConditions>
<Expression>bg2</Expression>
</Case><Case
 Name="Reverse and bg1.Position &gt; bg2.Position"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Reverse</PreCondition><PreCondition>bg1.Position.Position &gt; bg2.Position.Position</PreCondition></PreConditions>
<Expression>bg2</Expression>
</Case><Case
 Name="Reverse and bg1.Position &lt;= bg2.Position"
>
<PreConditions>
<PreCondition>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation == Orientation.Reverse</PreCondition><PreCondition>bg1.Position.Position &lt;= bg2.Position.Position</PreCondition></PreConditions>
<Expression>bg1</Expression>
</Case></Cases>
</Function><Function
 Type="BaliseGroup"
 Implemented="TRUE"
 Name="PreviousLRBG"
>
<ReqRef
 Id="3.6.5.1.2.i"
>
<Comment></Comment>
</ReqRef><Comment>Provides the previous LRBG, if any.</Comment>
<Cases>
<Case
 Name="Value"
>
<Expression>REDUCE PreviousLRBGs 
  USING SelectNearerBG ( X , RESULT )
  INITIAL_VALUE EMPTY</Expression>
</Case></Cases>
</Function><Function
 Type="Position"
 NeedsRequirement="FALSE"
 Name="PositionFromOdometry"
>
<Comment>Provides the position from the Odometry</Comment>
<Cases>
<Case
 Name="Always"
>
<Expression>Position
{
  OverReadingAmountOdo =&gt; Odometry.Accuracy.D_ora,
  Position =&gt; Odometry.NominalDistance,
  UnderReadingAmountOdo =&gt; Odometry.Accuracy.D_ura
}</Expression>
</Case></Cases>
</Function><Function
 Type="Default.Orientation"
 Implemented="TRUE"
 Name="BaliseGroupOrientation"
>
<ReqRef
 Id="3.4.1.3"
>
</ReqRef><ReqRef
 Id="3.4.2.1.2"
>
</ReqRef><ReqRef
 Id="3.4.2.2.2"
>
</ReqRef><ReqRef
 Id="3.4.4.4.5"
>
</ReqRef><Comment></Comment>
<Cases>
<Case
 Name="Less than two balises in the balise group, valid linking information"
>
<PreConditions>
<PreCondition>( COUNT CurrentBaliseGroup ) &lt; 2</PreCondition><PreCondition>Linking.CurrentLinking().NID_BG == ( FIRST_IN CurrentBaliseGroup ).NID_BG</PreCondition></PreConditions>
<Expression>Linking.CurrentLinking().Orientation</Expression>
</Case><Case
 Name="Less than two balises in the balise group, invalid linking information"
>
<PreConditions>
<PreCondition>( COUNT CurrentBaliseGroup ) &lt; 2</PreCondition></PreConditions>
<Expression>Orientation.Unknown</Expression>
</Case><Case
 Name="First balise is the number 0"
>
<PreConditions>
<PreCondition>(FIRST_IN CurrentBaliseGroup).N_PIG == 0</PreCondition></PreConditions>
<Expression>Orientation.Nominal</Expression>
</Case><Case
 Name="Otherwise"
>
<Expression>Orientation.Reverse</Expression>
</Case></Cases>
</Function><Function
 Type="Boolean"
 Name="LRBGCandidate"
>
<ReqRef
 Id="3.6.2.2.2"
>
</ReqRef><ReqRef
 Id="3.16.2.3.1.1"
>
<Comment></Comment>
</ReqRef><Comment>Indicates whether the Current Balise Group is a candidate for LRBG</Comment>
<Cases>
<Case
 Name="Value"
>
<Expression>Available ( Linking.CurrentLinking() ) AND Linking.CurrentBGWithinFrame()
  OR
NOT Available ( Linking.CurrentLinking() ) AND THERE_IS_IN CurrentBaliseGroup | X.Q_LINK != Messages.Q_LINK.Linked</Expression>
</Case></Cases>
</Function><Function
 Type="Integer"
 NeedsRequirement="FALSE"
 Name="CountBalises"
>
<Comment>This function counts the balises present in the current balise group, by considering duplicate balises with a weight of 2, since duplicate balises are not stored</Comment>
<Cases>
<Case
 Name="Always"
>
<Expression>REDUCE CurrentBaliseGroup USING RESULT + BaliseWeight(X) INITIAL_VALUE 0</Expression>
</Case></Cases>
</Function><Function
 Type="Integer"
 NeedsRequirement="FALSE"
 Name="BaliseWeight"
>
<ReqRef
 Id="A1.1.3.2.3"
>
<Comment></Comment>
</ReqRef><Comment>Provides the weight of a balise : a duplicate balise counts for two balises, whereas a non duplicated balise counts for one.</Comment>
<Parameters>
<Parameter
 Type="Messages.EUROBALISE.Message"
 Name="balise"
>
</Parameter></Parameters>
<Cases>
<Case
 Name="Not a duplicate"
>
<PreConditions>
<PreCondition>balise.M_DUP == Messages.M_DUP.No_duplicates</PreCondition></PreConditions>
<Expression>1</Expression>
</Case><Case
 Name="Otherwise"
>
<Expression>2</Expression>
</Case></Cases>
</Function><Function
 Type="Boolean"
 NeedsRequirement="FALSE"
 Name="BaliseNeedBeStored"
>
<ReqRef
 Id="A1.1.3.2.1"
>
<Comment></Comment>
</ReqRef><ReqRef
 Id="A1.1.3.2.3"
>
</ReqRef><Comment>This function indicates whether a single balise need be stored for further processing. Duplicate balises for wich the other balise of the pair has already been received does not need be stored.</Comment>
<Parameters>
<Parameter
 Type="Messages.EUROBALISE.Message"
 Name="Message"
>
</Parameter></Parameters>
<Cases>
<Case
 Name="Not a duplicate"
>
<PreConditions>
<PreCondition>Message.M_DUP == Messages.M_DUP.No_duplicates</PreCondition></PreConditions>
<Expression>True</Expression>
</Case><Case
 Name="No balise has been received yet"
>
<PreConditions>
<PreCondition>CurrentBaliseGroup == []</PreCondition></PreConditions>
<Expression>True</Expression>
</Case><Case
 Name="Not a duplicate of the next balise in the nominal direction"
>
<PreConditions>
<PreCondition>(LAST_IN CurrentBaliseGroup).N_PIG != Message.N_PIG + 1</PreCondition><PreCondition>Message.M_DUP == Messages.M_DUP.This_balise_is_a_duplicate_of_the_next_balise__seen_in_the_nominal_direction_of_the_balise_group</PreCondition></PreConditions>
<Expression>True</Expression>
</Case><Case
 Name="Not a duplicate of the previous balise in the nominal direction"
>
<PreConditions>
<PreCondition>(LAST_IN CurrentBaliseGroup).N_PIG != Message.N_PIG - 1</PreCondition><PreCondition>Message.M_DUP == Messages.M_DUP.This_balise_is_a_duplicate_of_the_previous_balise__seen_in_the_nominal_direction_of_the_balise_group</PreCondition></PreConditions>
<Expression>True</Expression>
</Case><Case
 Name="Otherwise"
>
<Expression>False</Expression>
</Case></Cases>
</Function><Function
 Type="Boolean"
 Name="ConsiderPacket"
>
<ReqRef
 Id="3.6.3.1.3"
>
<Comment></Comment>
</ReqRef><ReqRef
 Id="3.6.3.1.3.1"
>
</ReqRef><ReqRef
 Id="3.9.1.3"
>
</ReqRef><ReqRef
 Id="3.4.3.2"
>
</ReqRef><ReqRef
 Id="3.4.3.2.a"
>
</ReqRef><ReqRef
 Id="3.4.3.2.c"
>
</ReqRef><Comment>Returns true if the packet has to be considered, that is 
  - if the packet is available (hence its orientation is also available),
  - this is not an infill information, or the infill transmission media is available on-board and 
  - its information is valid for the current orientation of the train or for both directions). 
If the train direction is unknown, this function returns true only if the packet&apos;s information if valid for both directions.</Comment>
<Parameters>
<Parameter
 Type="Messages.Q_DIR"
 Name="PacketOrientation"
>
</Parameter></Parameters>
<Cases>
<Case
 Name="Empty orientation"
>
<PreConditions>
<PreCondition>NOT Available ( PacketOrientation )</PreCondition></PreConditions>
<Expression>False</Expression>
</Case><Case
 Name="Infill information but no infill transmission media"
>
<PreConditions>
<PreCondition>Kernel.Infill.Data != EMPTY AND NOT Kernel.Infill.InfillTransmissionMediaAvailable</PreCondition></PreConditions>
<Expression>False</Expression>
</Case><Case
 Name="Value"
>
<Expression>PacketOrientation == EFSOrientationConverter ( Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation ) OR PacketOrientation == Messages.Q_DIR.Both_directions</Expression>
</Case></Cases>
</Function><Function
 Type="Default.BaseTypes.Distance"
 Implemented="TRUE"
 Name="AntennaPosition"
>
<ReqRef
 Id="3.13.10.2.7"
>
</ReqRef><Comment></Comment>
<Parameters>
<Parameter
 Type="Default.DistanceInterval"
 Name="PointOfInterest"
>
</Parameter></Parameters>
<Cases>
<Case
 Name="Value"
>
<Expression>Kernel.TrainPosition.FrontEndPosition ( PointOfInterest ) - ActiveAntennaPosition</Expression>
</Case></Cases>
</Function></Functions>
<Procedures>
<Procedure
 NeedsRequirement="FALSE"
 Name="HandleNewPacket"
>
<Comment></Comment>
<Parameters>
<Parameter
 Type="Messages.EUROBALISE.SubStructure1"
 Name="Packet"
>
</Parameter><Parameter
 Type="Messages.NID_BG"
 Name="NID_BG"
>
</Parameter><Parameter
 Type="Messages.NID_C"
 Name="NID_C"
>
</Parameter></Parameters>
<Rules>
<Rule
 Priority="Processing"
 NeedsRequirement="FALSE"
 Name="Handle new packet"
>
<ReqRef
 Id="A1.1.3.3"
>
</ReqRef><Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 Implemented="TRUE"
 Name="National Values available"
>
<ReqRef
 Id="3.18.2.4"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.3"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.NATIONAL_VALUES.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.NationalValues.NationalValuesReceived ( Packet=&gt;Packet.TRACK_TO_TRAIN.NATIONAL_VALUES, NID_C=&gt;NID_C )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Linking available"
>
<ReqRef
 Id="3.4.2.3.2.1"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.4"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.LINKING.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Linking.LinkingInformationReceived ( Packet.TRACK_TO_TRAIN.LINKING )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Repositioning information available"
>
<ReqRef
 Id="3.8.5.2"
>
</ReqRef><ReqRef
 Id="3.8.5.2.2"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.9"
>
</ReqRef><PreConditions>
<PreCondition>Linking.CurrentBGAcceptableUnknown ()
  AND
ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.REPOSITIONING_INFORMATION.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.MA.RepositioningInformationReceived ( Packet =&gt; Packet.TRACK_TO_TRAIN.REPOSITIONING_INFORMATION, DistanceToBG =&gt; Linking.CurrentLinking().Distance )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Gradient available"
>
<ReqRef
 Id="3.11.12.1"
>
</ReqRef><ReqRef
 Id="3.7.1.1.c.2"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.10"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.GRADIENT_PROFILE.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.Gradient.ProfileReceived ( Packet.TRACK_TO_TRAIN.GRADIENT_PROFILE )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Static Speed Profile available"
>
<ReqRef
 Id="3.11.3.2.1"
>
</ReqRef><ReqRef
 Id="3.7.1.1.c.1"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.11"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.INTERNATIONAL_STATIC_SPEED_PROFILE.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.StaticSpeedProfile.StaticSpeedProfileReceived ( Packet.TRACK_TO_TRAIN.INTERNATIONAL_STATIC_SPEED_PROFILE )</Action></Actions>
</RuleCondition><RuleCondition
 Name="Level Transition available"
>
<ReqRef
 Id="Entry 7.4.1.1.14"
>
</ReqRef><Comment></Comment>
<PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation=&gt;Packet.TRACK_TO_TRAIN.LEVEL_TRANSITION_ORDER.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.LevelTransition.LTOReceived ( Packet=&gt;Packet.TRACK_TO_TRAIN.LEVEL_TRANSITION_ORDER )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Session management available"
>
<ReqRef
 Id="Entry 7.4.1.1.15"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.SESSION_MANAGEMENT.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>EURORADIO.TracksideOrderedSession(Packet.TRACK_TO_TRAIN.SESSION_MANAGEMENT)</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="List of balises for SH available"
>
<ReqRef
 Id="5.7.1.3"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.19"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.LIST_OF_BALISES_FOR_SH_AREA.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.Shunting.HandleNewListOfBaliseGroups ( Packet =&gt; Packet.TRACK_TO_TRAIN.LIST_OF_BALISES_FOR_SH_AREA )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Axle Load available"
>
<ReqRef
 Id="3.11.4.1"
>
</ReqRef><ReqRef
 Id="3.7.1.1.c.3"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.20"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.AXLE_LOAD_SPEED_PROFILE.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.AxleLoad.AxleLoadProfileReceived ( Packet.TRACK_TO_TRAIN.AXLE_LOAD_SPEED_PROFILE )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Permitted Braking Distance Information available"
>
<ReqRef
 Id="3.11.11.1"
>
</ReqRef><ReqRef
 Id="3.7.1.1.c.4"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.21"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.PERMITTED_BRAKING_DISTANCE_INFORMATION.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.PermittedBrakingDistance.PermittedBrakingDistanceReceived ( Packet.TRACK_TO_TRAIN.PERMITTED_BRAKING_DISTANCE_INFORMATION )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Temporary Speed Restriction available"
>
<ReqRef
 Id="3.11.5.1"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.26"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.TEMPORARY_SPEED_RESTRICTION.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TSR.TemporarySpeedRestrictionsReceived ( Packet=&gt;Packet.TRACK_TO_TRAIN.TEMPORARY_SPEED_RESTRICTION,NID_BG=&gt;NID_BG )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Temporary Speed Restriction Revocation available"
>
<ReqRef
 Id="3.11.5.5"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.27"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.TEMPORARY_SPEED_RESTRICTION_REVOCATION.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TSR.TemporarySpeedRestrictionRevocationReceived ( Packet=&gt;Packet.TRACK_TO_TRAIN.TEMPORARY_SPEED_RESTRICTION_REVOCATION,NID_BG=&gt;NID_BG )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Track Condition available"
>
<ReqRef
 Id="3.12.1.2"
>
</ReqRef><ReqRef
 Id="3.7.1.1.c.5"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.29"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.TRACK_CONDITION.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.TrackConditions.TrackConditionReceived ( Packet.TRACK_TO_TRAIN.TRACK_CONDITION )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Route Suitability available"
>
<ReqRef
 Id="3.12.2.2"
>
</ReqRef><ReqRef
 Id="3.7.1.1.c.6"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.31"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.ROUTE_SUITABILITY_DATA.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.RouteSuitability.RouteSuitabilityReceived ( Packet.TRACK_TO_TRAIN.ROUTE_SUITABILITY_DATA )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Adhesion Factor available"
>
<ReqRef
 Id="3.18.4.6.1"
>
</ReqRef><ReqRef
 Id="3.18.4.6.2.1"
>
</ReqRef><ReqRef
 Id="3.18.4.6.2.2"
>
</ReqRef><ReqRef
 Id="3.7.1.1.c.8"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.32"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.ADHESION_FACTOR.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.AdhesionFactors.AdhesionFactorReceived ( Packet.TRACK_TO_TRAIN.ADHESION_FACTOR )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Mode Profile available"
>
<ReqRef
 Id="5.7.1.3"
>
</ReqRef><ReqRef
 Id="5.19.1.1"
>
</ReqRef><ReqRef
 Id="3.7.1.1.b"
>
</ReqRef><ReqRef
 Id="5.9.2.1"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.36"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.MODE_PROFILE.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.MA.ModeProfile.ModeProfileReceived ( Packet=&gt; Packet.TRACK_TO_TRAIN.MODE_PROFILE )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Level Crossing available"
>
<ReqRef
 Id="3.12.5.1"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.37"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.LEVEL_CROSSING_INFORMATION.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.LX.LXReceived ( Packet=&gt;Packet.TRACK_TO_TRAIN.LEVEL_CROSSING_INFORMATION, NID_BG=&gt;NID_BG )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="Infill available"
>
<ReqRef
 Id="3.9.1.1"
>
</ReqRef><ReqRef
 Id="3.9.1.1.a"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.44"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.INFILL_LOCATION_REFERENCE.Q_DIR )</PreCondition><PreCondition>Kernel.Infill.InfillTransmissionMediaAvailable</PreCondition></PreConditions>
<Actions>
<Action>Kernel.Infill.InfillReceived ( Packet.TRACK_TO_TRAIN.INFILL_LOCATION_REFERENCE )</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Reversing area information available"
>
<ReqRef
 Id="3.15.4.1"
>
</ReqRef><ReqRef
 Id="5.13.1.2"
>
</ReqRef><ReqRef
 Id="5.13.1.7"
>
</ReqRef><ReqRef
 Id="3.7.1.1.c.7"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.46"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.REVERSING_AREA_INFORMATION.Q_DIR )</PreCondition><PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.REVERSING_SUPERVISION_INFORMATION.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.ReversingArea.ReversingAreaInformationReceived
(
    RVAreaPacket =&gt; Packet.TRACK_TO_TRAIN.REVERSING_AREA_INFORMATION,
    RVSupervisionPacket =&gt; Packet.TRACK_TO_TRAIN.REVERSING_SUPERVISION_INFORMATION
)</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Reversing supervision information available"
>
<ReqRef
 Id="3.15.4.3.1"
>
</ReqRef><ReqRef
 Id="5.13.1.6"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.47"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.REVERSING_SUPERVISION_INFORMATION.Q_DIR )</PreCondition><PreCondition>NOT ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.REVERSING_AREA_INFORMATION.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.ReversingArea.ReversingSupervisionInformationReceived
(
    RVSupervisionPacket =&gt; Packet.TRACK_TO_TRAIN.REVERSING_SUPERVISION_INFORMATION
)</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="Default gradient for TSR available"
>
<ReqRef
 Id="3.11.12.5"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.49"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.DEFAULT_GRADIENT_FOR_TEMPORARY_SPEED_RESTRICTION.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.TrackDescription.Gradient.DefaultGradientForTSRReceived ( Packet.TRACK_TO_TRAIN.DEFAULT_GRADIENT_FOR_TEMPORARY_SPEED_RESTRICTION )</Action></Actions>
</RuleCondition><RuleCondition
 Name="Conditional Level Transition Order"
>
<PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation=&gt;Packet.TRACK_TO_TRAIN.CONDITIONAL_LEVEL_TRANSITION_ORDER.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.LevelTransition.CLTOReceived ( Packet=&gt;Packet.TRACK_TO_TRAIN.CONDITIONAL_LEVEL_TRANSITION_ORDER )</Action></Actions>
</RuleCondition></Conditions>
</Rule></Rules>
</Procedure><Procedure
 Implemented="TRUE"
 Name="HandleNewLRBG"
>
<ReqRef
 Id="3.6.4.2.2"
>
</ReqRef><Comment>This procedure is used when the train detects a new LRBG, in order to update information relative to its LRBG.</Comment>
<Parameters>
<Parameter
 Type="Messages.NID_LRBG"
 Name="Nid_BG"
>
</Parameter><Parameter
 Type="Default.BaseTypes.Distance"
 Name="TravelledDistance"
>
</Parameter></Parameters>
<Rules>
<Rule
 Priority="Processing"
 NeedsRequirement="FALSE"
 Name="Store current LRBG as previous encountered BG"
>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 NeedsRequirement="FALSE"
 Name="LRBG is available"
>
<Comment></Comment>
<PreConditions>
<PreCondition>Available ( LRBG )</PreCondition></PreConditions>
<Actions>
<Action>INSERT LRBG IN PreviousLRBGs
  WHEN FULL REPLACE SelectFartherBG()</Action></Actions>
</RuleCondition></Conditions>
</Rule><Rule
 Priority="Processing"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="Update LRBG values"
>
<ReqRef
 Id="3.6.4.2.2"
>
<Comment></Comment>
</ReqRef><Comment>The LRBG position is updated with the current values of the odometer.</Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="Update LRBG values"
>
<Comment></Comment>
<PreConditions>
</PreConditions>
<Actions>
<Action>LRBG &lt;- BaliseGroup { 
  NID =&gt; Nid_BG,
  Position =&gt; FirstBalisePosition,
  Orientation =&gt; BaliseGroupOrientation()
}</Action><Action>Kernel.TrainPosition.Position.DirectionalPositionInformation.TrainOrientation &lt;- BaliseGroupOrientation()</Action></Actions>
</RuleCondition></Conditions>
</Rule></Rules>
</Procedure><Procedure
 Implemented="TRUE"
 Name="HandleUnlinkedBG"
>
<ReqRef
 Id="3.6.4.7.1"
>
</ReqRef><ReqRef
 Id="3.6.4.7.2.1"
>
</ReqRef><Comment>This procedure is used when the train detects an unlinked balise group, in order to update information relative to the last detected unlinked balise group.</Comment>
<Parameters>
<Parameter
 Type="Messages.EUROBALISE.Message"
 Name="Message"
>
</Parameter></Parameters>
<Rules>
<Rule
 Priority="Processing"
 Implemented="TRUE"
 Name="UpdateUnlinkedBGPosition"
>
<ReqRef
 Id="3.6.4.7.1"
>
</ReqRef><ReqRef
 Id="3.6.4.7.2.1"
>
</ReqRef><Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="UpdateUnlinkedBGPosition"
>
<PreConditions>
</PreConditions>
<Actions>
<Action>UnlinkedBGPosition &lt;- PositionFromOdometry()</Action></Actions>
</RuleCondition></Conditions>
</Rule></Rules>
</Procedure><Procedure
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="HandleBaliseMessage"
>
<ReqRef
 Id="3.4.4.2.1.1"
>
<Comment></Comment>
</ReqRef><Comment>Handles a new complete balise group message (when all its balise messages have been received). There are several steps:
- Test if the new BG is linked and has to be considered as a new LRBG
- If the new BG is not linked and is marked as unlinked, its information has to be considered
- After that all the packets of this BG are handled</Comment>
<Parameters>
<Parameter
 Type="Messages.EUROBALISE.Message"
 Name="Message"
>
</Parameter></Parameters>
<Rules>
<Rule
 Priority="Processing"
 NeedsRequirement="FALSE"
 Name="CleanLinkingInfo"
>
<Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 NeedsRequirement="FALSE"
 Name="&lt;RuleCondition1&gt;"
>
<PreConditions>
</PreConditions>
<Actions>
<Action>Linking.CleanLinkingInfo()</Action></Actions>
</RuleCondition></Conditions>
</Rule><Rule
 Priority="Processing"
 Implemented="TRUE"
 Name="LRBG change"
>
<Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="LRBG change"
>
<ReqRef
 Id="3.4.2.2.1"
>
</ReqRef><Comment></Comment>
<PreConditions>
<PreCondition>LRBG.NID != BG_To_LRBG(Message.NID_BG)</PreCondition><PreCondition>Message.N_PIG == 0</PreCondition><PreCondition>LRBGCandidate( )</PreCondition></PreConditions>
<Actions>
<Action>HandleNewLRBG(
  Nid_BG=&gt;BG_To_LRBG(Message.NID_BG), 
  TravelledDistance=&gt;TravelledDistanceFromLRBG()
)</Action></Actions>
</RuleCondition></Conditions>
</Rule><Rule
 Priority="Processing"
 Implemented="TRUE"
 Name="Unlinked BG"
>
<Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="Unlinked BG"
>
<PreConditions>
<PreCondition>Message.Q_LINK == Messages.Q_LINK.Unlinked</PreCondition></PreConditions>
<Actions>
<Action>HandleUnlinkedBG(Message)</Action></Actions>
</RuleCondition></Conditions>
</Rule><Rule
 Priority="Processing"
 Implemented="TRUE"
 Name="Clear mode profile if MA received"
>
<ReqRef
 Id="3.12.4.3"
>
</ReqRef><SubRules></SubRules>
<Conditions>
<RuleCondition
 Name="Clear mode profile if MA received"
>
<PreConditions>
<PreCondition>Linking.ConsiderBG()</PreCondition><PreCondition>THERE_IS_IN Message.Sequence1 | ( Available ( X.TRACK_TO_TRAIN.LEVEL_1_MOVEMENT_AUTHORITY ) OR Available ( X.TRACK_TO_TRAIN.LEVEL_2_3_MOVEMENT_AUTHORITY ) )</PreCondition></PreConditions>
<Actions>
</Actions>
<SubRules>
<Rule
 Priority="Processing"
 Implemented="TRUE"
 Name="Test infill availability"
>
<ReqRef
 Id="3.12.4.3.1"
>
</ReqRef><SubRules></SubRules>
<Conditions>
<RuleCondition
 Name="Infill available, before MA"
>
<PreConditions>
<PreCondition>THERE_IS_IN Message.Sequence1 | Available ( X.TRACK_TO_TRAIN.INFILL_LOCATION_REFERENCE )</PreCondition><PreCondition>Before
(
    ExpectedFirst=&gt; FIRST_IN Message.Sequence1 | Available ( X.TRACK_TO_TRAIN.INFILL_LOCATION_REFERENCE ),
    ExpectedSecond=&gt; FIRST_IN Message.Sequence1 | ( Available ( X.TRACK_TO_TRAIN.LEVEL_1_MOVEMENT_AUTHORITY ) OR Available ( X.TRACK_TO_TRAIN.LEVEL_2_3_MOVEMENT_AUTHORITY ) ),
    Collection=&gt; Message.Sequence1
)</PreCondition></PreConditions>
<Actions>
<Action>Kernel.MA.ModeProfile.ClearModeProfile ( InfillPacket =&gt; ( FIRST_IN Message.Sequence1 | Available ( X.TRACK_TO_TRAIN.INFILL_LOCATION_REFERENCE ) ).TRACK_TO_TRAIN.INFILL_LOCATION_REFERENCE )</Action></Actions>
</RuleCondition><RuleCondition
 Name="Infill available, after MA"
>
<PreConditions>
<PreCondition>THERE_IS_IN Message.Sequence1 | Available ( X.TRACK_TO_TRAIN.INFILL_LOCATION_REFERENCE )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.MA.ModeProfile.ClearModeProfile ( InfillPacket =&gt; EMPTY )</Action></Actions>
</RuleCondition><RuleCondition
 Name="No infill available"
>
<PreConditions>
</PreConditions>
<Actions>
<Action>Kernel.MA.ModeProfile.ClearModeProfile ( InfillPacket =&gt; EMPTY )</Action></Actions>
</RuleCondition></Conditions>
</Rule></SubRules>
</RuleCondition></Conditions>
</Rule><Rule
 Priority="Processing"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="HandleBaliseMessage"
>
<ReqRef
 Id="3.16.2.3.1"
>
</ReqRef><Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="HandleBaliseMessage"
>
<Comment></Comment>
<PreConditions>
<PreCondition>Linking.ConsiderBG()</PreCondition></PreConditions>
<Actions>
<Action>APPLY HandleNewPacket(
  Packet=&gt;X, 
  NID_BG=&gt;Message.NID_BG,
  NID_C=&gt;Message.NID_C
) 
ON Message.Sequence1</Action></Actions>
</RuleCondition><RuleCondition
 NeedsRequirement="FALSE"
 Name="ApplyLinkingReaction"
>
<PreConditions>
<PreCondition>NOT Linking.CurrentBGWithinFrame()</PreCondition><PreCondition>Message.Q_LINK == Messages.Q_LINK.Linked</PreCondition><PreCondition>Available ( Linking.CurrentLinking() )</PreCondition></PreConditions>
<Actions>
</Actions>
<SubRules>
<Rule
 Priority="Processing"
 NeedsRequirement="FALSE"
 Name="ApplyLinkingReaction"
>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 NeedsRequirement="FALSE"
 Name="ServiceBrake"
>
<PreConditions>
<PreCondition>(FIRST_IN BTM.Linking.Linkings).Reaction == Linking.LinkingReaction.CommandServiceBrake</PreCondition></PreConditions>
<Actions>
<Action>Kernel.SpeedAndDistanceMonitoring.TriggerSBCommand()</Action></Actions>
</RuleCondition><RuleCondition
 NeedsRequirement="FALSE"
 Name="TrainTrip"
>
<ReqRef
 Id="Entry 4.6.3.18"
>
</ReqRef><PreConditions>
<PreCondition>(FIRST_IN BTM.Linking.Linkings).Reaction == Linking.LinkingReaction.TrainTrip</PreCondition></PreConditions>
<Actions>
<Action>Kernel.Mode &lt;- Default.Mode.TR</Action></Actions>
</RuleCondition></Conditions>
</Rule></SubRules>
</RuleCondition></Conditions>
</Rule><Rule
 Priority="Processing"
 Implemented="TRUE"
 Name="HandleMAofBaliseMessage"
>
<ReqRef
 Id="A1.1.6.2"
>
</ReqRef><SubRules></SubRules>
<Conditions>
<RuleCondition
 Name="HandleBaliseMessage"
>
<Comment>This is structurally equal to BTM.HandleBaliseMessage.HandleBaliseMessage.HandleBaliseMessage but only considers MAs #morido, 13/10/24</Comment>
<PreConditions>
<PreCondition>Linking.ConsiderBG()</PreCondition></PreConditions>
<Actions>
<Action>APPLY HandleNewPacketMA(
  Packet=&gt;X, 
  NID_BG=&gt;Message.NID_BG
) 
ON Message.Sequence1</Action></Actions>
</RuleCondition></Conditions>
</Rule></Rules>
</Procedure><Procedure
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="StoreBaliseGroupMessage"
>
<ReqRef
 Id="3.4.1.3"
>
</ReqRef><ReqRef
 Id="3.4.2.4.1"
>
</ReqRef><Comment>Stores the balise group message in the list of balise messages of the current balise group.
Do not store duplicate balise messages.
If all the messages of the current balise group have been received, calls HandleBaliseMessage() procedure to manage the information of the new BG.</Comment>
<Parameters>
<Parameter
 Type="Messages.EUROBALISE.Message"
 Name="Message"
>
</Parameter></Parameters>
<Rules>
<Rule
 Priority="UpdateINTERNAL"
 NeedsRequirement="FALSE"
 Name="Store message"
>
<Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 NeedsRequirement="FALSE"
 Name="Not a duplicate"
>
<PreConditions>
<PreCondition>BaliseNeedBeStored (Message)</PreCondition></PreConditions>
<Actions>
<Action>INSERT Message IN CurrentBaliseGroup </Action></Actions>
</RuleCondition></Conditions>
</Rule><Rule
 Priority="UpdateINTERNAL"
 NeedsRequirement="FALSE"
 Name="Keep position of the first balise"
>
<Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 NeedsRequirement="FALSE"
 Name="Keep position of balise 1"
>
<PreConditions>
<PreCondition>Message.N_PIG == 0</PreCondition></PreConditions>
<Actions>
<Action>FirstBalisePosition &lt;- PositionFromOdometry()</Action></Actions>
</RuleCondition></Conditions>
</Rule><Rule
 Priority="UpdateINTERNAL"
 NeedsRequirement="FALSE"
 Name="All balises have been received for the balise group"
>
<Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 NeedsRequirement="FALSE"
 Name="All balises have been received for the balise group"
>
<Comment>N_TOTAL is the number of balises - 1</Comment>
<PreConditions>
<PreCondition>CountBalises() == Message.N_TOTAL + 1</PreCondition><PreCondition>FORALL_IN CurrentBaliseGroup |  
  (     X.M_MCOUNT == ( FIRST_IN CurrentBaliseGroup ).M_MCOUNT 
  OR X.M_MCOUNT == Messages.M_MCOUNT.The_telegram_fits_with_all_telegrams_of_the_same_balise_group )</PreCondition></PreConditions>
<Actions>
<Action>APPLY HandleBaliseMessage(X) ON CurrentBaliseGroup</Action></Actions>
</RuleCondition></Conditions>
</Rule></Rules>
</Procedure><Procedure
 Implemented="TRUE"
 Name="HandleNewPacketMA"
>
<ReqRef
 Id="A1.1.3.3"
>
</ReqRef><Parameters>
<Parameter
 Type="Messages.EUROBALISE.SubStructure1"
 Name="Packet"
>
</Parameter><Parameter
 Type="Messages.NID_BG"
 Name="NID_BG"
>
</Parameter></Parameters>
<Rules>
<Rule
 Priority="Processing"
 Name="HandleNewPacketMA"
>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 Implemented="TRUE"
 Name="MA Lvl1 available"
>
<ReqRef
 Id="3.8.3.6"
>
</ReqRef><ReqRef
 Id="3.7.1.1.a"
>
</ReqRef><ReqRef
 Id="3.7.1.1.b"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.6"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.LEVEL_1_MOVEMENT_AUTHORITY.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.MA.MALvl1Received
(
    Packet =&gt; Packet.TRACK_TO_TRAIN.LEVEL_1_MOVEMENT_AUTHORITY,
    NID_BG =&gt; NID_BG
)</Action></Actions>
</RuleCondition><RuleCondition
 Implemented="TRUE"
 Name="MA Lvl2or3 available"
>
<ReqRef
 Id="3.8.3.6"
>
</ReqRef><ReqRef
 Id="3.7.1.1.a"
>
</ReqRef><ReqRef
 Id="3.7.1.1.b"
>
</ReqRef><ReqRef
 Id="Entry 7.4.1.1.8"
>
</ReqRef><PreConditions>
<PreCondition>ConsiderPacket ( PacketOrientation =&gt; Packet.TRACK_TO_TRAIN.LEVEL_2_3_MOVEMENT_AUTHORITY.Q_DIR )</PreCondition></PreConditions>
<Actions>
<Action>Kernel.MA.MALvl2or3Received
(
    Packet =&gt; Packet.TRACK_TO_TRAIN.LEVEL_2_3_MOVEMENT_AUTHORITY,
    NID_BG =&gt; NID_BG
)</Action></Actions>
</RuleCondition></Conditions>
</Rule></Rules>
</Procedure></Procedures>
<Variables>
<Variable
 Type="Default.BaseTypes.Length"
 DefaultValue="0.0"
 VariableMode="Constant"
 Implemented="TRUE"
 Name="BGLocationDetectionError"
>
<ReqRef
 Id="3.6.4.2.a"
>
<Comment></Comment>
</ReqRef><ReqRef
 Id="A1.1.3.1"
>
</ReqRef><Comment>This variable represents the error in detection of balise group location by the train.</Comment>
</Variable><Variable
 Type="Messages.EUROBALISE.Message"
 DefaultValue="EMPTY"
 VariableMode="InOut"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="Message"
>
<ReqRef
 Id="3.16.2.1.1"
>
</ReqRef><Comment>This variable holds the balise message to be processed.</Comment>
</Variable><Variable
 Type="BaliseGroup"
 DefaultValue="EMPTY"
 VariableMode="Internal"
 Implemented="TRUE"
 Name="LRBG"
>
<ReqRef
 Id="3.6.1.3"
>
</ReqRef><Comment>This variable holds information about the LRBG</Comment>
</Variable><Variable
 Type="Position"
 DefaultValue=""
 VariableMode="Internal"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="UnlinkedBGPosition"
>
<ReqRef
 Id="3.6.4.7.1"
>
<Comment></Comment>
</ReqRef><Comment>Saves the information provided by the odometry at the moment where an unlinked balise group is passed. Used to compute the position, over and under reading amount relative to that unlinked balise. Can be deleted by setting its State sub variable to DataState.Unknown.</Comment>
</Variable><Variable
 Type="BaliseGroups"
 DefaultValue="[]"
 VariableMode="Internal"
 Implemented="TRUE"
 Name="PreviousLRBGs"
>
<ReqRef
 Id="3.6.1.3.4"
>
<Comment>Even if in the requiremets, the previous LRBG are decribed in the train position, it seemed more structured to place this list in the BTM namespace, near the LRBG</Comment>
</ReqRef><Comment>Holds the LRBG that have been processed before</Comment>
</Variable><Variable
 Type="BaliseGroupMessages"
 DefaultValue="[]"
 VariableMode="Internal"
 NeedsRequirement="FALSE"
 Name="CurrentBaliseGroup"
>
<Comment>This variable holds the messages from the current balise group until the complete balise group has been encountered</Comment>
</Variable><Variable
 Type="Position"
 DefaultValue="EMPTY"
 VariableMode="Internal"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="FirstBalisePosition"
>
<ReqRef
 Id="3.4.2.2.1"
>
</ReqRef><Comment>This is the position of the first balise (N_PIG == 1) in the balise group</Comment>
</Variable><Variable
 Type="Default.BaseTypes.Distance"
 DefaultValue="0.0"
 VariableMode="Internal"
 Implemented="TRUE"
 Name="ActiveAntennaPosition"
>
<ReqRef
 Id="3.13.10.2.7"
>
</ReqRef><Comment>Distance between the front end of the train and the active Eurobalise antenna.
[stan@ertmssolutions.com] We assume that ActiveAntennaPosition &gt; 0</Comment>
</Variable></Variables>
<Rules>
<Rule
 Priority="CleanUp"
 Implemented="TRUE"
 Name="Clean Up"
>
<ReqRef
 Id="3.9.1.2"
>
</ReqRef><Comment>After processing the new telegram its content is deleted.</Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 Implemented="TRUE"
 Name="Clear just received balise telegram"
>
<Comment></Comment>
<PreConditions>
<PreCondition>Available ( Message )</PreCondition></PreConditions>
<Actions>
<Action>Message &lt;- EMPTY</Action><Action>Kernel.Infill.Data &lt;- EMPTY</Action></Actions>
<SubRules>
<Rule
 Priority="CleanUp"
 Implemented="TRUE"
 NeedsRequirement="FALSE"
 Name="Clear current balises from current balise group"
>
<Comment>When the current balises from the current balise group have been processed, clear its data</Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 NeedsRequirement="FALSE"
 Name="Clear current balises from current balise group"
>
<Comment></Comment>
<PreConditions>
<PreCondition>( COUNT CurrentBaliseGroup ) == Message.N_TOTAL + 1</PreCondition></PreConditions>
<Actions>
<Action>CurrentBaliseGroup &lt;- []</Action></Actions>
</RuleCondition></Conditions>
</Rule></SubRules>
</RuleCondition></Conditions>
</Rule><Rule
 Priority="Verification"
 NeedsRequirement="FALSE"
 Name="Incomplete balise group received"
>
<Comment></Comment>
<SubRules></SubRules>
<Conditions>
<RuleCondition
 NeedsRequirement="FALSE"
 Name="Incomplete balise group received"
>
<PreConditions>
<PreCondition>Available ( Message )</PreCondition><PreCondition>(COUNT CurrentBaliseGroup ) &gt; 0 </PreCondition><PreCondition>Message.NID_BG != (FIRST_IN CurrentBaliseGroup).NID_BG</PreCondition></PreConditions>
<Actions>
<Action>CurrentBaliseGroup &lt;- [] </Action></Actions>
</RuleCondition></Conditions>
</Rule></Rules>
</NameSpace>
